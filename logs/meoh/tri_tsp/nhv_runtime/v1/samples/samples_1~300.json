[
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7823.964994376115,
            0.8197442173957825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7823.964994376115,
            0.8197442173957825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7823.964994376115,
            0.8197442173957825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\n",
        "score": [
            -7816.6322728059795,
            1.1020054340362548
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt combined with a novel 3-objective-aware swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the worst objective\n    worst_obj = np.argmax([sum(x[1]) for x in archive])\n    worst_solution = archive[worst_obj][0].copy()\n\n    # Find the worst edge in the worst solution\n    worst_edge = None\n    max_distance = -1\n    for i in range(n):\n        u, v = worst_solution[i], worst_solution[(i + 1) % n]\n        total_dist = distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n        if total_dist > max_distance:\n            max_distance = total_dist\n            worst_edge = (i, (i + 1) % n)\n\n    # Perform 2-opt on the worst edge\n    if worst_edge:\n        i, j = worst_edge\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Then apply a novel 3-objective-aware swap\n    # For each node, find the best swap that improves at least one objective\n    for i in range(n):\n        best_swap = None\n        best_improvement = 0\n\n        for j in range(i + 1, n):\n            # Calculate the change in all three objectives\n            old_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            old_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            old_dist3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n            new_dist3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n            # Check if at least one objective improves\n            if (new_dist1 < old_dist1) or (new_dist2 < old_dist2) or (new_dist3 < old_dist3):\n                total_improvement = (old_dist1 - new_dist1) + (old_dist2 - new_dist2) + (old_dist3 - new_dist3)\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_swap = j\n\n        if best_swap is not None:\n            new_solution[i], new_solution[best_swap] = new_solution[best_swap], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -7815.459342788238,
            2.0758976101875306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt combined with a novel 3-objective-aware swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the worst objective\n    worst_obj = np.argmax([sum(x[1]) for x in archive])\n    worst_solution = archive[worst_obj][0].copy()\n\n    # Find the worst edge in the worst solution\n    worst_edge = None\n    max_distance = -1\n    for i in range(n):\n        u, v = worst_solution[i], worst_solution[(i + 1) % n]\n        total_dist = distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n        if total_dist > max_distance:\n            max_distance = total_dist\n            worst_edge = (i, (i + 1) % n)\n\n    # Perform 2-opt on the worst edge\n    if worst_edge:\n        i, j = worst_edge\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Then apply a novel 3-objective-aware swap\n    # For each node, find the best swap that improves at least one objective\n    for i in range(n):\n        best_swap = None\n        best_improvement = 0\n\n        for j in range(i + 1, n):\n            # Calculate the change in all three objectives\n            old_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            old_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            old_dist3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n            new_dist3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n            # Check if at least one objective improves\n            if (new_dist1 < old_dist1) or (new_dist2 < old_dist2) or (new_dist3 < old_dist3):\n                total_improvement = (old_dist1 - new_dist1) + (old_dist2 - new_dist2) + (old_dist3 - new_dist3)\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_swap = j\n\n        if best_swap is not None:\n            new_solution[i], new_solution[best_swap] = new_solution[best_swap], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on objective diversity and applies a novel 3D path optimization operator that combines edge swaps, segment reversals, and objective-aware node insertions to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    def objective_diversity(obj):\n        return max(obj) - min(obj)\n\n    ranked_solutions = sorted(archive, key=lambda x: -objective_diversity(x[1]))\n    selected_idx = np.random.choice(min(5, len(ranked_solutions)))\n    base_solution = ranked_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between three different operators\n    operator = np.random.choice(['edge_swap', 'segment_reversal', 'node_insertion'])\n\n    if operator == 'edge_swap':\n        # Multi-objective edge swap\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'segment_reversal':\n        # Objective-aware segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    else:  # node_insertion\n        # Objective-aware node insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j:\n            j = np.random.randint(0, n)\n\n        # Calculate improvement\n        delta1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -7703.440317649794,
            0.4500385165214539
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    def objective_diversity(obj):\n        return max(obj) - min(obj)\n\n    ranked_solutions = sorted(archive, key=lambda x: -objective_diversity(x[1]))\n    selected_idx = np.random.choice(min(5, len(ranked_solutions)))\n    base_solution = ranked_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between three different operators\n    operator = np.random.choice(['edge_swap', 'segment_reversal', 'node_insertion'])\n\n    if operator == 'edge_swap':\n        # Multi-objective edge swap\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'segment_reversal':\n        # Objective-aware segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    else:  # node_insertion\n        # Objective-aware node insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j:\n            j = np.random.randint(0, n)\n\n        # Calculate improvement\n        delta1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on objective diversity and applies a novel 3D path optimization operator that combines edge swaps, segment reversals, and objective-aware node insertions to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    def objective_diversity(obj):\n        return max(obj) - min(obj)\n\n    ranked_solutions = sorted(archive, key=lambda x: -objective_diversity(x[1]))\n    selected_idx = np.random.choice(min(5, len(ranked_solutions)))\n    base_solution = ranked_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between three different operators\n    operator = np.random.choice(['edge_swap', 'segment_reversal', 'node_insertion'])\n\n    if operator == 'edge_swap':\n        # Multi-objective edge swap\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'segment_reversal':\n        # Objective-aware segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    else:  # node_insertion\n        # Objective-aware node insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j:\n            j = np.random.randint(0, n)\n\n        # Calculate improvement\n        delta1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -7703.440317649794,
            0.4500385165214539
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    def objective_diversity(obj):\n        return max(obj) - min(obj)\n\n    ranked_solutions = sorted(archive, key=lambda x: -objective_diversity(x[1]))\n    selected_idx = np.random.choice(min(5, len(ranked_solutions)))\n    base_solution = ranked_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between three different operators\n    operator = np.random.choice(['edge_swap', 'segment_reversal', 'node_insertion'])\n\n    if operator == 'edge_swap':\n        # Multi-objective edge swap\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'segment_reversal':\n        # Objective-aware segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    else:  # node_insertion\n        # Objective-aware node insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j:\n            j = np.random.randint(0, n)\n\n        # Calculate improvement\n        delta1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a 3D two-opt* operator with dynamic segment selection based on objective dominance, and ensures feasibility by maintaining the TSP tour structure while considering the trade-offs between objectives}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives (most balanced)\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = normalized.std(axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection based on objective dominance\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    if obj1 < obj2 and obj1 < obj3:\n        # Focus on first objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        if delta < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif obj2 < obj1 and obj2 < obj3:\n        # Focus on second objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        if delta < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Focus on third objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        if delta < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional 2-opt* move for further improvement\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7788.1073385244745,
            1.1389009952545166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives (most balanced)\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = normalized.std(axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection based on objective dominance\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    if obj1 < obj2 and obj1 < obj3:\n        # Focus on first objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        if delta < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif obj2 < obj1 and obj2 < obj3:\n        # Focus on second objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        if delta < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Focus on third objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        if delta < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional 2-opt* move for further improvement\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Perform a multi-objective edge insertion move\n    for _ in range(5):\n        # Randomly select two distinct edges\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n\n        # Perform the insertion\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(base_solution)\n\n        # Accept if the solution is non-dominated or improves at least one objective\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            base_solution = new_solution.copy()\n\n    return base_solution\n\n",
        "score": [
            -7807.360617696031,
            1.3040217638015748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Perform a multi-objective edge insertion move\n    for _ in range(5):\n        # Randomly select two distinct edges\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n\n        # Perform the insertion\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(base_solution)\n\n        # Accept if the solution is non-dominated or improves at least one objective\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            base_solution = new_solution.copy()\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D segment-shuffling and objective-biased edge-insertion operator, and ensures feasibility by preserving the TSP tour structure while dynamically balancing improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    def objective_diversity(sol):\n        obj = sol[1]\n        return (max(obj) - min(obj)) / sum(obj)\n\n    selected = max(archive, key=objective_diversity)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment shuffling with objective awareness\n    if np.random.random() < 0.6:\n        # Select a segment and move it to a new position\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find insertion point that improves at least one objective\n        best_pos = -1\n        best_improvement = -1\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Evaluate the move\n            old_edges = [\n                (new_solution[start-1], new_solution[start]),\n                (new_solution[start+segment_length-1], new_solution[(start+segment_length)%n])\n            ]\n            new_edges = [\n                (new_solution[start-1], new_solution[(start+segment_length)%n]),\n                (segment[0], segment[-1])\n            ]\n\n            if pos > 0:\n                new_edges.append((new_solution[pos-1], segment[0]))\n            if pos + segment_length < n:\n                new_edges.append((segment[-1], new_solution[pos+segment_length]))\n\n            # Calculate objective improvements\n            delta1 = sum(distance_matrix_1[a,b] for a,b in new_edges) - sum(distance_matrix_1[a,b] for a,b in old_edges)\n            delta2 = sum(distance_matrix_2[a,b] for a,b in new_edges) - sum(distance_matrix_2[a,b] for a,b in old_edges)\n            delta3 = sum(distance_matrix_3[a,b] for a,b in new_edges) - sum(distance_matrix_3[a,b] for a,b in old_edges)\n\n            improvement = sum(1 for d in [delta1, delta2, delta3] if d < 0)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n            # Insert at new position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n    else:\n        # Apply objective-biased edge insertion\n        worst_obj = np.argmax(selected[1])\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst edge in the selected objective\n        max_edge = -1\n        max_dist = -1\n        for i in range(n):\n            dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n            if dist > max_dist:\n                max_dist = dist\n                max_edge = i\n\n        # Try to replace this edge with a better one\n        a, b = new_solution[max_edge], new_solution[(max_edge+1)%n]\n        candidates = []\n        for i in range(n):\n            if i != max_edge and i != (max_edge+1)%n:\n                dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n                if dist < max_dist:\n                    candidates.append(i)\n\n        if candidates:\n            best_candidate = min(candidates, key=lambda x: dist_matrix[new_solution[x], new_solution[(x+1)%n]])\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:max_edge+1],\n                new_solution[best_candidate+1:],\n                new_solution[best_candidate:best_candidate+1],\n                new_solution[max_edge+1:best_candidate+1]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -7695.799031100536,
            0.4392615079879761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    def objective_diversity(sol):\n        obj = sol[1]\n        return (max(obj) - min(obj)) / sum(obj)\n\n    selected = max(archive, key=objective_diversity)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment shuffling with objective awareness\n    if np.random.random() < 0.6:\n        # Select a segment and move it to a new position\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find insertion point that improves at least one objective\n        best_pos = -1\n        best_improvement = -1\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Evaluate the move\n            old_edges = [\n                (new_solution[start-1], new_solution[start]),\n                (new_solution[start+segment_length-1], new_solution[(start+segment_length)%n])\n            ]\n            new_edges = [\n                (new_solution[start-1], new_solution[(start+segment_length)%n]),\n                (segment[0], segment[-1])\n            ]\n\n            if pos > 0:\n                new_edges.append((new_solution[pos-1], segment[0]))\n            if pos + segment_length < n:\n                new_edges.append((segment[-1], new_solution[pos+segment_length]))\n\n            # Calculate objective improvements\n            delta1 = sum(distance_matrix_1[a,b] for a,b in new_edges) - sum(distance_matrix_1[a,b] for a,b in old_edges)\n            delta2 = sum(distance_matrix_2[a,b] for a,b in new_edges) - sum(distance_matrix_2[a,b] for a,b in old_edges)\n            delta3 = sum(distance_matrix_3[a,b] for a,b in new_edges) - sum(distance_matrix_3[a,b] for a,b in old_edges)\n\n            improvement = sum(1 for d in [delta1, delta2, delta3] if d < 0)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n            # Insert at new position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n    else:\n        # Apply objective-biased edge insertion\n        worst_obj = np.argmax(selected[1])\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst edge in the selected objective\n        max_edge = -1\n        max_dist = -1\n        for i in range(n):\n            dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n            if dist > max_dist:\n                max_dist = dist\n                max_edge = i\n\n        # Try to replace this edge with a better one\n        a, b = new_solution[max_edge], new_solution[(max_edge+1)%n]\n        candidates = []\n        for i in range(n):\n            if i != max_edge and i != (max_edge+1)%n:\n                dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n                if dist < max_dist:\n                    candidates.append(i)\n\n        if candidates:\n            best_candidate = min(candidates, key=lambda x: dist_matrix[new_solution[x], new_solution[(x+1)%n]])\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:max_edge+1],\n                new_solution[best_candidate+1:],\n                new_solution[best_candidate:best_candidate+1],\n                new_solution[max_edge+1:best_candidate+1]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D segment-shuffling and objective-biased edge-insertion operator, and ensures feasibility by preserving the TSP tour structure while dynamically balancing improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    def objective_diversity(sol):\n        obj = sol[1]\n        return (max(obj) - min(obj)) / sum(obj)\n\n    selected = max(archive, key=objective_diversity)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment shuffling with objective awareness\n    if np.random.random() < 0.6:\n        # Select a segment and move it to a new position\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find insertion point that improves at least one objective\n        best_pos = -1\n        best_improvement = -1\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Evaluate the move\n            old_edges = [\n                (new_solution[start-1], new_solution[start]),\n                (new_solution[start+segment_length-1], new_solution[(start+segment_length)%n])\n            ]\n            new_edges = [\n                (new_solution[start-1], new_solution[(start+segment_length)%n]),\n                (segment[0], segment[-1])\n            ]\n\n            if pos > 0:\n                new_edges.append((new_solution[pos-1], segment[0]))\n            if pos + segment_length < n:\n                new_edges.append((segment[-1], new_solution[pos+segment_length]))\n\n            # Calculate objective improvements\n            delta1 = sum(distance_matrix_1[a,b] for a,b in new_edges) - sum(distance_matrix_1[a,b] for a,b in old_edges)\n            delta2 = sum(distance_matrix_2[a,b] for a,b in new_edges) - sum(distance_matrix_2[a,b] for a,b in old_edges)\n            delta3 = sum(distance_matrix_3[a,b] for a,b in new_edges) - sum(distance_matrix_3[a,b] for a,b in old_edges)\n\n            improvement = sum(1 for d in [delta1, delta2, delta3] if d < 0)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n            # Insert at new position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n    else:\n        # Apply objective-biased edge insertion\n        worst_obj = np.argmax(selected[1])\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst edge in the selected objective\n        max_edge = -1\n        max_dist = -1\n        for i in range(n):\n            dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n            if dist > max_dist:\n                max_dist = dist\n                max_edge = i\n\n        # Try to replace this edge with a better one\n        a, b = new_solution[max_edge], new_solution[(max_edge+1)%n]\n        candidates = []\n        for i in range(n):\n            if i != max_edge and i != (max_edge+1)%n:\n                dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n                if dist < max_dist:\n                    candidates.append(i)\n\n        if candidates:\n            best_candidate = min(candidates, key=lambda x: dist_matrix[new_solution[x], new_solution[(x+1)%n]])\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:max_edge+1],\n                new_solution[best_candidate+1:],\n                new_solution[best_candidate:best_candidate+1],\n                new_solution[max_edge+1:best_candidate+1]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -7695.799031100536,
            0.4392615079879761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    def objective_diversity(sol):\n        obj = sol[1]\n        return (max(obj) - min(obj)) / sum(obj)\n\n    selected = max(archive, key=objective_diversity)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment shuffling with objective awareness\n    if np.random.random() < 0.6:\n        # Select a segment and move it to a new position\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find insertion point that improves at least one objective\n        best_pos = -1\n        best_improvement = -1\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Evaluate the move\n            old_edges = [\n                (new_solution[start-1], new_solution[start]),\n                (new_solution[start+segment_length-1], new_solution[(start+segment_length)%n])\n            ]\n            new_edges = [\n                (new_solution[start-1], new_solution[(start+segment_length)%n]),\n                (segment[0], segment[-1])\n            ]\n\n            if pos > 0:\n                new_edges.append((new_solution[pos-1], segment[0]))\n            if pos + segment_length < n:\n                new_edges.append((segment[-1], new_solution[pos+segment_length]))\n\n            # Calculate objective improvements\n            delta1 = sum(distance_matrix_1[a,b] for a,b in new_edges) - sum(distance_matrix_1[a,b] for a,b in old_edges)\n            delta2 = sum(distance_matrix_2[a,b] for a,b in new_edges) - sum(distance_matrix_2[a,b] for a,b in old_edges)\n            delta3 = sum(distance_matrix_3[a,b] for a,b in new_edges) - sum(distance_matrix_3[a,b] for a,b in old_edges)\n\n            improvement = sum(1 for d in [delta1, delta2, delta3] if d < 0)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n            # Insert at new position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n    else:\n        # Apply objective-biased edge insertion\n        worst_obj = np.argmax(selected[1])\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst edge in the selected objective\n        max_edge = -1\n        max_dist = -1\n        for i in range(n):\n            dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n            if dist > max_dist:\n                max_dist = dist\n                max_edge = i\n\n        # Try to replace this edge with a better one\n        a, b = new_solution[max_edge], new_solution[(max_edge+1)%n]\n        candidates = []\n        for i in range(n):\n            if i != max_edge and i != (max_edge+1)%n:\n                dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n                if dist < max_dist:\n                    candidates.append(i)\n\n        if candidates:\n            best_candidate = min(candidates, key=lambda x: dist_matrix[new_solution[x], new_solution[(x+1)%n]])\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:max_edge+1],\n                new_solution[best_candidate+1:],\n                new_solution[best_candidate:best_candidate+1],\n                new_solution[max_edge+1:best_candidate+1]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Perform a multi-objective path relinking operation\n    n = len(new_solution)\n    for _ in range(5):  # Limit iterations\n        # Randomly select a segment to relink\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Find the best position to insert this segment in a different order\n        best_pos = i\n        best_obj = (float('inf'), float('inf'), float('inf'))\n\n        for k in range(n):\n            if k >= i and k < j+1:\n                continue  # Skip the original segment position\n\n            # Try inserting the segment in reverse order\n            candidate = np.concatenate([new_solution[:k], segment[::-1], new_solution[k:]])\n\n            # Calculate objectives\n            def calculate_objective(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n                cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n                cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n                return (cost1, cost2, cost3)\n\n            current_obj = calculate_objective(candidate)\n\n            # Update best position if the solution is non-dominated\n            if all(current_obj[i] <= best_obj[i] for i in range(3)) and any(current_obj[i] < best_obj[i] for i in range(3)):\n                best_pos = k\n                best_obj = current_obj\n\n        # Apply the best insertion if found\n        if best_pos != i:\n            new_solution = np.concatenate([new_solution[:best_pos], segment[::-1], new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -7780.296003338277,
            2.039249610900879
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Perform a multi-objective path relinking operation\n    n = len(new_solution)\n    for _ in range(5):  # Limit iterations\n        # Randomly select a segment to relink\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Find the best position to insert this segment in a different order\n        best_pos = i\n        best_obj = (float('inf'), float('inf'), float('inf'))\n\n        for k in range(n):\n            if k >= i and k < j+1:\n                continue  # Skip the original segment position\n\n            # Try inserting the segment in reverse order\n            candidate = np.concatenate([new_solution[:k], segment[::-1], new_solution[k:]])\n\n            # Calculate objectives\n            def calculate_objective(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n                cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n                cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n                return (cost1, cost2, cost3)\n\n            current_obj = calculate_objective(candidate)\n\n            # Update best position if the solution is non-dominated\n            if all(current_obj[i] <= best_obj[i] for i in range(3)) and any(current_obj[i] < best_obj[i] for i in range(3)):\n                best_pos = k\n                best_obj = current_obj\n\n        # Apply the best insertion if found\n        if best_pos != i:\n            new_solution = np.concatenate([new_solution[:best_pos], segment[::-1], new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a solution from the archive based on objective diversity, applies a hybrid 3D edge-swapping and segment-reversal operator with adaptive intensity, and ensures feasibility by preserving the TSP tour structure while leveraging objective-specific distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective diversity (maximize spread across objectives)\n    objectives = np.array([sol[1] for sol in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive intensity based on solution quality\n    intensity = min(0.3 + (len(archive) - selected_idx) / len(archive) * 0.7, 1.0)\n\n    if np.random.random() < intensity:\n        # 3D edge-swap with objective-specific consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Weighted acceptance based on objective improvements\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # More lenient acceptance for multi-objective optimization\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with objective balance\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Balance improvements across objectives\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.15):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7853.03067691646,
            1.5377792239189148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective diversity (maximize spread across objectives)\n    objectives = np.array([sol[1] for sol in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive intensity based on solution quality\n    intensity = min(0.3 + (len(archive) - selected_idx) / len(archive) * 0.7, 1.0)\n\n    if np.random.random() < intensity:\n        # 3D edge-swap with objective-specific consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Weighted acceptance based on objective improvements\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # More lenient acceptance for multi-objective optimization\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with objective balance\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Balance improvements across objectives\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.15):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a solution from the archive based on objective diversity, applies a hybrid 3D edge-swapping and segment-reversal operator with adaptive intensity, and ensures feasibility by preserving the TSP tour structure while leveraging objective-specific distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective diversity (maximize spread across objectives)\n    objectives = np.array([sol[1] for sol in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive intensity based on solution quality\n    intensity = min(0.3 + (len(archive) - selected_idx) / len(archive) * 0.7, 1.0)\n\n    if np.random.random() < intensity:\n        # 3D edge-swap with objective-specific consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Weighted acceptance based on objective improvements\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # More lenient acceptance for multi-objective optimization\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with objective balance\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Balance improvements across objectives\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.15):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7853.03067691646,
            1.5377792239189148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective diversity (maximize spread across objectives)\n    objectives = np.array([sol[1] for sol in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive intensity based on solution quality\n    intensity = min(0.3 + (len(archive) - selected_idx) / len(archive) * 0.7, 1.0)\n\n    if np.random.random() < intensity:\n        # 3D edge-swap with objective-specific consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Weighted acceptance based on objective improvements\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # More lenient acceptance for multi-objective optimization\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with objective balance\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Balance improvements across objectives\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.15):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 3-opt and a multi-objective edge insertion strategy to generate an improved neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Adjust weights based on objective importance\n    selected_solution = min(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 3-opt with multi-objective edge insertion\n    n = len(new_solution)\n    for _ in range(15):  # More iterations for better exploration\n        # Randomly select three edges to modify\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Perform 3-opt move\n        temp = new_solution.copy()\n        temp[a:b+1] = temp[a:b+1][::-1]\n        temp[b:c+1] = temp[b:c+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(temp)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves or solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            new_solution = temp.copy()\n\n        # Additional multi-objective edge insertion\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:  # Ensure we have at least one node to move\n            # Insert segment between i and j before position k\n            k = np.random.randint(0, n)\n            if k > j or k < i:\n                segment = new_solution[i:j+1]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    return new_solution\n\n",
        "score": [
            -7772.978189578765,
            1.3918166399002074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Adjust weights based on objective importance\n    selected_solution = min(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 3-opt with multi-objective edge insertion\n    n = len(new_solution)\n    for _ in range(15):  # More iterations for better exploration\n        # Randomly select three edges to modify\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Perform 3-opt move\n        temp = new_solution.copy()\n        temp[a:b+1] = temp[a:b+1][::-1]\n        temp[b:c+1] = temp[b:c+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(temp)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves or solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            new_solution = temp.copy()\n\n        # Additional multi-objective edge insertion\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:  # Ensure we have at least one node to move\n            # Insert segment between i and j before position k\n            k = np.random.randint(0, n)\n            if k > j or k < i:\n                segment = new_solution[i:j+1]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search operator that considers all three objectives simultaneously, and ensures feasibility through careful edge-swapping and segment-reversal operations tailored to multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on a weighted sum of objectives (weights can be adjusted)\n    weights = [0.4, 0.3, 0.3]  # Adjust weights based on objective importance\n    ranked_solutions = sorted(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n\n    # Select the top 30% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or 2-opt with consideration for all three objectives\n    if np.random.random() < 0.6:  # Higher probability for edge-swap\n        # Edge-swap with multi-objective consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least two objectives improve\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 2-opt with multi-objective consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7779.9995118898705,
            1.2579894423484803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on a weighted sum of objectives (weights can be adjusted)\n    weights = [0.4, 0.3, 0.3]  # Adjust weights based on objective importance\n    ranked_solutions = sorted(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n\n    # Select the top 30% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or 2-opt with consideration for all three objectives\n    if np.random.random() < 0.6:  # Higher probability for edge-swap\n        # Edge-swap with multi-objective consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least two objectives improve\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 2-opt with multi-objective consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best balance across objectives\n    def dominance_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions that are balanced\n\n    ranked_solutions = sorted(archive, key=lambda x: dominance_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware local search operator\n    for _ in range(5):  # Limit iterations\n        # Choose a segment to modify\n        seg_start = np.random.randint(0, n)\n        seg_length = min(3, np.random.randint(1, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Consider different types of modifications\n        if np.random.random() < 0.6:  # Edge swap\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) <= 1 or abs(i - j) >= n - 1:\n                j = np.random.randint(0, n)\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Segment reversal\n            if seg_start < seg_end:\n                segment = new_solution[seg_start:seg_end+1][::-1]\n                new_solution[seg_start:seg_end+1] = segment\n            else:\n                segment1 = new_solution[seg_start:][::-1]\n                segment2 = new_solution[:seg_end+1][::-1]\n                new_solution = np.concatenate([segment1, new_solution[seg_end+1:seg_start], segment2])\n\n    return new_solution\n\n",
        "score": [
            -7787.720528352528,
            0.36901015043258667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best balance across objectives\n    def dominance_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions that are balanced\n\n    ranked_solutions = sorted(archive, key=lambda x: dominance_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware local search operator\n    for _ in range(5):  # Limit iterations\n        # Choose a segment to modify\n        seg_start = np.random.randint(0, n)\n        seg_length = min(3, np.random.randint(1, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Consider different types of modifications\n        if np.random.random() < 0.6:  # Edge swap\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) <= 1 or abs(i - j) >= n - 1:\n                j = np.random.randint(0, n)\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Segment reversal\n            if seg_start < seg_end:\n                segment = new_solution[seg_start:seg_end+1][::-1]\n                new_solution[seg_start:seg_end+1] = segment\n            else:\n                segment1 = new_solution[seg_start:][::-1]\n                segment2 = new_solution[:seg_end+1][::-1]\n                new_solution = np.concatenate([segment1, new_solution[seg_end+1:seg_start], segment2])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best balance across objectives\n    def dominance_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions that are balanced\n\n    ranked_solutions = sorted(archive, key=lambda x: dominance_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware local search operator\n    for _ in range(5):  # Limit iterations\n        # Choose a segment to modify\n        seg_start = np.random.randint(0, n)\n        seg_length = min(3, np.random.randint(1, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Consider different types of modifications\n        if np.random.random() < 0.6:  # Edge swap\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) <= 1 or abs(i - j) >= n - 1:\n                j = np.random.randint(0, n)\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Segment reversal\n            if seg_start < seg_end:\n                segment = new_solution[seg_start:seg_end+1][::-1]\n                new_solution[seg_start:seg_end+1] = segment\n            else:\n                segment1 = new_solution[seg_start:][::-1]\n                segment2 = new_solution[:seg_end+1][::-1]\n                new_solution = np.concatenate([segment1, new_solution[seg_end+1:seg_start], segment2])\n\n    return new_solution\n\n",
        "score": [
            -7787.720528352528,
            0.36901015043258667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best balance across objectives\n    def dominance_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions that are balanced\n\n    ranked_solutions = sorted(archive, key=lambda x: dominance_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware local search operator\n    for _ in range(5):  # Limit iterations\n        # Choose a segment to modify\n        seg_start = np.random.randint(0, n)\n        seg_length = min(3, np.random.randint(1, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Consider different types of modifications\n        if np.random.random() < 0.6:  # Edge swap\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) <= 1 or abs(i - j) >= n - 1:\n                j = np.random.randint(0, n)\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Segment reversal\n            if seg_start < seg_end:\n                segment = new_solution[seg_start:seg_end+1][::-1]\n                new_solution[seg_start:seg_end+1] = segment\n            else:\n                segment1 = new_solution[seg_start:][::-1]\n                segment2 = new_solution[:seg_end+1][::-1]\n                new_solution = np.concatenate([segment1, new_solution[seg_end+1:seg_start], segment2])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best balance across objectives\n    def dominance_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions that are balanced\n\n    ranked_solutions = sorted(archive, key=lambda x: dominance_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware local search operator\n    for _ in range(5):  # Limit iterations\n        # Choose a segment to modify\n        seg_start = np.random.randint(0, n)\n        seg_length = min(3, np.random.randint(1, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Consider different types of modifications\n        if np.random.random() < 0.6:  # Edge swap\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) <= 1 or abs(i - j) >= n - 1:\n                j = np.random.randint(0, n)\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Segment reversal\n            if seg_start < seg_end:\n                segment = new_solution[seg_start:seg_end+1][::-1]\n                new_solution[seg_start:seg_end+1] = segment\n            else:\n                segment1 = new_solution[seg_start:][::-1]\n                segment2 = new_solution[:seg_end+1][::-1]\n                new_solution = np.concatenate([segment1, new_solution[seg_end+1:seg_start], segment2])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best balance across objectives\n    def dominance_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions that are balanced\n\n    ranked_solutions = sorted(archive, key=lambda x: dominance_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware local search operator\n    for _ in range(5):  # Limit iterations\n        # Choose a segment to modify\n        seg_start = np.random.randint(0, n)\n        seg_length = min(3, np.random.randint(1, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Consider different types of modifications\n        if np.random.random() < 0.6:  # Edge swap\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) <= 1 or abs(i - j) >= n - 1:\n                j = np.random.randint(0, n)\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Segment reversal\n            if seg_start < seg_end:\n                segment = new_solution[seg_start:seg_end+1][::-1]\n                new_solution[seg_start:seg_end+1] = segment\n            else:\n                segment1 = new_solution[seg_start:][::-1]\n                segment2 = new_solution[:seg_end+1][::-1]\n                new_solution = np.concatenate([segment1, new_solution[seg_end+1:seg_start], segment2])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{This novel algorithm combines multi-objective selection with a 3D-aware node insertion heuristic that intelligently balances objective improvements by considering the trade-offs between the three objectives during node insertion and removal operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives\n    def tradeoff_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions with balanced trade-offs\n\n    ranked_solutions = sorted(archive, key=lambda x: tradeoff_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware node insertion heuristic\n    for _ in range(5):  # Limit iterations\n        # Choose a node to remove and reinsert\n        node_to_move = np.random.randint(0, n)\n        node = new_solution[node_to_move]\n\n        # Remove the node from the solution\n        new_solution = np.delete(new_solution, node_to_move)\n\n        # Find the best insertion position considering all three objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution)):\n            prev_node = new_solution[pos]\n            next_node = new_solution[(pos + 1) % len(new_solution)]\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[prev_node, node] +\n                      distance_matrix_1[node, next_node] -\n                      distance_matrix_1[prev_node, next_node])\n\n            delta2 = (distance_matrix_2[prev_node, node] +\n                      distance_matrix_2[node, next_node] -\n                      distance_matrix_2[prev_node, next_node])\n\n            delta3 = (distance_matrix_3[prev_node, node] +\n                      distance_matrix_3[node, next_node] -\n                      distance_matrix_3[prev_node, next_node])\n\n            # Calculate a combined score considering all three objectives\n            combined_score = delta1 + delta2 + delta3\n\n            if combined_score < best_score:\n                best_score = combined_score\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -7771.659040863579,
            0.6725802540779113
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives\n    def tradeoff_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions with balanced trade-offs\n\n    ranked_solutions = sorted(archive, key=lambda x: tradeoff_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware node insertion heuristic\n    for _ in range(5):  # Limit iterations\n        # Choose a node to remove and reinsert\n        node_to_move = np.random.randint(0, n)\n        node = new_solution[node_to_move]\n\n        # Remove the node from the solution\n        new_solution = np.delete(new_solution, node_to_move)\n\n        # Find the best insertion position considering all three objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution)):\n            prev_node = new_solution[pos]\n            next_node = new_solution[(pos + 1) % len(new_solution)]\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[prev_node, node] +\n                      distance_matrix_1[node, next_node] -\n                      distance_matrix_1[prev_node, next_node])\n\n            delta2 = (distance_matrix_2[prev_node, node] +\n                      distance_matrix_2[node, next_node] -\n                      distance_matrix_2[prev_node, next_node])\n\n            delta3 = (distance_matrix_3[prev_node, node] +\n                      distance_matrix_3[node, next_node] -\n                      distance_matrix_3[prev_node, next_node])\n\n            # Calculate a combined score considering all three objectives\n            combined_score = delta1 + delta2 + delta3\n\n            if combined_score < best_score:\n                best_score = combined_score\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a 3D node insertion operator that considers the trade-off between the three objectives, and ensures feasibility by maintaining the TSP tour structure while intelligently selecting insertion points based on objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a random node to remove\n    remove_idx = np.random.randint(0, n)\n    node_to_remove = new_solution[remove_idx]\n\n    # Remove the node from the tour\n    new_solution = np.delete(new_solution, remove_idx)\n\n    # Find the best insertion point considering all three objectives\n    best_insert_pos = 0\n    best_improvement = (float('inf'), float('inf'), float('inf'))\n\n    for i in range(n - 1):\n        current_node = new_solution[i]\n        next_node = new_solution[(i + 1) % (n - 1)]\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[current_node, node_to_remove] +\n                  distance_matrix_1[node_to_remove, next_node] -\n                  distance_matrix_1[current_node, next_node])\n\n        delta2 = (distance_matrix_2[current_node, node_to_remove] +\n                  distance_matrix_2[node_to_remove, next_node] -\n                  distance_matrix_2[current_node, next_node])\n\n        delta3 = (distance_matrix_3[current_node, node_to_remove] +\n                  distance_matrix_3[node_to_remove, next_node] -\n                  distance_matrix_3[current_node, next_node])\n\n        # Calculate the total improvement (sum of deltas)\n        total_improvement = (delta1, delta2, delta3)\n\n        # Update best insertion point if this is better\n        if sum(total_improvement) < sum(best_improvement):\n            best_improvement = total_improvement\n            best_insert_pos = i + 1\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_insert_pos, node_to_remove)\n\n    return new_solution\n\n",
        "score": [
            -7651.219460570613,
            3.285051941871643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a random node to remove\n    remove_idx = np.random.randint(0, n)\n    node_to_remove = new_solution[remove_idx]\n\n    # Remove the node from the tour\n    new_solution = np.delete(new_solution, remove_idx)\n\n    # Find the best insertion point considering all three objectives\n    best_insert_pos = 0\n    best_improvement = (float('inf'), float('inf'), float('inf'))\n\n    for i in range(n - 1):\n        current_node = new_solution[i]\n        next_node = new_solution[(i + 1) % (n - 1)]\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[current_node, node_to_remove] +\n                  distance_matrix_1[node_to_remove, next_node] -\n                  distance_matrix_1[current_node, next_node])\n\n        delta2 = (distance_matrix_2[current_node, node_to_remove] +\n                  distance_matrix_2[node_to_remove, next_node] -\n                  distance_matrix_2[current_node, next_node])\n\n        delta3 = (distance_matrix_3[current_node, node_to_remove] +\n                  distance_matrix_3[node_to_remove, next_node] -\n                  distance_matrix_3[current_node, next_node])\n\n        # Calculate the total improvement (sum of deltas)\n        total_improvement = (delta1, delta2, delta3)\n\n        # Update best insertion point if this is better\n        if sum(total_improvement) < sum(best_improvement):\n            best_improvement = total_improvement\n            best_insert_pos = i + 1\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_insert_pos, node_to_remove)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search heuristic that intelligently selects a solution from the archive based on objective diversity, applies a hybrid 3D edge-swapping and segment-reversal operator with adaptive intensity, and ensures feasibility by preserving the TSP tour structure while leveraging objective-specific distance matrices.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective diversity (maximize spread across objectives)\n    objectives = np.array([sol[1] for sol in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive intensity based on solution quality\n    intensity = min(0.3 + (len(archive) - selected_idx) / len(archive) * 0.7, 1.0)\n\n    if np.random.random() < intensity:\n        # 3D edge-swap with objective-specific consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Weighted acceptance based on objective improvements\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # More lenient acceptance for multi-objective optimization\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with objective balance\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Balance improvements across objectives\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.15):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{An adaptive multi-objective local search heuristic that combines objective-aware node insertion with probabilistic segment inversion, dynamically balancing exploration of diverse solution spaces through weighted objective improvements and adaptive neighborhood intensity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective variance (diversity)\n    objectives = np.array([sol[1] for sol in archive])\n    objective_variance = np.var(objectives, axis=0)\n    diversity_scores = np.sum(objective_variance)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive intensity based on solution quality\n    intensity = min(0.2 + (len(archive) - selected_idx) / len(archive) * 0.8, 1.0)\n\n    if np.random.random() < intensity:\n        # Objective-aware node insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        # Calculate weighted improvement\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Weighted acceptance\n        weighted_delta = (delta1 + delta2 + delta3) / 3\n        if weighted_delta < 0 or np.random.random() < 0.1 * (1 - weighted_delta/100):\n            # Perform insertion\n            if i < j:\n                new_solution[i+1:j+1] = np.roll(new_solution[i+1:j+1], -1)\n            else:\n                new_solution[j+1:i+1] = np.roll(new_solution[j+1:i+1], 1)\n    else:\n        # Probabilistic segment inversion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate objective improvements\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Probabilistic acceptance based on improvement balance\n        improvement_count = sum(1 for d in [delta1, delta2, delta3] if d < 0)\n        if improvement_count >= 2 or np.random.random() < 0.2 * improvement_count:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7733.702153616345,
            0.4582378029823303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective variance (diversity)\n    objectives = np.array([sol[1] for sol in archive])\n    objective_variance = np.var(objectives, axis=0)\n    diversity_scores = np.sum(objective_variance)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive intensity based on solution quality\n    intensity = min(0.2 + (len(archive) - selected_idx) / len(archive) * 0.8, 1.0)\n\n    if np.random.random() < intensity:\n        # Objective-aware node insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        # Calculate weighted improvement\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Weighted acceptance\n        weighted_delta = (delta1 + delta2 + delta3) / 3\n        if weighted_delta < 0 or np.random.random() < 0.1 * (1 - weighted_delta/100):\n            # Perform insertion\n            if i < j:\n                new_solution[i+1:j+1] = np.roll(new_solution[i+1:j+1], -1)\n            else:\n                new_solution[j+1:i+1] = np.roll(new_solution[j+1:i+1], 1)\n    else:\n        # Probabilistic segment inversion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate objective improvements\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Probabilistic acceptance based on improvement balance\n        improvement_count = sum(1 for d in [delta1, delta2, delta3] if d < 0)\n        if improvement_count >= 2 or np.random.random() < 0.2 * improvement_count:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{A novel multi-objective local search heuristic that selects solutions based on objective diversity, applies a hybrid 3D edge-swap and segment-reversal operator with adaptive probabilities, and ensures feasibility by maintaining the TSP tour structure while prioritizing solutions that show improvement in at least two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the diversity of each solution based on objective values\n    diversity_scores = []\n    for sol, obj in archive:\n        obj1, obj2, obj3 = obj\n        diversity = abs(obj1 - obj2) + abs(obj2 - obj3) + abs(obj3 - obj1)\n        diversity_scores.append(diversity)\n\n    # Select solutions with above-average diversity\n    avg_diversity = np.mean(diversity_scores)\n    promising_indices = [i for i, score in enumerate(diversity_scores) if score >= avg_diversity]\n    selected_idx = np.random.choice(promising_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive probability based on diversity\n    prob_edge_swap = 0.6 if diversity_scores[selected_idx] > avg_diversity else 0.4\n\n    if np.random.random() < prob_edge_swap:\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least two objectives improve\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least two objectives improve\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7773.95083408706,
            0.8561256289482116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the diversity of each solution based on objective values\n    diversity_scores = []\n    for sol, obj in archive:\n        obj1, obj2, obj3 = obj\n        diversity = abs(obj1 - obj2) + abs(obj2 - obj3) + abs(obj3 - obj1)\n        diversity_scores.append(diversity)\n\n    # Select solutions with above-average diversity\n    avg_diversity = np.mean(diversity_scores)\n    promising_indices = [i for i, score in enumerate(diversity_scores) if score >= avg_diversity]\n    selected_idx = np.random.choice(promising_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive probability based on diversity\n    prob_edge_swap = 0.6 if diversity_scores[selected_idx] > avg_diversity else 0.4\n\n    if np.random.random() < prob_edge_swap:\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least two objectives improve\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least two objectives improve\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a 3D node insertion operator with objective-aware selection, and ensures feasibility by maintaining the TSP tour structure while considering the combined impact of all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective diversity\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.prod(norm_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node insertion with objective-aware selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) < 2:\n        j = np.random.randint(0, n)\n\n    # Calculate the change in all three objectives\n    delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n              distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_1[new_solution[i-1], new_solution[i]] -\n              distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n\n    delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n              distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_2[new_solution[i-1], new_solution[i]] -\n              distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n    delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n              distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_3[new_solution[i-1], new_solution[i]] -\n              distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n    # Accept if at least two objectives improve\n    if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n        # Perform the insertion\n        node_to_move = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -7784.5633248624845,
            0.3356810688972473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective diversity\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.prod(norm_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node insertion with objective-aware selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) < 2:\n        j = np.random.randint(0, n)\n\n    # Calculate the change in all three objectives\n    delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n              distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_1[new_solution[i-1], new_solution[i]] -\n              distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n\n    delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n              distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_2[new_solution[i-1], new_solution[i]] -\n              distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n    delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n              distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_3[new_solution[i-1], new_solution[i]] -\n              distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n    # Accept if at least two objectives improve\n    if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n        # Perform the insertion\n        node_to_move = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a 3D node insertion operator with objective-aware selection, and ensures feasibility by maintaining the TSP tour structure while considering the combined impact of all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective diversity\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.prod(norm_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node insertion with objective-aware selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) < 2:\n        j = np.random.randint(0, n)\n\n    # Calculate the change in all three objectives\n    delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n              distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_1[new_solution[i-1], new_solution[i]] -\n              distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n\n    delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n              distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_2[new_solution[i-1], new_solution[i]] -\n              distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n    delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n              distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_3[new_solution[i-1], new_solution[i]] -\n              distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n    # Accept if at least two objectives improve\n    if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n        # Perform the insertion\n        node_to_move = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -7784.5633248624845,
            0.3356810688972473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective diversity\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.prod(norm_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node insertion with objective-aware selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) < 2:\n        j = np.random.randint(0, n)\n\n    # Calculate the change in all three objectives\n    delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n              distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_1[new_solution[i-1], new_solution[i]] -\n              distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n\n    delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n              distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_2[new_solution[i-1], new_solution[i]] -\n              distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n    delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n              distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_3[new_solution[i-1], new_solution[i]] -\n              distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n    # Accept if at least two objectives improve\n    if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n        # Perform the insertion\n        node_to_move = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7217024937551688,
            1.1834818482398988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7217024937551688,
            1.1834818482398988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7217024937551688,
            1.1834818482398988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find the worst edge and try to replace it with a better one\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the worst edge in this objective\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n\n        # Try to replace the worst edge with a random better edge\n        if max_edge_idx != -1:\n            u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n]\n            candidates = []\n            for k in range(n):\n                if k != max_edge_idx and k != (max_edge_idx + 1) % n:\n                    # Check if swapping edges would maintain feasibility\n                    if new_solution[k] != u and new_solution[(k + 1) % n] != v:\n                        cost_diff = (distance_matrix[new_solution[k], v] + distance_matrix[u, new_solution[(k + 1) % n]]) - max_edge_cost\n                        if cost_diff < 0:\n                            candidates.append((k, cost_diff))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                k, _ = best_candidate\n                # Perform the swap\n                new_solution[max_edge_idx + 1], new_solution[k] = new_solution[k], new_solution[max_edge_idx + 1]\n\n    return new_solution\n\n",
        "score": [
            -0.6051273741762091,
            0.40557374954223635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find the worst edge and try to replace it with a better one\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the worst edge in this objective\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n\n        # Try to replace the worst edge with a random better edge\n        if max_edge_idx != -1:\n            u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n]\n            candidates = []\n            for k in range(n):\n                if k != max_edge_idx and k != (max_edge_idx + 1) % n:\n                    # Check if swapping edges would maintain feasibility\n                    if new_solution[k] != u and new_solution[(k + 1) % n] != v:\n                        cost_diff = (distance_matrix[new_solution[k], v] + distance_matrix[u, new_solution[(k + 1) % n]]) - max_edge_cost\n                        if cost_diff < 0:\n                            candidates.append((k, cost_diff))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                k, _ = best_candidate\n                # Perform the swap\n                new_solution[max_edge_idx + 1], new_solution[k] = new_solution[k], new_solution[max_edge_idx + 1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find the worst edge and try to replace it with a better one\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the worst edge in this objective\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n\n        # Try to replace the worst edge with a random better edge\n        if max_edge_idx != -1:\n            u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n]\n            candidates = []\n            for k in range(n):\n                if k != max_edge_idx and k != (max_edge_idx + 1) % n:\n                    # Check if swapping edges would maintain feasibility\n                    if new_solution[k] != u and new_solution[(k + 1) % n] != v:\n                        cost_diff = (distance_matrix[new_solution[k], v] + distance_matrix[u, new_solution[(k + 1) % n]]) - max_edge_cost\n                        if cost_diff < 0:\n                            candidates.append((k, cost_diff))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                k, _ = best_candidate\n                # Perform the swap\n                new_solution[max_edge_idx + 1], new_solution[k] = new_solution[k], new_solution[max_edge_idx + 1]\n\n    return new_solution\n\n",
        "score": [
            -0.6051273741762091,
            0.40557374954223635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find the worst edge and try to replace it with a better one\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the worst edge in this objective\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n\n        # Try to replace the worst edge with a random better edge\n        if max_edge_idx != -1:\n            u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n]\n            candidates = []\n            for k in range(n):\n                if k != max_edge_idx and k != (max_edge_idx + 1) % n:\n                    # Check if swapping edges would maintain feasibility\n                    if new_solution[k] != u and new_solution[(k + 1) % n] != v:\n                        cost_diff = (distance_matrix[new_solution[k], v] + distance_matrix[u, new_solution[(k + 1) % n]]) - max_edge_cost\n                        if cost_diff < 0:\n                            candidates.append((k, cost_diff))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                k, _ = best_candidate\n                # Perform the swap\n                new_solution[max_edge_idx + 1], new_solution[k] = new_solution[k], new_solution[max_edge_idx + 1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further refine by considering objective-aware edge selection\n    # Identify edges with high potential for improvement in any of the three objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Randomly select two edges and evaluate their potential improvement\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential new costs for the three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n\n        # If any objective improves, apply the swap\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n",
        "score": [
            -0.7058426196712846,
            0.4203469634056091
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further refine by considering objective-aware edge selection\n    # Identify edges with high potential for improvement in any of the three objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Randomly select two edges and evaluate their potential improvement\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential new costs for the three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n\n        # If any objective improves, apply the swap\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find the worst edge and try to replace it with a better one\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the worst edge in this objective\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n\n        # Try to replace the worst edge with a random better edge\n        if max_edge_idx != -1:\n            u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n]\n            candidates = []\n            for k in range(n):\n                if k != max_edge_idx and k != (max_edge_idx + 1) % n:\n                    # Check if swapping edges would maintain feasibility\n                    if new_solution[k] != u and new_solution[(k + 1) % n] != v:\n                        cost_diff = (distance_matrix[new_solution[k], v] + distance_matrix[u, new_solution[(k + 1) % n]]) - max_edge_cost\n                        if cost_diff < 0:\n                            candidates.append((k, cost_diff))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                k, _ = best_candidate\n                # Perform the swap\n                new_solution[max_edge_idx + 1], new_solution[k] = new_solution[k], new_solution[max_edge_idx + 1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a multi-objective edge insertion heuristic\n    for _ in range(10):  # Perform 10 random insertions\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the cost of removing the edges at i and j\n        old_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        # Calculate the cost of inserting node at j after i\n        new_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        # Only perform the insertion if it improves at least one objective\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            # Perform the insertion\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6442985840768769,
            0.42071622610092163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a multi-objective edge insertion heuristic\n    for _ in range(10):  # Perform 10 random insertions\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the cost of removing the edges at i and j\n        old_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        # Calculate the cost of inserting node at j after i\n        new_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        # Only perform the insertion if it improves at least one objective\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            # Perform the insertion\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find the worst edge and try to replace it with a better one\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the worst edge in this objective\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n\n        # Try to replace the worst edge with a random better edge\n        if max_edge_idx != -1:\n            u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n]\n            candidates = []\n            for k in range(n):\n                if k != max_edge_idx and k != (max_edge_idx + 1) % n:\n                    # Check if swapping edges would maintain feasibility\n                    if new_solution[k] != u and new_solution[(k + 1) % n] != v:\n                        cost_diff = (distance_matrix[new_solution[k], v] + distance_matrix[u, new_solution[(k + 1) % n]]) - max_edge_cost\n                        if cost_diff < 0:\n                            candidates.append((k, cost_diff))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                k, _ = best_candidate\n                # Perform the swap\n                new_solution[max_edge_idx + 1], new_solution[k] = new_solution[k], new_solution[max_edge_idx + 1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel \"multi-objective edge insertion\" heuristic that intelligently inserts nodes at positions that improve multiple objectives simultaneously, ensuring feasibility through careful edge replacement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Normalize objectives to compare across different scales\n    objectives = [obj for _, obj in archive]\n    max_vals = np.max(objectives, axis=0)\n    normalized = [tuple(obj / max_vals) for obj in objectives]\n    combined_scores = [sum(norm) for norm in normalized]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge insertion heuristic\n    for _ in range(3):  # Perform 3 insertion attempts\n        # Randomly select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find insertion position that improves at least two objectives\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx - 1) % n:\n                continue\n\n            # Calculate cost difference for all three objectives\n            prev_node = new_solution[(pos - 1) % n]\n            next_node = new_solution[pos % n]\n\n            old_costs = [\n                distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node],\n                distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node],\n                distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n            ]\n\n            new_costs = [\n                distance_matrix_1[prev_node, next_node],\n                distance_matrix_2[prev_node, next_node],\n                distance_matrix_3[prev_node, next_node]\n            ]\n\n            improvements = [old - new for old, new in zip(old_costs, new_costs)]\n            improvement_score = sum(1 for imp in improvements if imp > 0)\n\n            # Prefer positions that improve at least two objectives\n            if improvement_score >= 2 and sum(improvements) > best_improvement:\n                best_improvement = sum(improvements)\n                best_pos = pos\n\n        # Perform the insertion if beneficial\n        if best_pos != -1:\n            # Remove the node from its current position\n            new_solution = np.delete(new_solution, node_idx)\n            # Insert it at the best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7329742458545723,
            0.919282603263855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Normalize objectives to compare across different scales\n    objectives = [obj for _, obj in archive]\n    max_vals = np.max(objectives, axis=0)\n    normalized = [tuple(obj / max_vals) for obj in objectives]\n    combined_scores = [sum(norm) for norm in normalized]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge insertion heuristic\n    for _ in range(3):  # Perform 3 insertion attempts\n        # Randomly select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find insertion position that improves at least two objectives\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx - 1) % n:\n                continue\n\n            # Calculate cost difference for all three objectives\n            prev_node = new_solution[(pos - 1) % n]\n            next_node = new_solution[pos % n]\n\n            old_costs = [\n                distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node],\n                distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node],\n                distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n            ]\n\n            new_costs = [\n                distance_matrix_1[prev_node, next_node],\n                distance_matrix_2[prev_node, next_node],\n                distance_matrix_3[prev_node, next_node]\n            ]\n\n            improvements = [old - new for old, new in zip(old_costs, new_costs)]\n            improvement_score = sum(1 for imp in improvements if imp > 0)\n\n            # Prefer positions that improve at least two objectives\n            if improvement_score >= 2 and sum(improvements) > best_improvement:\n                best_improvement = sum(improvements)\n                best_pos = pos\n\n        # Perform the insertion if beneficial\n        if best_pos != -1:\n            # Remove the node from its current position\n            new_solution = np.delete(new_solution, node_idx)\n            # Insert it at the best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find the worst edge and try to replace it with a better one\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the worst edge in this objective\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n\n        # Try to replace the worst edge with a random better edge\n        if max_edge_idx != -1:\n            u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n]\n            candidates = []\n            for k in range(n):\n                if k != max_edge_idx and k != (max_edge_idx + 1) % n:\n                    # Check if swapping edges would maintain feasibility\n                    if new_solution[k] != u and new_solution[(k + 1) % n] != v:\n                        cost_diff = (distance_matrix[new_solution[k], v] + distance_matrix[u, new_solution[(k + 1) % n]]) - max_edge_cost\n                        if cost_diff < 0:\n                            candidates.append((k, cost_diff))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                k, _ = best_candidate\n                # Perform the swap\n                new_solution[max_edge_idx + 1], new_solution[k] = new_solution[k], new_solution[max_edge_idx + 1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel \"multi-objective edge insertion\" heuristic that intelligently inserts nodes at positions that improve multiple objectives simultaneously, ensuring feasibility through careful edge replacement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Normalize objectives to compare across different scales\n    objectives = [obj for _, obj in archive]\n    max_vals = np.max(objectives, axis=0)\n    normalized = [tuple(obj / max_vals) for obj in objectives]\n    combined_scores = [sum(norm) for norm in normalized]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge insertion heuristic\n    for _ in range(3):  # Perform 3 insertion attempts\n        # Randomly select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find insertion position that improves at least two objectives\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx - 1) % n:\n                continue\n\n            # Calculate cost difference for all three objectives\n            prev_node = new_solution[(pos - 1) % n]\n            next_node = new_solution[pos % n]\n\n            old_costs = [\n                distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node],\n                distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node],\n                distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n            ]\n\n            new_costs = [\n                distance_matrix_1[prev_node, next_node],\n                distance_matrix_2[prev_node, next_node],\n                distance_matrix_3[prev_node, next_node]\n            ]\n\n            improvements = [old - new for old, new in zip(old_costs, new_costs)]\n            improvement_score = sum(1 for imp in improvements if imp > 0)\n\n            # Prefer positions that improve at least two objectives\n            if improvement_score >= 2 and sum(improvements) > best_improvement:\n                best_improvement = sum(improvements)\n                best_pos = pos\n\n        # Perform the insertion if beneficial\n        if best_pos != -1:\n            # Remove the node from its current position\n            new_solution = np.delete(new_solution, node_idx)\n            # Insert it at the best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7329742458545723,
            0.919282603263855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Normalize objectives to compare across different scales\n    objectives = [obj for _, obj in archive]\n    max_vals = np.max(objectives, axis=0)\n    normalized = [tuple(obj / max_vals) for obj in objectives]\n    combined_scores = [sum(norm) for norm in normalized]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge insertion heuristic\n    for _ in range(3):  # Perform 3 insertion attempts\n        # Randomly select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find insertion position that improves at least two objectives\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx - 1) % n:\n                continue\n\n            # Calculate cost difference for all three objectives\n            prev_node = new_solution[(pos - 1) % n]\n            next_node = new_solution[pos % n]\n\n            old_costs = [\n                distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node],\n                distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node],\n                distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n            ]\n\n            new_costs = [\n                distance_matrix_1[prev_node, next_node],\n                distance_matrix_2[prev_node, next_node],\n                distance_matrix_3[prev_node, next_node]\n            ]\n\n            improvements = [old - new for old, new in zip(old_costs, new_costs)]\n            improvement_score = sum(1 for imp in improvements if imp > 0)\n\n            # Prefer positions that improve at least two objectives\n            if improvement_score >= 2 and sum(improvements) > best_improvement:\n                best_improvement = sum(improvements)\n                best_pos = pos\n\n        # Perform the insertion if beneficial\n        if best_pos != -1:\n            # Remove the node from its current position\n            new_solution = np.delete(new_solution, node_idx)\n            # Insert it at the best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find the worst edge and try to replace it with a better one\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the worst edge in this objective\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n\n        # Try to replace the worst edge with a random better edge\n        if max_edge_idx != -1:\n            u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n]\n            candidates = []\n            for k in range(n):\n                if k != max_edge_idx and k != (max_edge_idx + 1) % n:\n                    # Check if swapping edges would maintain feasibility\n                    if new_solution[k] != u and new_solution[(k + 1) % n] != v:\n                        cost_diff = (distance_matrix[new_solution[k], v] + distance_matrix[u, new_solution[(k + 1) % n]]) - max_edge_cost\n                        if cost_diff < 0:\n                            candidates.append((k, cost_diff))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                k, _ = best_candidate\n                # Perform the swap\n                new_solution[max_edge_idx + 1], new_solution[k] = new_solution[k], new_solution[max_edge_idx + 1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This new algorithm combines a multi-objective selection criterion with a novel edge insertion operator that prioritizes diverse objective improvements while maintaining feasibility through a constrained insertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    selected = min(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Find the edge with highest combined objective cost\n    max_edge_cost = -1\n    max_edge_idx = -1\n    for i in range(n):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        cost3 = distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        total_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        if total_cost > max_edge_cost:\n            max_edge_cost = total_cost\n            max_edge_idx = i\n\n    if max_edge_idx != -1:\n        # Remove the worst edge\n        u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx+1)%n]\n        new_solution = np.concatenate([new_solution[:max_edge_idx+1], new_solution[max_edge_idx+2:]])\n\n        # Find insertion point that improves at least one objective\n        best_improvement = 0\n        best_insert_pos = -1\n        for i in range(len(new_solution)-1):\n            # Calculate potential insertion cost\n            cost1 = distance_matrix_1[new_solution[i], v] + distance_matrix_1[u, new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], v] + distance_matrix_2[u, new_solution[i+1]]\n            cost3 = distance_matrix_3[new_solution[i], v] + distance_matrix_3[u, new_solution[i+1]]\n\n            # Calculate original cost\n            orig_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            orig_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            orig_cost3 = distance_matrix_3[new_solution[i], new_solution[i+1]]\n\n            # Calculate improvement\n            imp1 = orig_cost1 - cost1\n            imp2 = orig_cost2 - cost2\n            imp3 = orig_cost3 - cost3\n\n            # Total weighted improvement\n            total_imp = weights[0]*imp1 + weights[1]*imp2 + weights[2]*imp3\n\n            if total_imp > best_improvement:\n                best_improvement = total_imp\n                best_insert_pos = i\n\n        if best_insert_pos != -1:\n            # Insert the nodes back in the best position\n            new_solution = np.concatenate([\n                new_solution[:best_insert_pos+1],\n                np.array([v, u]),\n                new_solution[best_insert_pos+1:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.6722069221725123,
            0.4633386254310608
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    selected = min(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Find the edge with highest combined objective cost\n    max_edge_cost = -1\n    max_edge_idx = -1\n    for i in range(n):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        cost3 = distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        total_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        if total_cost > max_edge_cost:\n            max_edge_cost = total_cost\n            max_edge_idx = i\n\n    if max_edge_idx != -1:\n        # Remove the worst edge\n        u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx+1)%n]\n        new_solution = np.concatenate([new_solution[:max_edge_idx+1], new_solution[max_edge_idx+2:]])\n\n        # Find insertion point that improves at least one objective\n        best_improvement = 0\n        best_insert_pos = -1\n        for i in range(len(new_solution)-1):\n            # Calculate potential insertion cost\n            cost1 = distance_matrix_1[new_solution[i], v] + distance_matrix_1[u, new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], v] + distance_matrix_2[u, new_solution[i+1]]\n            cost3 = distance_matrix_3[new_solution[i], v] + distance_matrix_3[u, new_solution[i+1]]\n\n            # Calculate original cost\n            orig_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            orig_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            orig_cost3 = distance_matrix_3[new_solution[i], new_solution[i+1]]\n\n            # Calculate improvement\n            imp1 = orig_cost1 - cost1\n            imp2 = orig_cost2 - cost2\n            imp3 = orig_cost3 - cost3\n\n            # Total weighted improvement\n            total_imp = weights[0]*imp1 + weights[1]*imp2 + weights[2]*imp3\n\n            if total_imp > best_improvement:\n                best_improvement = total_imp\n                best_insert_pos = i\n\n        if best_insert_pos != -1:\n            # Insert the nodes back in the best position\n            new_solution = np.concatenate([\n                new_solution[:best_insert_pos+1],\n                np.array([v, u]),\n                new_solution[best_insert_pos+1:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find the worst edge and try to replace it with a better one\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the worst edge in this objective\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n\n        # Try to replace the worst edge with a random better edge\n        if max_edge_idx != -1:\n            u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n]\n            candidates = []\n            for k in range(n):\n                if k != max_edge_idx and k != (max_edge_idx + 1) % n:\n                    # Check if swapping edges would maintain feasibility\n                    if new_solution[k] != u and new_solution[(k + 1) % n] != v:\n                        cost_diff = (distance_matrix[new_solution[k], v] + distance_matrix[u, new_solution[(k + 1) % n]]) - max_edge_cost\n                        if cost_diff < 0:\n                            candidates.append((k, cost_diff))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                k, _ = best_candidate\n                # Perform the swap\n                new_solution[max_edge_idx + 1], new_solution[k] = new_solution[k], new_solution[max_edge_idx + 1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find the worst edge and try to replace it with a better one\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the worst edge in this objective\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n\n        # Try to replace the worst edge with a random better edge\n        if max_edge_idx != -1:\n            u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n]\n            candidates = []\n            for k in range(n):\n                if k != max_edge_idx and k != (max_edge_idx + 1) % n:\n                    # Check if swapping edges would maintain feasibility\n                    if new_solution[k] != u and new_solution[(k + 1) % n] != v:\n                        cost_diff = (distance_matrix[new_solution[k], v] + distance_matrix[u, new_solution[(k + 1) % n]]) - max_edge_cost\n                        if cost_diff < 0:\n                            candidates.append((k, cost_diff))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                k, _ = best_candidate\n                # Perform the swap\n                new_solution[max_edge_idx + 1], new_solution[k] = new_solution[k], new_solution[max_edge_idx + 1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{\"A novel multi-objective local search algorithm that combines a Pareto-aware segment inversion with a dynamic objective-weighted edge optimization, prioritizing solutions with high crowding distance and applying a hybrid of 2-opt and edge insertion moves to balance exploration and exploitation across all three objectives.\"}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances (simplified)\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n        for i in range(3):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n        base_solution = archive[np.argmax(crowding)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic objective weighting based on current solution's position\n    obj_weights = [1.0, 1.0, 1.0]  # Default equal weights\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        norm_factors = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        norm_factors[norm_factors == 0] = 1.0\n        current_obj = archive[np.argmax(crowding)][1]\n        normalized_obj = (current_obj - np.min(objectives, axis=0)) / norm_factors\n        obj_weights = [1.0 / (1.0 + o) for o in normalized_obj]\n\n    # Hybrid local search: Pareto-aware segment inversion + edge optimization\n    # First perform a segment inversion based on combined objective weights\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n    # Calculate segment cost for each objective\n    segment_costs = []\n    for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n        cost = dm[segment[-1], segment[0]]  # Closed loop cost\n        for k in range(len(segment)-1):\n            cost += dm[segment[k], segment[k+1]]\n        segment_costs.append(cost)\n    # Calculate weighted improvement potential\n    improvement = sum(w * (before - after) for w, before, after in zip(obj_weights, segment_costs, segment_costs[::-1]))\n    if improvement > 0 or random.random() < 0.1:  # Accept with some probability\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform edge optimization based on weighted objectives\n    for _ in range(2):  # Perform multiple edge optimizations\n        # Select edge based on weighted worst performance\n        edge_scores = []\n        for k in range(n):\n            u, v = new_solution[k], new_solution[(k+1)%n]\n            score = sum(w * dm[u, v] for w, dm in zip(obj_weights, [distance_matrix_1, distance_matrix_2, distance_matrix_3]))\n            edge_scores.append(score)\n        worst_edge = np.argmax(edge_scores)\n        u, v = new_solution[worst_edge], new_solution[(worst_edge+1)%n]\n\n        # Find best insertion point for this edge\n        best_insert = -1\n        best_improvement = 0.0\n        for k in range(n):\n            if k == worst_edge or k == (worst_edge-1)%n:\n                continue\n            # Calculate improvement for inserting after k\n            a, b = new_solution[k], new_solution[(k+1)%n]\n            old_cost = sum(w * dm[a, b] for w, dm in zip(obj_weights, [distance_matrix_1, distance_matrix_2, distance_matrix_3]))\n            new_cost = sum(w * (dm[a, u] + dm[v, b]) for w, dm in zip(obj_weights, [distance_matrix_1, distance_matrix_2, distance_matrix_3]))\n            improvement = old_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insert = k\n\n        if best_insert != -1 and best_improvement > 0:\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:best_insert+1],\n                [v, u],\n                new_solution[(best_insert+1):worst_edge],\n                new_solution[(worst_edge+1):]\n            ])\n            if len(new_solution) != n:\n                # Recover from potential error\n                new_solution = base_solution.copy()\n                continue\n\n    return new_solution\n\n",
        "score": [
            -0.4823494287436995,
            1.2498828172683716
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances (simplified)\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n        for i in range(3):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n        base_solution = archive[np.argmax(crowding)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic objective weighting based on current solution's position\n    obj_weights = [1.0, 1.0, 1.0]  # Default equal weights\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        norm_factors = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        norm_factors[norm_factors == 0] = 1.0\n        current_obj = archive[np.argmax(crowding)][1]\n        normalized_obj = (current_obj - np.min(objectives, axis=0)) / norm_factors\n        obj_weights = [1.0 / (1.0 + o) for o in normalized_obj]\n\n    # Hybrid local search: Pareto-aware segment inversion + edge optimization\n    # First perform a segment inversion based on combined objective weights\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n    # Calculate segment cost for each objective\n    segment_costs = []\n    for dm in [distance_matrix_1, distance_matrix_2, distance_matrix_3]:\n        cost = dm[segment[-1], segment[0]]  # Closed loop cost\n        for k in range(len(segment)-1):\n            cost += dm[segment[k], segment[k+1]]\n        segment_costs.append(cost)\n    # Calculate weighted improvement potential\n    improvement = sum(w * (before - after) for w, before, after in zip(obj_weights, segment_costs, segment_costs[::-1]))\n    if improvement > 0 or random.random() < 0.1:  # Accept with some probability\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform edge optimization based on weighted objectives\n    for _ in range(2):  # Perform multiple edge optimizations\n        # Select edge based on weighted worst performance\n        edge_scores = []\n        for k in range(n):\n            u, v = new_solution[k], new_solution[(k+1)%n]\n            score = sum(w * dm[u, v] for w, dm in zip(obj_weights, [distance_matrix_1, distance_matrix_2, distance_matrix_3]))\n            edge_scores.append(score)\n        worst_edge = np.argmax(edge_scores)\n        u, v = new_solution[worst_edge], new_solution[(worst_edge+1)%n]\n\n        # Find best insertion point for this edge\n        best_insert = -1\n        best_improvement = 0.0\n        for k in range(n):\n            if k == worst_edge or k == (worst_edge-1)%n:\n                continue\n            # Calculate improvement for inserting after k\n            a, b = new_solution[k], new_solution[(k+1)%n]\n            old_cost = sum(w * dm[a, b] for w, dm in zip(obj_weights, [distance_matrix_1, distance_matrix_2, distance_matrix_3]))\n            new_cost = sum(w * (dm[a, u] + dm[v, b]) for w, dm in zip(obj_weights, [distance_matrix_1, distance_matrix_2, distance_matrix_3]))\n            improvement = old_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insert = k\n\n        if best_insert != -1 and best_improvement > 0:\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:best_insert+1],\n                [v, u],\n                new_solution[(best_insert+1):worst_edge],\n                new_solution[(worst_edge+1):]\n            ])\n            if len(new_solution) != n:\n                # Recover from potential error\n                new_solution = base_solution.copy()\n                continue\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find the worst edge and try to replace it with a better one\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the worst edge in this objective\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n\n        # Try to replace the worst edge with a random better edge\n        if max_edge_idx != -1:\n            u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n]\n            candidates = []\n            for k in range(n):\n                if k != max_edge_idx and k != (max_edge_idx + 1) % n:\n                    # Check if swapping edges would maintain feasibility\n                    if new_solution[k] != u and new_solution[(k + 1) % n] != v:\n                        cost_diff = (distance_matrix[new_solution[k], v] + distance_matrix[u, new_solution[(k + 1) % n]]) - max_edge_cost\n                        if cost_diff < 0:\n                            candidates.append((k, cost_diff))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                k, _ = best_candidate\n                # Perform the swap\n                new_solution[max_edge_idx + 1], new_solution[k] = new_solution[k], new_solution[max_edge_idx + 1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{The new algorithm combines objective-aware edge selection with a multi-objective path relinking approach, where promising segments from high-quality solutions are incorporated into the current solution while maintaining feasibility across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst edge in any objective\n    worst_edge_costs = []\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n        worst_edge_costs.append((max_edge_idx, max_edge_cost))\n\n    # Find the worst edge across all objectives\n    worst_edge_idx, _ = max(worst_edge_costs, key=lambda x: x[1])\n\n    # Perform path relinking with a randomly selected elite solution\n    elite_solution = random.choice(archive)[0]\n    elite_edges = set(zip(elite_solution, np.roll(elite_solution, -1)))\n\n    # Find the longest common subsequence (LCS) between current and elite solution\n    lcs = []\n    for i in range(n):\n        for j in range(n):\n            if new_solution[i] == elite_solution[j]:\n                lcs.append((i, j))\n\n    if lcs:\n        # Use the LCS to guide the path relinking\n        lcs_start, lcs_end = lcs[0], lcs[-1]\n        current_pos, elite_pos = lcs_start[0], lcs_start[1]\n\n        # Insert the elite segment into the current solution\n        new_segment = []\n        while elite_pos != lcs_end[1]:\n            new_segment.append(elite_solution[elite_pos])\n            elite_pos = (elite_pos + 1) % n\n\n        # Insert the new segment after the worst edge\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx+1],\n            np.array(new_segment),\n            new_solution[lcs_end[0]+1:]\n        ])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, repair by removing and reinserting missing nodes\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6585157508766472,
            0.2513168215751648
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst edge in any objective\n    worst_edge_costs = []\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n        worst_edge_costs.append((max_edge_idx, max_edge_cost))\n\n    # Find the worst edge across all objectives\n    worst_edge_idx, _ = max(worst_edge_costs, key=lambda x: x[1])\n\n    # Perform path relinking with a randomly selected elite solution\n    elite_solution = random.choice(archive)[0]\n    elite_edges = set(zip(elite_solution, np.roll(elite_solution, -1)))\n\n    # Find the longest common subsequence (LCS) between current and elite solution\n    lcs = []\n    for i in range(n):\n        for j in range(n):\n            if new_solution[i] == elite_solution[j]:\n                lcs.append((i, j))\n\n    if lcs:\n        # Use the LCS to guide the path relinking\n        lcs_start, lcs_end = lcs[0], lcs[-1]\n        current_pos, elite_pos = lcs_start[0], lcs_start[1]\n\n        # Insert the elite segment into the current solution\n        new_segment = []\n        while elite_pos != lcs_end[1]:\n            new_segment.append(elite_solution[elite_pos])\n            elite_pos = (elite_pos + 1) % n\n\n        # Insert the new segment after the worst edge\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx+1],\n            np.array(new_segment),\n            new_solution[lcs_end[0]+1:]\n        ])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, repair by removing and reinserting missing nodes\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find the worst edge and try to replace it with a better one\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the worst edge in this objective\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n\n        # Try to replace the worst edge with a random better edge\n        if max_edge_idx != -1:\n            u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n]\n            candidates = []\n            for k in range(n):\n                if k != max_edge_idx and k != (max_edge_idx + 1) % n:\n                    # Check if swapping edges would maintain feasibility\n                    if new_solution[k] != u and new_solution[(k + 1) % n] != v:\n                        cost_diff = (distance_matrix[new_solution[k], v] + distance_matrix[u, new_solution[(k + 1) % n]]) - max_edge_cost\n                        if cost_diff < 0:\n                            candidates.append((k, cost_diff))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                k, _ = best_candidate\n                # Perform the swap\n                new_solution[max_edge_idx + 1], new_solution[k] = new_solution[k], new_solution[max_edge_idx + 1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{The new algorithm combines objective-aware edge selection with a multi-objective path relinking approach, where promising segments from high-quality solutions are incorporated into the current solution while maintaining feasibility across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst edge in any objective\n    worst_edge_costs = []\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n        worst_edge_costs.append((max_edge_idx, max_edge_cost))\n\n    # Find the worst edge across all objectives\n    worst_edge_idx, _ = max(worst_edge_costs, key=lambda x: x[1])\n\n    # Perform path relinking with a randomly selected elite solution\n    elite_solution = random.choice(archive)[0]\n    elite_edges = set(zip(elite_solution, np.roll(elite_solution, -1)))\n\n    # Find the longest common subsequence (LCS) between current and elite solution\n    lcs = []\n    for i in range(n):\n        for j in range(n):\n            if new_solution[i] == elite_solution[j]:\n                lcs.append((i, j))\n\n    if lcs:\n        # Use the LCS to guide the path relinking\n        lcs_start, lcs_end = lcs[0], lcs[-1]\n        current_pos, elite_pos = lcs_start[0], lcs_start[1]\n\n        # Insert the elite segment into the current solution\n        new_segment = []\n        while elite_pos != lcs_end[1]:\n            new_segment.append(elite_solution[elite_pos])\n            elite_pos = (elite_pos + 1) % n\n\n        # Insert the new segment after the worst edge\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx+1],\n            np.array(new_segment),\n            new_solution[lcs_end[0]+1:]\n        ])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, repair by removing and reinserting missing nodes\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6585157508766472,
            0.2513168215751648
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst edge in any objective\n    worst_edge_costs = []\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n        worst_edge_costs.append((max_edge_idx, max_edge_cost))\n\n    # Find the worst edge across all objectives\n    worst_edge_idx, _ = max(worst_edge_costs, key=lambda x: x[1])\n\n    # Perform path relinking with a randomly selected elite solution\n    elite_solution = random.choice(archive)[0]\n    elite_edges = set(zip(elite_solution, np.roll(elite_solution, -1)))\n\n    # Find the longest common subsequence (LCS) between current and elite solution\n    lcs = []\n    for i in range(n):\n        for j in range(n):\n            if new_solution[i] == elite_solution[j]:\n                lcs.append((i, j))\n\n    if lcs:\n        # Use the LCS to guide the path relinking\n        lcs_start, lcs_end = lcs[0], lcs[-1]\n        current_pos, elite_pos = lcs_start[0], lcs_start[1]\n\n        # Insert the elite segment into the current solution\n        new_segment = []\n        while elite_pos != lcs_end[1]:\n            new_segment.append(elite_solution[elite_pos])\n            elite_pos = (elite_pos + 1) % n\n\n        # Insert the new segment after the worst edge\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx+1],\n            np.array(new_segment),\n            new_solution[lcs_end[0]+1:]\n        ])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, repair by removing and reinserting missing nodes\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{A novel multi-objective local search algorithm that combines adaptive edge selection with a hybrid 2-opt and insertion heuristic to intelligently explore the solution space while maintaining feasibility and potentially improving all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt or insertion based on objective diversity\n    if np.random.random() < 0.7:\n        # Adaptive 2-opt with objective-aware edge selection\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n    else:\n        # Objective-aware insertion\n        k = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n        if pos != k and pos != (k + 1) % n:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6423459799933496,
            0.8381133913993836
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between 2-opt or insertion based on objective diversity\n    if np.random.random() < 0.7:\n        # Adaptive 2-opt with objective-aware edge selection\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n    else:\n        # Objective-aware insertion\n        k = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n        if pos != k and pos != (k + 1) % n:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{This new algorithm will select a solution from the archive based on a novel selection criterion that combines objective diversity and solution quality, then apply a hybrid local search operator that performs a multi-objective-aware node insertion and deletion to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def objective_diversity(obj):\n        return max(obj) - min(obj)\n\n    archive.sort(key=lambda x: (-objective_diversity(x[1]), sum(x[1])))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware node insertion and deletion\n    if n > 3:\n        # Randomly select a node to remove\n        remove_idx = np.random.randint(1, n-1)\n        removed_node = new_solution[remove_idx]\n\n        # Find the best insertion point considering all objectives\n        best_pos = 1\n        best_score = float('inf')\n\n        for i in range(1, n):\n            if i == remove_idx or i == remove_idx - 1:\n                continue\n\n            # Calculate insertion cost for all objectives\n            cost1 = distance_matrix_1[new_solution[i-1], removed_node] + distance_matrix_1[removed_node, new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1], removed_node] + distance_matrix_2[removed_node, new_solution[i]]\n            cost3 = distance_matrix_3[new_solution[i-1], removed_node] + distance_matrix_3[removed_node, new_solution[i]]\n\n            # Weighted sum of costs (equal weights for simplicity)\n            total_cost = cost1 + cost2 + cost3\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_pos = i\n\n        # Remove the node and insert it at the best position\n        new_solution = np.delete(new_solution, remove_idx)\n        new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    return new_solution\n\n",
        "score": [
            -0.5123136439395398,
            0.9110708713531495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def objective_diversity(obj):\n        return max(obj) - min(obj)\n\n    archive.sort(key=lambda x: (-objective_diversity(x[1]), sum(x[1])))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware node insertion and deletion\n    if n > 3:\n        # Randomly select a node to remove\n        remove_idx = np.random.randint(1, n-1)\n        removed_node = new_solution[remove_idx]\n\n        # Find the best insertion point considering all objectives\n        best_pos = 1\n        best_score = float('inf')\n\n        for i in range(1, n):\n            if i == remove_idx or i == remove_idx - 1:\n                continue\n\n            # Calculate insertion cost for all objectives\n            cost1 = distance_matrix_1[new_solution[i-1], removed_node] + distance_matrix_1[removed_node, new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1], removed_node] + distance_matrix_2[removed_node, new_solution[i]]\n            cost3 = distance_matrix_3[new_solution[i-1], removed_node] + distance_matrix_3[removed_node, new_solution[i]]\n\n            # Weighted sum of costs (equal weights for simplicity)\n            total_cost = cost1 + cost2 + cost3\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_pos = i\n\n        # Remove the node and insert it at the best position\n        new_solution = np.delete(new_solution, remove_idx)\n        new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{A new algorithm that selects a solution from the archive based on a weighted sum of objectives, then applies a 3-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0, 0.8, 0.6]  # Weights for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search with objective-aware edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform 3-opt swap\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7089536759190119,
            0.5115267157554626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0, 0.8, 0.6]  # Weights for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search with objective-aware edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform 3-opt swap\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    for _ in range(2):  # Perform multiple attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply a secondary operator: swap two non-adjacent nodes if it improves any objective\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7925495345199637,
            0.5407833933830262
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    for _ in range(2):  # Perform multiple attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply a secondary operator: swap two non-adjacent nodes if it improves any objective\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    for _ in range(2):  # Perform multiple attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply a secondary operator: swap two non-adjacent nodes if it improves any objective\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7925495345199637,
            0.5407833933830262
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    for _ in range(2):  # Perform multiple attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply a secondary operator: swap two non-adjacent nodes if it improves any objective\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find the worst edge and try to replace it with a better one\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the worst edge in this objective\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n\n        # Try to replace the worst edge with a random better edge\n        if max_edge_idx != -1:\n            u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n]\n            candidates = []\n            for k in range(n):\n                if k != max_edge_idx and k != (max_edge_idx + 1) % n:\n                    # Check if swapping edges would maintain feasibility\n                    if new_solution[k] != u and new_solution[(k + 1) % n] != v:\n                        cost_diff = (distance_matrix[new_solution[k], v] + distance_matrix[u, new_solution[(k + 1) % n]]) - max_edge_cost\n                        if cost_diff < 0:\n                            candidates.append((k, cost_diff))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                k, _ = best_candidate\n                # Perform the swap\n                new_solution[max_edge_idx + 1], new_solution[k] = new_solution[k], new_solution[max_edge_idx + 1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]) / len(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst edge in each objective space\n    worst_edges = []\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n        worst_edges.append(max_edge_idx)\n\n    # Perform a multi-objective edge insertion\n    for i in range(n):\n        if i not in worst_edges:\n            continue\n\n        # Find the best insertion point that improves at least one objective\n        best_insertion = None\n        best_improvement = [0, 0, 0]\n\n        for j in range(n):\n            if j == i or j == (i + 1) % n:\n                continue\n\n            # Calculate cost before and after insertion\n            old_cost = (\n                distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n            )\n\n            new_cost = (\n                distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n            )\n\n            improvement = [new - old for new, old in zip(new_cost, old_cost)]\n            if any(imp < 0 for imp in improvement):\n                if sum(imp for imp in improvement if imp < 0) < sum(best_improvement):\n                    best_insertion = j\n                    best_improvement = improvement\n\n        if best_insertion is not None:\n            # Perform the insertion\n            if best_insertion > i:\n                new_solution = np.concatenate([\n                    new_solution[:i+1],\n                    new_solution[i+1:best_insertion+1][::-1],\n                    new_solution[best_insertion+1:]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:best_insertion+1],\n                    new_solution[i+1:best_insertion:-1],\n                    new_solution[i+1:]\n                ])\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.5993170343001943,
            3.901550853252411
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]) / len(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst edge in each objective space\n    worst_edges = []\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n        worst_edges.append(max_edge_idx)\n\n    # Perform a multi-objective edge insertion\n    for i in range(n):\n        if i not in worst_edges:\n            continue\n\n        # Find the best insertion point that improves at least one objective\n        best_insertion = None\n        best_improvement = [0, 0, 0]\n\n        for j in range(n):\n            if j == i or j == (i + 1) % n:\n                continue\n\n            # Calculate cost before and after insertion\n            old_cost = (\n                distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n            )\n\n            new_cost = (\n                distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n            )\n\n            improvement = [new - old for new, old in zip(new_cost, old_cost)]\n            if any(imp < 0 for imp in improvement):\n                if sum(imp for imp in improvement if imp < 0) < sum(best_improvement):\n                    best_insertion = j\n                    best_improvement = improvement\n\n        if best_insertion is not None:\n            # Perform the insertion\n            if best_insertion > i:\n                new_solution = np.concatenate([\n                    new_solution[:i+1],\n                    new_solution[i+1:best_insertion+1][::-1],\n                    new_solution[best_insertion+1:]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:best_insertion+1],\n                    new_solution[i+1:best_insertion:-1],\n                    new_solution[i+1:]\n                ])\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find the worst edge and try to replace it with a better one\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the worst edge in this objective\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n\n        # Try to replace the worst edge with a random better edge\n        if max_edge_idx != -1:\n            u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n]\n            candidates = []\n            for k in range(n):\n                if k != max_edge_idx and k != (max_edge_idx + 1) % n:\n                    # Check if swapping edges would maintain feasibility\n                    if new_solution[k] != u and new_solution[(k + 1) % n] != v:\n                        cost_diff = (distance_matrix[new_solution[k], v] + distance_matrix[u, new_solution[(k + 1) % n]]) - max_edge_cost\n                        if cost_diff < 0:\n                            candidates.append((k, cost_diff))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                k, _ = best_candidate\n                # Perform the swap\n                new_solution[max_edge_idx + 1], new_solution[k] = new_solution[k], new_solution[max_edge_idx + 1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find the worst edge and try to replace it with a better one\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the worst edge in this objective\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n\n        # Try to replace the worst edge with a random better edge\n        if max_edge_idx != -1:\n            u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n]\n            candidates = []\n            for k in range(n):\n                if k != max_edge_idx and k != (max_edge_idx + 1) % n:\n                    # Check if swapping edges would maintain feasibility\n                    if new_solution[k] != u and new_solution[(k + 1) % n] != v:\n                        cost_diff = (distance_matrix[new_solution[k], v] + distance_matrix[u, new_solution[(k + 1) % n]]) - max_edge_cost\n                        if cost_diff < 0:\n                            candidates.append((k, cost_diff))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                k, _ = best_candidate\n                # Perform the swap\n                new_solution[max_edge_idx + 1], new_solution[k] = new_solution[k], new_solution[max_edge_idx + 1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a multi-objective aware insertion heuristic\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to relocate\n    segment_length = random.randint(2, min(5, n // 3))\n    start_idx = random.randint(0, n - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n\n    # Evaluate potential insertion points based on all three objectives\n    best_insert_pos = -1\n    best_improvement = 0\n\n    for pos in range(len(new_solution) - segment_length + 1):\n        # Insert the segment at position pos\n        candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate improvement for each objective\n        total_improvement = 0\n        for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n            old_cost = sum(distance_matrix[selected_solution[k], selected_solution[k+1]] for k in range(n-1)) + distance_matrix[selected_solution[-1], selected_solution[0]]\n            new_cost = sum(distance_matrix[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix[candidate[-1], candidate[0]]\n            total_improvement += (old_cost - new_cost)\n\n        # Update best position if this is better\n        if total_improvement > best_improvement:\n            best_improvement = total_improvement\n            best_insert_pos = pos\n\n    # Perform the best insertion if found\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7165201049328347,
            1.1220825433731079
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a multi-objective aware insertion heuristic\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to relocate\n    segment_length = random.randint(2, min(5, n // 3))\n    start_idx = random.randint(0, n - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n\n    # Evaluate potential insertion points based on all three objectives\n    best_insert_pos = -1\n    best_improvement = 0\n\n    for pos in range(len(new_solution) - segment_length + 1):\n        # Insert the segment at position pos\n        candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate improvement for each objective\n        total_improvement = 0\n        for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n            old_cost = sum(distance_matrix[selected_solution[k], selected_solution[k+1]] for k in range(n-1)) + distance_matrix[selected_solution[-1], selected_solution[0]]\n            new_cost = sum(distance_matrix[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix[candidate[-1], candidate[0]]\n            total_improvement += (old_cost - new_cost)\n\n        # Update best position if this is better\n        if total_improvement > best_improvement:\n            best_improvement = total_improvement\n            best_insert_pos = pos\n\n    # Perform the best insertion if found\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a weighted sum of objectives, then applies a 3-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [1.0, 0.8, 0.6]  # Weights for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search with objective-aware edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform 3-opt swap\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further refine by considering objective-aware edge selection\n    # Identify edges with high potential for improvement in any of the three objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Randomly select two edges and evaluate their potential improvement\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential new costs for the three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n\n        # If any objective improves, apply the swap\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = sum(np.abs(sol[:-1] - sol[1:]))  # Measure diversity as sum of consecutive node differences\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply segmented crossover with random segments from other solutions\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments from other solutions in the archive\n    for _ in range(3):  # Apply 3 random segment swaps\n        other_idx = np.random.choice(len(archive))\n        other_solution = archive[other_idx][0]\n\n        # Randomly select a segment from the other solution\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        segment = other_solution[start:end+1]\n\n        # Find a compatible position in the current solution\n        for i in range(n):\n            if new_solution[i] not in segment:\n                # Insert the segment while maintaining feasibility\n                new_solution = np.concatenate([\n                    new_solution[:i],\n                    segment,\n                    new_solution[i:]\n                ])[:n]\n                break\n\n    # Ensure the solution remains feasible (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n",
        "score": [
            -0.6612244313704446,
            0.4870666146278381
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = sum(np.abs(sol[:-1] - sol[1:]))  # Measure diversity as sum of consecutive node differences\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply segmented crossover with random segments from other solutions\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments from other solutions in the archive\n    for _ in range(3):  # Apply 3 random segment swaps\n        other_idx = np.random.choice(len(archive))\n        other_solution = archive[other_idx][0]\n\n        # Randomly select a segment from the other solution\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        segment = other_solution[start:end+1]\n\n        # Find a compatible position in the current solution\n        for i in range(n):\n            if new_solution[i] not in segment:\n                # Insert the segment while maintaining feasibility\n                new_solution = np.concatenate([\n                    new_solution[:i],\n                    segment,\n                    new_solution[i:]\n                ])[:n]\n                break\n\n    # Ensure the solution remains feasible (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further refine by considering objective-aware edge selection\n    # Identify edges with high potential for improvement in any of the three objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Randomly select two edges and evaluate their potential improvement\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential new costs for the three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n\n        # If any objective improves, apply the swap\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a multi-objective-aware 2-opt local search with adaptive edge selection and objective-specific perturbations, and ensures feasibility through careful edge swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt with adaptive edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost and np.random.rand() < 0.7:  # Accept with probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-specific perturbations\n    for _ in range(5):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Perturb for first objective\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Perturb for second objective\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Perturb for third objective\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]]:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\n",
        "score": [
            -0.8020609514601988,
            1.1996041417121888
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt with adaptive edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost and np.random.rand() < 0.7:  # Accept with probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-specific perturbations\n    for _ in range(5):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Perturb for first objective\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Perturb for second objective\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Perturb for third objective\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]]:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further refine by considering objective-aware edge selection\n    # Identify edges with high potential for improvement in any of the three objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Randomly select two edges and evaluate their potential improvement\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential new costs for the three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n\n        # If any objective improves, apply the swap\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a multi-objective-aware 2-opt local search with adaptive edge selection and objective-specific perturbations, and ensures feasibility through careful edge swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt with adaptive edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost and np.random.rand() < 0.7:  # Accept with probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-specific perturbations\n    for _ in range(5):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Perturb for first objective\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Perturb for second objective\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Perturb for third objective\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]]:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\n",
        "score": [
            -0.8020609514601988,
            1.1996041417121888
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt with adaptive edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost and np.random.rand() < 0.7:  # Accept with probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-specific perturbations\n    for _ in range(5):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Perturb for first objective\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Perturb for second objective\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Perturb for third objective\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]]:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    for _ in range(2):  # Perform multiple attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply a secondary operator: swap two non-adjacent nodes if it improves any objective\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{This algorithm selects a solution from the archive using a crowding-distance-based selection, then applies a multi-objective-aware local search that combines 3-opt moves with adaptive edge selection to generate a neighbor solution while ensuring feasibility and potential Pareto improvement across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(3):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n    # Select solution with highest crowding distance (most in the middle of the front)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt move with multi-objective awareness\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try all possible 3-opt configurations\n    for a, b, c in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n        temp_solution = new_solution.copy()\n        temp_solution[a:b] = temp_solution[a:b][::-1]\n        temp_solution[b:c] = temp_solution[b:c][::-1]\n\n        # Calculate all three objectives for the new tour\n        def calculate_objective(tour):\n            obj1 = sum(distance_matrix_1[tour[i], tour[(i+1)%n]] for i in range(n))\n            obj2 = sum(distance_matrix_2[tour[i], tour[(i+1)%n]] for i in range(n))\n            obj3 = sum(distance_matrix_3[tour[i], tour[(i+1)%n]] for i in range(n))\n            return (obj1, obj2, obj3)\n\n        old_obj = calculate_objective(new_solution)\n        new_obj = calculate_objective(temp_solution)\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_obj, old_obj)):\n            new_solution = temp_solution\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.486614072687196,
            0.6857424974441528
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(3):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n    # Select solution with highest crowding distance (most in the middle of the front)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt move with multi-objective awareness\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Try all possible 3-opt configurations\n    for a, b, c in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n        temp_solution = new_solution.copy()\n        temp_solution[a:b] = temp_solution[a:b][::-1]\n        temp_solution[b:c] = temp_solution[b:c][::-1]\n\n        # Calculate all three objectives for the new tour\n        def calculate_objective(tour):\n            obj1 = sum(distance_matrix_1[tour[i], tour[(i+1)%n]] for i in range(n))\n            obj2 = sum(distance_matrix_2[tour[i], tour[(i+1)%n]] for i in range(n))\n            obj3 = sum(distance_matrix_3[tour[i], tour[(i+1)%n]] for i in range(n))\n            return (obj1, obj2, obj3)\n\n        old_obj = calculate_objective(new_solution)\n        new_obj = calculate_objective(temp_solution)\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_obj, old_obj)):\n            new_solution = temp_solution\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect, biased towards edges with high potential improvement\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reverse the segment between i and j\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to break and reconnect\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[k]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reconnect the edges in a different order\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        new_solution[(j+1):(k+1)] = new_solution[(j+1):(k+1)][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6162571465168541,
            0.43652660846710206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to break and reconnect\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Calculate potential improvement for each objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[k]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    # Only perform the swap if it improves at least one objective\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Reconnect the edges in a different order\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        new_solution[(j+1):(k+1)] = new_solution[(j+1):(k+1)][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    for _ in range(2):  # Perform multiple attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply a secondary operator: swap two non-adjacent nodes if it improves any objective\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{This algorithm selects a solution from the archive based on the dominance count of each solution (number of solutions it dominates), then applies a hybrid local search combining 3-opt with objective-aware node insertions to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_counts = [0] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                dominates = True\n                for k in range(3):\n                    if archive[j][1][k] < archive[i][1][k]:\n                        dominates = False\n                        break\n                if dominates and any(archive[j][1][k] < archive[i][1][k] for k in range(3)):\n                    dominance_counts[i] += 1\n\n    selected_idx = np.argmin(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware selection\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start], new_solution[(start+1)%n]]\n            cost2 = distance_matrix_2[new_solution[start], new_solution[(start+1)%n]]\n            cost3 = distance_matrix_3[new_solution[start], new_solution[(start+1)%n]]\n            for i in range(start+1, end):\n                cost1 += distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                cost2 += distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n                cost3 += distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n            return (cost1, cost2, cost3)\n\n        old_cost = segment_cost(a, b) + segment_cost(b, c) + segment_cost(c, a)\n\n        # Try all possible 3-opt moves\n        possible_moves = [\n            (a, b, c, (a, b, c)),\n            (a, c, b, (a, c, b)),\n            (b, a, c, (b, a, c)),\n            (b, c, a, (b, c, a)),\n            (c, a, b, (c, a, b)),\n            (c, b, a, (c, b, a))\n        ]\n\n        best_move = None\n        best_improvement = 0\n\n        for move in possible_moves:\n            new_order = list(new_solution)\n            new_order[move[0]:move[1]] = new_order[move[0]:move[1]][::-1]\n            new_order[move[1]:move[2]] = new_order[move[1]:move[2]][::-1]\n            new_order[move[2]:move[0]] = new_order[move[2]:move[0]][::-1]\n\n            temp_solution = np.array(new_order)\n            new_cost = (0, 0, 0)\n            for i in range(n):\n                new_cost = (\n                    new_cost[0] + distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]],\n                    new_cost[1] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]],\n                    new_cost[2] + distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]]\n                )\n\n            improvement = sum((old - new) for old, new in zip(old_cost, new_cost))\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_move = move[3]\n\n        if best_move:\n            new_solution[best_move[0]:best_move[1]] = new_solution[best_move[0]:best_move[1]][::-1]\n            new_solution[best_move[1]:best_move[2]] = new_solution[best_move[1]:best_move[2]][::-1]\n            new_solution[best_move[2]:best_move[0]] = new_solution[best_move[2]:best_move[0]][::-1]\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n        while pos == node or pos == (node + 1) % n or pos == (node - 1) % n:\n            pos = np.random.randint(0, n)\n\n        old_cost = (\n            distance_matrix_1[new_solution[node], new_solution[(node+1)%n]] +\n            distance_matrix_1[new_solution[(node-1)%n], new_solution[node]],\n            distance_matrix_2[new_solution[node], new_solution[(node+1)%n]] +\n            distance_matrix_2[new_solution[(node-1)%n], new_solution[node]],\n            distance_matrix_3[new_solution[node], new_solution[(node+1)%n]] +\n            distance_matrix_3[new_solution[(node-1)%n], new_solution[node]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[(node-1)%n], new_solution[pos]] +\n            distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n            distance_matrix_2[new_solution[(node-1)%n], new_solution[pos]] +\n            distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n            distance_matrix_3[new_solution[(node-1)%n], new_solution[pos]] +\n            distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]]\n        )\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.689191757605577,
            2.909703481197357
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_counts = [0] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                dominates = True\n                for k in range(3):\n                    if archive[j][1][k] < archive[i][1][k]:\n                        dominates = False\n                        break\n                if dominates and any(archive[j][1][k] < archive[i][1][k] for k in range(3)):\n                    dominance_counts[i] += 1\n\n    selected_idx = np.argmin(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware selection\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start], new_solution[(start+1)%n]]\n            cost2 = distance_matrix_2[new_solution[start], new_solution[(start+1)%n]]\n            cost3 = distance_matrix_3[new_solution[start], new_solution[(start+1)%n]]\n            for i in range(start+1, end):\n                cost1 += distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                cost2 += distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n                cost3 += distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n            return (cost1, cost2, cost3)\n\n        old_cost = segment_cost(a, b) + segment_cost(b, c) + segment_cost(c, a)\n\n        # Try all possible 3-opt moves\n        possible_moves = [\n            (a, b, c, (a, b, c)),\n            (a, c, b, (a, c, b)),\n            (b, a, c, (b, a, c)),\n            (b, c, a, (b, c, a)),\n            (c, a, b, (c, a, b)),\n            (c, b, a, (c, b, a))\n        ]\n\n        best_move = None\n        best_improvement = 0\n\n        for move in possible_moves:\n            new_order = list(new_solution)\n            new_order[move[0]:move[1]] = new_order[move[0]:move[1]][::-1]\n            new_order[move[1]:move[2]] = new_order[move[1]:move[2]][::-1]\n            new_order[move[2]:move[0]] = new_order[move[2]:move[0]][::-1]\n\n            temp_solution = np.array(new_order)\n            new_cost = (0, 0, 0)\n            for i in range(n):\n                new_cost = (\n                    new_cost[0] + distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]],\n                    new_cost[1] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]],\n                    new_cost[2] + distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]]\n                )\n\n            improvement = sum((old - new) for old, new in zip(old_cost, new_cost))\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_move = move[3]\n\n        if best_move:\n            new_solution[best_move[0]:best_move[1]] = new_solution[best_move[0]:best_move[1]][::-1]\n            new_solution[best_move[1]:best_move[2]] = new_solution[best_move[1]:best_move[2]][::-1]\n            new_solution[best_move[2]:best_move[0]] = new_solution[best_move[2]:best_move[0]][::-1]\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n        while pos == node or pos == (node + 1) % n or pos == (node - 1) % n:\n            pos = np.random.randint(0, n)\n\n        old_cost = (\n            distance_matrix_1[new_solution[node], new_solution[(node+1)%n]] +\n            distance_matrix_1[new_solution[(node-1)%n], new_solution[node]],\n            distance_matrix_2[new_solution[node], new_solution[(node+1)%n]] +\n            distance_matrix_2[new_solution[(node-1)%n], new_solution[node]],\n            distance_matrix_3[new_solution[node], new_solution[(node+1)%n]] +\n            distance_matrix_3[new_solution[(node-1)%n], new_solution[node]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[(node-1)%n], new_solution[pos]] +\n            distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n            distance_matrix_2[new_solution[(node-1)%n], new_solution[pos]] +\n            distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n            distance_matrix_3[new_solution[(node-1)%n], new_solution[pos]] +\n            distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]]\n        )\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines objective-aware edge selection with a multi-objective path relinking approach, where promising segments from high-quality solutions are incorporated into the current solution while maintaining feasibility across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst edge in any objective\n    worst_edge_costs = []\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n        worst_edge_costs.append((max_edge_idx, max_edge_cost))\n\n    # Find the worst edge across all objectives\n    worst_edge_idx, _ = max(worst_edge_costs, key=lambda x: x[1])\n\n    # Perform path relinking with a randomly selected elite solution\n    elite_solution = random.choice(archive)[0]\n    elite_edges = set(zip(elite_solution, np.roll(elite_solution, -1)))\n\n    # Find the longest common subsequence (LCS) between current and elite solution\n    lcs = []\n    for i in range(n):\n        for j in range(n):\n            if new_solution[i] == elite_solution[j]:\n                lcs.append((i, j))\n\n    if lcs:\n        # Use the LCS to guide the path relinking\n        lcs_start, lcs_end = lcs[0], lcs[-1]\n        current_pos, elite_pos = lcs_start[0], lcs_start[1]\n\n        # Insert the elite segment into the current solution\n        new_segment = []\n        while elite_pos != lcs_end[1]:\n            new_segment.append(elite_solution[elite_pos])\n            elite_pos = (elite_pos + 1) % n\n\n        # Insert the new segment after the worst edge\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx+1],\n            np.array(new_segment),\n            new_solution[lcs_end[0]+1:]\n        ])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, repair by removing and reinserting missing nodes\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{This new algorithm employs a multi-objective edge swapping strategy that prioritizes high-contribution edges from elite solutions while dynamically balancing improvements across all three objectives through a weighted edge selection mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge contributions across all objectives\n    edge_contributions = []\n    for k in range(n-1):\n        cost1 = distance_matrix_1[new_solution[k], new_solution[k+1]]\n        cost2 = distance_matrix_2[new_solution[k], new_solution[k+1]]\n        cost3 = distance_matrix_3[new_solution[k], new_solution[k+1]]\n        total_contribution = cost1 + cost2 + cost3\n        edge_contributions.append((k, total_contribution))\n\n    # Identify the worst 20% of edges\n    edge_contributions.sort(key=lambda x: x[1], reverse=True)\n    worst_edges = [x[0] for x in edge_contributions[:max(1, n//5)]]\n\n    # Select a random edge to modify\n    if worst_edges:\n        selected_edge = random.choice(worst_edges)\n    else:\n        selected_edge = random.randint(0, n-2)\n\n    # Perform a 2-opt swap to improve the solution\n    i, j = selected_edge, (selected_edge + 1) % n\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by removing and reinserting missing nodes\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6445460656044377,
            1.7685515642166139
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge contributions across all objectives\n    edge_contributions = []\n    for k in range(n-1):\n        cost1 = distance_matrix_1[new_solution[k], new_solution[k+1]]\n        cost2 = distance_matrix_2[new_solution[k], new_solution[k+1]]\n        cost3 = distance_matrix_3[new_solution[k], new_solution[k+1]]\n        total_contribution = cost1 + cost2 + cost3\n        edge_contributions.append((k, total_contribution))\n\n    # Identify the worst 20% of edges\n    edge_contributions.sort(key=lambda x: x[1], reverse=True)\n    worst_edges = [x[0] for x in edge_contributions[:max(1, n//5)]]\n\n    # Select a random edge to modify\n    if worst_edges:\n        selected_edge = random.choice(worst_edges)\n    else:\n        selected_edge = random.randint(0, n-2)\n\n    # Perform a 2-opt swap to improve the solution\n    i, j = selected_edge, (selected_edge + 1) % n\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by removing and reinserting missing nodes\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a weighted sum of objectives, then applies a 3-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [1.0, 0.8, 0.6]  # Weights for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search with objective-aware edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform 3-opt swap\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines objective-aware edge selection with a multi-objective path relinking approach, where promising segments from high-quality solutions are incorporated into the current solution while maintaining feasibility across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst edge in any objective\n    worst_edge_costs = []\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n        worst_edge_costs.append((max_edge_idx, max_edge_cost))\n\n    # Find the worst edge across all objectives\n    worst_edge_idx, _ = max(worst_edge_costs, key=lambda x: x[1])\n\n    # Perform path relinking with a randomly selected elite solution\n    elite_solution = random.choice(archive)[0]\n    elite_edges = set(zip(elite_solution, np.roll(elite_solution, -1)))\n\n    # Find the longest common subsequence (LCS) between current and elite solution\n    lcs = []\n    for i in range(n):\n        for j in range(n):\n            if new_solution[i] == elite_solution[j]:\n                lcs.append((i, j))\n\n    if lcs:\n        # Use the LCS to guide the path relinking\n        lcs_start, lcs_end = lcs[0], lcs[-1]\n        current_pos, elite_pos = lcs_start[0], lcs_start[1]\n\n        # Insert the elite segment into the current solution\n        new_segment = []\n        while elite_pos != lcs_end[1]:\n            new_segment.append(elite_solution[elite_pos])\n            elite_pos = (elite_pos + 1) % n\n\n        # Insert the new segment after the worst edge\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx+1],\n            np.array(new_segment),\n            new_solution[lcs_end[0]+1:]\n        ])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, repair by removing and reinserting missing nodes\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a weighted sum of objectives, then applies a 3-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [1.0, 0.8, 0.6]  # Weights for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search with objective-aware edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform 3-opt swap\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines objective-aware edge selection with a multi-objective path relinking approach, where promising segments from high-quality solutions are incorporated into the current solution while maintaining feasibility across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst edge in any objective\n    worst_edge_costs = []\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n        worst_edge_costs.append((max_edge_idx, max_edge_cost))\n\n    # Find the worst edge across all objectives\n    worst_edge_idx, _ = max(worst_edge_costs, key=lambda x: x[1])\n\n    # Perform path relinking with a randomly selected elite solution\n    elite_solution = random.choice(archive)[0]\n    elite_edges = set(zip(elite_solution, np.roll(elite_solution, -1)))\n\n    # Find the longest common subsequence (LCS) between current and elite solution\n    lcs = []\n    for i in range(n):\n        for j in range(n):\n            if new_solution[i] == elite_solution[j]:\n                lcs.append((i, j))\n\n    if lcs:\n        # Use the LCS to guide the path relinking\n        lcs_start, lcs_end = lcs[0], lcs[-1]\n        current_pos, elite_pos = lcs_start[0], lcs_start[1]\n\n        # Insert the elite segment into the current solution\n        new_segment = []\n        while elite_pos != lcs_end[1]:\n            new_segment.append(elite_solution[elite_pos])\n            elite_pos = (elite_pos + 1) % n\n\n        # Insert the new segment after the worst edge\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx+1],\n            np.array(new_segment),\n            new_solution[lcs_end[0]+1:]\n        ])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, repair by removing and reinserting missing nodes\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7035685802766107,
            0.13554178476333617
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines objective-aware edge selection with a multi-objective path relinking approach, where promising segments from high-quality solutions are incorporated into the current solution while maintaining feasibility across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst edge in any objective\n    worst_edge_costs = []\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n        worst_edge_costs.append((max_edge_idx, max_edge_cost))\n\n    # Find the worst edge across all objectives\n    worst_edge_idx, _ = max(worst_edge_costs, key=lambda x: x[1])\n\n    # Perform path relinking with a randomly selected elite solution\n    elite_solution = random.choice(archive)[0]\n    elite_edges = set(zip(elite_solution, np.roll(elite_solution, -1)))\n\n    # Find the longest common subsequence (LCS) between current and elite solution\n    lcs = []\n    for i in range(n):\n        for j in range(n):\n            if new_solution[i] == elite_solution[j]:\n                lcs.append((i, j))\n\n    if lcs:\n        # Use the LCS to guide the path relinking\n        lcs_start, lcs_end = lcs[0], lcs[-1]\n        current_pos, elite_pos = lcs_start[0], lcs_start[1]\n\n        # Insert the elite segment into the current solution\n        new_segment = []\n        while elite_pos != lcs_end[1]:\n            new_segment.append(elite_solution[elite_pos])\n            elite_pos = (elite_pos + 1) % n\n\n        # Insert the new segment after the worst edge\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx+1],\n            np.array(new_segment),\n            new_solution[lcs_end[0]+1:]\n        ])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, repair by removing and reinserting missing nodes\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{The new algorithm combines a multi-objective edge selection strategy with a hybrid local search that alternates between objective-aware node swaps and path relinking, prioritizing edges that show significant improvement potential across all three objectives while ensuring feasibility through a novel segment insertion and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a base solution with high diversity potential\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge importance scores across all objectives\n    edge_scores = np.zeros(n-1)\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        for k in range(n-1):\n            edge_scores[k] += distance_matrix[new_solution[k], new_solution[k+1]]\n\n    # Find the most critical edge to modify\n    critical_edge = np.argmax(edge_scores)\n    critical_node1 = new_solution[critical_edge]\n    critical_node2 = new_solution[critical_edge+1]\n\n    # Perform a hybrid local search\n    if np.random.rand() < 0.7:  # 70% chance for node swap\n        # Find the best swap candidate\n        best_gain = 0\n        best_swap = None\n        for i in range(n-1):\n            for j in range(i+1, n):\n                if i == critical_edge or i+1 == critical_edge or j == critical_edge or j+1 == critical_edge:\n                    continue\n                # Calculate gain for all objectives\n                gain = 0\n                for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n                    old_cost = (distance_matrix[new_solution[i], new_solution[i+1]] +\n                               distance_matrix[new_solution[j], new_solution[(j+1)%n]])\n                    new_cost = (distance_matrix[new_solution[i], new_solution[j]] +\n                               distance_matrix[new_solution[i+1], new_solution[(j+1)%n]])\n                    gain += old_cost - new_cost\n                if gain > best_gain:\n                    best_gain = gain\n                    best_swap = (i, j)\n\n        if best_swap:\n            i, j = best_swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for path relinking\n        # Select a reference solution with complementary strengths\n        reference_solutions = [sol for sol, _ in archive if not np.array_equal(sol, base_solution)]\n        if reference_solutions:\n            reference = random.choice(reference_solutions)\n            # Find common segments and insert them\n            common_nodes = set(new_solution) & set(reference)\n            if common_nodes:\n                common_positions = {node: np.where(new_solution == node)[0][0] for node in common_nodes}\n                reference_positions = {node: np.where(reference == node)[0][0] for node in common_nodes}\n\n                # Insert reference segments between common nodes\n                for node in common_nodes:\n                    if np.random.rand() < 0.5:  # 50% chance to insert segment\n                        start_pos = common_positions[node]\n                        end_pos = reference_positions[node]\n                        segment = []\n                        current = end_pos\n                        while current != (end_pos + 1) % n:\n                            segment.append(reference[current])\n                            current = (current + 1) % n\n                        # Insert segment after the node\n                        new_solution = np.concatenate([\n                            new_solution[:start_pos+1],\n                            np.array(segment),\n                            new_solution[start_pos+1:]\n                        ])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by removing duplicates and adding missing nodes\n        seen = set()\n        repaired = []\n        for node in new_solution:\n            if node not in seen:\n                seen.add(node)\n                repaired.append(node)\n        missing = set(range(n)) - seen\n        repaired.extend(list(missing))\n        new_solution = np.array(repaired)\n\n    return new_solution\n\n",
        "score": [
            -0.6241526942195883,
            2.505396854877472
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a base solution with high diversity potential\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge importance scores across all objectives\n    edge_scores = np.zeros(n-1)\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        for k in range(n-1):\n            edge_scores[k] += distance_matrix[new_solution[k], new_solution[k+1]]\n\n    # Find the most critical edge to modify\n    critical_edge = np.argmax(edge_scores)\n    critical_node1 = new_solution[critical_edge]\n    critical_node2 = new_solution[critical_edge+1]\n\n    # Perform a hybrid local search\n    if np.random.rand() < 0.7:  # 70% chance for node swap\n        # Find the best swap candidate\n        best_gain = 0\n        best_swap = None\n        for i in range(n-1):\n            for j in range(i+1, n):\n                if i == critical_edge or i+1 == critical_edge or j == critical_edge or j+1 == critical_edge:\n                    continue\n                # Calculate gain for all objectives\n                gain = 0\n                for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n                    old_cost = (distance_matrix[new_solution[i], new_solution[i+1]] +\n                               distance_matrix[new_solution[j], new_solution[(j+1)%n]])\n                    new_cost = (distance_matrix[new_solution[i], new_solution[j]] +\n                               distance_matrix[new_solution[i+1], new_solution[(j+1)%n]])\n                    gain += old_cost - new_cost\n                if gain > best_gain:\n                    best_gain = gain\n                    best_swap = (i, j)\n\n        if best_swap:\n            i, j = best_swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for path relinking\n        # Select a reference solution with complementary strengths\n        reference_solutions = [sol for sol, _ in archive if not np.array_equal(sol, base_solution)]\n        if reference_solutions:\n            reference = random.choice(reference_solutions)\n            # Find common segments and insert them\n            common_nodes = set(new_solution) & set(reference)\n            if common_nodes:\n                common_positions = {node: np.where(new_solution == node)[0][0] for node in common_nodes}\n                reference_positions = {node: np.where(reference == node)[0][0] for node in common_nodes}\n\n                # Insert reference segments between common nodes\n                for node in common_nodes:\n                    if np.random.rand() < 0.5:  # 50% chance to insert segment\n                        start_pos = common_positions[node]\n                        end_pos = reference_positions[node]\n                        segment = []\n                        current = end_pos\n                        while current != (end_pos + 1) % n:\n                            segment.append(reference[current])\n                            current = (current + 1) % n\n                        # Insert segment after the node\n                        new_solution = np.concatenate([\n                            new_solution[:start_pos+1],\n                            np.array(segment),\n                            new_solution[start_pos+1:]\n                        ])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by removing duplicates and adding missing nodes\n        seen = set()\n        repaired = []\n        for node in new_solution:\n            if node not in seen:\n                seen.add(node)\n                repaired.append(node)\n        missing = set(range(n)) - seen\n        repaired.extend(list(missing))\n        new_solution = np.array(repaired)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a multi-objective-aware 2-opt local search with adaptive edge selection and objective-specific perturbations, and ensures feasibility through careful edge swaps.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt with adaptive edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost and np.random.rand() < 0.7:  # Accept with probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-specific perturbations\n    for _ in range(5):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Perturb for first objective\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Perturb for second objective\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Perturb for third objective\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]]:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further refine by considering objective-aware edge selection\n    # Identify edges with high potential for improvement in any of the three objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Randomly select two edges and evaluate their potential improvement\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential new costs for the three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n\n        # If any objective improves, apply the swap\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{This algorithm selects a solution from the archive based on the solution's potential for improvement across all three objectives, then applies a novel multi-objective-aware segment inversion operator that considers the combined impact of edge swaps on all three objectives, while ensuring feasibility through careful segment selection and inversion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) / len(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware segment inversion operator\n    for _ in range(10):\n        # Randomly select a segment to invert\n        seg_start = np.random.randint(0, n)\n        seg_length = np.random.randint(2, min(5, n))\n        seg_end = (seg_start + seg_length) % n\n\n        if seg_start < seg_end:\n            segment = new_solution[seg_start:seg_end]\n        else:\n            segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n\n        # Calculate current and potential new costs for the three objectives\n        current_costs = [\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        ]\n\n        # Create potential new solution\n        temp_solution = new_solution.copy()\n        if seg_start < seg_end:\n            temp_solution[seg_start:seg_end] = segment[::-1]\n        else:\n            temp_solution[:seg_end] = segment[:seg_end][::-1]\n            temp_solution[seg_start:] = segment[seg_end:][::-1]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6435919733843524,
            0.9903238773345947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) / len(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware segment inversion operator\n    for _ in range(10):\n        # Randomly select a segment to invert\n        seg_start = np.random.randint(0, n)\n        seg_length = np.random.randint(2, min(5, n))\n        seg_end = (seg_start + seg_length) % n\n\n        if seg_start < seg_end:\n            segment = new_solution[seg_start:seg_end]\n        else:\n            segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n\n        # Calculate current and potential new costs for the three objectives\n        current_costs = [\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        ]\n\n        # Create potential new solution\n        temp_solution = new_solution.copy()\n        if seg_start < seg_end:\n            temp_solution[seg_start:seg_end] = segment[::-1]\n        else:\n            temp_solution[:seg_end] = segment[:seg_end][::-1]\n            temp_solution[seg_start:] = segment[seg_end:][::-1]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines objective-aware edge selection with a multi-objective path relinking approach, where promising segments from high-quality solutions are incorporated into the current solution while maintaining feasibility across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst edge in any objective\n    worst_edge_costs = []\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n        worst_edge_costs.append((max_edge_idx, max_edge_cost))\n\n    # Find the worst edge across all objectives\n    worst_edge_idx, _ = max(worst_edge_costs, key=lambda x: x[1])\n\n    # Perform path relinking with a randomly selected elite solution\n    elite_solution = random.choice(archive)[0]\n    elite_edges = set(zip(elite_solution, np.roll(elite_solution, -1)))\n\n    # Find the longest common subsequence (LCS) between current and elite solution\n    lcs = []\n    for i in range(n):\n        for j in range(n):\n            if new_solution[i] == elite_solution[j]:\n                lcs.append((i, j))\n\n    if lcs:\n        # Use the LCS to guide the path relinking\n        lcs_start, lcs_end = lcs[0], lcs[-1]\n        current_pos, elite_pos = lcs_start[0], lcs_start[1]\n\n        # Insert the elite segment into the current solution\n        new_segment = []\n        while elite_pos != lcs_end[1]:\n            new_segment.append(elite_solution[elite_pos])\n            elite_pos = (elite_pos + 1) % n\n\n        # Insert the new segment after the worst edge\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx+1],\n            np.array(new_segment),\n            new_solution[lcs_end[0]+1:]\n        ])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, repair by removing and reinserting missing nodes\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    for _ in range(2):  # Perform multiple attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply a secondary operator: swap two non-adjacent nodes if it improves any objective\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{This algorithm selects a solution from the archive based on a multi-objective dominance measure, then applies a novel segment-based crossover operator that combines high-quality segments from the solution with its reverse, creating a neighbor solution that preserves diversity while improving at least one objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_count(sol):\n        count = 0\n        for other_sol, _ in archive:\n            if all(a <= b for a, b in zip(sol[1], other_sol[1])):\n                count += 1\n        return count\n\n    archive.sort(key=lambda x: dominance_count(x))\n    base_solution = archive[0][0].copy()\n\n    # Create a reversed version of the solution\n    reversed_solution = np.flip(base_solution)\n\n    # Find the best segment in the reversed solution\n    best_segment = None\n    best_improvement = 0\n\n    for i in range(len(base_solution)):\n        for j in range(i+1, len(base_solution)):\n            segment = reversed_solution[i:j+1]\n            # Calculate the improvement in each objective\n            original_cost = sum(distance_matrix_1[base_solution[k], base_solution[k+1]] for k in range(i, j))\n            new_cost = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            improvement = original_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_segment = segment\n\n    if best_segment is not None:\n        # Replace the corresponding segment in the original solution\n        i = np.where(base_solution == best_segment[0])[0][0]\n        j = np.where(base_solution == best_segment[-1])[0][0]\n        new_solution = np.concatenate([\n            base_solution[:i],\n            best_segment,\n            base_solution[j+1:]\n        ])\n    else:\n        new_solution = base_solution.copy()\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(base_solution):\n        # If duplicates exist, repair by removing and reinserting missing nodes\n        missing_nodes = set(range(len(base_solution))) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7455237215978701,
            1.4885720252990722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_count(sol):\n        count = 0\n        for other_sol, _ in archive:\n            if all(a <= b for a, b in zip(sol[1], other_sol[1])):\n                count += 1\n        return count\n\n    archive.sort(key=lambda x: dominance_count(x))\n    base_solution = archive[0][0].copy()\n\n    # Create a reversed version of the solution\n    reversed_solution = np.flip(base_solution)\n\n    # Find the best segment in the reversed solution\n    best_segment = None\n    best_improvement = 0\n\n    for i in range(len(base_solution)):\n        for j in range(i+1, len(base_solution)):\n            segment = reversed_solution[i:j+1]\n            # Calculate the improvement in each objective\n            original_cost = sum(distance_matrix_1[base_solution[k], base_solution[k+1]] for k in range(i, j))\n            new_cost = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            improvement = original_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_segment = segment\n\n    if best_segment is not None:\n        # Replace the corresponding segment in the original solution\n        i = np.where(base_solution == best_segment[0])[0][0]\n        j = np.where(base_solution == best_segment[-1])[0][0]\n        new_solution = np.concatenate([\n            base_solution[:i],\n            best_segment,\n            base_solution[j+1:]\n        ])\n    else:\n        new_solution = base_solution.copy()\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(base_solution):\n        # If duplicates exist, repair by removing and reinserting missing nodes\n        missing_nodes = set(range(len(base_solution))) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further refine by considering objective-aware edge selection\n    # Identify edges with high potential for improvement in any of the three objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Randomly select two edges and evaluate their potential improvement\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential new costs for the three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n\n        # If any objective improves, apply the swap\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a 2-opt local search with a novel edge selection strategy that considers both individual objective improvements and combined multi-objective potential, and ensures the solution remains feasible while exploring diverse neighborhood structures.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, 3)\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[i:j] = temp_solution[i:j][::-1]\n\n        # Evaluate multi-objective improvement potential\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        # Accept if any objective improves or if combined improvement is significant\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)) or \\\n           sum(new_costs) < 0.98 * sum(current_costs):\n            new_solution = temp_solution\n\n        # Additional edge swap for multi-objective optimization\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Evaluate edge swap impact\n        current_edges = [\n            (new_solution[a], new_solution[(a+1)%n]),\n            (new_solution[b], new_solution[(b+1)%n])\n        ]\n\n        new_edges = [\n            (temp_solution[a], temp_solution[(a+1)%n]),\n            (temp_solution[b], temp_solution[(b+1)%n])\n        ]\n\n        edge_improvements = [\n            distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n            distance_matrix_1[current_edges[0][0], current_edges[0][1]] - distance_matrix_1[current_edges[1][0], current_edges[1][1]],\n            distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n            distance_matrix_2[current_edges[0][0], current_edges[0][1]] - distance_matrix_2[current_edges[1][0], current_edges[1][1]],\n            distance_matrix_3[new_edges[0][0], new_edges[0][1]] + distance_matrix_3[new_edges[1][0], new_edges[1][1]] -\n            distance_matrix_3[current_edges[0][0], current_edges[0][1]] - distance_matrix_3[current_edges[1][0], current_edges[1][1]]\n        ]\n\n        if any(improvement < 0 for improvement in edge_improvements):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8012330177850181,
            1.228614616394043
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, 3)\n    weighted_scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[i:j] = temp_solution[i:j][::-1]\n\n        # Evaluate multi-objective improvement potential\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        # Accept if any objective improves or if combined improvement is significant\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)) or \\\n           sum(new_costs) < 0.98 * sum(current_costs):\n            new_solution = temp_solution\n\n        # Additional edge swap for multi-objective optimization\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Evaluate edge swap impact\n        current_edges = [\n            (new_solution[a], new_solution[(a+1)%n]),\n            (new_solution[b], new_solution[(b+1)%n])\n        ]\n\n        new_edges = [\n            (temp_solution[a], temp_solution[(a+1)%n]),\n            (temp_solution[b], temp_solution[(b+1)%n])\n        ]\n\n        edge_improvements = [\n            distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n            distance_matrix_1[current_edges[0][0], current_edges[0][1]] - distance_matrix_1[current_edges[1][0], current_edges[1][1]],\n            distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n            distance_matrix_2[current_edges[0][0], current_edges[0][1]] - distance_matrix_2[current_edges[1][0], current_edges[1][1]],\n            distance_matrix_3[new_edges[0][0], new_edges[0][1]] + distance_matrix_3[new_edges[1][0], new_edges[1][1]] -\n            distance_matrix_3[current_edges[0][0], current_edges[0][1]] - distance_matrix_3[current_edges[1][0], current_edges[1][1]]\n        ]\n\n        if any(improvement < 0 for improvement in edge_improvements):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a multi-objective-aware 2-opt local search with adaptive edge selection and objective-specific perturbations, and ensures feasibility through careful edge swaps.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt with adaptive edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost and np.random.rand() < 0.7:  # Accept with probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-specific perturbations\n    for _ in range(5):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Perturb for first objective\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Perturb for second objective\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Perturb for third objective\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]]:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines objective-aware edge selection with a multi-objective path relinking approach, where promising segments from high-quality solutions are incorporated into the current solution while maintaining feasibility across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst edge in any objective\n    worst_edge_costs = []\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n        worst_edge_costs.append((max_edge_idx, max_edge_cost))\n\n    # Find the worst edge across all objectives\n    worst_edge_idx, _ = max(worst_edge_costs, key=lambda x: x[1])\n\n    # Perform path relinking with a randomly selected elite solution\n    elite_solution = random.choice(archive)[0]\n    elite_edges = set(zip(elite_solution, np.roll(elite_solution, -1)))\n\n    # Find the longest common subsequence (LCS) between current and elite solution\n    lcs = []\n    for i in range(n):\n        for j in range(n):\n            if new_solution[i] == elite_solution[j]:\n                lcs.append((i, j))\n\n    if lcs:\n        # Use the LCS to guide the path relinking\n        lcs_start, lcs_end = lcs[0], lcs[-1]\n        current_pos, elite_pos = lcs_start[0], lcs_start[1]\n\n        # Insert the elite segment into the current solution\n        new_segment = []\n        while elite_pos != lcs_end[1]:\n            new_segment.append(elite_solution[elite_pos])\n            elite_pos = (elite_pos + 1) % n\n\n        # Insert the new segment after the worst edge\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx+1],\n            np.array(new_segment),\n            new_solution[lcs_end[0]+1:]\n        ])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, repair by removing and reinserting missing nodes\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{This algorithm combines multi-objective edge selection with a novel segment-based crossover and perturbation strategy that dynamically adapts to the current Pareto front, using objective-aware segment swaps to explore promising regions while maintaining feasibility through careful segment recombination and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify high-improvement segments across objectives\n    segment_length = max(2, n // 10)\n    best_segments = []\n\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        best_segment_cost = np.inf\n        best_segment = None\n        for i in range(n - segment_length + 1):\n            segment = new_solution[i:i+segment_length]\n            segment_cost = sum(distance_matrix[segment[j], segment[(j+1)%segment_length]] for j in range(segment_length))\n            if segment_cost < best_segment_cost:\n                best_segment_cost = segment_cost\n                best_segment = segment.copy()\n\n        if best_segment is not None:\n            best_segments.append((best_segment, obj_idx))\n\n    # Perform segment-based crossover with another solution\n    if best_segments and len(archive) > 1:\n        other_solution = random.choice(archive)[0]\n        segment, obj_idx = random.choice(best_segments)\n\n        # Find the position to insert the segment\n        insert_pos = np.random.randint(0, n - len(segment) + 1)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Repair duplicates by removing and reinserting missing nodes\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply objective-specific segment perturbations\n    for _ in range(3):\n        obj_idx = np.random.choice(3)\n        segment_length = np.random.randint(2, min(5, n//2))\n        i = np.random.randint(0, n - segment_length)\n\n        if obj_idx == 0:\n            current_cost = sum(distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] for j in range(i, i+segment_length))\n            new_cost = sum(distance_matrix_1[new_solution[(i+j)%n], new_solution[(i+j+1)%n]] for j in range(segment_length))\n        elif obj_idx == 1:\n            current_cost = sum(distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] for j in range(i, i+segment_length))\n            new_cost = sum(distance_matrix_2[new_solution[(i+j)%n], new_solution[(i+j+1)%n]] for j in range(segment_length))\n        else:\n            current_cost = sum(distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] for j in range(i, i+segment_length))\n            new_cost = sum(distance_matrix_3[new_solution[(i+j)%n], new_solution[(i+j+1)%n]] for j in range(segment_length))\n\n        if new_cost < current_cost and np.random.rand() < 0.5:\n            new_solution[i:i+segment_length] = new_solution[i:i+segment_length][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6773204956550392,
            0.6646630525588989
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify high-improvement segments across objectives\n    segment_length = max(2, n // 10)\n    best_segments = []\n\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        best_segment_cost = np.inf\n        best_segment = None\n        for i in range(n - segment_length + 1):\n            segment = new_solution[i:i+segment_length]\n            segment_cost = sum(distance_matrix[segment[j], segment[(j+1)%segment_length]] for j in range(segment_length))\n            if segment_cost < best_segment_cost:\n                best_segment_cost = segment_cost\n                best_segment = segment.copy()\n\n        if best_segment is not None:\n            best_segments.append((best_segment, obj_idx))\n\n    # Perform segment-based crossover with another solution\n    if best_segments and len(archive) > 1:\n        other_solution = random.choice(archive)[0]\n        segment, obj_idx = random.choice(best_segments)\n\n        # Find the position to insert the segment\n        insert_pos = np.random.randint(0, n - len(segment) + 1)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Repair duplicates by removing and reinserting missing nodes\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply objective-specific segment perturbations\n    for _ in range(3):\n        obj_idx = np.random.choice(3)\n        segment_length = np.random.randint(2, min(5, n//2))\n        i = np.random.randint(0, n - segment_length)\n\n        if obj_idx == 0:\n            current_cost = sum(distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] for j in range(i, i+segment_length))\n            new_cost = sum(distance_matrix_1[new_solution[(i+j)%n], new_solution[(i+j+1)%n]] for j in range(segment_length))\n        elif obj_idx == 1:\n            current_cost = sum(distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] for j in range(i, i+segment_length))\n            new_cost = sum(distance_matrix_2[new_solution[(i+j)%n], new_solution[(i+j+1)%n]] for j in range(segment_length))\n        else:\n            current_cost = sum(distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] for j in range(i, i+segment_length))\n            new_cost = sum(distance_matrix_3[new_solution[(i+j)%n], new_solution[(i+j+1)%n]] for j in range(segment_length))\n\n        if new_cost < current_cost and np.random.rand() < 0.5:\n            new_solution[i:i+segment_length] = new_solution[i:i+segment_length][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a weighted sum of objectives, then applies a 3-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [1.0, 0.8, 0.6]  # Weights for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search with objective-aware edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform 3-opt swap\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{This new algorithm combines multiple archive solutions using a Pareto-optimal segment selection strategy, followed by an adaptive 2.5-opt local search that dynamically balances improvements across all three objectives based on their relative importance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    balance_scores = np.std(normalized, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply adaptive 2.5-opt local search\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b])\n\n    # Calculate objective weights based on current performance\n    avg_costs = np.mean(objectives, axis=0)\n    weights = 1 / (avg_costs + 1e-8)\n    weights /= weights.sum()\n\n    # Evaluate improvement across all objectives\n    improvement = sum((old - new) * w for (old, new), w in zip(zip(old_cost, new_cost), weights))\n\n    if improvement > 0:\n        # Perform 2.5-opt swap (combination of 2-opt and edge insertion)\n        segment = new_solution[(a+1):(b+1)]\n        new_solution[(a+1):(b+1)] = segment[::-1]\n        # Insert node c after position b\n        if c > b:\n            new_solution = np.concatenate([new_solution[:b+1], [new_solution[c]], new_solution[b+1:c], new_solution[c+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:b+1], [new_solution[c]], new_solution[c:b], new_solution[b+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6843762922340768,
            0.9064132332801819
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    balance_scores = np.std(normalized, axis=1)\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply adaptive 2.5-opt local search\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b])\n\n    # Calculate objective weights based on current performance\n    avg_costs = np.mean(objectives, axis=0)\n    weights = 1 / (avg_costs + 1e-8)\n    weights /= weights.sum()\n\n    # Evaluate improvement across all objectives\n    improvement = sum((old - new) * w for (old, new), w in zip(zip(old_cost, new_cost), weights))\n\n    if improvement > 0:\n        # Perform 2.5-opt swap (combination of 2-opt and edge insertion)\n        segment = new_solution[(a+1):(b+1)]\n        new_solution[(a+1):(b+1)] = segment[::-1]\n        # Insert node c after position b\n        if c > b:\n            new_solution = np.concatenate([new_solution[:b+1], [new_solution[c]], new_solution[b+1:c], new_solution[c+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:b+1], [new_solution[c]], new_solution[c:b], new_solution[b+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further refine by considering objective-aware edge selection\n    # Identify edges with high potential for improvement in any of the three objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Randomly select two edges and evaluate their potential improvement\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential new costs for the three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n\n        # If any objective improves, apply the swap\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{This algorithm selects the first solution from the archive, performs a simple swap of the first two nodes, and returns the modified solution, ensuring feasibility by maintaining a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            -0.6487521269777595,
            0.25273447036743163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find the worst edge and try to replace it with a better one\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find the worst edge in this objective\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n\n        # Try to replace the worst edge with a random better edge\n        if max_edge_idx != -1:\n            u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx + 1) % n]\n            candidates = []\n            for k in range(n):\n                if k != max_edge_idx and k != (max_edge_idx + 1) % n:\n                    # Check if swapping edges would maintain feasibility\n                    if new_solution[k] != u and new_solution[(k + 1) % n] != v:\n                        cost_diff = (distance_matrix[new_solution[k], v] + distance_matrix[u, new_solution[(k + 1) % n]]) - max_edge_cost\n                        if cost_diff < 0:\n                            candidates.append((k, cost_diff))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                k, _ = best_candidate\n                # Perform the swap\n                new_solution[max_edge_idx + 1], new_solution[k] = new_solution[k], new_solution[max_edge_idx + 1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{A novel multi-objective local search algorithm that combines crowding-distance aware selection with a hybrid 2-opt and edge replacement strategy, prioritizing solutions with high crowding distance in the objective space while adaptively improving edges across all three objectives through targeted swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(obj_values):\n        distances = []\n        for i in range(len(obj_values)):\n            left = obj_values[i-1] if i > 0 else obj_values[-1]\n            right = obj_values[(i+1)%len(obj_values)] if i < len(obj_values)-1 else obj_values[0]\n            dist = sum(abs(obj_values[i][j] - left[j]) + abs(obj_values[i][j] - right[j]) for j in range(3))\n            distances.append(dist)\n        return distances\n\n    obj_values = [obj for (sol, obj) in archive]\n    distances = crowding_distance(obj_values)\n    selected_idx = distances.index(max(distances))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with multi-objective edge replacement\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with random edges\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find worst edge and try to replace it\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find worst edge in this objective\n        worst_edge = -1\n        worst_cost = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > worst_cost:\n                worst_cost = edge_cost\n                worst_edge = k\n\n        if worst_edge != -1:\n            u, v = new_solution[worst_edge], new_solution[(worst_edge + 1) % n]\n\n            # Find best replacement edge\n            best_replacement = None\n            best_improvement = 0\n            for k in range(n):\n                if k != worst_edge and k != (worst_edge + 1) % n:\n                    new_u = new_solution[k]\n                    new_v = new_solution[(k + 1) % n]\n                    if new_u != v and new_v != u:\n                        improvement = (distance_matrix[u, new_v] + distance_matrix[new_u, v]) - worst_cost\n                        if improvement < best_improvement:\n                            best_improvement = improvement\n                            best_replacement = k\n\n            if best_replacement is not None:\n                # Perform the replacement\n                new_solution[worst_edge + 1], new_solution[best_replacement] = new_solution[best_replacement], new_solution[worst_edge + 1]\n\n    return new_solution\n\n",
        "score": [
            -0.6039181594909293,
            0.5189500093460083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(obj_values):\n        distances = []\n        for i in range(len(obj_values)):\n            left = obj_values[i-1] if i > 0 else obj_values[-1]\n            right = obj_values[(i+1)%len(obj_values)] if i < len(obj_values)-1 else obj_values[0]\n            dist = sum(abs(obj_values[i][j] - left[j]) + abs(obj_values[i][j] - right[j]) for j in range(3))\n            distances.append(dist)\n        return distances\n\n    obj_values = [obj for (sol, obj) in archive]\n    distances = crowding_distance(obj_values)\n    selected_idx = distances.index(max(distances))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with multi-objective edge replacement\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with random edges\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # For each objective, find worst edge and try to replace it\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        current_cost = sum(distance_matrix[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix[new_solution[-1], new_solution[0]]\n\n        # Find worst edge in this objective\n        worst_edge = -1\n        worst_cost = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > worst_cost:\n                worst_cost = edge_cost\n                worst_edge = k\n\n        if worst_edge != -1:\n            u, v = new_solution[worst_edge], new_solution[(worst_edge + 1) % n]\n\n            # Find best replacement edge\n            best_replacement = None\n            best_improvement = 0\n            for k in range(n):\n                if k != worst_edge and k != (worst_edge + 1) % n:\n                    new_u = new_solution[k]\n                    new_v = new_solution[(k + 1) % n]\n                    if new_u != v and new_v != u:\n                        improvement = (distance_matrix[u, new_v] + distance_matrix[new_u, v]) - worst_cost\n                        if improvement < best_improvement:\n                            best_improvement = improvement\n                            best_replacement = k\n\n            if best_replacement is not None:\n                # Perform the replacement\n                new_solution[worst_edge + 1], new_solution[best_replacement] = new_solution[best_replacement], new_solution[worst_edge + 1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    for _ in range(2):  # Perform multiple attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply a secondary operator: swap two non-adjacent nodes if it improves any objective\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7407640924325171,
            0.39989787340164185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A new algorithm that selects a solution from the archive based on a weighted sum of objectives, then applies a 3-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [1.0, 0.8, 0.6]  # Weights for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search with objective-aware edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform 3-opt swap\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{A new algorithm that selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the spread of each objective's values, then applies a hybrid 3-opt and 2-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    spreads = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    weights = 1.0 / (spreads + 1e-6)  # Avoid division by zero\n    weights /= np.sum(weights)  # Normalize\n\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid 3-opt and 2-opt local search\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # 3-opt move\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # 2-opt move (additional local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7789831971774414,
            0.5182350397109985
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    spreads = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    weights = 1.0 / (spreads + 1e-6)  # Avoid division by zero\n    weights /= np.sum(weights)  # Normalize\n\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid 3-opt and 2-opt local search\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # 3-opt move\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # 2-opt move (additional local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm combines a multi-objective selection criterion with a novel edge insertion operator that prioritizes diverse objective improvements while maintaining feasibility through a constrained insertion strategy.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [0.4, 0.3, 0.3]  # Weights for the three objectives\n    selected = min(archive, key=lambda x: sum(w * v for w, v in zip(weights, x[1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Find the edge with highest combined objective cost\n    max_edge_cost = -1\n    max_edge_idx = -1\n    for i in range(n):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        cost3 = distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        total_cost = weights[0]*cost1 + weights[1]*cost2 + weights[2]*cost3\n        if total_cost > max_edge_cost:\n            max_edge_cost = total_cost\n            max_edge_idx = i\n\n    if max_edge_idx != -1:\n        # Remove the worst edge\n        u, v = new_solution[max_edge_idx], new_solution[(max_edge_idx+1)%n]\n        new_solution = np.concatenate([new_solution[:max_edge_idx+1], new_solution[max_edge_idx+2:]])\n\n        # Find insertion point that improves at least one objective\n        best_improvement = 0\n        best_insert_pos = -1\n        for i in range(len(new_solution)-1):\n            # Calculate potential insertion cost\n            cost1 = distance_matrix_1[new_solution[i], v] + distance_matrix_1[u, new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], v] + distance_matrix_2[u, new_solution[i+1]]\n            cost3 = distance_matrix_3[new_solution[i], v] + distance_matrix_3[u, new_solution[i+1]]\n\n            # Calculate original cost\n            orig_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            orig_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            orig_cost3 = distance_matrix_3[new_solution[i], new_solution[i+1]]\n\n            # Calculate improvement\n            imp1 = orig_cost1 - cost1\n            imp2 = orig_cost2 - cost2\n            imp3 = orig_cost3 - cost3\n\n            # Total weighted improvement\n            total_imp = weights[0]*imp1 + weights[1]*imp2 + weights[2]*imp3\n\n            if total_imp > best_improvement:\n                best_improvement = total_imp\n                best_insert_pos = i\n\n        if best_insert_pos != -1:\n            # Insert the nodes back in the best position\n            new_solution = np.concatenate([\n                new_solution[:best_insert_pos+1],\n                np.array([v, u]),\n                new_solution[best_insert_pos+1:]\n            ])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel \"multi-objective edge insertion\" heuristic that intelligently inserts nodes at positions that improve multiple objectives simultaneously, ensuring feasibility through careful edge replacement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.array([])\n\n    # Normalize objectives to compare across different scales\n    objectives = [obj for _, obj in archive]\n    max_vals = np.max(objectives, axis=0)\n    normalized = [tuple(obj / max_vals) for obj in objectives]\n    combined_scores = [sum(norm) for norm in normalized]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge insertion heuristic\n    for _ in range(3):  # Perform 3 insertion attempts\n        # Randomly select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find insertion position that improves at least two objectives\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx - 1) % n:\n                continue\n\n            # Calculate cost difference for all three objectives\n            prev_node = new_solution[(pos - 1) % n]\n            next_node = new_solution[pos % n]\n\n            old_costs = [\n                distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node],\n                distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node],\n                distance_matrix_3[prev_node, node] + distance_matrix_3[node, next_node]\n            ]\n\n            new_costs = [\n                distance_matrix_1[prev_node, next_node],\n                distance_matrix_2[prev_node, next_node],\n                distance_matrix_3[prev_node, next_node]\n            ]\n\n            improvements = [old - new for old, new in zip(old_costs, new_costs)]\n            improvement_score = sum(1 for imp in improvements if imp > 0)\n\n            # Prefer positions that improve at least two objectives\n            if improvement_score >= 2 and sum(improvements) > best_improvement:\n                best_improvement = sum(improvements)\n                best_pos = pos\n\n        # Perform the insertion if beneficial\n        if best_pos != -1:\n            # Remove the node from its current position\n            new_solution = np.delete(new_solution, node_idx)\n            # Insert it at the best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{This algorithm combines a multi-objective selection criterion with a novel \"objective-aware segment reversal\" operator that identifies critical segments in the tour based on their contribution to each objective, then reverses these segments to simultaneously improve multiple objectives while maintaining feasibility through careful boundary handling.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select the solution with the best combined objective score\n    objectives = [obj for _, obj in archive]\n    max_vals = np.max(objectives, axis=0)\n    normalized = [tuple(obj / max_vals) for obj in objectives]\n    combined_scores = [sum(norm) for norm in normalized]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical segments based on objective contributions\n    segment_scores = []\n    for i in range(n):\n        j = (i + 1) % n\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        cost3 = distance_matrix_3[new_solution[i], new_solution[j]]\n        segment_scores.append((cost1 + cost2 + cost3, i, j))\n\n    # Sort segments by their total cost in descending order\n    segment_scores.sort(reverse=True, key=lambda x: x[0])\n\n    # Reverse the top 3 most expensive segments\n    for _, i, j in segment_scores[:3]:\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Handle circular segment reversal\n            segment = np.concatenate([new_solution[i:], new_solution[:j+1]])\n            reversed_segment = segment[::-1]\n            new_solution = np.concatenate([reversed_segment[n-(i%n):], reversed_segment[:n-(i%n)]])\n\n    return new_solution\n\n",
        "score": [
            -0.6452237903209784,
            0.6148682355880737
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select the solution with the best combined objective score\n    objectives = [obj for _, obj in archive]\n    max_vals = np.max(objectives, axis=0)\n    normalized = [tuple(obj / max_vals) for obj in objectives]\n    combined_scores = [sum(norm) for norm in normalized]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical segments based on objective contributions\n    segment_scores = []\n    for i in range(n):\n        j = (i + 1) % n\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        cost3 = distance_matrix_3[new_solution[i], new_solution[j]]\n        segment_scores.append((cost1 + cost2 + cost3, i, j))\n\n    # Sort segments by their total cost in descending order\n    segment_scores.sort(reverse=True, key=lambda x: x[0])\n\n    # Reverse the top 3 most expensive segments\n    for _, i, j in segment_scores[:3]:\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Handle circular segment reversal\n            segment = np.concatenate([new_solution[i:], new_solution[:j+1]])\n            reversed_segment = segment[::-1]\n            new_solution = np.concatenate([reversed_segment[n-(i%n):], reversed_segment[:n-(i%n)]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.5, 0.3, 0.2])\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[(b+1)%n], new_solution[(d+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(j - i) < 2:\n        j = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7233237258777476,
            0.4089452147483826
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.5, 0.3, 0.2])\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[(b+1)%n], new_solution[(d+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge reversal\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(j - i) < 2:\n        j = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance metric to identify under-explored regions, then applies a hybrid local search combining 2-opt with objective-specific edge swaps to generate a neighbor solution, ensuring feasibility and multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each solution\n    crowding = np.zeros(len(archive))\n    for i in range(3):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        sorted_obj = objectives[sorted_idx, i]\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (sorted_obj[j+1] - sorted_obj[j-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-8)\n\n    # Select solution with lowest crowding (most under-explored)\n    selected_idx = np.argmin(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt local search\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-specific edge swap\n    obj_weights = np.array([0.5, 0.3, 0.2])  # Different weights for objectives\n    for _ in range(3):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while abs(k-l) < 2:\n            l = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[k], new_solution[l]],\n                    distance_matrix_2[new_solution[k], new_solution[l]],\n                    distance_matrix_3[new_solution[k], new_solution[l]])\n\n        if np.dot(new_cost, obj_weights) < np.dot(old_cost, obj_weights):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6708597671341634,
            0.4859090089797974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each solution\n    crowding = np.zeros(len(archive))\n    for i in range(3):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        sorted_obj = objectives[sorted_idx, i]\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (sorted_obj[j+1] - sorted_obj[j-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-8)\n\n    # Select solution with lowest crowding (most under-explored)\n    selected_idx = np.argmin(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt local search\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-specific edge swap\n    obj_weights = np.array([0.5, 0.3, 0.2])  # Different weights for objectives\n    for _ in range(3):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while abs(k-l) < 2:\n            l = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[k], new_solution[l]],\n                    distance_matrix_2[new_solution[k], new_solution[l]],\n                    distance_matrix_3[new_solution[k], new_solution[l]])\n\n        if np.dot(new_cost, obj_weights) < np.dot(old_cost, obj_weights):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a multi-objective-aware 2-opt local search with adaptive edge selection and objective-specific perturbations, and ensures feasibility through careful edge swaps.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt with adaptive edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost and np.random.rand() < 0.7:  # Accept with probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-specific perturbations\n    for _ in range(5):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Perturb for first objective\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Perturb for second objective\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Perturb for third objective\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]]:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{This algorithm employs a novel multi-objective path decomposition and reconstruction approach that first partitions the tour into segments based on objective-specific critical nodes, then intelligently reassembles these segments using a combination of objective-aware edge swaps and adaptive segment merging to create a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical nodes for each objective\n    obj_weights = np.random.dirichlet(np.ones(3))\n    critical_nodes = []\n\n    for obj_idx in range(3):\n        if obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find nodes with highest degree of connectivity in this objective space\n        degrees = np.sum(dist_matrix < np.percentile(dist_matrix, 30), axis=1)\n        critical_nodes.append(np.argsort(degrees)[-int(n*0.2):])  # Top 20% nodes\n\n    # Partition the tour into segments based on critical nodes\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        is_critical = any(node in cn for cn in critical_nodes)\n        if is_critical and len(current_segment) > 1:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n    segments.append(current_segment)\n\n    # Reassemble segments with objective-aware edge swaps\n    for _ in range(5):\n        if len(segments) < 2:\n            break\n\n        # Select segments to merge\n        seg1_idx, seg2_idx = sorted(np.random.choice(len(segments), 2, replace=False))\n        seg1, seg2 = segments[seg1_idx], segments[seg2_idx]\n\n        # Find best merge point based on objective improvement\n        best_improvement = 0\n        best_merge = None\n\n        for i in range(len(seg1)):\n            for j in range(len(seg2)):\n                # Calculate current cost\n                current_cost = sum(w * (distance_matrix_1[seg1[i-1], seg1[i]] +\n                                        distance_matrix_1[seg2[j-1], seg2[j]]) +\n                                  w * (distance_matrix_2[seg1[i-1], seg1[i]] +\n                                       distance_matrix_2[seg2[j-1], seg2[j]]) +\n                                  w * (distance_matrix_3[seg1[i-1], seg1[i]] +\n                                       distance_matrix_3[seg2[j-1], seg2[j]])\n                                  for w in obj_weights)\n\n                # Calculate new cost if merged\n                new_cost = sum(w * (distance_matrix_1[seg1[i-1], seg2[j]] +\n                                    distance_matrix_1[seg2[j], seg1[i]]) +\n                              w * (distance_matrix_2[seg1[i-1], seg2[j]] +\n                                   distance_matrix_2[seg2[j], seg1[i]]) +\n                              w * (distance_matrix_3[seg1[i-1], seg2[j]] +\n                                   distance_matrix_3[seg2[j], seg1[i]])\n                              for w in obj_weights)\n\n                improvement = current_cost - new_cost\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_merge = (i, j)\n\n        if best_merge and best_improvement > 0:\n            i, j = best_merge\n            # Merge the segments\n            new_segment = seg1[:i] + seg2[j:] + seg2[:j] + seg1[i:]\n            segments.pop(max(seg1_idx, seg2_idx))\n            segments.pop(min(seg1_idx, seg2_idx))\n            segments.append(new_segment)\n\n    # Reconstruct the solution from segments\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6237901537551611,
            1.8292125105857848
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical nodes for each objective\n    obj_weights = np.random.dirichlet(np.ones(3))\n    critical_nodes = []\n\n    for obj_idx in range(3):\n        if obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find nodes with highest degree of connectivity in this objective space\n        degrees = np.sum(dist_matrix < np.percentile(dist_matrix, 30), axis=1)\n        critical_nodes.append(np.argsort(degrees)[-int(n*0.2):])  # Top 20% nodes\n\n    # Partition the tour into segments based on critical nodes\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        is_critical = any(node in cn for cn in critical_nodes)\n        if is_critical and len(current_segment) > 1:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n    segments.append(current_segment)\n\n    # Reassemble segments with objective-aware edge swaps\n    for _ in range(5):\n        if len(segments) < 2:\n            break\n\n        # Select segments to merge\n        seg1_idx, seg2_idx = sorted(np.random.choice(len(segments), 2, replace=False))\n        seg1, seg2 = segments[seg1_idx], segments[seg2_idx]\n\n        # Find best merge point based on objective improvement\n        best_improvement = 0\n        best_merge = None\n\n        for i in range(len(seg1)):\n            for j in range(len(seg2)):\n                # Calculate current cost\n                current_cost = sum(w * (distance_matrix_1[seg1[i-1], seg1[i]] +\n                                        distance_matrix_1[seg2[j-1], seg2[j]]) +\n                                  w * (distance_matrix_2[seg1[i-1], seg1[i]] +\n                                       distance_matrix_2[seg2[j-1], seg2[j]]) +\n                                  w * (distance_matrix_3[seg1[i-1], seg1[i]] +\n                                       distance_matrix_3[seg2[j-1], seg2[j]])\n                                  for w in obj_weights)\n\n                # Calculate new cost if merged\n                new_cost = sum(w * (distance_matrix_1[seg1[i-1], seg2[j]] +\n                                    distance_matrix_1[seg2[j], seg1[i]]) +\n                              w * (distance_matrix_2[seg1[i-1], seg2[j]] +\n                                   distance_matrix_2[seg2[j], seg1[i]]) +\n                              w * (distance_matrix_3[seg1[i-1], seg2[j]] +\n                                   distance_matrix_3[seg2[j], seg1[i]])\n                              for w in obj_weights)\n\n                improvement = current_cost - new_cost\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_merge = (i, j)\n\n        if best_merge and best_improvement > 0:\n            i, j = best_merge\n            # Merge the segments\n            new_segment = seg1[:i] + seg2[j:] + seg2[:j] + seg1[i:]\n            segments.pop(max(seg1_idx, seg2_idx))\n            segments.pop(min(seg1_idx, seg2_idx))\n            segments.append(new_segment)\n\n    # Reconstruct the solution from segments\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A new algorithm that selects a solution from the archive based on a weighted sum of objectives, then applies a 3-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [1.0, 0.8, 0.6]  # Weights for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search with objective-aware edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform 3-opt swap\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the current objective values, then applies a hybrid 3-opt local search with probabilistic edge selection to generate a neighbor solution, ensuring improvement in at least one objective while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    avg_objectives = np.mean([obj for _, obj in archive], axis=0)\n    weights = [1.0 / (obj + 1e-6) for obj in avg_objectives]  # Avoid division by zero\n\n    # Normalize weights\n    weights = [w / sum(weights) for w in weights]\n\n    # Selection probability based on weighted sum\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 3-opt with probabilistic edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    # Probabilistic acceptance to allow some non-improving moves\n    if any(new < old for new, old in zip(new_cost, old_cost)) or np.random.random() < 0.1:\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7667865195344993,
            0.5162989020347595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    avg_objectives = np.mean([obj for _, obj in archive], axis=0)\n    weights = [1.0 / (obj + 1e-6) for obj in avg_objectives]  # Avoid division by zero\n\n    # Normalize weights\n    weights = [w / sum(weights) for w in weights]\n\n    # Selection probability based on weighted sum\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 3-opt with probabilistic edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    # Probabilistic acceptance to allow some non-improving moves\n    if any(new < old for new, old in zip(new_cost, old_cost)) or np.random.random() < 0.1:\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    for _ in range(2):  # Perform multiple attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply a secondary operator: swap two non-adjacent nodes if it improves any objective\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further refine by considering objective-aware edge selection\n    # Identify edges with high potential for improvement in any of the three objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Randomly select two edges and evaluate their potential improvement\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential new costs for the three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n            distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] +\n            distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[b]] +\n            distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[b]] +\n            distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n\n        # If any objective improves, apply the swap\n        if any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This algorithm selects a solution from the archive based on the worst-performing objective, then applies a novel multi-objective segment inversion operator that considers the trade-off between all three objectives, ensuring feasibility and potential improvement across all dimensions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_obj = max(archive, key=lambda x: max(x[1]))\n    base_solution = worst_obj[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Apply multi-objective segment inversion with trade-off consideration\n    for _ in range(3):  # Perform multiple attempts\n        # Select a random segment to invert\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or abs(j - i) < 2:  # Ensure segment length > 1\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs for all objectives\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j))\n        ]\n\n        # Create inverted segment\n        inverted_segment = new_solution[i:j+1][::-1]\n        new_costs = [\n            sum(distance_matrix_1[inverted_segment[k], inverted_segment[(k+1)%len(inverted_segment)]] for k in range(len(inverted_segment))),\n            sum(distance_matrix_2[inverted_segment[k], inverted_segment[(k+1)%len(inverted_segment)]] for k in range(len(inverted_segment))),\n            sum(distance_matrix_3[inverted_segment[k], inverted_segment[(k+1)%len(inverted_segment)]] for k in range(len(inverted_segment)))\n        ]\n\n        # Accept if at least one objective improves and the trade-off is balanced\n        if (any(new < current for new, current in zip(new_costs, current_costs)) and\n            sum(new_costs) <= 1.1 * sum(current_costs)):  # Allow slight degradation for trade-off\n            new_solution[i:j+1] = inverted_segment\n\n    # Apply a secondary operator: swap nodes based on multi-objective improvement potential\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        while b == a or b == (a + 1) % n or b == (a - 1) % n:\n            b = np.random.randint(0, n)\n\n        # Calculate potential improvement for all objectives\n        old_costs = [\n            distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]],\n            distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]],\n            distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n        ]\n\n        # Accept if at least one objective improves and the trade-off is balanced\n        if (any(new < old for new, old in zip(new_costs, old_costs)) and\n            sum(new_costs) <= 1.05 * sum(old_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.565757543979135,
            0.7506567001342773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_obj = max(archive, key=lambda x: max(x[1]))\n    base_solution = worst_obj[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Apply multi-objective segment inversion with trade-off consideration\n    for _ in range(3):  # Perform multiple attempts\n        # Select a random segment to invert\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or abs(j - i) < 2:  # Ensure segment length > 1\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs for all objectives\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j))\n        ]\n\n        # Create inverted segment\n        inverted_segment = new_solution[i:j+1][::-1]\n        new_costs = [\n            sum(distance_matrix_1[inverted_segment[k], inverted_segment[(k+1)%len(inverted_segment)]] for k in range(len(inverted_segment))),\n            sum(distance_matrix_2[inverted_segment[k], inverted_segment[(k+1)%len(inverted_segment)]] for k in range(len(inverted_segment))),\n            sum(distance_matrix_3[inverted_segment[k], inverted_segment[(k+1)%len(inverted_segment)]] for k in range(len(inverted_segment)))\n        ]\n\n        # Accept if at least one objective improves and the trade-off is balanced\n        if (any(new < current for new, current in zip(new_costs, current_costs)) and\n            sum(new_costs) <= 1.1 * sum(current_costs)):  # Allow slight degradation for trade-off\n            new_solution[i:j+1] = inverted_segment\n\n    # Apply a secondary operator: swap nodes based on multi-objective improvement potential\n    for _ in range(2):\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        while b == a or b == (a + 1) % n or b == (a - 1) % n:\n            b = np.random.randint(0, n)\n\n        # Calculate potential improvement for all objectives\n        old_costs = [\n            distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n            distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]],\n            distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]],\n            distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n        ]\n\n        # Accept if at least one objective improves and the trade-off is balanced\n        if (any(new < old for new, old in zip(new_costs, old_costs)) and\n            sum(new_costs) <= 1.05 * sum(old_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a weighted sum of objectives, then applies a 3-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [1.0, 0.8, 0.6]  # Weights for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search with objective-aware edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform 3-opt swap\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{This new algorithm combines the objective-aware selection mechanism from the first algorithm with a novel multi-segment inversion operator that adaptively selects and reverses multiple non-overlapping segments in the tour based on objective improvement potential, ensuring feasibility and balanced optimization across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.7, 0.5, 0.3]  # Weights for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(scores) / sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segments = sorted(np.random.choice(range(1, n), size=min(3, n//2), replace=False))\n\n    for i in range(len(segments)):\n        start = segments[i]\n        end = segments[(i+1)%len(segments)] if i+1 < len(segments) else n\n\n        current_cost = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                         distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                         distance_matrix_3[new_solution[start-1], new_solution[start]] +\n                         distance_matrix_1[new_solution[end-1], new_solution[end%n]] +\n                         distance_matrix_2[new_solution[end-1], new_solution[end%n]] +\n                         distance_matrix_3[new_solution[end-1], new_solution[end%n]])\n\n        reversed_cost = (distance_matrix_1[new_solution[start-1], new_solution[end-1]] +\n                          distance_matrix_2[new_solution[start-1], new_solution[end-1]] +\n                          distance_matrix_3[new_solution[start-1], new_solution[end-1]] +\n                          distance_matrix_1[new_solution[start], new_solution[end%n]] +\n                          distance_matrix_2[new_solution[start], new_solution[end%n]] +\n                          distance_matrix_3[new_solution[start], new_solution[end%n]])\n\n        if reversed_cost < current_cost:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.772917928154496,
            1.230957555770874
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.7, 0.5, 0.3]  # Weights for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(scores) / sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segments = sorted(np.random.choice(range(1, n), size=min(3, n//2), replace=False))\n\n    for i in range(len(segments)):\n        start = segments[i]\n        end = segments[(i+1)%len(segments)] if i+1 < len(segments) else n\n\n        current_cost = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                         distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                         distance_matrix_3[new_solution[start-1], new_solution[start]] +\n                         distance_matrix_1[new_solution[end-1], new_solution[end%n]] +\n                         distance_matrix_2[new_solution[end-1], new_solution[end%n]] +\n                         distance_matrix_3[new_solution[end-1], new_solution[end%n]])\n\n        reversed_cost = (distance_matrix_1[new_solution[start-1], new_solution[end-1]] +\n                          distance_matrix_2[new_solution[start-1], new_solution[end-1]] +\n                          distance_matrix_3[new_solution[start-1], new_solution[end-1]] +\n                          distance_matrix_1[new_solution[start], new_solution[end%n]] +\n                          distance_matrix_2[new_solution[start], new_solution[end%n]] +\n                          distance_matrix_3[new_solution[start], new_solution[end%n]])\n\n        if reversed_cost < current_cost:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines objective-aware edge selection with a multi-objective path relinking approach, where promising segments from high-quality solutions are incorporated into the current solution while maintaining feasibility across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst edge in any objective\n    worst_edge_costs = []\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        max_edge_cost = -1\n        max_edge_idx = -1\n        for k in range(n-1):\n            edge_cost = distance_matrix[new_solution[k], new_solution[k+1]]\n            if edge_cost > max_edge_cost:\n                max_edge_cost = edge_cost\n                max_edge_idx = k\n        worst_edge_costs.append((max_edge_idx, max_edge_cost))\n\n    # Find the worst edge across all objectives\n    worst_edge_idx, _ = max(worst_edge_costs, key=lambda x: x[1])\n\n    # Perform path relinking with a randomly selected elite solution\n    elite_solution = random.choice(archive)[0]\n    elite_edges = set(zip(elite_solution, np.roll(elite_solution, -1)))\n\n    # Find the longest common subsequence (LCS) between current and elite solution\n    lcs = []\n    for i in range(n):\n        for j in range(n):\n            if new_solution[i] == elite_solution[j]:\n                lcs.append((i, j))\n\n    if lcs:\n        # Use the LCS to guide the path relinking\n        lcs_start, lcs_end = lcs[0], lcs[-1]\n        current_pos, elite_pos = lcs_start[0], lcs_start[1]\n\n        # Insert the elite segment into the current solution\n        new_segment = []\n        while elite_pos != lcs_end[1]:\n            new_segment.append(elite_solution[elite_pos])\n            elite_pos = (elite_pos + 1) % n\n\n        # Insert the new segment after the worst edge\n        new_solution = np.concatenate([\n            new_solution[:worst_edge_idx+1],\n            np.array(new_segment),\n            new_solution[lcs_end[0]+1:]\n        ])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, repair by removing and reinserting missing nodes\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{This new algorithm combines objective-aware segment selection with a multi-objective inversion operator, where high-quality segments from elite solutions are strategically inverted and reinserted into the current solution to create diverse, high-potential neighbors across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the best segment in each objective\n    best_segments = []\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        min_segment_cost = float('inf')\n        best_segment = None\n\n        # Check all possible segments of length 3 to 5\n        for length in range(3, min(6, n)):\n            for i in range(n - length + 1):\n                segment = new_solution[i:i+length]\n                segment_cost = sum(distance_matrix[segment[j], segment[(j+1)%length]] for j in range(length-1))\n                if segment_cost < min_segment_cost:\n                    min_segment_cost = segment_cost\n                    best_segment = segment\n\n        if best_segment is not None:\n            best_segments.append(best_segment)\n\n    if not best_segments:\n        return new_solution\n\n    # Select the most promising segment (appears in most objectives)\n    segment_counts = {}\n    for segment in best_segments:\n        segment_tuple = tuple(segment)\n        segment_counts[segment_tuple] = segment_counts.get(segment_tuple, 0) + 1\n\n    if segment_counts:\n        best_segment = max(segment_counts.items(), key=lambda x: x[1])[0]\n        best_segment = np.array(best_segment)\n\n        # Invert the segment and reinsert it at a random position\n        inverted_segment = best_segment[::-1]\n        insert_pos = np.random.randint(0, n - len(inverted_segment) + 1)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            inverted_segment,\n            new_solution[insert_pos + len(inverted_segment):]\n        ])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6174738013238577,
            0.4428423881530762
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the best segment in each objective\n    best_segments = []\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        min_segment_cost = float('inf')\n        best_segment = None\n\n        # Check all possible segments of length 3 to 5\n        for length in range(3, min(6, n)):\n            for i in range(n - length + 1):\n                segment = new_solution[i:i+length]\n                segment_cost = sum(distance_matrix[segment[j], segment[(j+1)%length]] for j in range(length-1))\n                if segment_cost < min_segment_cost:\n                    min_segment_cost = segment_cost\n                    best_segment = segment\n\n        if best_segment is not None:\n            best_segments.append(best_segment)\n\n    if not best_segments:\n        return new_solution\n\n    # Select the most promising segment (appears in most objectives)\n    segment_counts = {}\n    for segment in best_segments:\n        segment_tuple = tuple(segment)\n        segment_counts[segment_tuple] = segment_counts.get(segment_tuple, 0) + 1\n\n    if segment_counts:\n        best_segment = max(segment_counts.items(), key=lambda x: x[1])[0]\n        best_segment = np.array(best_segment)\n\n        # Invert the segment and reinsert it at a random position\n        inverted_segment = best_segment[::-1]\n        insert_pos = np.random.randint(0, n - len(inverted_segment) + 1)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            inverted_segment,\n            new_solution[insert_pos + len(inverted_segment):]\n        ])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a multi-objective-aware 2-opt local search with adaptive edge selection and objective-specific perturbations, and ensures feasibility through careful edge swaps.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt with adaptive edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost and np.random.rand() < 0.7:  # Accept with probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-specific perturbations\n    for _ in range(5):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Perturb for first objective\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Perturb for second objective\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Perturb for third objective\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]]:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify promising solutions for improvement, then applies a multi-objective-aware 3-opt local search with adaptive edge selection and objective-specific perturbations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 3-opt local search\n    for _ in range(15):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Try three possible 3-opt moves\n        for move in [\n            (i, j, k),\n            (i, k, j),\n            (j, i, k)\n        ]:\n            a, b, c = move\n            # Calculate cost change for all three objectives\n            cost_change = (\n                (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[c]] + distance_matrix_1[new_solution[c], new_solution[(a+1)%n]] -\n                 distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] - distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] - distance_matrix_1[new_solution[c], new_solution[(c+1)%n]]),\n\n                (distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[c]] + distance_matrix_2[new_solution[c], new_solution[(a+1)%n]] -\n                 distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] - distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] - distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]),\n\n                (distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[c]] + distance_matrix_3[new_solution[c], new_solution[(a+1)%n]] -\n                 distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] - distance_matrix_3[new_solution[b], new_solution[(b+1)%n]] - distance_matrix_3[new_solution[c], new_solution[(c+1)%n]])\n            )\n\n            if all(cost_change[m] < 0 for m in range(3)) and np.random.rand() < 0.8:\n                # Apply the move that improves all objectives\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n                new_solution[b:c+1] = new_solution[b:c+1][::-1]\n                break\n\n    # Objective-specific edge swaps\n    for _ in range(8):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Find best edge swap for first objective\n            best_improvement = 0\n            best_swap = None\n            for a in range(n):\n                for b in range(a+1, n):\n                    improvement = (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a-1)%n], new_solution[(b+1)%n]] -\n                                 distance_matrix_1[new_solution[(a-1)%n], new_solution[a]] - distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                    if improvement < best_improvement:\n                        best_improvement = improvement\n                        best_swap = (a, b)\n            if best_swap and best_improvement < 0 and np.random.rand() < 0.6:\n                a, b = best_swap\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        elif obj_idx == 1:\n            # Find best edge swap for second objective\n            best_improvement = 0\n            best_swap = None\n            for a in range(n):\n                for b in range(a+1, n):\n                    improvement = (distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a-1)%n], new_solution[(b+1)%n]] -\n                                 distance_matrix_2[new_solution[(a-1)%n], new_solution[a]] - distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                    if improvement < best_improvement:\n                        best_improvement = improvement\n                        best_swap = (a, b)\n            if best_swap and best_improvement < 0 and np.random.rand() < 0.6:\n                a, b = best_swap\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Find best edge swap for third objective\n            best_improvement = 0\n            best_swap = None\n            for a in range(n):\n                for b in range(a+1, n):\n                    improvement = (distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[(a-1)%n], new_solution[(b+1)%n]] -\n                                 distance_matrix_3[new_solution[(a-1)%n], new_solution[a]] - distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n                    if improvement < best_improvement:\n                        best_improvement = improvement\n                        best_swap = (a, b)\n            if best_swap and best_improvement < 0 and np.random.rand() < 0.6:\n                a, b = best_swap\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7576575141953822,
            4.27775491476059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 3-opt local search\n    for _ in range(15):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Try three possible 3-opt moves\n        for move in [\n            (i, j, k),\n            (i, k, j),\n            (j, i, k)\n        ]:\n            a, b, c = move\n            # Calculate cost change for all three objectives\n            cost_change = (\n                (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[c]] + distance_matrix_1[new_solution[c], new_solution[(a+1)%n]] -\n                 distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] - distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] - distance_matrix_1[new_solution[c], new_solution[(c+1)%n]]),\n\n                (distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[c]] + distance_matrix_2[new_solution[c], new_solution[(a+1)%n]] -\n                 distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] - distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] - distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]),\n\n                (distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[c]] + distance_matrix_3[new_solution[c], new_solution[(a+1)%n]] -\n                 distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] - distance_matrix_3[new_solution[b], new_solution[(b+1)%n]] - distance_matrix_3[new_solution[c], new_solution[(c+1)%n]])\n            )\n\n            if all(cost_change[m] < 0 for m in range(3)) and np.random.rand() < 0.8:\n                # Apply the move that improves all objectives\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n                new_solution[b:c+1] = new_solution[b:c+1][::-1]\n                break\n\n    # Objective-specific edge swaps\n    for _ in range(8):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Find best edge swap for first objective\n            best_improvement = 0\n            best_swap = None\n            for a in range(n):\n                for b in range(a+1, n):\n                    improvement = (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a-1)%n], new_solution[(b+1)%n]] -\n                                 distance_matrix_1[new_solution[(a-1)%n], new_solution[a]] - distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                    if improvement < best_improvement:\n                        best_improvement = improvement\n                        best_swap = (a, b)\n            if best_swap and best_improvement < 0 and np.random.rand() < 0.6:\n                a, b = best_swap\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        elif obj_idx == 1:\n            # Find best edge swap for second objective\n            best_improvement = 0\n            best_swap = None\n            for a in range(n):\n                for b in range(a+1, n):\n                    improvement = (distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a-1)%n], new_solution[(b+1)%n]] -\n                                 distance_matrix_2[new_solution[(a-1)%n], new_solution[a]] - distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                    if improvement < best_improvement:\n                        best_improvement = improvement\n                        best_swap = (a, b)\n            if best_swap and best_improvement < 0 and np.random.rand() < 0.6:\n                a, b = best_swap\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Find best edge swap for third objective\n            best_improvement = 0\n            best_swap = None\n            for a in range(n):\n                for b in range(a+1, n):\n                    improvement = (distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[(a-1)%n], new_solution[(b+1)%n]] -\n                                 distance_matrix_3[new_solution[(a-1)%n], new_solution[a]] - distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n                    if improvement < best_improvement:\n                        best_improvement = improvement\n                        best_swap = (a, b)\n            if best_swap and best_improvement < 0 and np.random.rand() < 0.6:\n                a, b = best_swap\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A new algorithm that selects a solution from the archive based on a weighted sum of objectives, then applies a 3-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = [1.0, 0.8, 0.6]  # Weights for each objective\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search with objective-aware edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform 3-opt swap\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{A new algorithm that selects a solution from the archive based on a normalized objective score with adaptive weights, then applies a hybrid 2-opt and edge-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.exp(-np.mean(normalized, axis=0))  # Weight inversely proportional to average normalized objective\n    scores = np.dot(normalized, weights)\n\n    # Select solution with probability proportional to score\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with edge-swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform 2-opt swap\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n    else:\n        # Perform edge-swap if 2-opt doesn't help\n        if np.random.rand() < 0.3:  # 30% chance for edge-swap\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            if k != i and l != j and k != j and l != i:\n                old_cost = edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n])\n                new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.743317339197078,
            0.452105188369751
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.exp(-np.mean(normalized, axis=0))  # Weight inversely proportional to average normalized objective\n    scores = np.dot(normalized, weights)\n\n    # Select solution with probability proportional to score\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with edge-swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform 2-opt swap\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n    else:\n        # Perform edge-swap if 2-opt doesn't help\n        if np.random.rand() < 0.3:  # 30% chance for edge-swap\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            if k != i and l != j and k != j and l != i:\n                old_cost = edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n])\n                new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    for _ in range(2):  # Perform multiple attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply a secondary operator: swap two non-adjacent nodes if it improves any objective\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less explored regions, then applies a multi-objective edge insertion heuristic that considers the trade-off between objectives to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n        crowding_distances[sorted_idx[1:-1]] += (sorted_obj[2:] - sorted_obj[:-2]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n    # Select solution with highest crowding distance (least explored region)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge insertion heuristic\n    n = len(new_solution)\n    for _ in range(3):  # Perform multiple attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate objective trade-offs\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Accept if at least one objective improves while others don't worsen too much\n        if (new_cost[0] < old_cost[0] or new_cost[1] < old_cost[1] or new_cost[2] < old_cost[2]) and \\\n           not (new_cost[0] > 1.1 * old_cost[0] or new_cost[1] > 1.1 * old_cost[1] or new_cost[2] > 1.1 * old_cost[2]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6932086936047366,
            0.9934831380844116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n        crowding_distances[sorted_idx[1:-1]] += (sorted_obj[2:] - sorted_obj[:-2]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n    # Select solution with highest crowding distance (least explored region)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective edge insertion heuristic\n    n = len(new_solution)\n    for _ in range(3):  # Perform multiple attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate objective trade-offs\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Accept if at least one objective improves while others don't worsen too much\n        if (new_cost[0] < old_cost[0] or new_cost[1] < old_cost[1] or new_cost[2] < old_cost[2]) and \\\n           not (new_cost[0] > 1.1 * old_cost[0] or new_cost[1] > 1.1 * old_cost[1] or new_cost[2] > 1.1 * old_cost[2]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    for _ in range(2):  # Perform multiple attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply a secondary operator: swap two non-adjacent nodes if it improves any objective\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8113107888687315,
            0.5235142707824707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    for _ in range(2):  # Perform multiple attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply a secondary operator: swap two non-adjacent nodes if it improves any objective\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8113107888687315,
            0.5235142707824707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{This new algorithm employs a multi-objective path relinking approach that dynamically blends segments from two high-quality solutions while incorporating objective-specific edge selection criteria to create a balanced neighbor solution, followed by an adaptive mutation step to explore the solution space across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_k = max(1, len(archive) // 10)\n    top_solutions = sorted(archive, key=lambda x: sum(x[1]))[:top_k]\n\n    # Select two solutions for path relinking\n    sol1, sol2 = random.sample(top_solutions, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by blending segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply adaptive mutation based on objective dominance\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Calculate cost differences for each objective\n        cost_diff1 = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        cost_diff2 = (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        cost_diff3 = (distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Calculate weighted sum of cost differences\n        total_diff = cost_diff1 + cost_diff2 + cost_diff3\n\n        if total_diff < 0:\n            # Perform 2-opt swap if beneficial\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # Perform random swap if not beneficial\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.669159635119182,
            0.15635037422180176
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_k = max(1, len(archive) // 10)\n    top_solutions = sorted(archive, key=lambda x: sum(x[1]))[:top_k]\n\n    # Select two solutions for path relinking\n    sol1, sol2 = random.sample(top_solutions, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by blending segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply adaptive mutation based on objective dominance\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Calculate cost differences for each objective\n        cost_diff1 = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        cost_diff2 = (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        cost_diff3 = (distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]) - (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Calculate weighted sum of cost differences\n        total_diff = cost_diff1 + cost_diff2 + cost_diff3\n\n        if total_diff < 0:\n            # Perform 2-opt swap if beneficial\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # Perform random swap if not beneficial\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with adaptive weights, then applies a hybrid 2-opt and edge-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.exp(-np.mean(normalized, axis=0))  # Weight inversely proportional to average normalized objective\n    scores = np.dot(normalized, weights)\n\n    # Select solution with probability proportional to score\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with edge-swap\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform 2-opt swap\n        new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n    else:\n        # Perform edge-swap if 2-opt doesn't help\n        if np.random.rand() < 0.3:  # 30% chance for edge-swap\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            if k != i and l != j and k != j and l != i:\n                old_cost = edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n])\n                new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n",
        "score": [
            -0.7953175966449583,
            0.4413440227508545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{This algorithm selects a solution from the archive based on the diversity of its objectives, then applies a novel multi-objective path relinking operator that combines segments from the selected solution with segments from a randomly generated solution, followed by an objective-aware insertion heuristic to further optimize the solution across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution\n    random_solution = np.random.permutation(len(base_solution))\n\n    # Apply multi-objective path relinking\n    new_solution = []\n    n = len(base_solution)\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(base_solution[i])\n        else:\n            new_solution.append(random_solution[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware insertion heuristic\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        # Find best insertion position for the node\n        best_pos = i\n        best_cost = (distance_matrix_1[new_solution[(i-1)%n], node] + distance_matrix_1[node, new_solution[(i+1)%n]],\n                     distance_matrix_2[new_solution[(i-1)%n], node] + distance_matrix_2[node, new_solution[(i+1)%n]],\n                     distance_matrix_3[new_solution[(i-1)%n], node] + distance_matrix_3[node, new_solution[(i+1)%n]])\n\n        for pos in range(n):\n            if pos == i or pos == (i-1)%n or pos == (i+1)%n:\n                continue\n            cost = (distance_matrix_1[new_solution[(pos-1)%n], node] + distance_matrix_1[node, new_solution[pos]],\n                    distance_matrix_2[new_solution[(pos-1)%n], node] + distance_matrix_2[node, new_solution[pos]],\n                    distance_matrix_3[new_solution[(pos-1)%n], node] + distance_matrix_3[node, new_solution[pos]])\n            if any(new < old for new, old in zip(cost, best_cost)):\n                best_cost = cost\n                best_pos = pos\n\n        # Perform insertion if beneficial\n        if best_pos != i:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6737423671104347,
            0.3266602396965027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution\n    random_solution = np.random.permutation(len(base_solution))\n\n    # Apply multi-objective path relinking\n    new_solution = []\n    n = len(base_solution)\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(base_solution[i])\n        else:\n            new_solution.append(random_solution[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware insertion heuristic\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        # Find best insertion position for the node\n        best_pos = i\n        best_cost = (distance_matrix_1[new_solution[(i-1)%n], node] + distance_matrix_1[node, new_solution[(i+1)%n]],\n                     distance_matrix_2[new_solution[(i-1)%n], node] + distance_matrix_2[node, new_solution[(i+1)%n]],\n                     distance_matrix_3[new_solution[(i-1)%n], node] + distance_matrix_3[node, new_solution[(i+1)%n]])\n\n        for pos in range(n):\n            if pos == i or pos == (i-1)%n or pos == (i+1)%n:\n                continue\n            cost = (distance_matrix_1[new_solution[(pos-1)%n], node] + distance_matrix_1[node, new_solution[pos]],\n                    distance_matrix_2[new_solution[(pos-1)%n], node] + distance_matrix_2[node, new_solution[pos]],\n                    distance_matrix_3[new_solution[(pos-1)%n], node] + distance_matrix_3[node, new_solution[pos]])\n            if any(new < old for new, old in zip(cost, best_cost)):\n                best_cost = cost\n                best_pos = pos\n\n        # Perform insertion if beneficial\n        if best_pos != i:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the spread of each objective's values, then applies a hybrid 3-opt and 2-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    spreads = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    weights = 1.0 / (spreads + 1e-6)  # Avoid division by zero\n    weights /= np.sum(weights)  # Normalize\n\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid 3-opt and 2-opt local search\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # 3-opt move\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # 2-opt move (additional local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the spread of each objective's values, then applies a hybrid 3-opt and 2-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    spreads = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    weights = 1.0 / (spreads + 1e-6)  # Avoid division by zero\n    weights /= np.sum(weights)  # Normalize\n\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid 3-opt and 2-opt local search\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # 3-opt move\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # 2-opt move (additional local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the spread of each objective's values, then applies a hybrid 3-opt and 2-opt local search with objective-aware edge selection, but additionally incorporates a novel segment-based crossover operation to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    spreads = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    weights = 1.0 / (spreads + 1e-6)\n    weights /= np.sum(weights)\n\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # 3-opt move\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Segment-based crossover\n    if np.random.rand() < 0.5:\n        crossover_point = np.random.randint(1, n-1)\n        new_solution[:crossover_point] = base_solution[:crossover_point]\n        remaining_nodes = [node for node in base_solution if node not in new_solution[:crossover_point]]\n        new_solution[crossover_point:] = np.array(remaining_nodes)\n\n    return new_solution\n\n",
        "score": [
            -0.7855630671340909,
            1.0716437816619873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    spreads = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    weights = 1.0 / (spreads + 1e-6)\n    weights /= np.sum(weights)\n\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # 3-opt move\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Segment-based crossover\n    if np.random.rand() < 0.5:\n        crossover_point = np.random.randint(1, n-1)\n        new_solution[:crossover_point] = base_solution[:crossover_point]\n        remaining_nodes = [node for node in base_solution if node not in new_solution[:crossover_point]]\n        new_solution[crossover_point:] = np.array(remaining_nodes)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the current objective values, then applies a hybrid 3-opt local search with probabilistic edge selection to generate a neighbor solution, ensuring improvement in at least one objective while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    avg_objectives = np.mean([obj for _, obj in archive], axis=0)\n    weights = [1.0 / (obj + 1e-6) for obj in avg_objectives]  # Avoid division by zero\n\n    # Normalize weights\n    weights = [w / sum(weights) for w in weights]\n\n    # Selection probability based on weighted sum\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 3-opt with probabilistic edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    # Probabilistic acceptance to allow some non-improving moves\n    if any(new < old for new, old in zip(new_cost, old_cost)) or np.random.random() < 0.1:\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{This algorithm selects a solution from the archive based on the worst-performing objective, then applies a hybrid 4-opt local search with adaptive edge selection to generate a neighbor solution, prioritizing improvement in the most underperformed objective while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_obj = max([max(obj) for _, obj in archive])\n    candidates = [i for i, (_, obj) in enumerate(archive) if max(obj) == worst_obj]\n    selected_idx = np.random.choice(candidates)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 4-opt with adaptive edge selection\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n    # Adaptive acceptance based on objective improvement\n    if any(new < old for new, old in zip(new_cost, old_cost)) or np.random.random() < 0.2:\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        segment3 = new_solution[(c+1):(d+1)]\n        new_solution[(a+1):(d+1)] = np.concatenate([segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.4732377284617087,
            0.36779247522354125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_obj = max([max(obj) for _, obj in archive])\n    candidates = [i for i, (_, obj) in enumerate(archive) if max(obj) == worst_obj]\n    selected_idx = np.random.choice(candidates)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 4-opt with adaptive edge selection\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n    # Adaptive acceptance based on objective improvement\n    if any(new < old for new, old in zip(new_cost, old_cost)) or np.random.random() < 0.2:\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        segment3 = new_solution[(c+1):(d+1)]\n        new_solution[(a+1):(d+1)] = np.concatenate([segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a multi-objective-aware 2-opt local search with adaptive edge selection and objective-specific perturbations, and ensures feasibility through careful edge swaps.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt with adaptive edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost and np.random.rand() < 0.7:  # Accept with probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-specific perturbations\n    for _ in range(5):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Perturb for first objective\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Perturb for second objective\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Perturb for third objective\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]]:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a multi-objective-aware 2-opt local search with adaptive edge selection and objective-specific perturbations, and ensures feasibility through careful edge swaps.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt with adaptive edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost and np.random.rand() < 0.7:  # Accept with probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-specific perturbations\n    for _ in range(5):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Perturb for first objective\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Perturb for second objective\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Perturb for third objective\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]]:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel multi-objective segment inversion and node shifting operator that intelligently balances improvements across all three objectives by considering both local and global perspective swaps while ensuring feasibility through careful segment manipulation and node reinsertion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / np.sum(diversity)\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion with global perspective\n    for _ in range(15):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                          w * (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                          w * (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                          for w in obj_weights)\n\n        inverted_cost = sum(w * (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                                distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        if inverted_cost < current_cost and np.random.rand() < 0.8:\n            new_solution[i:j+1] = segment[::-1]\n\n    # Multi-objective node shifting with objective-specific criteria\n    for _ in range(8):\n        obj_idx = np.random.choice(3)\n        k = np.random.randint(n)\n        node = new_solution[k]\n\n        # Find best insertion point considering all objectives\n        best_pos = k\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == k or pos == (k-1)%n:\n                continue\n\n            # Calculate cost for current insertion\n            current_cost = 0\n            if obj_idx == 0:\n                current_cost = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] +\n                               distance_matrix_1[new_solution[k-1], new_solution[(k+1)%n]])\n            elif obj_idx == 1:\n                current_cost = (distance_matrix_2[new_solution[pos-1], new_solution[pos]] +\n                               distance_matrix_2[new_solution[k-1], new_solution[(k+1)%n]])\n            else:\n                current_cost = (distance_matrix_3[new_solution[pos-1], new_solution[pos]] +\n                               distance_matrix_3[new_solution[k-1], new_solution[(k+1)%n]])\n\n            # Calculate new cost after insertion\n            new_cost = 0\n            if obj_idx == 0:\n                new_cost = (distance_matrix_1[new_solution[pos-1], node] +\n                           distance_matrix_1[node, new_solution[pos]] +\n                           distance_matrix_1[new_solution[k-1], new_solution[(k+1)%n]])\n            elif obj_idx == 1:\n                new_cost = (distance_matrix_2[new_solution[pos-1], node] +\n                           distance_matrix_2[node, new_solution[pos]] +\n                           distance_matrix_2[new_solution[k-1], new_solution[(k+1)%n]])\n            else:\n                new_cost = (distance_matrix_3[new_solution[pos-1], node] +\n                           distance_matrix_3[node, new_solution[pos]] +\n                           distance_matrix_3[new_solution[k-1], new_solution[(k+1)%n]])\n\n            if new_cost < best_cost and np.random.rand() < 0.6:\n                best_cost = new_cost\n                best_pos = pos\n\n        if best_pos != k:\n            # Remove node and reinsert at best position\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7720846571803919,
            1.5877274513244628
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / np.sum(diversity)\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion with global perspective\n    for _ in range(15):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                          w * (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                          w * (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                          for w in obj_weights)\n\n        inverted_cost = sum(w * (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                                distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        if inverted_cost < current_cost and np.random.rand() < 0.8:\n            new_solution[i:j+1] = segment[::-1]\n\n    # Multi-objective node shifting with objective-specific criteria\n    for _ in range(8):\n        obj_idx = np.random.choice(3)\n        k = np.random.randint(n)\n        node = new_solution[k]\n\n        # Find best insertion point considering all objectives\n        best_pos = k\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == k or pos == (k-1)%n:\n                continue\n\n            # Calculate cost for current insertion\n            current_cost = 0\n            if obj_idx == 0:\n                current_cost = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] +\n                               distance_matrix_1[new_solution[k-1], new_solution[(k+1)%n]])\n            elif obj_idx == 1:\n                current_cost = (distance_matrix_2[new_solution[pos-1], new_solution[pos]] +\n                               distance_matrix_2[new_solution[k-1], new_solution[(k+1)%n]])\n            else:\n                current_cost = (distance_matrix_3[new_solution[pos-1], new_solution[pos]] +\n                               distance_matrix_3[new_solution[k-1], new_solution[(k+1)%n]])\n\n            # Calculate new cost after insertion\n            new_cost = 0\n            if obj_idx == 0:\n                new_cost = (distance_matrix_1[new_solution[pos-1], node] +\n                           distance_matrix_1[node, new_solution[pos]] +\n                           distance_matrix_1[new_solution[k-1], new_solution[(k+1)%n]])\n            elif obj_idx == 1:\n                new_cost = (distance_matrix_2[new_solution[pos-1], node] +\n                           distance_matrix_2[node, new_solution[pos]] +\n                           distance_matrix_2[new_solution[k-1], new_solution[(k+1)%n]])\n            else:\n                new_cost = (distance_matrix_3[new_solution[pos-1], node] +\n                           distance_matrix_3[node, new_solution[pos]] +\n                           distance_matrix_3[new_solution[k-1], new_solution[(k+1)%n]])\n\n            if new_cost < best_cost and np.random.rand() < 0.6:\n                best_cost = new_cost\n                best_pos = pos\n\n        if best_pos != k:\n            # Remove node and reinsert at best position\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining 4-opt with objective-specific node relocations to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) == 0:\n        return archive[0][0].copy()\n\n    # Calculate crowding distances\n    crowding = np.zeros(len(objectives))\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_idx[-1], m] == objectives[sorted_idx[0], m]:\n                continue\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[(c+1)%n], new_solution[(d+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-specific node relocation\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        # Choose the objective to prioritize\n        obj_idx = np.random.randint(0, 3)\n        if obj_idx == 0:\n            dm = distance_matrix_1\n        elif obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        old_cost = dm[new_solution[k], new_solution[(k+1)%n]] + dm[new_solution[l], new_solution[(l+1)%n]]\n        new_cost = dm[new_solution[k], new_solution[l]] + dm[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n        if new_cost < old_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7157243368414208,
            0.6777544379234314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) == 0:\n        return archive[0][0].copy()\n\n    # Calculate crowding distances\n    crowding = np.zeros(len(objectives))\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_idx[-1], m] == objectives[sorted_idx[0], m]:\n                continue\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[(c+1)%n], new_solution[(d+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-specific node relocation\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        # Choose the objective to prioritize\n        obj_idx = np.random.randint(0, 3)\n        if obj_idx == 0:\n            dm = distance_matrix_1\n        elif obj_idx == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        old_cost = dm[new_solution[k], new_solution[(k+1)%n]] + dm[new_solution[l], new_solution[(l+1)%n]]\n        new_cost = dm[new_solution[k], new_solution[l]] + dm[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n        if new_cost < old_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{This new algorithm selects a solution from the archive based on a non-linear transformation of normalized objectives, then applies a hybrid local search combining 4-opt with objective-aware edge insertions to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.5, 0.3, 0.2])  # Different weights for objectives\n    scores = np.sum(normalized ** 2 * weights, axis=1)  # Non-linear transformation\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[d]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n]) + edge_cost(new_solution[(a+1)%n], new_solution[(d+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6716383553935497,
            0.4114772081375122
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.5, 0.3, 0.2])  # Different weights for objectives\n    scores = np.sum(normalized ** 2 * weights, axis=1)  # Non-linear transformation\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[d]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n]) + edge_cost(new_solution[(a+1)%n], new_solution[(d+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the current objective values, then applies a hybrid 3-opt local search with probabilistic edge selection to generate a neighbor solution, ensuring improvement in at least one objective while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    avg_objectives = np.mean([obj for _, obj in archive], axis=0)\n    weights = [1.0 / (obj + 1e-6) for obj in avg_objectives]  # Avoid division by zero\n\n    # Normalize weights\n    weights = [w / sum(weights) for w in weights]\n\n    # Selection probability based on weighted sum\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 3-opt with probabilistic edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    # Probabilistic acceptance to allow some non-improving moves\n    if any(new < old for new, old in zip(new_cost, old_cost)) or np.random.random() < 0.1:\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are proportional to the current objective values, then applies a hybrid 4-opt local search with probabilistic edge selection to generate a neighbor solution, ensuring improvement in at least one objective while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    avg_objectives = np.mean([obj for _, obj in archive], axis=0)\n    weights = [obj + 1e-6 for obj in avg_objectives]  # Avoid zero weights\n\n    # Normalize weights\n    weights = [w / sum(weights) for w in weights]\n\n    # Selection probability based on weighted sum\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(scores) / sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 4-opt with probabilistic edge selection\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n    # Probabilistic acceptance to allow some non-improving moves\n    if any(new < old for new, old in zip(new_cost, old_cost)) or np.random.random() < 0.15:\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        segment3 = new_solution[(c+1):(d+1)]\n        new_solution[(a+1):(d+1)] = np.concatenate([segment3[::-1], segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7529649589271854,
            0.5166299104690552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    avg_objectives = np.mean([obj for _, obj in archive], axis=0)\n    weights = [obj + 1e-6 for obj in avg_objectives]  # Avoid zero weights\n\n    # Normalize weights\n    weights = [w / sum(weights) for w in weights]\n\n    # Selection probability based on weighted sum\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(scores) / sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 4-opt with probabilistic edge selection\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n    # Probabilistic acceptance to allow some non-improving moves\n    if any(new < old for new, old in zip(new_cost, old_cost)) or np.random.random() < 0.15:\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        segment3 = new_solution[(c+1):(d+1)]\n        new_solution[(a+1):(d+1)] = np.concatenate([segment3[::-1], segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a multi-objective-aware 2-opt local search with adaptive edge selection and objective-specific perturbations, and ensures feasibility through careful edge swaps.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt with adaptive edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost and np.random.rand() < 0.7:  # Accept with probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-specific perturbations\n    for _ in range(5):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Perturb for first objective\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Perturb for second objective\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Perturb for third objective\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]]:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic objective-space exploration strategy, applies a hybrid 2-opt and insertion local search with adaptive neighborhood selection and objective-aware perturbations, and ensures feasibility through careful edge operations and node insertions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objective_ranges = [\n        max(objs[0] for _, objs in archive) - min(objs[0] for _, objs in archive),\n        max(objs[1] for _, objs in archive) - min(objs[1] for _, objs in archive),\n        max(objs[2] for _, objs in archive) - min(objs[2] for _, objs in archive)\n    ]\n    weights = np.array([1/(r+1e-6) for r in objective_ranges])  # Inverse range weighting\n    weights /= weights.sum()\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 2-opt and insertion local search\n    for _ in range(15):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost * 0.95:  # More aggressive improvement threshold\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Insertion operation with objective-aware selection\n        k = np.random.randint(n)\n        l = np.random.randint(n)\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n            new_solution = np.insert(new_solution, l, node)\n\n    # Objective-aware perturbations with adaptive intensity\n    for _ in range(8):\n        obj_idx = np.random.choice(3, p=weights)\n        if obj_idx == 0:\n            # First objective perturbation\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] * 1.2:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Second objective perturbation\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]] * 1.2:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Third objective perturbation\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]] * 1.2:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\n",
        "score": [
            -0.7758005193909675,
            1.4864126443862915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objective_ranges = [\n        max(objs[0] for _, objs in archive) - min(objs[0] for _, objs in archive),\n        max(objs[1] for _, objs in archive) - min(objs[1] for _, objs in archive),\n        max(objs[2] for _, objs in archive) - min(objs[2] for _, objs in archive)\n    ]\n    weights = np.array([1/(r+1e-6) for r in objective_ranges])  # Inverse range weighting\n    weights /= weights.sum()\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 2-opt and insertion local search\n    for _ in range(15):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost * 0.95:  # More aggressive improvement threshold\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Insertion operation with objective-aware selection\n        k = np.random.randint(n)\n        l = np.random.randint(n)\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n            new_solution = np.insert(new_solution, l, node)\n\n    # Objective-aware perturbations with adaptive intensity\n    for _ in range(8):\n        obj_idx = np.random.choice(3, p=weights)\n        if obj_idx == 0:\n            # First objective perturbation\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] * 1.2:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Second objective perturbation\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]] * 1.2:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Third objective perturbation\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]] * 1.2:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a multi-objective-aware 2-opt local search with adaptive edge selection and objective-specific perturbations, and ensures feasibility through careful edge swaps.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt with adaptive edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost and np.random.rand() < 0.7:  # Accept with probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-specific perturbations\n    for _ in range(5):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Perturb for first objective\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Perturb for second objective\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Perturb for third objective\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]]:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of crowding distance and objective diversity, then applies a novel segment-based local search with objective-aware segment inversion and adaptive segment length, while ensuring feasibility through careful segment operations and maintaining diversity across objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(3):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    # Combine crowding distance with objective diversity\n    diversity = np.std(objectives, axis=1)\n    scores = crowding + diversity\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment-based local search with adaptive segment length\n    for _ in range(5):\n        seg_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - seg_length)\n        end = start + seg_length\n\n        # Objective-aware segment inversion\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[start], new_solution[(start+1)%n]] +\n                                distance_matrix_1[new_solution[end-1], new_solution[end%n]]) +\n                           w * (distance_matrix_2[new_solution[start], new_solution[(start+1)%n]] +\n                                distance_matrix_2[new_solution[end-1], new_solution[end%n]]) +\n                           w * (distance_matrix_3[new_solution[start], new_solution[(start+1)%n]] +\n                                distance_matrix_3[new_solution[end-1], new_solution[end%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[start], new_solution[end%n]] +\n                            distance_matrix_1[new_solution[(start+1)%n], new_solution[(end-1)%n]]) +\n                       w * (distance_matrix_2[new_solution[start], new_solution[end%n]] +\n                            distance_matrix_2[new_solution[(start+1)%n], new_solution[(end-1)%n]]) +\n                       w * (distance_matrix_3[new_solution[start], new_solution[end%n]] +\n                            distance_matrix_3[new_solution[(start+1)%n], new_solution[(end-1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost or np.random.rand() < 0.3:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Objective-aware segment rotation\n    for _ in range(3):\n        obj_idx = np.random.choice(3)\n        seg_length = np.random.randint(2, min(4, n//3))\n        start = np.random.randint(0, n - seg_length)\n\n        if obj_idx == 0:\n            # Rotate segment to minimize first objective\n            current_cost = distance_matrix_1[new_solution[start], new_solution[(start+1)%n]] + distance_matrix_1[new_solution[(start+seg_length-1)%n], new_solution[(start+seg_length)%n]]\n            min_cost = current_cost\n            best_rotation = 0\n\n            for rot in range(1, seg_length):\n                cost = distance_matrix_1[new_solution[start], new_solution[(start+rot)%n]] + distance_matrix_1[new_solution[(start+seg_length-1)%n], new_solution[(start+rot-1)%n]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_rotation = rot\n\n            if best_rotation > 0:\n                new_solution[start:start+seg_length] = np.roll(new_solution[start:start+seg_length], -best_rotation)\n\n        elif obj_idx == 1:\n            # Rotate segment to minimize second objective\n            current_cost = distance_matrix_2[new_solution[start], new_solution[(start+1)%n]] + distance_matrix_2[new_solution[(start+seg_length-1)%n], new_solution[(start+seg_length)%n]]\n            min_cost = current_cost\n            best_rotation = 0\n\n            for rot in range(1, seg_length):\n                cost = distance_matrix_2[new_solution[start], new_solution[(start+rot)%n]] + distance_matrix_2[new_solution[(start+seg_length-1)%n], new_solution[(start+rot-1)%n]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_rotation = rot\n\n            if best_rotation > 0:\n                new_solution[start:start+seg_length] = np.roll(new_solution[start:start+seg_length], -best_rotation)\n\n        else:\n            # Rotate segment to minimize third objective\n            current_cost = distance_matrix_3[new_solution[start], new_solution[(start+1)%n]] + distance_matrix_3[new_solution[(start+seg_length-1)%n], new_solution[(start+seg_length)%n]]\n            min_cost = current_cost\n            best_rotation = 0\n\n            for rot in range(1, seg_length):\n                cost = distance_matrix_3[new_solution[start], new_solution[(start+rot)%n]] + distance_matrix_3[new_solution[(start+seg_length-1)%n], new_solution[(start+rot-1)%n]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_rotation = rot\n\n            if best_rotation > 0:\n                new_solution[start:start+seg_length] = np.roll(new_solution[start:start+seg_length], -best_rotation)\n\n    return new_solution\n\n",
        "score": [
            -0.7964576148701112,
            0.8611174821853638
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(3):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    # Combine crowding distance with objective diversity\n    diversity = np.std(objectives, axis=1)\n    scores = crowding + diversity\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment-based local search with adaptive segment length\n    for _ in range(5):\n        seg_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - seg_length)\n        end = start + seg_length\n\n        # Objective-aware segment inversion\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[start], new_solution[(start+1)%n]] +\n                                distance_matrix_1[new_solution[end-1], new_solution[end%n]]) +\n                           w * (distance_matrix_2[new_solution[start], new_solution[(start+1)%n]] +\n                                distance_matrix_2[new_solution[end-1], new_solution[end%n]]) +\n                           w * (distance_matrix_3[new_solution[start], new_solution[(start+1)%n]] +\n                                distance_matrix_3[new_solution[end-1], new_solution[end%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[start], new_solution[end%n]] +\n                            distance_matrix_1[new_solution[(start+1)%n], new_solution[(end-1)%n]]) +\n                       w * (distance_matrix_2[new_solution[start], new_solution[end%n]] +\n                            distance_matrix_2[new_solution[(start+1)%n], new_solution[(end-1)%n]]) +\n                       w * (distance_matrix_3[new_solution[start], new_solution[end%n]] +\n                            distance_matrix_3[new_solution[(start+1)%n], new_solution[(end-1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost or np.random.rand() < 0.3:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Objective-aware segment rotation\n    for _ in range(3):\n        obj_idx = np.random.choice(3)\n        seg_length = np.random.randint(2, min(4, n//3))\n        start = np.random.randint(0, n - seg_length)\n\n        if obj_idx == 0:\n            # Rotate segment to minimize first objective\n            current_cost = distance_matrix_1[new_solution[start], new_solution[(start+1)%n]] + distance_matrix_1[new_solution[(start+seg_length-1)%n], new_solution[(start+seg_length)%n]]\n            min_cost = current_cost\n            best_rotation = 0\n\n            for rot in range(1, seg_length):\n                cost = distance_matrix_1[new_solution[start], new_solution[(start+rot)%n]] + distance_matrix_1[new_solution[(start+seg_length-1)%n], new_solution[(start+rot-1)%n]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_rotation = rot\n\n            if best_rotation > 0:\n                new_solution[start:start+seg_length] = np.roll(new_solution[start:start+seg_length], -best_rotation)\n\n        elif obj_idx == 1:\n            # Rotate segment to minimize second objective\n            current_cost = distance_matrix_2[new_solution[start], new_solution[(start+1)%n]] + distance_matrix_2[new_solution[(start+seg_length-1)%n], new_solution[(start+seg_length)%n]]\n            min_cost = current_cost\n            best_rotation = 0\n\n            for rot in range(1, seg_length):\n                cost = distance_matrix_2[new_solution[start], new_solution[(start+rot)%n]] + distance_matrix_2[new_solution[(start+seg_length-1)%n], new_solution[(start+rot-1)%n]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_rotation = rot\n\n            if best_rotation > 0:\n                new_solution[start:start+seg_length] = np.roll(new_solution[start:start+seg_length], -best_rotation)\n\n        else:\n            # Rotate segment to minimize third objective\n            current_cost = distance_matrix_3[new_solution[start], new_solution[(start+1)%n]] + distance_matrix_3[new_solution[(start+seg_length-1)%n], new_solution[(start+seg_length)%n]]\n            min_cost = current_cost\n            best_rotation = 0\n\n            for rot in range(1, seg_length):\n                cost = distance_matrix_3[new_solution[start], new_solution[(start+rot)%n]] + distance_matrix_3[new_solution[(start+seg_length-1)%n], new_solution[(start+rot-1)%n]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_rotation = rot\n\n            if best_rotation > 0:\n                new_solution[start:start+seg_length] = np.roll(new_solution[start:start+seg_length], -best_rotation)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the spread of each objective's values, then applies a hybrid 3-opt and 2-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    spreads = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    weights = 1.0 / (spreads + 1e-6)  # Avoid division by zero\n    weights /= np.sum(weights)  # Normalize\n\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid 3-opt and 2-opt local search\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # 3-opt move\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # 2-opt move (additional local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the current objective values, then applies a hybrid 3-opt local search with probabilistic edge selection to generate a neighbor solution, ensuring improvement in at least one objective while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    avg_objectives = np.mean([obj for _, obj in archive], axis=0)\n    weights = [1.0 / (obj + 1e-6) for obj in avg_objectives]  # Avoid division by zero\n\n    # Normalize weights\n    weights = [w / sum(weights) for w in weights]\n\n    # Selection probability based on weighted sum\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 3-opt with probabilistic edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    # Probabilistic acceptance to allow some non-improving moves\n    if any(new < old for new, old in zip(new_cost, old_cost)) or np.random.random() < 0.1:\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the current objective values, then applies a hybrid 4-opt local search with probabilistic edge selection to generate a neighbor solution, ensuring improvement in at least one objective while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    avg_objectives = np.mean([obj for _, obj in archive], axis=0)\n    weights = [1.0 / (obj + 1e-6) for obj in avg_objectives]\n    weights = [w / sum(weights) for w in weights]\n\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)) or np.random.random() < 0.1:\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        segment3 = new_solution[(c+1):(d+1)]\n        new_solution[(a+1):(d+1)] = np.concatenate([segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7528428789893651,
            0.4601970434188843
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    avg_objectives = np.mean([obj for _, obj in archive], axis=0)\n    weights = [1.0 / (obj + 1e-6) for obj in avg_objectives]\n    weights = [w / sum(weights) for w in weights]\n\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)) or np.random.random() < 0.1:\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        segment3 = new_solution[(c+1):(d+1)]\n        new_solution[(a+1):(d+1)] = np.concatenate([segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the current objective values, then applies a hybrid 3-opt local search with probabilistic edge selection to generate a neighbor solution, ensuring improvement in at least one objective while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    avg_objectives = np.mean([obj for _, obj in archive], axis=0)\n    weights = [1.0 / (obj + 1e-6) for obj in avg_objectives]  # Avoid division by zero\n\n    # Normalize weights\n    weights = [w / sum(weights) for w in weights]\n\n    # Selection probability based on weighted sum\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 3-opt with probabilistic edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    # Probabilistic acceptance to allow some non-improving moves\n    if any(new < old for new, old in zip(new_cost, old_cost)) or np.random.random() < 0.1:\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are proportional to the current objective values, then applies a hybrid 4-opt local search with adaptive edge selection to generate a neighbor solution, ensuring improvement in at least one objective while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_objectives = np.max([obj for _, obj in archive], axis=0)\n    weights = [obj / (max_obj + 1e-6) for obj, max_obj in zip(np.mean([obj for _, obj in archive], axis=0), max_objectives)]\n\n    weights = [w / sum(weights) for w in weights]\n\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(scores) / np.sum(np.array(scores)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)) or np.random.random() < 0.2:\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        segment3 = new_solution[(c+1):(d+1)]\n        new_solution[(a+1):(d+1)] = np.concatenate([segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7505330146668954,
            0.5042648315429688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_objectives = np.max([obj for _, obj in archive], axis=0)\n    weights = [obj / (max_obj + 1e-6) for obj, max_obj in zip(np.mean([obj for _, obj in archive], axis=0), max_objectives)]\n\n    weights = [w / sum(weights) for w in weights]\n\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(scores) / np.sum(np.array(scores)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)) or np.random.random() < 0.2:\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        segment3 = new_solution[(c+1):(d+1)]\n        new_solution[(a+1):(d+1)] = np.concatenate([segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the spread of each objective's values, then applies a hybrid 3-opt and 2-opt local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    spreads = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    weights = 1.0 / (spreads + 1e-6)  # Avoid division by zero\n    weights /= np.sum(weights)  # Normalize\n\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid 3-opt and 2-opt local search\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # 3-opt move\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # 2-opt move (additional local search)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection mechanism that prioritizes solutions with high objective diversity, then applies a novel segment-based local search that combines elements of both 2-opt and 3-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based hybrid local search\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 5))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Try both 2-opt and 3-opt moves on the selected segment\n    for _ in range(2):\n        if np.random.rand() < 0.5:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7307172451307181,
            0.3655233263969421
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based hybrid local search\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 5))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Try both 2-opt and 3-opt moves on the selected segment\n    for _ in range(2):\n        if np.random.rand() < 0.5:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8245367578593978,
            0.546731150150299
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8245367578593978,
            0.546731150150299
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects the first solution from the archive, performs a simple swap of the first two nodes, and returns the modified solution, ensuring feasibility by maintaining a valid TSP tour.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score that balances individual objective improvements and solution diversity, then applies a novel 4-opt local search with objective-aware edge selection and dynamic segment reversal to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives by exploring more complex tour modifications.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * (1 - normalized.mean(axis=0))  # Balance diversity and objective values\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[l]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[i+1:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:l+1]\n        new_solution[i+1:l+1] = np.concatenate([segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7460972722025783,
            0.4353316903114319
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * (1 - normalized.mean(axis=0))  # Balance diversity and objective values\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[l]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[i+1:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:l+1]\n        new_solution[i+1:l+1] = np.concatenate([segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{This new algorithm selects solutions from the archive based on a dynamic score combining objective ranks and diversity measures, then applies a hybrid local search using 2-opt with objective-aware edge selection and a novel multi-objective node relocation strategy to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros_like(objectives)\n    for i in range(3):\n        ranks[:, i] = np.argsort(np.argsort(objectives[:, i]))\n\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        diversity[i] = np.sum(np.abs(ranks[i] - np.mean(ranks, axis=0)))\n\n    scores = np.sum(ranks, axis=1) + 0.3 * diversity\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.7476052291534551,
            0.8985064268112183
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros_like(objectives)\n    for i in range(3):\n        ranks[:, i] = np.argsort(np.argsort(objectives[:, i]))\n\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        diversity[i] = np.sum(np.abs(ranks[i] - np.mean(ranks, axis=0)))\n\n    scores = np.sum(ranks, axis=1) + 0.3 * diversity\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a multi-objective-aware 2-opt local search with adaptive edge selection and objective-specific perturbations, and ensures feasibility through careful edge swaps.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt with adaptive edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost and np.random.rand() < 0.7:  # Accept with probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-specific perturbations\n    for _ in range(5):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Perturb for first objective\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Perturb for second objective\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Perturb for third objective\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]]:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.8126371584141945,
            0.5375605702400208
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on the diversity of its objectives, then applies a novel multi-objective path relinking operator that combines segments from the selected solution with segments from a randomly generated solution, followed by an objective-aware insertion heuristic to further optimize the solution across all three objectives while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a random solution\n    random_solution = np.random.permutation(len(base_solution))\n\n    # Apply multi-objective path relinking\n    new_solution = []\n    n = len(base_solution)\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(base_solution[i])\n        else:\n            new_solution.append(random_solution[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware insertion heuristic\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        # Find best insertion position for the node\n        best_pos = i\n        best_cost = (distance_matrix_1[new_solution[(i-1)%n], node] + distance_matrix_1[node, new_solution[(i+1)%n]],\n                     distance_matrix_2[new_solution[(i-1)%n], node] + distance_matrix_2[node, new_solution[(i+1)%n]],\n                     distance_matrix_3[new_solution[(i-1)%n], node] + distance_matrix_3[node, new_solution[(i+1)%n]])\n\n        for pos in range(n):\n            if pos == i or pos == (i-1)%n or pos == (i+1)%n:\n                continue\n            cost = (distance_matrix_1[new_solution[(pos-1)%n], node] + distance_matrix_1[node, new_solution[pos]],\n                    distance_matrix_2[new_solution[(pos-1)%n], node] + distance_matrix_2[node, new_solution[pos]],\n                    distance_matrix_3[new_solution[(pos-1)%n], node] + distance_matrix_3[node, new_solution[pos]])\n            if any(new < old for new, old in zip(cost, best_cost)):\n                best_cost = cost\n                best_pos = pos\n\n        # Perform insertion if beneficial\n        if best_pos != i:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values, then applies a novel multi-objective edge crossover operator that combines edges from the selected solution with edges from a reference solution, followed by a 3-opt local search to optimize the solution across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create reference solution by sorting nodes based on their combined coordinates\n    combined_coords = instance[:, :2] + instance[:, 2:4]\n    reference_indices = np.argsort(combined_coords[:, 0] + combined_coords[:, 1])\n    reference_solution = np.array([reference_indices[i] for i in range(len(reference_indices))])\n\n    # Apply edge crossover\n    edges = set()\n    n = len(base_solution)\n    for i in range(n):\n        edges.add((base_solution[i], base_solution[(i+1)%n]))\n        edges.add((reference_solution[i], reference_solution[(i+1)%n]))\n\n    # Build new solution using edges\n    new_solution = [base_solution[0]]\n    while len(new_solution) < n:\n        last_node = new_solution[-1]\n        candidates = [edge[1] for edge in edges if edge[0] == last_node and edge[1] not in new_solution]\n        if not candidates:\n            # If no outgoing edges, find a node not yet visited\n            for node in range(n):\n                if node not in new_solution:\n                    candidates = [node]\n                    break\n        next_node = candidates[0]\n        new_solution.append(next_node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(10):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Try all possible 3-opt moves\n        for a, b in [(i, j), (j, k), (i, k)]:\n            # Reverse segment between a and b\n            temp_solution = new_solution.copy()\n            temp_solution[a:b+1] = temp_solution[a:b+1][::-1]\n\n            # Calculate cost change\n            old_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                        distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n            new_cost = (distance_matrix_1[temp_solution[a-1], temp_solution[a]] + distance_matrix_1[temp_solution[b], temp_solution[(b+1)%n]],\n                        distance_matrix_2[temp_solution[a-1], temp_solution[a]] + distance_matrix_2[temp_solution[b], temp_solution[(b+1)%n]],\n                        distance_matrix_3[temp_solution[a-1], temp_solution[a]] + distance_matrix_3[temp_solution[b], temp_solution[(b+1)%n]])\n\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.737088829498857,
            0.5828271508216858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create reference solution by sorting nodes based on their combined coordinates\n    combined_coords = instance[:, :2] + instance[:, 2:4]\n    reference_indices = np.argsort(combined_coords[:, 0] + combined_coords[:, 1])\n    reference_solution = np.array([reference_indices[i] for i in range(len(reference_indices))])\n\n    # Apply edge crossover\n    edges = set()\n    n = len(base_solution)\n    for i in range(n):\n        edges.add((base_solution[i], base_solution[(i+1)%n]))\n        edges.add((reference_solution[i], reference_solution[(i+1)%n]))\n\n    # Build new solution using edges\n    new_solution = [base_solution[0]]\n    while len(new_solution) < n:\n        last_node = new_solution[-1]\n        candidates = [edge[1] for edge in edges if edge[0] == last_node and edge[1] not in new_solution]\n        if not candidates:\n            # If no outgoing edges, find a node not yet visited\n            for node in range(n):\n                if node not in new_solution:\n                    candidates = [node]\n                    break\n        next_node = candidates[0]\n        new_solution.append(next_node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(10):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        # Try all possible 3-opt moves\n        for a, b in [(i, j), (j, k), (i, k)]:\n            # Reverse segment between a and b\n            temp_solution = new_solution.copy()\n            temp_solution[a:b+1] = temp_solution[a:b+1][::-1]\n\n            # Calculate cost change\n            old_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                        distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n            new_cost = (distance_matrix_1[temp_solution[a-1], temp_solution[a]] + distance_matrix_1[temp_solution[b], temp_solution[(b+1)%n]],\n                        distance_matrix_2[temp_solution[a-1], temp_solution[a]] + distance_matrix_2[temp_solution[b], temp_solution[(b+1)%n]],\n                        distance_matrix_3[temp_solution[a-1], temp_solution[a]] + distance_matrix_3[temp_solution[b], temp_solution[(b+1)%n]])\n\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects the first solution from the archive, performs a simple swap of the first two nodes, and returns the modified solution, ensuring feasibility by maintaining a valid TSP tour.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective diversity, then applies a novel multi-objective path relinking strategy that combines segments from the selected solution with promising segments from other solutions in the archive, followed by a targeted 3-opt local search to refine the solution across all three objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Path relinking with multi-objective guidance\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select a reference solution from the archive\n    ref_solution = random.choice(archive)[0].copy()\n\n    # Identify common segments between base and reference solutions\n    for i in range(n):\n        if base_solution[i] == ref_solution[i]:\n            continue\n\n        # Find position of base_solution[i] in ref_solution\n        pos_in_ref = np.where(ref_solution == base_solution[i])[0][0]\n\n        # Calculate cost difference if we swap segments\n        old_cost = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                    distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                    distance_matrix_3[base_solution[i-1], base_solution[i]])\n\n        new_cost = (distance_matrix_1[base_solution[i-1], ref_solution[pos_in_ref]] +\n                    distance_matrix_2[base_solution[i-1], ref_solution[pos_in_ref]] +\n                    distance_matrix_3[base_solution[i-1], ref_solution[pos_in_ref]])\n\n        if new_cost < old_cost:\n            # Perform the swap\n            temp = new_solution[i]\n            new_solution[i] = ref_solution[pos_in_ref]\n            new_solution[pos_in_ref] = temp\n\n    # Apply targeted 3-opt local search\n    for _ in range(10):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate current cost\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] +\n                        distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n        # Try all possible 3-opt moves\n        best_cost = current_cost\n        best_move = None\n\n        # Move 1: Reverse segment between i and j\n        temp_sol = new_solution.copy()\n        temp_sol[(i+1):(j+1)] = temp_sol[(i+1):(j+1)][::-1]\n        new_cost = (distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] +\n                    distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] +\n                    distance_matrix_3[temp_sol[i], temp_sol[(i+1)%n]] +\n                    distance_matrix_1[temp_sol[j], temp_sol[(j+1)%n]] +\n                    distance_matrix_2[temp_sol[j], temp_sol[(j+1)%n]] +\n                    distance_matrix_3[temp_sol[j], temp_sol[(j+1)%n]])\n\n        if new_cost < best_cost:\n            best_cost = new_cost\n            best_move = temp_sol.copy()\n\n        # Move 2: Reverse segment between j and k\n        temp_sol = new_solution.copy()\n        temp_sol[(j+1):(k+1)] = temp_sol[(j+1):(k+1)][::-1]\n        new_cost = (distance_matrix_1[temp_sol[j], temp_sol[(j+1)%n]] +\n                    distance_matrix_2[temp_sol[j], temp_sol[(j+1)%n]] +\n                    distance_matrix_3[temp_sol[j], temp_sol[(j+1)%n]] +\n                    distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] +\n                    distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] +\n                    distance_matrix_3[temp_sol[k], temp_sol[(k+1)%n]])\n\n        if new_cost < best_cost:\n            best_cost = new_cost\n            best_move = temp_sol.copy()\n\n        # Move 3: Reverse segment between i and k\n        temp_sol = new_solution.copy()\n        temp_sol[(i+1):(k+1)] = temp_sol[(i+1):(k+1)][::-1]\n        new_cost = (distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] +\n                    distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] +\n                    distance_matrix_3[temp_sol[i], temp_sol[(i+1)%n]] +\n                    distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] +\n                    distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] +\n                    distance_matrix_3[temp_sol[k], temp_sol[(k+1)%n]])\n\n        if new_cost < best_cost:\n            best_cost = new_cost\n            best_move = temp_sol.copy()\n\n        if best_move is not None:\n            new_solution = best_move.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6902559871885735,
            0.7218490600585937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Path relinking with multi-objective guidance\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select a reference solution from the archive\n    ref_solution = random.choice(archive)[0].copy()\n\n    # Identify common segments between base and reference solutions\n    for i in range(n):\n        if base_solution[i] == ref_solution[i]:\n            continue\n\n        # Find position of base_solution[i] in ref_solution\n        pos_in_ref = np.where(ref_solution == base_solution[i])[0][0]\n\n        # Calculate cost difference if we swap segments\n        old_cost = (distance_matrix_1[base_solution[i-1], base_solution[i]] +\n                    distance_matrix_2[base_solution[i-1], base_solution[i]] +\n                    distance_matrix_3[base_solution[i-1], base_solution[i]])\n\n        new_cost = (distance_matrix_1[base_solution[i-1], ref_solution[pos_in_ref]] +\n                    distance_matrix_2[base_solution[i-1], ref_solution[pos_in_ref]] +\n                    distance_matrix_3[base_solution[i-1], ref_solution[pos_in_ref]])\n\n        if new_cost < old_cost:\n            # Perform the swap\n            temp = new_solution[i]\n            new_solution[i] = ref_solution[pos_in_ref]\n            new_solution[pos_in_ref] = temp\n\n    # Apply targeted 3-opt local search\n    for _ in range(10):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate current cost\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] +\n                        distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] +\n                        distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n        # Try all possible 3-opt moves\n        best_cost = current_cost\n        best_move = None\n\n        # Move 1: Reverse segment between i and j\n        temp_sol = new_solution.copy()\n        temp_sol[(i+1):(j+1)] = temp_sol[(i+1):(j+1)][::-1]\n        new_cost = (distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] +\n                    distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] +\n                    distance_matrix_3[temp_sol[i], temp_sol[(i+1)%n]] +\n                    distance_matrix_1[temp_sol[j], temp_sol[(j+1)%n]] +\n                    distance_matrix_2[temp_sol[j], temp_sol[(j+1)%n]] +\n                    distance_matrix_3[temp_sol[j], temp_sol[(j+1)%n]])\n\n        if new_cost < best_cost:\n            best_cost = new_cost\n            best_move = temp_sol.copy()\n\n        # Move 2: Reverse segment between j and k\n        temp_sol = new_solution.copy()\n        temp_sol[(j+1):(k+1)] = temp_sol[(j+1):(k+1)][::-1]\n        new_cost = (distance_matrix_1[temp_sol[j], temp_sol[(j+1)%n]] +\n                    distance_matrix_2[temp_sol[j], temp_sol[(j+1)%n]] +\n                    distance_matrix_3[temp_sol[j], temp_sol[(j+1)%n]] +\n                    distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] +\n                    distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] +\n                    distance_matrix_3[temp_sol[k], temp_sol[(k+1)%n]])\n\n        if new_cost < best_cost:\n            best_cost = new_cost\n            best_move = temp_sol.copy()\n\n        # Move 3: Reverse segment between i and k\n        temp_sol = new_solution.copy()\n        temp_sol[(i+1):(k+1)] = temp_sol[(i+1):(k+1)][::-1]\n        new_cost = (distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] +\n                    distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] +\n                    distance_matrix_3[temp_sol[i], temp_sol[(i+1)%n]] +\n                    distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] +\n                    distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] +\n                    distance_matrix_3[temp_sol[k], temp_sol[(k+1)%n]])\n\n        if new_cost < best_cost:\n            best_cost = new_cost\n            best_move = temp_sol.copy()\n\n        if best_move is not None:\n            new_solution = best_move.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{An algorithm that selects a solution from the archive based on a weighted sum of normalized objectives, with weights adjusted by objective correlation and solution quality, then applies a hybrid 3-opt and edge-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate correlation between objectives\n    corr_matrix = np.corrcoef(objectives.T)\n    corr_weights = np.mean(corr_matrix, axis=1)\n\n    # Combine with solution quality (inverse of objective values)\n    weights = corr_weights * (1 / (1 + normalized.mean(axis=0)))\n\n    # Select solution with highest weighted score\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.3:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n",
        "score": [
            -0.6962607581178089,
            0.39747267961502075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate correlation between objectives\n    corr_matrix = np.corrcoef(objectives.T)\n    corr_weights = np.mean(corr_matrix, axis=1)\n\n    # Combine with solution quality (inverse of objective values)\n    weights = corr_weights * (1 / (1 + normalized.mean(axis=0)))\n\n    # Select solution with highest weighted score\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.3:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects the first solution from the archive, performs a simple swap of the first two nodes, and returns the modified solution, ensuring feasibility by maintaining a valid TSP tour.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score that balances individual objective improvements and solution diversity, then applies a novel 4-opt local search with objective-aware edge selection and dynamic segment reversal to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives by exploring more complex tour modifications.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * (1 - normalized.mean(axis=0))  # Balance diversity and objective values\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[l]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[i+1:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:l+1]\n        new_solution[i+1:l+1] = np.concatenate([segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score that balances individual objective improvements and solution diversity, then applies a novel hybrid local search operator that combines 2-opt and 3-opt moves with objective-aware edge selection and dynamic segment reversal to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives by exploring more complex tour modifications.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * (1 - normalized.mean(axis=0))\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    move_type = np.random.choice(['2opt', '3opt'])\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    if move_type == '2opt':\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[(i+1)%n], new_solution[(k+1)%n])\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment1 = new_solution[i+1:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution[i+1:k+1] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7387582989644546,
            0.4932074785232544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * (1 - normalized.mean(axis=0))\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    move_type = np.random.choice(['2opt', '3opt'])\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    if move_type == '2opt':\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[(i+1)%n], new_solution[(k+1)%n])\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment1 = new_solution[i+1:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution[i+1:k+1] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects the first solution from the archive, performs a simple swap of the first two nodes, and returns the modified solution, ensuring feasibility by maintaining a valid TSP tour.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This algorithm selects a solution from the archive based on the sum of its normalized objective values, then applies a 2-opt local search with a probability-based edge selection to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on the sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2-opt local search with probability-based edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random edges with probability based on their distance\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate the distance for all three objectives\n    obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    obj3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n\n    # Calculate the new distance if we reverse the segment\n    new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n    new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n    new_obj3 = distance_matrix_3[new_solution[i-1], new_solution[j-1]] + distance_matrix_3[new_solution[i], new_solution[j]]\n\n    # Accept the move if it improves at least one objective\n    if (new_obj1 < obj1) or (new_obj2 < obj2) or (new_obj3 < obj3):\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6979881117807504,
            0.5956823110580445
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on the sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply 2-opt local search with probability-based edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random edges with probability based on their distance\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate the distance for all three objectives\n    obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    obj3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n\n    # Calculate the new distance if we reverse the segment\n    new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n    new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n    new_obj3 = distance_matrix_3[new_solution[i-1], new_solution[j-1]] + distance_matrix_3[new_solution[i], new_solution[j]]\n\n    # Accept the move if it improves at least one objective\n    if (new_obj1 < obj1) or (new_obj2 < obj2) or (new_obj3 < obj3):\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combined objective score that balances individual objective improvements and solution diversity, then applies a novel 4-opt local search with objective-aware edge selection and dynamic segment reversal to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives by exploring more complex tour modifications.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * (1 - normalized.mean(axis=0))  # Balance diversity and objective values\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[l]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[i+1:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:l+1]\n        new_solution[i+1:l+1] = np.concatenate([segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a hybrid 3-opt and edge-swapping local search with objective-aware segment selection and dynamic reversal to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives by exploring both simple and complex tour modifications.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(objectives, axis=0)\n    front_ranks = np.zeros(len(archive))\n    for i in range(3):\n        front_ranks[ranks[:, i]] += i + 1\n    selected_idx = np.argmin(front_ranks)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Hybrid 3-opt and edge-swapping\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[j], new_solution[k]) + edge_cost(new_solution[k], new_solution[(i+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[i+1:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i+1:k+1] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Additional edge-swapping for potential improvement\n    if np.random.rand() < 0.3:\n        u, v = sorted(np.random.choice(n, 2, replace=False))\n        old_edge = edge_cost(new_solution[u], new_solution[(u+1)%n]) + edge_cost(new_solution[v], new_solution[(v+1)%n])\n        new_edge = edge_cost(new_solution[u], new_solution[v]) + edge_cost(new_solution[(u+1)%n], new_solution[(v+1)%n])\n        if any(new < old for new, old in zip(new_edge, old_edge)):\n            new_solution[u+1:v+1] = new_solution[u+1:v+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6375034368741829,
            0.34720554351806643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(objectives, axis=0)\n    front_ranks = np.zeros(len(archive))\n    for i in range(3):\n        front_ranks[ranks[:, i]] += i + 1\n    selected_idx = np.argmin(front_ranks)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Hybrid 3-opt and edge-swapping\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[j], new_solution[k]) + edge_cost(new_solution[k], new_solution[(i+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[i+1:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i+1:k+1] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Additional edge-swapping for potential improvement\n    if np.random.rand() < 0.3:\n        u, v = sorted(np.random.choice(n, 2, replace=False))\n        old_edge = edge_cost(new_solution[u], new_solution[(u+1)%n]) + edge_cost(new_solution[v], new_solution[(v+1)%n])\n        new_edge = edge_cost(new_solution[u], new_solution[v]) + edge_cost(new_solution[(u+1)%n], new_solution[(v+1)%n])\n        if any(new < old for new, old in zip(new_edge, old_edge)):\n            new_solution[u+1:v+1] = new_solution[u+1:v+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combined objective score that balances individual objective improvements and solution diversity, then applies a novel 4-opt local search with objective-aware edge selection and dynamic segment reversal to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives by exploring more complex tour modifications.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * (1 - normalized.mean(axis=0))  # Balance diversity and objective values\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[l]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        segment1 = new_solution[i+1:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:l+1]\n        new_solution[i+1:l+1] = np.concatenate([segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted objective score that emphasizes underperforming objectives and solution diversity, then applies a hybrid 3-opt and 2-opt local search with adaptive segment selection and objective-aware reversal to generate a neighbor solution, ensuring feasibility and targeted improvement across all three objectives by balancing exploration of different tour modifications.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    underperformance = 1 - normalized.mean(axis=0)\n    weights = underperformance * (1 + np.std(normalized, axis=0))\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    if c > b:\n        d = np.random.choice([a, b, c])\n        old_cost = edge_cost(new_solution[d], new_solution[(d+1)%n]) + edge_cost(new_solution[(d+1)%n], new_solution[(d+2)%n])\n        new_cost = edge_cost(new_solution[d], new_solution[(d+2)%n]) + edge_cost(new_solution[(d+1)%n], new_solution[d])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[d+1:d+2] = new_solution[d+1:d+2][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.742352620975636,
            0.5434354662895202
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    underperformance = 1 - normalized.mean(axis=0)\n    weights = underperformance * (1 + np.std(normalized, axis=0))\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    if c > b:\n        d = np.random.choice([a, b, c])\n        old_cost = edge_cost(new_solution[d], new_solution[(d+1)%n]) + edge_cost(new_solution[(d+1)%n], new_solution[(d+2)%n])\n        new_cost = edge_cost(new_solution[d], new_solution[(d+2)%n]) + edge_cost(new_solution[(d+1)%n], new_solution[d])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[d+1:d+2] = new_solution[d+1:d+2][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.780437307133167,
            0.41548835039138793
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a hybrid local search combining multi-objective edge swapping with adaptive node reinsertion, ensuring feasibility while promoting balanced improvement across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.std(normalized, axis=1)\n    quality_scores = -np.sum(objectives, axis=1)\n    combined_scores = diversity_scores + quality_scores\n    probs = np.exp(combined_scores) / np.sum(np.exp(combined_scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge swapping\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Adaptive node reinsertion\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        node_val = new_solution[node]\n\n        # Remove node\n        new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n\n        # Find best insertion position\n        best_pos = 0\n        best_cost = (float('inf'), float('inf'), float('inf'))\n\n        for pos in range(n-1):\n            cost = (distance_matrix_1[node_val, new_solution[pos]] + distance_matrix_1[node_val, new_solution[(pos+1)%(n-1)]],\n                   distance_matrix_2[node_val, new_solution[pos]] + distance_matrix_2[node_val, new_solution[(pos+1)%(n-1)]],\n                   distance_matrix_3[node_val, new_solution[pos]] + distance_matrix_3[node_val, new_solution[(pos+1)%(n-1)]])\n\n            if any(new < best for new, best in zip(cost, best_cost)):\n                best_pos = pos\n                best_cost = cost\n\n        new_solution = np.insert(new_solution, best_pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.7855107893634103,
            0.6542032122611999
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.std(normalized, axis=1)\n    quality_scores = -np.sum(objectives, axis=1)\n    combined_scores = diversity_scores + quality_scores\n    probs = np.exp(combined_scores) / np.sum(np.exp(combined_scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge swapping\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        i, j = min(i, j), max(i, j)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Adaptive node reinsertion\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        node_val = new_solution[node]\n\n        # Remove node\n        new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n\n        # Find best insertion position\n        best_pos = 0\n        best_cost = (float('inf'), float('inf'), float('inf'))\n\n        for pos in range(n-1):\n            cost = (distance_matrix_1[node_val, new_solution[pos]] + distance_matrix_1[node_val, new_solution[(pos+1)%(n-1)]],\n                   distance_matrix_2[node_val, new_solution[pos]] + distance_matrix_2[node_val, new_solution[(pos+1)%(n-1)]],\n                   distance_matrix_3[node_val, new_solution[pos]] + distance_matrix_3[node_val, new_solution[(pos+1)%(n-1)]])\n\n            if any(new < best for new, best in zip(cost, best_cost)):\n                best_pos = pos\n                best_cost = cost\n\n        new_solution = np.insert(new_solution, best_pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a multi-objective-aware 2-opt local search with adaptive edge selection and objective-specific perturbations, and ensures feasibility through careful edge swaps.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.random.dirichlet(np.ones(3))  # Random weights for multi-objective selection\n    selected_idx = np.argmin([sum(w * obj for w, obj in zip(weights, objs)) for _, objs in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware 2-opt with adaptive edge selection\n    for _ in range(10):  # More iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Apply 2-opt with probability based on objective improvement potential\n        obj_weights = np.random.dirichlet(np.ones(3))\n        current_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) +\n                           w * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n                           for w in obj_weights)\n\n        new_cost = sum(w * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]) +\n                       w * (distance_matrix_3[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n                       for w in obj_weights)\n\n        if new_cost < current_cost and np.random.rand() < 0.7:  # Accept with probability\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-specific perturbations\n    for _ in range(5):\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Perturb for first objective\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_1[new_solution[a], new_solution[b]] < distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        elif obj_idx == 1:\n            # Perturb for second objective\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_2[new_solution[c], new_solution[d]] < distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n        else:\n            # Perturb for third objective\n            e, f = sorted(np.random.choice(n, 2, replace=False))\n            if distance_matrix_3[new_solution[e], new_solution[f]] < distance_matrix_3[new_solution[e], new_solution[(e+1)%n]]:\n                new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a dynamic weighted sum of objectives, where weights are inversely proportional to the current objective values, then applies a hybrid 3-opt local search with probabilistic edge selection to generate a neighbor solution, ensuring improvement in at least one objective while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    avg_objectives = np.mean([obj for _, obj in archive], axis=0)\n    weights = [1.0 / (obj + 1e-6) for obj in avg_objectives]  # Avoid division by zero\n\n    # Normalize weights\n    weights = [w / sum(weights) for w in weights]\n\n    # Selection probability based on weighted sum\n    scores = [sum(w * obj for w, obj in zip(weights, objectives)) for _, objectives in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid 3-opt with probabilistic edge selection\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n    # Probabilistic acceptance to allow some non-improving moves\n    if any(new < old for new, old in zip(new_cost, old_cost)) or np.random.random() < 0.1:\n        segment1 = new_solution[(a+1):(b+1)]\n        segment2 = new_solution[(b+1):(c+1)]\n        new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{This algorithm selects a solution from the archive based on a multi-objective Pareto front dominance analysis, then applies a novel \"objective-aware segment rotation\" operator that rotates segments of the tour while considering the trade-offs between objectives, ensuring feasibility through careful segment reversal and insertion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(archive[i][1][k] >= archive[j][1][k] for k in range(3)) and any(archive[i][1][k] > archive[j][1][k] for k in range(3)):\n                dominated[i] = True\n                break\n    candidates = [i for i in range(len(archive)) if not dominated[i]]\n    selected_idx = np.random.choice(candidates) if candidates else np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment rotation\n    for _ in range(5):\n        # Select a segment to rotate\n        start = np.random.randint(n)\n        length = np.random.randint(2, min(5, n))\n        end = (start + length) % n\n        segment = new_solution[start:end] if start < end else np.concatenate([new_solution[start:], new_solution[:end]])\n\n        # Choose an objective to prioritize\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Rotate to minimize first objective\n            best_rotation = 0\n            best_cost = float('inf')\n            for rot in range(1, len(segment)):\n                rotated = np.roll(segment, rot)\n                cost = sum(distance_matrix_1[rotated[i], rotated[(i+1)%len(rotated)]] for i in range(len(rotated)))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_rotation = rot\n            segment = np.roll(segment, best_rotation)\n        elif obj_idx == 1:\n            # Rotate to minimize second objective\n            best_rotation = 0\n            best_cost = float('inf')\n            for rot in range(1, len(segment)):\n                rotated = np.roll(segment, rot)\n                cost = sum(distance_matrix_2[rotated[i], rotated[(i+1)%len(rotated)]] for i in range(len(rotated)))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_rotation = rot\n            segment = np.roll(segment, best_rotation)\n        else:\n            # Rotate to minimize third objective\n            best_rotation = 0\n            best_cost = float('inf')\n            for rot in range(1, len(segment)):\n                rotated = np.roll(segment, rot)\n                cost = sum(distance_matrix_3[rotated[i], rotated[(i+1)%len(rotated)]] for i in range(len(rotated)))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_rotation = rot\n            segment = np.roll(segment, best_rotation)\n\n        # Insert the rotated segment back\n        if start < end:\n            new_solution[start:end] = segment\n        else:\n            new_solution[start:] = segment[:n-start]\n            new_solution[:end] = segment[n-start:]\n\n    return new_solution\n\n",
        "score": [
            -0.7460105994867406,
            2.6714881896972655
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(archive[i][1][k] >= archive[j][1][k] for k in range(3)) and any(archive[i][1][k] > archive[j][1][k] for k in range(3)):\n                dominated[i] = True\n                break\n    candidates = [i for i in range(len(archive)) if not dominated[i]]\n    selected_idx = np.random.choice(candidates) if candidates else np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment rotation\n    for _ in range(5):\n        # Select a segment to rotate\n        start = np.random.randint(n)\n        length = np.random.randint(2, min(5, n))\n        end = (start + length) % n\n        segment = new_solution[start:end] if start < end else np.concatenate([new_solution[start:], new_solution[:end]])\n\n        # Choose an objective to prioritize\n        obj_idx = np.random.choice(3)\n        if obj_idx == 0:\n            # Rotate to minimize first objective\n            best_rotation = 0\n            best_cost = float('inf')\n            for rot in range(1, len(segment)):\n                rotated = np.roll(segment, rot)\n                cost = sum(distance_matrix_1[rotated[i], rotated[(i+1)%len(rotated)]] for i in range(len(rotated)))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_rotation = rot\n            segment = np.roll(segment, best_rotation)\n        elif obj_idx == 1:\n            # Rotate to minimize second objective\n            best_rotation = 0\n            best_cost = float('inf')\n            for rot in range(1, len(segment)):\n                rotated = np.roll(segment, rot)\n                cost = sum(distance_matrix_2[rotated[i], rotated[(i+1)%len(rotated)]] for i in range(len(rotated)))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_rotation = rot\n            segment = np.roll(segment, best_rotation)\n        else:\n            # Rotate to minimize third objective\n            best_rotation = 0\n            best_cost = float('inf')\n            for rot in range(1, len(segment)):\n                rotated = np.roll(segment, rot)\n                cost = sum(distance_matrix_3[rotated[i], rotated[(i+1)%len(rotated)]] for i in range(len(rotated)))\n                if cost < best_cost:\n                    best_cost = cost\n                    best_rotation = rot\n            segment = np.roll(segment, best_rotation)\n\n        # Insert the rotated segment back\n        if start < end:\n            new_solution[start:end] = segment\n        else:\n            new_solution[start:] = segment[:n-start]\n            new_solution[:end] = segment[n-start:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2-opt with objective-aware segment reversal to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware segment reversal\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware segment reversal\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def segment_cost(start, end):\n            cost = (0, 0, 0)\n            for a in range(start, end):\n                b = (a + 1) % n\n                cost = (cost[0] + distance_matrix_1[new_solution[a], new_solution[b]],\n                        cost[1] + distance_matrix_2[new_solution[a], new_solution[b]],\n                        cost[2] + distance_matrix_3[new_solution[a], new_solution[b]])\n            return cost\n\n        old_cost = segment_cost(i, j)\n        new_cost = segment_cost(i, j)[::-1]\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i:(j+1)] = new_solution[i:(j+1)][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7718018597848246,
            0.5551124095916748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware segment reversal\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware segment reversal\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def segment_cost(start, end):\n            cost = (0, 0, 0)\n            for a in range(start, end):\n                b = (a + 1) % n\n                cost = (cost[0] + distance_matrix_1[new_solution[a], new_solution[b]],\n                        cost[1] + distance_matrix_2[new_solution[a], new_solution[b]],\n                        cost[2] + distance_matrix_3[new_solution[a], new_solution[b]])\n            return cost\n\n        old_cost = segment_cost(i, j)\n        new_cost = segment_cost(i, j)[::-1]\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i:(j+1)] = new_solution[i:(j+1)][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a diversity-aware selection mechanism that prioritizes solutions with high objective diversity, then applies a novel segment-based local search that combines elements of both 2-opt and 3-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based hybrid local search\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 5))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Try both 2-opt and 3-opt moves on the selected segment\n    for _ in range(2):\n        if np.random.rand() < 0.5:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware selection mechanism that prioritizes solutions in less crowded regions of the objective space, then applies a novel segment-based local search that combines elements of both 2-opt and 3-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_indices = np.argsort(objectives[:, i])\n        objectives_sorted = objectives[sorted_indices, i]\n        crowding_distances[sorted_indices[1:-1]] += (objectives_sorted[2:] - objectives_sorted[:-2]) / (objectives_sorted[-1] - objectives_sorted[0] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    for _ in range(3):\n        if np.random.rand() < 0.6:\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7230958915464554,
            0.981573486328125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(3):\n        sorted_indices = np.argsort(objectives[:, i])\n        objectives_sorted = objectives[sorted_indices, i]\n        crowding_distances[sorted_indices[1:-1]] += (objectives_sorted[2:] - objectives_sorted[:-2]) / (objectives_sorted[-1] - objectives_sorted[0] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    for _ in range(3):\n        if np.random.rand() < 0.6:\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware selection mechanism that prioritizes solutions with high objective diversity, then applies a novel segment-based local search that combines elements of both 2-opt and 3-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based hybrid local search\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 5))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Try both 2-opt and 3-opt moves on the selected segment\n    for _ in range(2):\n        if np.random.rand() < 0.5:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware mechanism that prioritizes solutions in less crowded regions of the objective space, then applies a novel segment-based local search that combines elements of both 2-opt and 4-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n\n    # Calculate crowding distances\n    crowding_distances = np.zeros(n)\n    for obj_idx in range(3):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, n-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], obj_idx] - objectives[sorted_indices[i-1], obj_idx]) / (objectives[sorted_indices[-1], obj_idx] - objectives[sorted_indices[0], obj_idx] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based hybrid local search with 2-opt and 4-opt\n    n_nodes = len(new_solution)\n    segment_length = max(2, min(6, n_nodes // 4))\n    start = np.random.randint(0, n_nodes - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    for _ in range(3):\n        if np.random.rand() < 0.6:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n_nodes]) + edge_cost(new_solution[j], new_solution[(j+1)%n_nodes]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n_nodes], new_solution[(j+1)%n_nodes]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 4-opt move\n            a, b, c, d = sorted(np.random.choice(range(start, end), 4, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n_nodes]) + edge_cost(new_solution[b], new_solution[(b+1)%n_nodes]) +\n                          edge_cost(new_solution[c], new_solution[(c+1)%n_nodes]) + edge_cost(new_solution[d], new_solution[(d+1)%n_nodes]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) +\n                          edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n_nodes]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                segment3 = new_solution[(c+1):(d+1)]\n                new_solution[(a+1):(d+1)] = np.concatenate([segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.5507301308846493,
            1.7907360196113586
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n\n    # Calculate crowding distances\n    crowding_distances = np.zeros(n)\n    for obj_idx in range(3):\n        sorted_indices = np.argsort(objectives[:, obj_idx])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, n-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], obj_idx] - objectives[sorted_indices[i-1], obj_idx]) / (objectives[sorted_indices[-1], obj_idx] - objectives[sorted_indices[0], obj_idx] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based hybrid local search with 2-opt and 4-opt\n    n_nodes = len(new_solution)\n    segment_length = max(2, min(6, n_nodes // 4))\n    start = np.random.randint(0, n_nodes - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    for _ in range(3):\n        if np.random.rand() < 0.6:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n_nodes]) + edge_cost(new_solution[j], new_solution[(j+1)%n_nodes]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n_nodes], new_solution[(j+1)%n_nodes]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 4-opt move\n            a, b, c, d = sorted(np.random.choice(range(start, end), 4, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n_nodes]) + edge_cost(new_solution[b], new_solution[(b+1)%n_nodes]) +\n                          edge_cost(new_solution[c], new_solution[(c+1)%n_nodes]) + edge_cost(new_solution[d], new_solution[(d+1)%n_nodes]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) +\n                          edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n_nodes]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                segment3 = new_solution[(c+1):(d+1)]\n                new_solution[(a+1):(d+1)] = np.concatenate([segment2[::-1], segment1[::-1], segment3[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a diversity-aware selection mechanism that prioritizes solutions with high objective diversity, then applies a novel segment-based local search that combines elements of both 2-opt and 3-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based hybrid local search\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 5))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Try both 2-opt and 3-opt moves on the selected segment\n    for _ in range(2):\n        if np.random.rand() < 0.5:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-aware selection mechanism that prioritizes solutions with high objective diversity, then applies a novel edge-swapping local search that combines elements of both 2-opt and 4-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.sum(objectives <= objectives, axis=0) / len(archive)\n    selected_idx = np.argmax(np.sum(dominance_scores * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_length = max(3, min(6, n // 4))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    for _ in range(3):\n        if np.random.rand() < 0.4:\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            a, b, c, d = sorted(np.random.choice(range(start, end), 4, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) +\n                          edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) +\n                          edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                segment3 = new_solution[(c+1):(d+1)]\n                new_solution[(a+1):(d+1)] = np.concatenate([segment3[::-1], segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.6761214664381031,
            0.38971418142318726
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.sum(objectives <= objectives, axis=0) / len(archive)\n    selected_idx = np.argmax(np.sum(dominance_scores * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_length = max(3, min(6, n // 4))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    for _ in range(3):\n        if np.random.rand() < 0.4:\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            a, b, c, d = sorted(np.random.choice(range(start, end), 4, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) +\n                          edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) +\n                          edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                segment3 = new_solution[(c+1):(d+1)]\n                new_solution[(a+1):(d+1)] = np.concatenate([segment3[::-1], segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with lower variance, then applies a hybrid local search combining 3-opt with objective-aware edge swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = 1.0 / (variances + 1e-6)\n    weights = weights / np.sum(weights) if np.sum(weights) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[k], new_solution[(j+1)%n]) + edge_cost(new_solution[i], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_segment = np.concatenate([segment1[::-1], segment2[::-1]])\n            new_solution[(i+1):(k+1)] = new_segment\n\n    # Apply objective-aware edge swapping\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7134586461870441,
            0.5117547988891602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = 1.0 / (variances + 1e-6)\n    weights = weights / np.sum(weights) if np.sum(weights) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[k], new_solution[(j+1)%n]) + edge_cost(new_solution[i], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_segment = np.concatenate([segment1[::-1], segment2[::-1]])\n            new_solution[(i+1):(k+1)] = new_segment\n\n    # Apply objective-aware edge swapping\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.2 for each objective), then applies a hybrid local search combining 3-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.748050774424298,
            0.38950161933898925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware selection mechanism that prioritizes solutions with high objective diversity, then applies a novel segment-based local search that combines elements of both 2-opt and 3-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based hybrid local search\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 5))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Try both 2-opt and 3-opt moves on the selected segment\n    for _ in range(2):\n        if np.random.rand() < 0.5:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto-frontier-aware selection mechanism that prioritizes solutions with high objective diversity and applies a novel multi-objective path relinking operator that combines segments from two elite solutions while maintaining feasibility and optimizing across all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    elite_solutions = sorted(archive, key=lambda x: sum(x[1]))[:2]\n    sol1, sol2 = elite_solutions[0][0], elite_solutions[1][0]\n    n = len(sol1)\n\n    # Perform multi-objective path relinking\n    new_solution = np.zeros(n, dtype=int)\n    visited = set()\n    current_node = sol1[0]\n    visited.add(current_node)\n    new_solution[0] = current_node\n\n    for i in range(1, n):\n        # Choose between sol1 and sol2 based on objective-aware criteria\n        if np.random.rand() < 0.5:\n            # Follow sol1's order\n            next_node = sol1[(sol1 == current_node).argmax() + 1] if (sol1 == current_node).argmax() + 1 < n else sol1[0]\n        else:\n            # Follow sol2's order\n            next_node = sol2[(sol2 == current_node).argmax() + 1] if (sol2 == current_node).argmax() + 1 < n else sol2[0]\n\n        # Ensure next_node hasn't been visited\n        if next_node in visited:\n            # Find an unvisited node from the other solution\n            candidates = [node for node in sol1 if node not in visited] + [node for node in sol2 if node not in visited]\n            if candidates:\n                next_node = random.choice(candidates)\n            else:\n                # Fallback: choose any unvisited node\n                next_node = next(node for node in range(n) if node not in visited)\n\n        new_solution[i] = next_node\n        visited.add(next_node)\n        current_node = next_node\n\n    # Apply objective-aware edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7142285220252789,
            0.6190496325492859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    elite_solutions = sorted(archive, key=lambda x: sum(x[1]))[:2]\n    sol1, sol2 = elite_solutions[0][0], elite_solutions[1][0]\n    n = len(sol1)\n\n    # Perform multi-objective path relinking\n    new_solution = np.zeros(n, dtype=int)\n    visited = set()\n    current_node = sol1[0]\n    visited.add(current_node)\n    new_solution[0] = current_node\n\n    for i in range(1, n):\n        # Choose between sol1 and sol2 based on objective-aware criteria\n        if np.random.rand() < 0.5:\n            # Follow sol1's order\n            next_node = sol1[(sol1 == current_node).argmax() + 1] if (sol1 == current_node).argmax() + 1 < n else sol1[0]\n        else:\n            # Follow sol2's order\n            next_node = sol2[(sol2 == current_node).argmax() + 1] if (sol2 == current_node).argmax() + 1 < n else sol2[0]\n\n        # Ensure next_node hasn't been visited\n        if next_node in visited:\n            # Find an unvisited node from the other solution\n            candidates = [node for node in sol1 if node not in visited] + [node for node in sol2 if node not in visited]\n            if candidates:\n                next_node = random.choice(candidates)\n            else:\n                # Fallback: choose any unvisited node\n                next_node = next(node for node in range(n) if node not in visited)\n\n        new_solution[i] = next_node\n        visited.add(next_node)\n        current_node = next_node\n\n    # Apply objective-aware edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6678823050084987,
            0.13136506080627441
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6678823050084987,
            0.13136506080627441
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[j], new_solution[k]) + edge_cost(new_solution[k], new_solution[(i+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment2, segment1])\n\n    # Apply objective-aware node insertion\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.7553740157707102,
            0.5411503195762635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[j], new_solution[k]) + edge_cost(new_solution[k], new_solution[(i+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment2, segment1])\n\n    # Apply objective-aware node insertion\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This algorithm selects a solution from the archive based on a Pareto-dominance aware selection with objective correlation analysis, then applies a novel hybrid local search combining path relinking with multi-objective edge insertion, ensuring feasibility and potential improvement across all three objectives while maintaining diversity in the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(archive)\n\n    # Calculate correlation between objectives\n    corr_matrix = np.corrcoef(objectives, rowvar=False)\n    corr_scores = np.sum(np.abs(corr_matrix), axis=0)\n\n    # Select solution based on Pareto dominance and correlation\n    selected_idx = 0\n    for i in range(n_solutions):\n        dominates = True\n        for j in range(n_solutions):\n            if any(objectives[j][k] < objectives[i][k] for k in range(3)):\n                dominates = False\n                break\n        if dominates and corr_scores[i] > corr_scores[selected_idx]:\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path relinking with multi-objective edge insertion\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Find insertion point with multi-objective consideration\n        best_pos = -1\n        best_improvement = (0, 0, 0)\n\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Calculate cost of removing segment and inserting at new position\n            old_cost = (\n                distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n            )\n\n            new_cost = (\n                distance_matrix_1[new_solution[(pos-1)%n], segment[0]] + distance_matrix_1[segment[-1], new_solution[(pos+1)%n]],\n                distance_matrix_2[new_solution[(pos-1)%n], segment[0]] + distance_matrix_2[segment[-1], new_solution[(pos+1)%n]],\n                distance_matrix_3[new_solution[(pos-1)%n], segment[0]] + distance_matrix_3[segment[-1], new_solution[(pos+1)%n]]\n            )\n\n            improvement = tuple(new - old for new, old in zip(new_cost, old_cost))\n\n            if any(imp < 0 for imp in improvement):\n                if sum(improvement) < sum(best_improvement):\n                    best_pos = pos\n                    best_improvement = improvement\n\n        if best_pos != -1:\n            # Remove segment from current position\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n            # Insert segment at best position\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7964441122907948,
            0.9047785639762879
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(archive)\n\n    # Calculate correlation between objectives\n    corr_matrix = np.corrcoef(objectives, rowvar=False)\n    corr_scores = np.sum(np.abs(corr_matrix), axis=0)\n\n    # Select solution based on Pareto dominance and correlation\n    selected_idx = 0\n    for i in range(n_solutions):\n        dominates = True\n        for j in range(n_solutions):\n            if any(objectives[j][k] < objectives[i][k] for k in range(3)):\n                dominates = False\n                break\n        if dominates and corr_scores[i] > corr_scores[selected_idx]:\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path relinking with multi-objective edge insertion\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Find insertion point with multi-objective consideration\n        best_pos = -1\n        best_improvement = (0, 0, 0)\n\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Calculate cost of removing segment and inserting at new position\n            old_cost = (\n                distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]]\n            )\n\n            new_cost = (\n                distance_matrix_1[new_solution[(pos-1)%n], segment[0]] + distance_matrix_1[segment[-1], new_solution[(pos+1)%n]],\n                distance_matrix_2[new_solution[(pos-1)%n], segment[0]] + distance_matrix_2[segment[-1], new_solution[(pos+1)%n]],\n                distance_matrix_3[new_solution[(pos-1)%n], segment[0]] + distance_matrix_3[segment[-1], new_solution[(pos+1)%n]]\n            )\n\n            improvement = tuple(new - old for new, old in zip(new_cost, old_cost))\n\n            if any(imp < 0 for imp in improvement):\n                if sum(improvement) < sum(best_improvement):\n                    best_pos = pos\n                    best_improvement = improvement\n\n        if best_pos != -1:\n            # Remove segment from current position\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n            # Insert segment at best position\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives, then applies a hybrid local search combining 3-opt with objective-aware node swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[(b+1)%n], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives with adaptive weights that prioritize solutions with diverse improvement potential across objectives, then applies a hybrid local search combining 2-opt with objective-aware segment reversals and a novel multi-objective edge insertion operator to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Adaptive weights based on objective diversity\n    diversity = np.std(normalized, axis=0)\n    weights = diversity / np.sum(diversity)\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with multi-objective improvement check\n    for _ in range(5):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n\n        # Check for improvement in at least one objective\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n\n    # Apply multi-objective edge insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while abs(k - l) <= 1:\n        l = np.random.randint(0, n)\n\n    # Remove edges (k, k+1) and (l, l+1)\n    segment = new_solution[(k+1)%n : (l+1)%n]\n    if k > l:\n        segment = segment[::-1]\n\n    # Try inserting the segment at a different position\n    m = np.random.randint(0, n)\n    while abs(m - k) <= 1 or abs(m - l) <= 1:\n        m = np.random.randint(0, n)\n\n    # Calculate old and new costs\n    def segment_cost(seg):\n        cost = (0, 0, 0)\n        for i in range(len(seg)-1):\n            cost = (cost[0] + distance_matrix_1[seg[i], seg[i+1]],\n                    cost[1] + distance_matrix_2[seg[i], seg[i+1]],\n                    cost[2] + distance_matrix_3[seg[i], seg[i+1]])\n        return cost\n\n    old_cost = segment_cost([new_solution[k], new_solution[(k+1)%n], new_solution[l], new_solution[(l+1)%n]])\n    new_cost = segment_cost([new_solution[m], *segment, new_solution[(m+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Insert the segment at position m\n        new_solution = np.concatenate([\n            new_solution[:(m+1)%n],\n            segment,\n            new_solution[(m+1)%n:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.7435655007417361,
            0.43642846345901487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Adaptive weights based on objective diversity\n    diversity = np.std(normalized, axis=0)\n    weights = diversity / np.sum(diversity)\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with multi-objective improvement check\n    for _ in range(5):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n\n        # Check for improvement in at least one objective\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n\n    # Apply multi-objective edge insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while abs(k - l) <= 1:\n        l = np.random.randint(0, n)\n\n    # Remove edges (k, k+1) and (l, l+1)\n    segment = new_solution[(k+1)%n : (l+1)%n]\n    if k > l:\n        segment = segment[::-1]\n\n    # Try inserting the segment at a different position\n    m = np.random.randint(0, n)\n    while abs(m - k) <= 1 or abs(m - l) <= 1:\n        m = np.random.randint(0, n)\n\n    # Calculate old and new costs\n    def segment_cost(seg):\n        cost = (0, 0, 0)\n        for i in range(len(seg)-1):\n            cost = (cost[0] + distance_matrix_1[seg[i], seg[i+1]],\n                    cost[1] + distance_matrix_2[seg[i], seg[i+1]],\n                    cost[2] + distance_matrix_3[seg[i], seg[i+1]])\n        return cost\n\n    old_cost = segment_cost([new_solution[k], new_solution[(k+1)%n], new_solution[l], new_solution[(l+1)%n]])\n    new_cost = segment_cost([new_solution[m], *segment, new_solution[(m+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Insert the segment at position m\n        new_solution = np.concatenate([\n            new_solution[:(m+1)%n],\n            segment,\n            new_solution[(m+1)%n:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This new algorithm employs a multi-objective segment recombination operator that intelligently merges segments from two diverse archive solutions while maintaining feasibility, followed by a Pareto-frontier-aware edge optimization step to improve the solution across all three objectives using a novel dominance-based refinement strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = sorted(archive, key=lambda x: x[1][0] + x[1][1] + x[1][2])[:2]\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create new solution by merging segments with objective-aware selection\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        elif i % 3 == 1:\n            new_solution.append(sol2[i])\n        else:\n            # Select based on which solution has better objective values\n            obj1 = (distance_matrix_1[sol1[i], sol1[(i+1)%n]] + distance_matrix_2[sol1[i], sol1[(i+1)%n]] + distance_matrix_3[sol1[i], sol1[(i+1)%n]])\n            obj2 = (distance_matrix_1[sol2[i], sol2[(i+1)%n]] + distance_matrix_2[sol2[i], sol2[(i+1)%n]] + distance_matrix_3[sol2[i], sol2[(i+1)%n]])\n            new_solution.append(sol1[i] if obj1 < obj2 else sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply Pareto-frontier-aware edge optimization\n    for _ in range(7):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if new edge dominates old edge in any objective\n        if (new_cost[0] <= old_cost[0] and new_cost[1] <= old_cost[1] and new_cost[2] <= old_cost[2] and\n            (new_cost[0] < old_cost[0] or new_cost[1] < old_cost[1] or new_cost[2] < old_cost[2])):\n            # Perform edge swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6433012186139051,
            0.20186443328857423
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = sorted(archive, key=lambda x: x[1][0] + x[1][1] + x[1][2])[:2]\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create new solution by merging segments with objective-aware selection\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        elif i % 3 == 1:\n            new_solution.append(sol2[i])\n        else:\n            # Select based on which solution has better objective values\n            obj1 = (distance_matrix_1[sol1[i], sol1[(i+1)%n]] + distance_matrix_2[sol1[i], sol1[(i+1)%n]] + distance_matrix_3[sol1[i], sol1[(i+1)%n]])\n            obj2 = (distance_matrix_1[sol2[i], sol2[(i+1)%n]] + distance_matrix_2[sol2[i], sol2[(i+1)%n]] + distance_matrix_3[sol2[i], sol2[(i+1)%n]])\n            new_solution.append(sol1[i] if obj1 < obj2 else sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply Pareto-frontier-aware edge optimization\n    for _ in range(7):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if new edge dominates old edge in any objective\n        if (new_cost[0] <= old_cost[0] and new_cost[1] <= old_cost[1] and new_cost[2] <= old_cost[2] and\n            (new_cost[0] < old_cost[0] or new_cost[1] < old_cost[1] or new_cost[2] < old_cost[2])):\n            # Perform edge swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{This new algorithm employs a multi-objective segment inversion operator that selectively inverts segments of the solution based on their contribution to each objective, followed by a hybrid 2-opt refinement step that considers all three objectives simultaneously to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1])/3)[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion based on objective contributions\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Calculate segment cost for each objective\n        seg_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        seg_cost3 = sum(distance_matrix_3[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n        # Invert segment if it improves at least one objective\n        if (seg_cost1 > sum(distance_matrix_1[segment[k], segment[(k-1)%len(segment)]] for k in range(len(segment))) or\n            seg_cost2 > sum(distance_matrix_2[segment[k], segment[(k-1)%len(segment)]] for k in range(len(segment))) or\n            seg_cost3 > sum(distance_matrix_3[segment[k], segment[(k-1)%len(segment)]] for k in range(len(segment)))):\n            new_solution[i:j+1] = segment[::-1]\n\n    # Apply hybrid 2-opt refinement considering all three objectives\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7203065776450611,
            0.7418646216392517
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1])/3)[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion based on objective contributions\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Calculate segment cost for each objective\n        seg_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        seg_cost3 = sum(distance_matrix_3[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n        # Invert segment if it improves at least one objective\n        if (seg_cost1 > sum(distance_matrix_1[segment[k], segment[(k-1)%len(segment)]] for k in range(len(segment))) or\n            seg_cost2 > sum(distance_matrix_2[segment[k], segment[(k-1)%len(segment)]] for k in range(len(segment))) or\n            seg_cost3 > sum(distance_matrix_3[segment[k], segment[(k-1)%len(segment)]] for k in range(len(segment)))):\n            new_solution[i:j+1] = segment[::-1]\n\n    # Apply hybrid 2-opt refinement considering all three objectives\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{This new algorithm selects a solution from the archive based on the diversity of its objectives, then applies a multi-objective path smoothing operator that iteratively adjusts node positions while maintaining feasibility, using a combination of local and global perspective optimization to improve all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores) if np.sum(diversity_scores) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path smoothing operator\n    for _ in range(5):\n        # Select a segment to smooth\n        start = np.random.randint(0, n-2)\n        end = np.random.randint(start+1, n)\n        segment = new_solution[start:end+1]\n\n        # Calculate current segment costs\n        current_costs = [\n            sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)),\n            sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)),\n            sum(distance_matrix_3[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        ]\n\n        # Try different segment orderings\n        for _ in range(3):\n            candidate = segment.copy()\n            np.random.shuffle(candidate)\n\n            candidate_costs = [\n                sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)),\n                sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)),\n                sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(len(candidate)-1))\n            ]\n\n            if any(c < o for c, o in zip(candidate_costs, current_costs)):\n                new_solution[start:end+1] = candidate\n                break\n\n    # Global perspective optimization\n    for _ in range(3):\n        # Select two distant nodes to potentially swap\n        i, j = np.random.choice(n, 2, replace=False)\n\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_1[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[j], new_solution[(i-1)%n]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[j], new_solution[(i-1)%n]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[j], new_solution[(i-1)%n]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_1[new_solution[i], new_solution[(j-1)%n]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[i], new_solution[(j-1)%n]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[i], new_solution[(j-1)%n]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]\n        )\n\n        if sum(new_cost) < sum(old_cost):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7623918783683391,
            0.6552936911582947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores) if np.sum(diversity_scores) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path smoothing operator\n    for _ in range(5):\n        # Select a segment to smooth\n        start = np.random.randint(0, n-2)\n        end = np.random.randint(start+1, n)\n        segment = new_solution[start:end+1]\n\n        # Calculate current segment costs\n        current_costs = [\n            sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)),\n            sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)),\n            sum(distance_matrix_3[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        ]\n\n        # Try different segment orderings\n        for _ in range(3):\n            candidate = segment.copy()\n            np.random.shuffle(candidate)\n\n            candidate_costs = [\n                sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)),\n                sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)),\n                sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(len(candidate)-1))\n            ]\n\n            if any(c < o for c, o in zip(candidate_costs, current_costs)):\n                new_solution[start:end+1] = candidate\n                break\n\n    # Global perspective optimization\n    for _ in range(3):\n        # Select two distant nodes to potentially swap\n        i, j = np.random.choice(n, 2, replace=False)\n\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_1[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[j], new_solution[(i-1)%n]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[j], new_solution[(i-1)%n]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[j], new_solution[(i-1)%n]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_1[new_solution[i], new_solution[(j-1)%n]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[i], new_solution[(j-1)%n]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[i], new_solution[(j-1)%n]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]\n        )\n\n        if sum(new_cost) < sum(old_cost):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a diversity-aware selection mechanism that prioritizes solutions with high objective diversity, then applies a novel segment-based local search that combines elements of both 2-opt and 3-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based hybrid local search\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 5))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Try both 2-opt and 3-opt moves on the selected segment\n    for _ in range(2):\n        if np.random.rand() < 0.5:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{This new algorithm employs a multi-objective aware selection mechanism that prioritizes solutions with balanced objective improvements, followed by an adaptive edge-swapping local search that dynamically adjusts move sizes based on objective correlation patterns to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    correlation_matrix = np.corrcoef(objectives, rowvar=False)\n    objective_weights = np.mean(np.abs(correlation_matrix), axis=0)\n\n    weighted_scores = objectives @ objective_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    swap_size = max(2, min(5, n // 4))\n    positions = np.random.choice(range(n), size=swap_size, replace=False)\n\n    for i in range(len(positions)):\n        j = (i + 1) % len(positions)\n        a, b = positions[i], positions[j]\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                    distance_matrix_2[new_solution[a], new_solution[b]] +\n                    distance_matrix_3[new_solution[a], new_solution[b]])\n\n        if new_cost < old_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6072489904517913,
            1.2169510126113892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    correlation_matrix = np.corrcoef(objectives, rowvar=False)\n    objective_weights = np.mean(np.abs(correlation_matrix), axis=0)\n\n    weighted_scores = objectives @ objective_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    swap_size = max(2, min(5, n // 4))\n    positions = np.random.choice(range(n), size=swap_size, replace=False)\n\n    for i in range(len(positions)):\n        j = (i + 1) % len(positions)\n        a, b = positions[i], positions[j]\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                    distance_matrix_2[new_solution[a], new_solution[b]] +\n                    distance_matrix_3[new_solution[a], new_solution[b]])\n\n        if new_cost < old_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{A new algorithm that selects a solution from the archive based on a normalized objective score with adaptive weights derived from objective correlation and diversity, then applies a hybrid 4-opt and edge-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    correlation = np.corrcoef(normalized.T)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * (1 - np.mean(correlation, axis=0))\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[l]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n]) + edge_cost(new_solution[l], new_solution[(k+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n        new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n    else:\n        if np.random.rand() < 0.5:\n            m, o = sorted(np.random.choice(n, 2, replace=False))\n            if m != i and o != j and m != j and o != i and m != k and o != k and m != l and o != l:\n                old_cost = edge_cost(new_solution[m], new_solution[(m+1)%n]) + edge_cost(new_solution[o], new_solution[(o+1)%n])\n                new_cost = edge_cost(new_solution[m], new_solution[o]) + edge_cost(new_solution[(m+1)%n], new_solution[(o+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[m], new_solution[o] = new_solution[o], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            -0.7653142202572576,
            0.4691975235939026
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    correlation = np.corrcoef(normalized.T)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * (1 - np.mean(correlation, axis=0))\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[l]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n]) + edge_cost(new_solution[l], new_solution[(k+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n        new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n    else:\n        if np.random.rand() < 0.5:\n            m, o = sorted(np.random.choice(n, 2, replace=False))\n            if m != i and o != j and m != j and o != i and m != k and o != k and m != l and o != l:\n                old_cost = edge_cost(new_solution[m], new_solution[(m+1)%n]) + edge_cost(new_solution[o], new_solution[(o+1)%n])\n                new_cost = edge_cost(new_solution[m], new_solution[o]) + edge_cost(new_solution[(m+1)%n], new_solution[(o+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[m], new_solution[o] = new_solution[o], new_solution[m]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.2 for each objective), then applies a hybrid local search combining 3-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion and edge reversal to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge reversal\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node insertion\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    # Apply edge reversal with objective-aware selection\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.67965167407538,
            0.5449082374572753
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge reversal\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node insertion\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    # Apply edge reversal with objective-aware selection\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware selection mechanism that prioritizes solutions with high objective diversity, then applies a novel segment-based local search that combines elements of both 2-opt and 3-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based hybrid local search\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 5))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Try both 2-opt and 3-opt moves on the selected segment\n    for _ in range(2):\n        if np.random.rand() < 0.5:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto-frontier proximity metric that combines objective values and diversity, then applies a novel multi-objective aware edge-swapping operator that considers the trade-off between objectives to generate a neighbor solution, ensuring feasibility and potential improvement across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    crowding = np.zeros(len(archive))\n    for i in range(3):\n        sorted_idx = np.argsort(normalized[:, i])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += normalized[sorted_idx[j+1], i] - normalized[sorted_idx[j-1], i]\n\n    scores = np.sum(objectives, axis=1) / (crowding + 1e-8)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n\n        improvement = sum((old - new) for old, new in zip(old_cost, new_cost) if new < old)\n        if improvement > 0:\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6513308191717554,
            0.4853305697441101
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    crowding = np.zeros(len(archive))\n    for i in range(3):\n        sorted_idx = np.argsort(normalized[:, i])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += normalized[sorted_idx[j+1], i] - normalized[sorted_idx[j-1], i]\n\n    scores = np.sum(objectives, axis=1) / (crowding + 1e-8)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n\n        improvement = sum((old - new) for old, new in zip(old_cost, new_cost) if new < old)\n        if improvement > 0:\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2-opt with objective-aware node swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware node swapping\n    for _ in range(3):\n        a, b = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8028060492012855,
            0.5815470337867736
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware node swapping\n    for _ in range(3):\n        a, b = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher range, then applies a hybrid local search combining 3-opt with objective-aware segment reversal to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    weights = ranges / np.sum(ranges) if np.sum(ranges) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware segment reversal\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Apply objective-aware segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7561346963986704,
            0.5423810362815857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    weights = ranges / np.sum(ranges) if np.sum(ranges) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware segment reversal\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Apply objective-aware segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2-opt with objective-aware node swaps and path relinking to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware node swaps\n    for _ in range(3):\n        a, b = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Apply path relinking with objective-aware selection\n    if len(archive) > 1:\n        guide_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        guide_solution = archive[guide_idx][0]\n\n        for _ in range(2):\n            pos = np.random.randint(0, n)\n            if new_solution[pos] != guide_solution[pos]:\n                node = guide_solution[pos]\n                if node in new_solution:\n                    old_pos = np.where(new_solution == node)[0][0]\n                    new_solution[old_pos] = new_solution[pos]\n                    new_solution[pos] = node\n\n    return new_solution\n\n",
        "score": [
            -0.725654186517003,
            0.5684576392173767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware node swaps\n    for _ in range(3):\n        a, b = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Apply path relinking with objective-aware selection\n    if len(archive) > 1:\n        guide_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        guide_solution = archive[guide_idx][0]\n\n        for _ in range(2):\n            pos = np.random.randint(0, n)\n            if new_solution[pos] != guide_solution[pos]:\n                node = guide_solution[pos]\n                if node in new_solution:\n                    old_pos = np.where(new_solution == node)[0][0]\n                    new_solution[old_pos] = new_solution[pos]\n                    new_solution[pos] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects the first solution from the archive, performs a simple swap of the first two nodes, and returns the modified solution, ensuring feasibility by maintaining a valid TSP tour.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{This new algorithm selects a solution from the archive based on its potential for improvement across all three objectives, then applies a hybrid local search that combines segment inversion with objective-aware edge refinement, while ensuring feasibility by maintaining a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[min(3, len(archive_sorted)-1)][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion with objective-aware selection\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        inverted_segment = segment[::-1]\n\n        # Calculate cost change for all three objectives\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i-1], inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i-1], inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i-1], inverted_segment[0]] + distance_matrix_3[inverted_segment[-1], new_solution[(j+1)%n]])\n\n        # Accept if any objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            new_solution[i:j+1] = inverted_segment\n\n    # Apply edge refinement based on combined objective improvement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_edges = [(new_solution[i], new_solution[(i+1)%n]), (new_solution[j], new_solution[(j+1)%n])]\n        new_edges = [(new_solution[i], new_solution[j]), (new_solution[(i+1)%n], new_solution[(j+1)%n])]\n\n        old_total = sum(distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] + distance_matrix_3[e[0], e[1]] for e in old_edges)\n        new_total = sum(distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] + distance_matrix_3[e[0], e[1]] for e in new_edges)\n\n        if new_total < old_total:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7324158737022252,
            0.5500234961509705
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[min(3, len(archive_sorted)-1)][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment inversion with objective-aware selection\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        inverted_segment = segment[::-1]\n\n        # Calculate cost change for all three objectives\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i-1], inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i-1], inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i-1], inverted_segment[0]] + distance_matrix_3[inverted_segment[-1], new_solution[(j+1)%n]])\n\n        # Accept if any objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            new_solution[i:j+1] = inverted_segment\n\n    # Apply edge refinement based on combined objective improvement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_edges = [(new_solution[i], new_solution[(i+1)%n]), (new_solution[j], new_solution[(j+1)%n])]\n        new_edges = [(new_solution[i], new_solution[j]), (new_solution[(i+1)%n], new_solution[(j+1)%n])]\n\n        old_total = sum(distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] + distance_matrix_3[e[0], e[1]] for e in old_edges)\n        new_total = sum(distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] + distance_matrix_3[e[0], e[1]] for e in new_edges)\n\n        if new_total < old_total:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2-opt with objective-aware edge swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware edge swapping\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[(b+1)%n], new_solution[a]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[(b+1)%n], new_solution[a]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[(a+1)%n], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[(b+1)%n], new_solution[a]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[a]] + distance_matrix_1[new_solution[(b+1)%n], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[a]] + distance_matrix_2[new_solution[(b+1)%n], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[(a+1)%n], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[a]] + distance_matrix_3[new_solution[(b+1)%n], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.728368358811318,
            0.537718391418457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware edge swapping\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[(b+1)%n], new_solution[a]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[(b+1)%n], new_solution[a]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[(a+1)%n], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[(b+1)%n], new_solution[a]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[a]] + distance_matrix_1[new_solution[(b+1)%n], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[a]] + distance_matrix_2[new_solution[(b+1)%n], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[(a+1)%n], new_solution[b]] + distance_matrix_3[new_solution[b], new_solution[a]] + distance_matrix_3[new_solution[(b+1)%n], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[k], new_solution[(j+1)%n]) + edge_cost(new_solution[(i+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Apply objective-aware node relocation\n    for _ in range(4):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.6907052084102043,
            0.5652206540107727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[k], new_solution[(j+1)%n]) + edge_cost(new_solution[(i+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Apply objective-aware node relocation\n    for _ in range(4):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware Pareto-frontier proximity measure, then applies a hybrid 3-opt with adaptive segment reversal that prioritizes improvement in the most under-represented objective space, ensuring multi-objective optimization through targeted local search.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate objective diversity\n    diversity = np.std(normalized, axis=0)\n    target_obj = np.argmax(diversity)  # Focus on the most under-represented objective\n\n    # Select solution closest to Pareto frontier in target objective\n    pareto_scores = -normalized[:, target_obj]\n    selected_idx = np.argmin(pareto_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with adaptive segment reversal\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n        if new_cost[target_obj] < old_cost[target_obj]:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n        else:\n            # Try adaptive segment reversal\n            if np.random.rand() < 0.3:\n                m = np.random.randint(0, n)\n                if m != i and m != j and m != k:\n                    old_cost = edge_cost(new_solution[m], new_solution[(m+1)%n])\n                    new_cost = edge_cost(new_solution[m], new_solution[(m+1)%n]) if m != (i+1)%n else edge_cost(new_solution[m], new_solution[i])\n                    if new_cost[target_obj] < old_cost[target_obj]:\n                        new_solution[m:(m+2)%n] = new_solution[m:(m+2)%n][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7070313446121717,
            0.4432756304740906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate objective diversity\n    diversity = np.std(normalized, axis=0)\n    target_obj = np.argmax(diversity)  # Focus on the most under-represented objective\n\n    # Select solution closest to Pareto frontier in target objective\n    pareto_scores = -normalized[:, target_obj]\n    selected_idx = np.argmin(pareto_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with adaptive segment reversal\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n        if new_cost[target_obj] < old_cost[target_obj]:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n        else:\n            # Try adaptive segment reversal\n            if np.random.rand() < 0.3:\n                m = np.random.randint(0, n)\n                if m != i and m != j and m != k:\n                    old_cost = edge_cost(new_solution[m], new_solution[(m+1)%n])\n                    new_cost = edge_cost(new_solution[m], new_solution[(m+1)%n]) if m != (i+1)%n else edge_cost(new_solution[m], new_solution[i])\n                    if new_cost[target_obj] < old_cost[target_obj]:\n                        new_solution[m:(m+2)%n] = new_solution[m:(m+2)%n][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.2 for each objective), then applies a hybrid local search combining 3-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware metric that combines both objective values and structural diversity, then applies a hybrid local search combining path relinking with objective-specific edge flips, ensuring feasibility and multi-objective improvement through a novel adaptive neighborhood exploration strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity_scores = np.mean(np.abs(normalized - np.mean(normalized, axis=0)), axis=1)\n    probs = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path relinking with objective-aware edge selection\n    reference_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n    reference_solution = archive[reference_idx][0]\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if reference_solution[i] != base_solution[i] or reference_solution[j] != base_solution[j]:\n            def edge_cost(a, b):\n                return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n            old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n            new_cost = edge_cost(reference_solution[i], reference_solution[(i+1)%n]) + edge_cost(reference_solution[j], reference_solution[(j+1)%n])\n\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                new_solution[i], new_solution[(i+1)%n] = reference_solution[i], reference_solution[(i+1)%n]\n                new_solution[j], new_solution[(j+1)%n] = reference_solution[j], reference_solution[(j+1)%n]\n\n    # Objective-specific edge flips\n    for obj_idx in range(3):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        old_cost = [0, 0, 0]\n        new_cost = [0, 0, 0]\n\n        if obj_idx == 0:\n            old_cost[0] = distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n            new_cost[0] = distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n        elif obj_idx == 1:\n            old_cost[1] = distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n            new_cost[1] = distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n        else:\n            old_cost[2] = distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n            new_cost[2] = distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n        if new_cost[obj_idx] < old_cost[obj_idx]:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6062429524197658,
            0.22073086500167846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity_scores = np.mean(np.abs(normalized - np.mean(normalized, axis=0)), axis=1)\n    probs = diversity_scores / np.sum(diversity_scores)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path relinking with objective-aware edge selection\n    reference_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n    reference_solution = archive[reference_idx][0]\n\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if reference_solution[i] != base_solution[i] or reference_solution[j] != base_solution[j]:\n            def edge_cost(a, b):\n                return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n            old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n            new_cost = edge_cost(reference_solution[i], reference_solution[(i+1)%n]) + edge_cost(reference_solution[j], reference_solution[(j+1)%n])\n\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                new_solution[i], new_solution[(i+1)%n] = reference_solution[i], reference_solution[(i+1)%n]\n                new_solution[j], new_solution[(j+1)%n] = reference_solution[j], reference_solution[(j+1)%n]\n\n    # Objective-specific edge flips\n    for obj_idx in range(3):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        old_cost = [0, 0, 0]\n        new_cost = [0, 0, 0]\n\n        if obj_idx == 0:\n            old_cost[0] = distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n            new_cost[0] = distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n        elif obj_idx == 1:\n            old_cost[1] = distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n            new_cost[1] = distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n        else:\n            old_cost[2] = distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n            new_cost[2] = distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n        if new_cost[obj_idx] < old_cost[obj_idx]:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{This algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives, with a novel segment-based mutation to introduce diversity while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments from both solutions\n    new_solution = []\n    segment_length = max(2, n // 5)\n    for i in range(0, n, segment_length):\n        if random.random() < 0.5:\n            new_solution.extend(sol1[i:i+segment_length])\n        else:\n            new_solution.extend(sol2[i:i+segment_length])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply segment-based mutation\n    if random.random() < 0.3:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6367914763862164,
            0.22066305875778197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments from both solutions\n    new_solution = []\n    segment_length = max(2, n // 5)\n    for i in range(0, n, segment_length):\n        if random.random() < 0.5:\n            new_solution.extend(sol1[i:i+segment_length])\n        else:\n            new_solution.extend(sol2[i:i+segment_length])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply segment-based mutation\n    if random.random() < 0.3:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{A new algorithm that selects a solution from the archive by prioritizing those with high objective diversity, then applies a hybrid 2-opt and adaptive edge-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        if np.random.rand() < 0.5:\n            k = np.random.randint(n)\n            if k != i and k != j and k != (i+1)%n and k != (j+1)%n:\n                old_cost = edge_cost(new_solution[k], new_solution[(k+1)%n])\n                new_cost = edge_cost(new_solution[k], new_solution[j]) + edge_cost(new_solution[i], new_solution[(k+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[k], new_solution[j] = new_solution[j], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7130213851850937,
            0.4805303931236267
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        if np.random.rand() < 0.5:\n            k = np.random.randint(n)\n            if k != i and k != j and k != (i+1)%n and k != (j+1)%n:\n                old_cost = edge_cost(new_solution[k], new_solution[(k+1)%n])\n                new_cost = edge_cost(new_solution[k], new_solution[j]) + edge_cost(new_solution[i], new_solution[(k+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[k], new_solution[j] = new_solution[j], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a diversity-aware selection mechanism that prioritizes solutions with high objective diversity, then applies a novel segment-based local search that combines elements of both 2-opt and 3-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based hybrid local search\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 5))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Try both 2-opt and 3-opt moves on the selected segment\n    for _ in range(2):\n        if np.random.rand() < 0.5:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware selection mechanism that prioritizes solutions with high diversity in objective space, then applies a novel 4-opt local search that combines elements of both 2-opt and 3-opt moves while incorporating objective-weighted edge selection to balance improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):\n        sorted_indices = np.argsort(objectives[:, m])\n        sorted_objectives = objectives[sorted_indices, m]\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (sorted_objectives[i+1] - sorted_objectives[i-1]) / (sorted_objectives[-1] - sorted_objectives[0] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_length = max(3, min(7, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(range(start, end), 4, replace=False))\n        old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n]))\n        new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n]))\n\n        if new_cost < old_cost:\n            segment1 = new_solution[(a+1):(b+1)]\n            segment2 = new_solution[(b+1):(c+1)]\n            segment3 = new_solution[(c+1):(d+1)]\n            new_solution[(a+1):(d+1)] = np.concatenate([segment3[::-1], segment2, segment1[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.5488530550443135,
            1.1713663935661316
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):\n        sorted_indices = np.argsort(objectives[:, m])\n        sorted_objectives = objectives[sorted_indices, m]\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (sorted_objectives[i+1] - sorted_objectives[i-1]) / (sorted_objectives[-1] - sorted_objectives[0] + 1e-10)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_length = max(3, min(7, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(range(start, end), 4, replace=False))\n        old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n]))\n        new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n]))\n\n        if new_cost < old_cost:\n            segment1 = new_solution[(a+1):(b+1)]\n            segment2 = new_solution[(b+1):(c+1)]\n            segment3 = new_solution[(c+1):(d+1)]\n            new_solution[(a+1):(d+1)] = np.concatenate([segment3[::-1], segment2, segment1[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a diversity-aware selection mechanism that prioritizes solutions with high objective diversity, then applies a novel segment-based local search that combines elements of both 2-opt and 3-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based hybrid local search\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 5))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Try both 2-opt and 3-opt moves on the selected segment\n    for _ in range(2):\n        if np.random.rand() < 0.5:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware selection mechanism that prioritizes solutions in less crowded regions of the Pareto front, then applies a novel edge-swapping local search that combines elements of 2-opt and 3-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    crowding_distances = np.zeros(len(archive))\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n        crowding_distances[sorted_idx[1:-1]] += (sorted_obj[2:] - sorted_obj[:-2]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n    # Select solution with highest crowding distance (least crowded region)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Edge-swapping local search\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 4))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Try both 2-opt and 3-opt moves on the selected segment\n    for _ in range(3):\n        if np.random.rand() < 0.6:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.6372629775940846,
            0.707610809803009
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance for each objective\n    crowding_distances = np.zeros(len(archive))\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n        crowding_distances[sorted_idx[1:-1]] += (sorted_obj[2:] - sorted_obj[:-2]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n    # Select solution with highest crowding distance (least crowded region)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Edge-swapping local search\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 4))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Try both 2-opt and 3-opt moves on the selected segment\n    for _ in range(3):\n        if np.random.rand() < 0.6:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of crowding distance and objective diversity, then applies a hybrid local search combining segment inversion with objective-aware node swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    n_obj = len(objectives[0])\n    n_sol = len(objectives)\n\n    # Calculate crowding distance for each objective\n    crowding = np.zeros(n_sol)\n    for m in range(n_obj):\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, n_sol-1):\n            crowding[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n    # Combine crowding distance with objective diversity\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / (np.sum(diversity) + 1e-10)\n    scores = crowding * np.dot(objectives, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search\n    for _ in range(5):\n        # Segment inversion with objective-aware selection\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Calculate objective differences\n        obj_diff = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] - distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] - distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] - distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] - distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] - distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] - distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n\n        if obj_diff < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n        # Objective-aware node swapping\n        a, b = np.random.choice(n, 2, replace=False)\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate potential objective improvements\n        old_cost = (\n            distance_matrix_1[node_a, new_solution[(a-1)%n]] + distance_matrix_1[node_a, new_solution[(a+1)%n]] +\n            distance_matrix_1[node_b, new_solution[(b-1)%n]] + distance_matrix_1[node_b, new_solution[(b+1)%n]] +\n            distance_matrix_2[node_a, new_solution[(a-1)%n]] + distance_matrix_2[node_a, new_solution[(a+1)%n]] +\n            distance_matrix_2[node_b, new_solution[(b-1)%n]] + distance_matrix_2[node_b, new_solution[(b+1)%n]] +\n            distance_matrix_3[node_a, new_solution[(a-1)%n]] + distance_matrix_3[node_a, new_solution[(a+1)%n]] +\n            distance_matrix_3[node_b, new_solution[(b-1)%n]] + distance_matrix_3[node_b, new_solution[(b+1)%n]]\n        )\n\n        new_cost = (\n            distance_matrix_1[node_b, new_solution[(a-1)%n]] + distance_matrix_1[node_b, new_solution[(a+1)%n]] +\n            distance_matrix_1[node_a, new_solution[(b-1)%n]] + distance_matrix_1[node_a, new_solution[(b+1)%n]] +\n            distance_matrix_2[node_b, new_solution[(a-1)%n]] + distance_matrix_2[node_b, new_solution[(a+1)%n]] +\n            distance_matrix_2[node_a, new_solution[(b-1)%n]] + distance_matrix_2[node_a, new_solution[(b+1)%n]] +\n            distance_matrix_3[node_b, new_solution[(a-1)%n]] + distance_matrix_3[node_b, new_solution[(a+1)%n]] +\n            distance_matrix_3[node_a, new_solution[(b-1)%n]] + distance_matrix_3[node_a, new_solution[(b+1)%n]]\n        )\n\n        if new_cost < old_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7512882999639808,
            0.7869560122489929
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    n_obj = len(objectives[0])\n    n_sol = len(objectives)\n\n    # Calculate crowding distance for each objective\n    crowding = np.zeros(n_sol)\n    for m in range(n_obj):\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, n_sol-1):\n            crowding[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n    # Combine crowding distance with objective diversity\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / (np.sum(diversity) + 1e-10)\n    scores = crowding * np.dot(objectives, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search\n    for _ in range(5):\n        # Segment inversion with objective-aware selection\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Calculate objective differences\n        obj_diff = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] - distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] - distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] - distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] - distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] - distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] - distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n\n        if obj_diff < 0:\n            new_solution[i:j+1] = segment[::-1]\n\n        # Objective-aware node swapping\n        a, b = np.random.choice(n, 2, replace=False)\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate potential objective improvements\n        old_cost = (\n            distance_matrix_1[node_a, new_solution[(a-1)%n]] + distance_matrix_1[node_a, new_solution[(a+1)%n]] +\n            distance_matrix_1[node_b, new_solution[(b-1)%n]] + distance_matrix_1[node_b, new_solution[(b+1)%n]] +\n            distance_matrix_2[node_a, new_solution[(a-1)%n]] + distance_matrix_2[node_a, new_solution[(a+1)%n]] +\n            distance_matrix_2[node_b, new_solution[(b-1)%n]] + distance_matrix_2[node_b, new_solution[(b+1)%n]] +\n            distance_matrix_3[node_a, new_solution[(a-1)%n]] + distance_matrix_3[node_a, new_solution[(a+1)%n]] +\n            distance_matrix_3[node_b, new_solution[(b-1)%n]] + distance_matrix_3[node_b, new_solution[(b+1)%n]]\n        )\n\n        new_cost = (\n            distance_matrix_1[node_b, new_solution[(a-1)%n]] + distance_matrix_1[node_b, new_solution[(a+1)%n]] +\n            distance_matrix_1[node_a, new_solution[(b-1)%n]] + distance_matrix_1[node_a, new_solution[(b+1)%n]] +\n            distance_matrix_2[node_b, new_solution[(a-1)%n]] + distance_matrix_2[node_b, new_solution[(a+1)%n]] +\n            distance_matrix_2[node_a, new_solution[(b-1)%n]] + distance_matrix_2[node_a, new_solution[(b+1)%n]] +\n            distance_matrix_3[node_b, new_solution[(a-1)%n]] + distance_matrix_3[node_b, new_solution[(a+1)%n]] +\n            distance_matrix_3[node_a, new_solution[(b-1)%n]] + distance_matrix_3[node_a, new_solution[(b+1)%n]]\n        )\n\n        if new_cost < old_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.2 for each objective), then applies a hybrid local search combining 3-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives with adaptive weights that prioritize underperforming objectives, then applies a hybrid local search combining 2-opt with objective-specific edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Adaptive weights based on objective performance\n    avg_obj = np.mean(normalized, axis=0)\n    weights = 1.0 / (1.0 + avg_obj)\n    weights /= np.sum(weights)\n\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt local search\n    for _ in range(5):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n\n    # Apply objective-specific edge swap\n    for _ in range(3):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.710901669691577,
            0.4576785445213318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Adaptive weights based on objective performance\n    avg_obj = np.mean(normalized, axis=0)\n    weights = 1.0 / (1.0 + avg_obj)\n    weights /= np.sum(weights)\n\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt local search\n    for _ in range(5):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n\n    # Apply objective-specific edge swap\n    for _ in range(3):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a Pareto-frontier proximity metric with adaptive objective weighting, then applies a hybrid 2.5-opt and edge-flip local search with objective-aware segment selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and all(other_obj <= obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[c], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[c])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n        new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n        new_solution[c+1:d+1] = new_solution[c+1:d+1][::-1]\n    else:\n        if np.random.rand() < 0.5:\n            x, y = sorted(np.random.choice(n, 2, replace=False))\n            if x != a and y != b and x != b and y != a and x != c and y != c and x != d and y != d:\n                old_cost = edge_cost(new_solution[x], new_solution[(x+1)%n]) + edge_cost(new_solution[y], new_solution[(y+1)%n])\n                new_cost = edge_cost(new_solution[x], new_solution[y]) + edge_cost(new_solution[(x+1)%n], new_solution[(y+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[x:(y+1)%n] = new_solution[x:(y+1)%n][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7889073645763061,
            4.258470177650452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and all(other_obj <= obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[c], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[c])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n        new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n        new_solution[c+1:d+1] = new_solution[c+1:d+1][::-1]\n    else:\n        if np.random.rand() < 0.5:\n            x, y = sorted(np.random.choice(n, 2, replace=False))\n            if x != a and y != b and x != b and y != a and x != c and y != c and x != d and y != d:\n                old_cost = edge_cost(new_solution[x], new_solution[(x+1)%n]) + edge_cost(new_solution[y], new_solution[(y+1)%n])\n                new_cost = edge_cost(new_solution[x], new_solution[y]) + edge_cost(new_solution[(x+1)%n], new_solution[(y+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[x:(y+1)%n] = new_solution[x:(y+1)%n][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2-opt with objective-aware node swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware node swapping\n    for _ in range(3):\n        i, j = np.random.choice(n, 2, replace=False)\n\n        def node_cost(node, pos):\n            left = new_solution[(pos-1)%n]\n            right = new_solution[(pos+1)%n]\n            return (distance_matrix_1[node, left] + distance_matrix_1[node, right],\n                    distance_matrix_2[node, left] + distance_matrix_2[node, right],\n                    distance_matrix_3[node, left] + distance_matrix_3[node, right])\n\n        old_cost = node_cost(new_solution[i], i) + node_cost(new_solution[j], j)\n        new_cost = node_cost(new_solution[i], j) + node_cost(new_solution[j], i)\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7101244484778699,
            0.5414658784866333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware node swapping\n    for _ in range(3):\n        i, j = np.random.choice(n, 2, replace=False)\n\n        def node_cost(node, pos):\n            left = new_solution[(pos-1)%n]\n            right = new_solution[(pos+1)%n]\n            return (distance_matrix_1[node, left] + distance_matrix_1[node, right],\n                    distance_matrix_2[node, left] + distance_matrix_2[node, right],\n                    distance_matrix_3[node, left] + distance_matrix_3[node, right])\n\n        old_cost = node_cost(new_solution[i], i) + node_cost(new_solution[j], j)\n        new_cost = node_cost(new_solution[i], j) + node_cost(new_solution[j], i)\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2-opt with objective-aware edge reversal to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge reversal\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Apply objective-aware edge reversal\n    for _ in range(3):\n        i = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(i+2)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(i+2)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(i+2)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[(i+1)%n] = new_solution[(i+1)%n], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7568784841099787,
            0.5328004598617554
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge reversal\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Apply objective-aware edge reversal\n    for _ in range(3):\n        i = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(i+2)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(i+2)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(i+2)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[(i+1)%n] = new_solution[(i+1)%n], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{This algorithm selects a solution from the archive using a dynamic weighted sum of objectives, where weights are adjusted based on the relative improvement potential of each objective, then applies a hybrid local search combining 2-opt with objective-specific edge swaps to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Dynamic weights based on improvement potential\n    improvement_potential = 1 / (normalized + 1e-8)\n    weights = improvement_potential / np.sum(improvement_potential, axis=1, keepdims=True)\n    scores = np.sum(normalized * weights, axis=1)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt local search\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-specific edge swap\n    obj_idx = np.random.choice(3)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    selected_matrix = distance_matrices[obj_idx]\n\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = selected_matrix[new_solution[k], new_solution[(k+1)%n]] + selected_matrix[new_solution[l], new_solution[(l+1)%n]]\n    new_cost = selected_matrix[new_solution[k], new_solution[l]] + selected_matrix[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n    if new_cost < old_cost:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7728840370845027,
            0.45167405605316163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Dynamic weights based on improvement potential\n    improvement_potential = 1 / (normalized + 1e-8)\n    weights = improvement_potential / np.sum(improvement_potential, axis=1, keepdims=True)\n    scores = np.sum(normalized * weights, axis=1)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt local search\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-specific edge swap\n    obj_idx = np.random.choice(3)\n    distance_matrices = [distance_matrix_1, distance_matrix_2, distance_matrix_3]\n    selected_matrix = distance_matrices[obj_idx]\n\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = selected_matrix[new_solution[k], new_solution[(k+1)%n]] + selected_matrix[new_solution[l], new_solution[(l+1)%n]]\n    new_cost = selected_matrix[new_solution[k], new_solution[l]] + selected_matrix[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n    if new_cost < old_cost:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects the first solution from the archive, performs a simple swap of the first two nodes, and returns the modified solution, ensuring feasibility by maintaining a valid TSP tour.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{This algorithm selects a solution from the archive using a novel multi-objective clustering approach that groups solutions by their objective similarities, then performs a hybrid local search combining segment reversal and node insertion, prioritizing edges that show potential for improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    from sklearn.cluster import KMeans\n    k = min(3, len(archive))\n    clusters = KMeans(n_clusters=k, random_state=42).fit_predict(normalized)\n\n    cluster_sizes = np.bincount(clusters)\n    selected_cluster = np.argmin(cluster_sizes)\n    candidates = [i for i, c in enumerate(clusters) if c == selected_cluster]\n\n    if not candidates:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = np.random.choice(candidates)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        k = np.random.randint(n)\n        if k != i and k != j and k != (i+1)%n and k != (j+1)%n:\n            old_cost = edge_cost(new_solution[k], new_solution[(k+1)%n])\n            new_cost = edge_cost(new_solution[k], new_solution[i]) + edge_cost(new_solution[i], new_solution[(k+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                new_solution = np.insert(new_solution, (k+1)%n, new_solution[i])\n                new_solution = np.delete(new_solution, i if i < (k+1)%n else i+1)\n\n    return new_solution\n\n",
        "score": [
            -0.753713822200942,
            1.7633017778396607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    from sklearn.cluster import KMeans\n    k = min(3, len(archive))\n    clusters = KMeans(n_clusters=k, random_state=42).fit_predict(normalized)\n\n    cluster_sizes = np.bincount(clusters)\n    selected_cluster = np.argmin(cluster_sizes)\n    candidates = [i for i, c in enumerate(clusters) if c == selected_cluster]\n\n    if not candidates:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = np.random.choice(candidates)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        k = np.random.randint(n)\n        if k != i and k != j and k != (i+1)%n and k != (j+1)%n:\n            old_cost = edge_cost(new_solution[k], new_solution[(k+1)%n])\n            new_cost = edge_cost(new_solution[k], new_solution[i]) + edge_cost(new_solution[i], new_solution[(k+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                new_solution = np.insert(new_solution, (k+1)%n, new_solution[i])\n                new_solution = np.delete(new_solution, i if i < (k+1)%n else i+1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This new algorithm employs a multi-objective path smoothing operator that iteratively refines the tour by replacing sub-paths with alternative routes based on a combined objective-aware distance metric, while maintaining feasibility through careful segment reassignment and objective-driven selection criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    combined_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def combined_distance(a, b):\n            return (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n\n        old_cost = combined_distance(new_solution[i], new_solution[(i+1)%n]) + combined_distance(new_solution[j], new_solution[(j+1)%n])\n        new_cost = combined_distance(new_solution[i], new_solution[j]) + combined_distance(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if new_cost < old_cost:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = combined_distance(new_solution[node], new_solution[(node-1)%n]) + combined_distance(new_solution[node], new_solution[(node+1)%n])\n        new_cost = combined_distance(new_solution[node], new_solution[pos]) + combined_distance(new_solution[node], new_solution[(pos+1)%n])\n\n        if new_cost < old_cost:\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.7166939279681465,
            0.5817601680755615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    combined_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def combined_distance(a, b):\n            return (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n\n        old_cost = combined_distance(new_solution[i], new_solution[(i+1)%n]) + combined_distance(new_solution[j], new_solution[(j+1)%n])\n        new_cost = combined_distance(new_solution[i], new_solution[j]) + combined_distance(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if new_cost < old_cost:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = combined_distance(new_solution[node], new_solution[(node-1)%n]) + combined_distance(new_solution[node], new_solution[(node+1)%n])\n        new_cost = combined_distance(new_solution[node], new_solution[pos]) + combined_distance(new_solution[node], new_solution[(pos+1)%n])\n\n        if new_cost < old_cost:\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized weighted sum of objectives using exponentially increasing weights (0.2, 0.3, 0.5) for objectives, then applies a hybrid local search combining 3-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])  # Exponentially increasing weights\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(5):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6921664034295778,
            0.4305929660797119
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])  # Exponentially increasing weights\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(5):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic objective correlation analysis, then applies a hybrid local search combining adaptive k-opt with objective-aware segment inversion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement by leveraging inter-objective relationships.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    correlations = np.corrcoef(objectives.T)\n    corr_weights = np.mean(np.abs(correlations), axis=1)\n    weights = corr_weights / np.sum(corr_weights) if np.sum(corr_weights) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    k = np.random.randint(2, 6)\n    for _ in range(3):\n        segments = sorted(np.random.choice(n, k, replace=False))\n        segments = [0] + segments + [n]\n\n        def segment_cost(start, end):\n            total = (0, 0, 0)\n            for i in range(start, end):\n                a = new_solution[i]\n                b = new_solution[(i+1)%n]\n                total = (total[0] + distance_matrix_1[a, b],\n                        total[1] + distance_matrix_2[a, b],\n                        total[2] + distance_matrix_3[a, b])\n            return total\n\n        old_cost = segment_cost(0, n)\n        new_cost = old_cost\n\n        for i in range(1, len(segments)-1):\n            segment = new_solution[segments[i-1]:segments[i]]\n            reversed_segment = segment[::-1]\n            temp_solution = new_solution.copy()\n            temp_solution[segments[i-1]:segments[i]] = reversed_segment\n\n            temp_cost = segment_cost(0, n)\n            if any(new < old for new, old in zip(temp_cost, old_cost)):\n                new_solution = temp_solution\n                old_cost = temp_cost\n\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.7927507726334493,
            0.9981725811958313
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    correlations = np.corrcoef(objectives.T)\n    corr_weights = np.mean(np.abs(correlations), axis=1)\n    weights = corr_weights / np.sum(corr_weights) if np.sum(corr_weights) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    k = np.random.randint(2, 6)\n    for _ in range(3):\n        segments = sorted(np.random.choice(n, k, replace=False))\n        segments = [0] + segments + [n]\n\n        def segment_cost(start, end):\n            total = (0, 0, 0)\n            for i in range(start, end):\n                a = new_solution[i]\n                b = new_solution[(i+1)%n]\n                total = (total[0] + distance_matrix_1[a, b],\n                        total[1] + distance_matrix_2[a, b],\n                        total[2] + distance_matrix_3[a, b])\n            return total\n\n        old_cost = segment_cost(0, n)\n        new_cost = old_cost\n\n        for i in range(1, len(segments)-1):\n            segment = new_solution[segments[i-1]:segments[i]]\n            reversed_segment = segment[::-1]\n            temp_solution = new_solution.copy()\n            temp_solution[segments[i-1]:segments[i]] = reversed_segment\n\n            temp_cost = segment_cost(0, n)\n            if any(new < old for new, old in zip(temp_cost, old_cost)):\n                new_solution = temp_solution\n                old_cost = temp_cost\n\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects the first solution from the archive, performs a simple swap of the first two nodes, and returns the modified solution, ensuring feasibility by maintaining a valid TSP tour.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects the first solution from the archive, performs a simple swap of the first two nodes, and returns the modified solution, ensuring feasibility by maintaining a valid TSP tour.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest diversity in its objective values, then applies a hybrid local search operator that combines 2-opt and 3-opt moves with a probabilistic selection of segments to optimize across all three objectives, ensuring feasibility by maintaining a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest diversity in objectives\n    def diversity(obj):\n        return (max(obj) - min(obj)) / (sum(obj) + 1e-6)\n\n    selected = max(archive, key=lambda x: diversity(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt or 3-opt with probability\n    if random.random() < 0.5:\n        # 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt move\n        if k < i < j < l:\n            new_solution[k:i+1] = new_solution[k:i+1][::-1]\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            new_solution[j+1:l+1] = new_solution[j+1:l+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        new_solution = base_solution.copy()\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.3854215661577051,
            0.7932344079017639
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest diversity in objectives\n    def diversity(obj):\n        return (max(obj) - min(obj)) / (sum(obj) + 1e-6)\n\n    selected = max(archive, key=lambda x: diversity(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt or 3-opt with probability\n    if random.random() < 0.5:\n        # 2-opt move\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt move\n        if k < i < j < l:\n            new_solution[k:i+1] = new_solution[k:i+1][::-1]\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            new_solution[j+1:l+1] = new_solution[j+1:l+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        new_solution = base_solution.copy()\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with lower variance, then applies a hybrid local search combining 3-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = np.minimum(variances, 1.0) / np.sum(np.minimum(variances, 1.0)) if np.sum(np.minimum(variances, 1.0)) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(np.array(scores)) / np.sum(np.exp(np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Apply objective-aware edge swaps\n    for _ in range(4):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7405814588476061,
            0.535300898551941
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = np.minimum(variances, 1.0) / np.sum(np.minimum(variances, 1.0)) if np.sum(np.minimum(variances, 1.0)) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(np.array(scores)) / np.sum(np.exp(np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Apply objective-aware edge swaps\n    for _ in range(4):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.2 for each objective), then applies a hybrid local search combining 3-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{This algorithm selects a solution from the archive based on a multi-objective diversity-aware selection, then applies a novel hybrid local search combining 4-opt with objective-specific edge insertions and a probabilistic multi-objective swap operator to generate a neighbor solution, ensuring feasibility and balanced improvement across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / np.sum(diversity)\n    scores = np.dot(objectives, weights)\n    probs = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n        new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n        new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-specific edge insertion\n    obj_idx = np.random.choice([0, 1, 2])\n    if obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    old_cost = dist_matrix[new_solution[i], new_solution[(i+1)%n]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n    new_cost = dist_matrix[new_solution[i], new_solution[j]] + dist_matrix[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n    if new_cost < old_cost:\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Apply probabilistic multi-objective swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    improvement_count = sum(new < old for new, old in zip(new_cost, old_cost))\n    if improvement_count >= 2 or (improvement_count == 1 and np.random.random() < 0.3):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6959239106090365,
            0.41748865842819216
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    weights = diversity / np.sum(diversity)\n    scores = np.dot(objectives, weights)\n    probs = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n        new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n        new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-specific edge insertion\n    obj_idx = np.random.choice([0, 1, 2])\n    if obj_idx == 0:\n        dist_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    old_cost = dist_matrix[new_solution[i], new_solution[(i+1)%n]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n    new_cost = dist_matrix[new_solution[i], new_solution[j]] + dist_matrix[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n    if new_cost < old_cost:\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Apply probabilistic multi-objective swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    improvement_count = sum(new < old for new, old in zip(new_cost, old_cost))\n    if improvement_count >= 2 or (improvement_count == 1 and np.random.random() < 0.3):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.7142872952717572,
            0.5308400750160217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{This algorithm selects a solution from the archive using a Pareto-dominance-based selection mechanism, then applies a hybrid local search combining 2-opt with objective-specific edge insertions to generate a neighbor solution while ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and all(o <= other for o, other in zip(obj, other_obj)) and any(o < other for o, other in zip(obj, other_obj)):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = np.random.choice(len(non_dominated))\n    base_solution = non_dominated[selected_idx][0].copy() if non_dominated else archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt local search\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Apply objective-specific edge insertion\n    for _ in range(3):\n        obj_idx = np.random.randint(3)\n        if obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        old_cost = (dist_matrix[new_solution[k], new_solution[(k+1)%n]],\n                    dist_matrix[new_solution[l], new_solution[(l+1)%n]])\n        new_cost = (dist_matrix[new_solution[k], new_solution[l]],\n                    dist_matrix[new_solution[l], new_solution[(k+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            if k < l:\n                new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n            else:\n                new_solution[l+1:k+1] = new_solution[l+1:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7697794544301761,
            2.057622504234314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and all(o <= other for o, other in zip(obj, other_obj)) and any(o < other for o, other in zip(obj, other_obj)):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = np.random.choice(len(non_dominated))\n    base_solution = non_dominated[selected_idx][0].copy() if non_dominated else archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt local search\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Apply objective-specific edge insertion\n    for _ in range(3):\n        obj_idx = np.random.randint(3)\n        if obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        old_cost = (dist_matrix[new_solution[k], new_solution[(k+1)%n]],\n                    dist_matrix[new_solution[l], new_solution[(l+1)%n]])\n        new_cost = (dist_matrix[new_solution[k], new_solution[l]],\n                    dist_matrix[new_solution[l], new_solution[(k+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            if k < l:\n                new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n            else:\n                new_solution[l+1:k+1] = new_solution[l+1:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7176142359800707,
            0.14310144186019896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node relocation and insertion, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    # Apply objective-aware node relocation and insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n        # Additional node insertion\n        if np.random.rand() < 0.3:\n            insert_pos = np.random.randint(0, n)\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, insert_pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.7898666540934889,
            0.5145103931427002
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n\n    # Apply objective-aware node relocation and insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n        # Additional node insertion\n        if np.random.rand() < 0.3:\n            insert_pos = np.random.randint(0, n)\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, insert_pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.2 for each objective), then applies a hybrid local search combining 3-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{This algorithm selects a solution from the archive based on crowding distance in objective space to prioritize under-represented regions, then applies a hybrid local search combining 4-opt with objective-aware segment reversals to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(objectives)\n\n    # Calculate crowding distance for each solution\n    crowding = np.zeros(n_solutions)\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, n_solutions-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    # Select solution with lowest crowding distance\n    selected_idx = np.argmin(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(5):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware segment reversal\n    for _ in range(3):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        if k > l:\n            k, l = l, k\n\n        old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[k:(l+1)] = new_solution[k:(l+1)][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7031654601257322,
            0.5198860406875611
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(objectives)\n\n    # Calculate crowding distance for each solution\n    crowding = np.zeros(n_solutions)\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, n_solutions-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    # Select solution with lowest crowding distance\n    selected_idx = np.argmin(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(5):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware segment reversal\n    for _ in range(3):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        if k > l:\n            k, l = l, k\n\n        old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[k:(l+1)] = new_solution[k:(l+1)][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.2 for each objective), then applies a hybrid local search combining 3-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify under-explored regions, then applies a hybrid local search combining 4-opt with objective-specific edge insertions to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives, axis=0)\n    crowding_dist = np.zeros(len(archive))\n\n    for obj_idx in range(3):\n        sorted_obj = objectives[sorted_indices[:, obj_idx], obj_idx]\n        crowding_dist[sorted_indices[0, obj_idx]] = np.inf\n        crowding_dist[sorted_indices[-1, obj_idx]] = np.inf\n        for i in range(1, len(archive)-1):\n            if np.max(sorted_obj) == np.min(sorted_obj):\n                crowding_dist[sorted_indices[i, obj_idx]] += 0\n            else:\n                crowding_dist[sorted_indices[i, obj_idx]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (np.max(sorted_obj) - np.min(sorted_obj))\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(2):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-specific edge insertion\n    for obj_idx in range(3):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        if obj_idx == 0:\n            matrix = distance_matrix_1\n        elif obj_idx == 1:\n            matrix = distance_matrix_2\n        else:\n            matrix = distance_matrix_3\n\n        old_cost = (matrix[new_solution[k], new_solution[(k+1)%n]] + matrix[new_solution[l], new_solution[(l+1)%n]],\n                    matrix[new_solution[k], new_solution[(k+1)%n]] + matrix[new_solution[l], new_solution[(l+1)%n]],\n                    matrix[new_solution[k], new_solution[(k+1)%n]] + matrix[new_solution[l], new_solution[(l+1)%n]])\n\n        new_cost = (matrix[new_solution[k], new_solution[l]] + matrix[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    matrix[new_solution[k], new_solution[l]] + matrix[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    matrix[new_solution[k], new_solution[l]] + matrix[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n        if new_cost[obj_idx] < old_cost[obj_idx]:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.713227366952987,
            1.9660209894180298
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives, axis=0)\n    crowding_dist = np.zeros(len(archive))\n\n    for obj_idx in range(3):\n        sorted_obj = objectives[sorted_indices[:, obj_idx], obj_idx]\n        crowding_dist[sorted_indices[0, obj_idx]] = np.inf\n        crowding_dist[sorted_indices[-1, obj_idx]] = np.inf\n        for i in range(1, len(archive)-1):\n            if np.max(sorted_obj) == np.min(sorted_obj):\n                crowding_dist[sorted_indices[i, obj_idx]] += 0\n            else:\n                crowding_dist[sorted_indices[i, obj_idx]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (np.max(sorted_obj) - np.min(sorted_obj))\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(2):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-specific edge insertion\n    for obj_idx in range(3):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        if obj_idx == 0:\n            matrix = distance_matrix_1\n        elif obj_idx == 1:\n            matrix = distance_matrix_2\n        else:\n            matrix = distance_matrix_3\n\n        old_cost = (matrix[new_solution[k], new_solution[(k+1)%n]] + matrix[new_solution[l], new_solution[(l+1)%n]],\n                    matrix[new_solution[k], new_solution[(k+1)%n]] + matrix[new_solution[l], new_solution[(l+1)%n]],\n                    matrix[new_solution[k], new_solution[(k+1)%n]] + matrix[new_solution[l], new_solution[(l+1)%n]])\n\n        new_cost = (matrix[new_solution[k], new_solution[l]] + matrix[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    matrix[new_solution[k], new_solution[l]] + matrix[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    matrix[new_solution[k], new_solution[l]] + matrix[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n        if new_cost[obj_idx] < old_cost[obj_idx]:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.2 for each objective), then applies a hybrid local search combining 3-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with high objective diversity, then applies a novel segment-based local search that combines 2-opt with objective-aware segment reversals to generate a neighbor solution while ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    scores = np.dot(objectives, weights)\n    probs = np.exp(scores) / np.sum(np.exp(scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment-based local search\n    for _ in range(5):\n        segment_length = np.random.randint(2, min(6, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        def segment_cost(sol, start, end):\n            cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(start, end))\n            cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(start, end))\n            cost3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(start, end))\n            return (cost1, cost2, cost3)\n\n        old_cost = segment_cost(new_solution, start, end)\n        reversed_segment = new_solution[start:end][::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = reversed_segment\n        new_cost = segment_cost(temp_solution, start, end)\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution = temp_solution\n\n    # Apply objective-aware segment reversal\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment_length = min(b - a, n - b + a)\n\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6248568384346623,
            0.49598170518875123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    scores = np.dot(objectives, weights)\n    probs = np.exp(scores) / np.sum(np.exp(scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment-based local search\n    for _ in range(5):\n        segment_length = np.random.randint(2, min(6, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        def segment_cost(sol, start, end):\n            cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(start, end))\n            cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(start, end))\n            cost3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(start, end))\n            return (cost1, cost2, cost3)\n\n        old_cost = segment_cost(new_solution, start, end)\n        reversed_segment = new_solution[start:end][::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = reversed_segment\n        new_cost = segment_cost(temp_solution, start, end)\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution = temp_solution\n\n    # Apply objective-aware segment reversal\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment_length = min(b - a, n - b + a)\n\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{This algorithm selects a solution from the archive using a normalized weighted sum of objectives with different weights (0.4, 0.3, 0.3) and applies a hybrid local search combining 4-opt with objective-aware edge swaps, ensuring multi-objective improvement while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7315607258415275,
            0.3965446352958679
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.4, 0.3, 0.3])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2-opt with objective-aware edge swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware edge swapping\n    for _ in range(3):\n        a, b = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                     distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                     distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                     distance_matrix_1[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]],\n                     distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                     distance_matrix_2[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]],\n                     distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] +\n                     distance_matrix_3[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8013824862888207,
            0.5417869091033936
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware edge swapping\n    for _ in range(3):\n        a, b = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                     distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                     distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                     distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                     distance_matrix_1[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]],\n                     distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                     distance_matrix_2[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]],\n                     distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] +\n                     distance_matrix_3[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{This new algorithm employs a multi-objective segment fusion operator that combines path segments from multiple archive solutions with weighted selection based on objective-specific improvements, followed by a dynamic objective-aware edge refinement step that adaptively prioritizes edge swaps based on the current solution's Pareto front position.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    n = len(base_solution)\n\n    # Create weighted selection of segments from multiple solutions\n    segment_length = max(2, n // 4)\n    new_solution = []\n    used_indices = set()\n\n    for i in range(0, n, segment_length):\n        # Select segment from random solution with probability based on objective weights\n        selected_sol = random.choice(archive)[0]\n        segment_start = random.randint(0, n - segment_length)\n        segment = selected_sol[segment_start:segment_start+segment_length]\n\n        # Add segment while maintaining feasibility\n        for node in segment:\n            if node not in used_indices:\n                new_solution.append(node)\n                used_indices.add(node)\n\n    # Fill remaining nodes\n    remaining_nodes = [node for node in range(n) if node not in used_indices]\n    random.shuffle(remaining_nodes)\n    new_solution.extend(remaining_nodes)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Dynamic objective-aware edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential costs\n        current_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        ]\n\n        # Calculate improvement counts\n        improvements = sum(1 for c, p in zip(current_costs, potential_costs) if p < c)\n\n        # Perform swap with probability based on improvement count\n        if improvements > 1 or (improvements == 1 and random.random() < 0.7):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7226985601830491,
            0.32806546688079835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    n = len(base_solution)\n\n    # Create weighted selection of segments from multiple solutions\n    segment_length = max(2, n // 4)\n    new_solution = []\n    used_indices = set()\n\n    for i in range(0, n, segment_length):\n        # Select segment from random solution with probability based on objective weights\n        selected_sol = random.choice(archive)[0]\n        segment_start = random.randint(0, n - segment_length)\n        segment = selected_sol[segment_start:segment_start+segment_length]\n\n        # Add segment while maintaining feasibility\n        for node in segment:\n            if node not in used_indices:\n                new_solution.append(node)\n                used_indices.add(node)\n\n    # Fill remaining nodes\n    remaining_nodes = [node for node in range(n) if node not in used_indices]\n    random.shuffle(remaining_nodes)\n    new_solution.extend(remaining_nodes)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Dynamic objective-aware edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential costs\n        current_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        ]\n\n        # Calculate improvement counts\n        improvements = sum(1 for c, p in zip(current_costs, potential_costs) if p < c)\n\n        # Perform swap with probability based on improvement count\n        if improvements > 1 or (improvements == 1 and random.random() < 0.7):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{This new algorithm combines a multi-objective tournament selection mechanism with a hybrid local search that alternates between objective-specific 2-opt moves and a novel \"objective-aware edge flipping\" operation to simultaneously improve all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = random.sample(archive, min(5, len(archive)))\n    selected = min(candidates, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search\n    for _ in range(5):\n        # Objective-specific 2-opt\n        obj = random.choice([0, 1, 2])\n        if obj == 0:\n            dm = distance_matrix_1\n        elif obj == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = dm[new_solution[i], new_solution[(i+1)%n]] + dm[new_solution[j], new_solution[(j+1)%n]]\n        new_cost = dm[new_solution[i], new_solution[j]] + dm[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        if new_cost < old_cost:\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n        # Objective-aware edge flipping\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k != l and k != (l+1)%n and l != (k+1)%n:\n            old_costs = [dm[new_solution[k], new_solution[(k+1)%n]],\n                         dm[new_solution[l], new_solution[(l+1)%n]]]\n            new_costs = [dm[new_solution[k], new_solution[l]],\n                         dm[new_solution[(k+1)%n], new_solution[(l+1)%n]]]\n\n            if sum(new_costs) < sum(old_costs):\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6980325483774892,
            0.4736273646354675
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = random.sample(archive, min(5, len(archive)))\n    selected = min(candidates, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search\n    for _ in range(5):\n        # Objective-specific 2-opt\n        obj = random.choice([0, 1, 2])\n        if obj == 0:\n            dm = distance_matrix_1\n        elif obj == 1:\n            dm = distance_matrix_2\n        else:\n            dm = distance_matrix_3\n\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = dm[new_solution[i], new_solution[(i+1)%n]] + dm[new_solution[j], new_solution[(j+1)%n]]\n        new_cost = dm[new_solution[i], new_solution[j]] + dm[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        if new_cost < old_cost:\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n        # Objective-aware edge flipping\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k != l and k != (l+1)%n and l != (k+1)%n:\n            old_costs = [dm[new_solution[k], new_solution[(k+1)%n]],\n                         dm[new_solution[l], new_solution[(l+1)%n]]]\n            new_costs = [dm[new_solution[k], new_solution[l]],\n                         dm[new_solution[(k+1)%n], new_solution[(l+1)%n]]]\n\n            if sum(new_costs) < sum(old_costs):\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware edge inversion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge inversion\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[j], new_solution[k]) + edge_cost(new_solution[k], new_solution[(i+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Apply objective-aware edge inversion\n    for _ in range(4):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(a+1):(b+1)]\n            new_solution[(a+1):(b+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8262069840869899,
            0.5575563549995423
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge inversion\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[j], new_solution[k]) + edge_cost(new_solution[k], new_solution[(i+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Apply objective-aware edge inversion\n    for _ in range(4):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(a+1):(b+1)]\n            new_solution[(a+1):(b+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware edge inversion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge inversion\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[j], new_solution[k]) + edge_cost(new_solution[k], new_solution[(i+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Apply objective-aware edge inversion\n    for _ in range(4):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(a+1):(b+1)]\n            new_solution[(a+1):(b+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8262069840869899,
            0.5575563549995423
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge inversion\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[j], new_solution[k]) + edge_cost(new_solution[k], new_solution[(i+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Apply objective-aware edge inversion\n    for _ in range(4):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[(a+1)%n], new_solution[(b+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(a+1):(b+1)]\n            new_solution[(a+1):(b+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.2 for each objective), then applies a hybrid local search combining 3-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This algorithm selects a solution from the archive based on a Pareto-frontier-based selection mechanism that prioritizes solutions with diverse objective trade-offs, then applies a hybrid local search combining a novel multi-objective path relinking operator with adaptive objective-aware edge insertions to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path relinking\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Adaptive objective-aware edge insertion\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        # Calculate objective improvements\n        old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n        # Adaptive acceptance\n        improvement = sum(new < old for new, old in zip(new_cost, old_cost))\n        if improvement > 1 or (improvement == 1 and np.random.rand() < 0.7):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7410736028814158,
            2.633733320236206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path relinking\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Adaptive objective-aware edge insertion\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        # Calculate objective improvements\n        old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n        # Adaptive acceptance\n        improvement = sum(new < old for new, old in zip(new_cost, old_cost))\n        if improvement > 1 or (improvement == 1 and np.random.rand() < 0.7):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with adaptive steps\n    for _ in range(10):  # Increased refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost) * 0.95:  # More aggressive improvement threshold\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6840164924855163,
            0.22154717445373534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with adaptive steps\n    for _ in range(10):  # Increased refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost) * 0.95:  # More aggressive improvement threshold\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{This new algorithm employs a multi-objective-aware crossover operator that combines segments from the best and second-best solutions in the archive with a probabilistic selection based on Pareto dominance, followed by a dynamic edge refinement step that selectively improves edges with the most significant objective-specific improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) >= 2:\n        sol1, sol2 = archive[0][0], archive[1][0]\n        n = len(sol1)\n\n        # Create new solution with probabilistic crossover\n        new_solution = []\n        for i in range(n):\n            if np.random.random() < 0.7:  # Higher probability for better solution\n                new_solution.append(sol1[i])\n            else:\n                new_solution.append(sol2[i])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution.insert(insert_pos, node)\n\n        new_solution = np.array(new_solution)\n\n        # Dynamic edge refinement based on objective improvements\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                        distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                        distance_matrix_2[new_solution[i], new_solution[j]],\n                        distance_matrix_3[new_solution[i], new_solution[j]])\n\n            # Calculate improvement scores for each objective\n            improvements = [oc - nc for nc, oc in zip(new_cost, old_cost)]\n            total_improvement = sum(improvements)\n\n            # Apply 2-opt if significant improvement in any objective\n            if total_improvement > 0:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n\n    else:\n        # Fallback to simple mutation if archive is small\n        new_solution = archive[0][0].copy()\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6823208354225547,
            0.126544189453125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) >= 2:\n        sol1, sol2 = archive[0][0], archive[1][0]\n        n = len(sol1)\n\n        # Create new solution with probabilistic crossover\n        new_solution = []\n        for i in range(n):\n            if np.random.random() < 0.7:  # Higher probability for better solution\n                new_solution.append(sol1[i])\n            else:\n                new_solution.append(sol2[i])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution.insert(insert_pos, node)\n\n        new_solution = np.array(new_solution)\n\n        # Dynamic edge refinement based on objective improvements\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                        distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                        distance_matrix_2[new_solution[i], new_solution[j]],\n                        distance_matrix_3[new_solution[i], new_solution[j]])\n\n            # Calculate improvement scores for each objective\n            improvements = [oc - nc for nc, oc in zip(new_cost, old_cost)]\n            total_improvement = sum(improvements)\n\n            # Apply 2-opt if significant improvement in any objective\n            if total_improvement > 0:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n\n    else:\n        # Fallback to simple mutation if archive is small\n        new_solution = archive[0][0].copy()\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{This new algorithm employs a multi-objective-aware crossover operator that combines segments from the best and second-best solutions in the archive with a probabilistic selection based on Pareto dominance, followed by a dynamic edge refinement step that selectively improves edges with the most significant objective-specific improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) >= 2:\n        sol1, sol2 = archive[0][0], archive[1][0]\n        n = len(sol1)\n\n        # Create new solution with probabilistic crossover\n        new_solution = []\n        for i in range(n):\n            if np.random.random() < 0.7:  # Higher probability for better solution\n                new_solution.append(sol1[i])\n            else:\n                new_solution.append(sol2[i])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution.insert(insert_pos, node)\n\n        new_solution = np.array(new_solution)\n\n        # Dynamic edge refinement based on objective improvements\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                        distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                        distance_matrix_2[new_solution[i], new_solution[j]],\n                        distance_matrix_3[new_solution[i], new_solution[j]])\n\n            # Calculate improvement scores for each objective\n            improvements = [oc - nc for nc, oc in zip(new_cost, old_cost)]\n            total_improvement = sum(improvements)\n\n            # Apply 2-opt if significant improvement in any objective\n            if total_improvement > 0:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n\n    else:\n        # Fallback to simple mutation if archive is small\n        new_solution = archive[0][0].copy()\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6823208354225547,
            0.126544189453125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) >= 2:\n        sol1, sol2 = archive[0][0], archive[1][0]\n        n = len(sol1)\n\n        # Create new solution with probabilistic crossover\n        new_solution = []\n        for i in range(n):\n            if np.random.random() < 0.7:  # Higher probability for better solution\n                new_solution.append(sol1[i])\n            else:\n                new_solution.append(sol2[i])\n\n        # Ensure all nodes are visited exactly once\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = set(range(n)) - set(unique_nodes)\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution.insert(insert_pos, node)\n\n        new_solution = np.array(new_solution)\n\n        # Dynamic edge refinement based on objective improvements\n        for _ in range(5):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                        distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                        distance_matrix_2[new_solution[i], new_solution[j]],\n                        distance_matrix_3[new_solution[i], new_solution[j]])\n\n            # Calculate improvement scores for each objective\n            improvements = [oc - nc for nc, oc in zip(new_cost, old_cost)]\n            total_improvement = sum(improvements)\n\n            # Apply 2-opt if significant improvement in any objective\n            if total_improvement > 0:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n\n    else:\n        # Fallback to simple mutation if archive is small\n        new_solution = archive[0][0].copy()\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion, but with a novel adaptive temperature-based acceptance mechanism to balance exploration and exploitation, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    temperature = 1.0 / (1 + np.log(len(archive) + 1))\n\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        cost_diff1 = np.array(new_cost1) - np.array(old_cost)\n        cost_diff2 = np.array(new_cost2) - np.array(old_cost)\n\n        if any(diff < 0 for diff in cost_diff1) or (np.random.rand() < temperature and any(diff < 0 for diff in cost_diff1)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(diff < 0 for diff in cost_diff2) or (np.random.rand() < temperature and any(diff < 0 for diff in cost_diff2)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        cost_diff = np.array(new_cost) - np.array(old_cost)\n\n        if any(diff < 0 for diff in cost_diff) or (np.random.rand() < temperature and any(diff < 0 for diff in cost_diff)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.7638153750717238,
            0.6149490356445313
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    temperature = 1.0 / (1 + np.log(len(archive) + 1))\n\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        cost_diff1 = np.array(new_cost1) - np.array(old_cost)\n        cost_diff2 = np.array(new_cost2) - np.array(old_cost)\n\n        if any(diff < 0 for diff in cost_diff1) or (np.random.rand() < temperature and any(diff < 0 for diff in cost_diff1)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(diff < 0 for diff in cost_diff2) or (np.random.rand() < temperature and any(diff < 0 for diff in cost_diff2)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        cost_diff = np.array(new_cost) - np.array(old_cost)\n\n        if any(diff < 0 for diff in cost_diff) or (np.random.rand() < temperature and any(diff < 0 for diff in cost_diff)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{This new algorithm employs a multi-objective path relinking approach that blends segments from multiple archive solutions using a weighted combination of their edges, followed by a simulated annealing-inspired acceptance criterion that balances exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solutions = [sol[0] for sol in sorted_archive[:min(5, len(archive))]]\n\n    # Initialize with a random solution from the selected top solutions\n    base_solution = random.choice(selected_solutions).copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path relinking with weighted edge selection\n    for _ in range(3):  # Perform 3 relinking steps\n        # Select another solution for relinking\n        relink_solution = random.choice(selected_solutions)\n        relink_solution = relink_solution.copy()\n\n        # Create a mask for nodes to relink\n        mask = np.random.rand(n) > 0.5\n        temp_solution = new_solution.copy()\n\n        # Replace nodes in the mask with corresponding nodes from relink solution\n        for i in range(n):\n            if mask[i]:\n                # Find the position of new_solution[i] in relink_solution\n                pos_in_relink = np.where(relink_solution == new_solution[i])[0][0]\n                # Insert the corresponding node from relink_solution\n                temp_solution[i] = relink_solution[pos_in_relink]\n\n        # Ensure feasibility by fixing duplicates\n        unique, counts = np.unique(temp_solution, return_counts=True)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            # Find all positions with this duplicate\n            dup_positions = np.where(temp_solution == dup)[0]\n            # Replace duplicates with missing nodes\n            missing_nodes = set(range(n)) - set(temp_solution)\n            for pos in dup_positions[1:]:\n                if missing_nodes:\n                    temp_solution[pos] = missing_nodes.pop()\n\n        # Simulated annealing acceptance criterion\n        current_cost = (sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                        sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                        sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n)))\n        new_cost = (sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                    sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                    sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)))\n\n        # Acceptance probability based on Pareto dominance\n        if (all(nc <= cc for nc, cc in zip(new_cost, current_cost)) and\n            any(nc < cc for nc, cc in zip(new_cost, current_cost))):\n            new_solution = temp_solution.copy()\n        else:\n            # Accept with some probability if not dominated\n            if random.random() < 0.3:\n                new_solution = temp_solution.copy()\n\n    # Final local 2-opt refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5046166889617221,
            3.613835322856903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solutions = [sol[0] for sol in sorted_archive[:min(5, len(archive))]]\n\n    # Initialize with a random solution from the selected top solutions\n    base_solution = random.choice(selected_solutions).copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path relinking with weighted edge selection\n    for _ in range(3):  # Perform 3 relinking steps\n        # Select another solution for relinking\n        relink_solution = random.choice(selected_solutions)\n        relink_solution = relink_solution.copy()\n\n        # Create a mask for nodes to relink\n        mask = np.random.rand(n) > 0.5\n        temp_solution = new_solution.copy()\n\n        # Replace nodes in the mask with corresponding nodes from relink solution\n        for i in range(n):\n            if mask[i]:\n                # Find the position of new_solution[i] in relink_solution\n                pos_in_relink = np.where(relink_solution == new_solution[i])[0][0]\n                # Insert the corresponding node from relink_solution\n                temp_solution[i] = relink_solution[pos_in_relink]\n\n        # Ensure feasibility by fixing duplicates\n        unique, counts = np.unique(temp_solution, return_counts=True)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            # Find all positions with this duplicate\n            dup_positions = np.where(temp_solution == dup)[0]\n            # Replace duplicates with missing nodes\n            missing_nodes = set(range(n)) - set(temp_solution)\n            for pos in dup_positions[1:]:\n                if missing_nodes:\n                    temp_solution[pos] = missing_nodes.pop()\n\n        # Simulated annealing acceptance criterion\n        current_cost = (sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                        sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                        sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n)))\n        new_cost = (sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                    sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)),\n                    sum(distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n)))\n\n        # Acceptance probability based on Pareto dominance\n        if (all(nc <= cc for nc, cc in zip(new_cost, current_cost)) and\n            any(nc < cc for nc, cc in zip(new_cost, current_cost))):\n            new_solution = temp_solution.copy()\n        else:\n            # Accept with some probability if not dominated\n            if random.random() < 0.3:\n                new_solution = temp_solution.copy()\n\n    # Final local 2-opt refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto-dominance-aware selection criterion, then applies a novel multi-objective local search operator that combines adaptive edge insertion with objective-specific node reordering to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and all(o <= t for o, t in zip(other_obj, obj)):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive edge insertion with objective-specific node reordering\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    # Objective-specific node reordering\n    for obj_idx in range(3):\n        segment_start = np.random.randint(0, n-4)\n        segment_length = np.random.randint(2, 5)\n\n        segment = new_solution[segment_start:segment_start+segment_length]\n        if obj_idx == 0:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        elif obj_idx == 1:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n        else:\n            segment = sorted(segment, key=lambda x: sum(instance[x, :]))\n\n        new_solution[segment_start:segment_start+segment_length] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.7743893498852182,
            2.482560098171234
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and all(o <= t for o, t in zip(other_obj, obj)):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive edge insertion with objective-specific node reordering\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    # Objective-specific node reordering\n    for obj_idx in range(3):\n        segment_start = np.random.randint(0, n-4)\n        segment_length = np.random.randint(2, 5)\n\n        segment = new_solution[segment_start:segment_start+segment_length]\n        if obj_idx == 0:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        elif obj_idx == 1:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n        else:\n            segment = sorted(segment, key=lambda x: sum(instance[x, :]))\n\n        new_solution[segment_start:segment_start+segment_length] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This new algorithm employs a multi-objective segment inversion operator that first identifies critical segments in a randomly selected archive solution by analyzing their contribution to each objective, then inverts these segments while ensuring feasibility, followed by a targeted edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = random.choice(archive)[0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical segments based on objective contributions\n    segment_length = max(2, n // 5)\n    segment_starts = np.random.choice(range(n - segment_length + 1), size=3, replace=False)\n\n    for start in segment_starts:\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Calculate segment contribution to each objective\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        obj3_contrib = sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Invert segment if it contributes significantly to any objective\n        if (obj1_contrib > np.mean(distance_matrix_1) or\n            obj2_contrib > np.mean(distance_matrix_2) or\n            obj3_contrib > np.mean(distance_matrix_3)):\n            new_solution[start:end] = segment[::-1]\n\n    # Apply targeted edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i < 2:\n            continue\n\n        # Calculate current and potential costs for each objective\n        obj1_current = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                       distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        obj2_current = (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                       distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        obj3_current = (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                       distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        obj1_new = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                   distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n        obj2_new = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                   distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n        obj3_new = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                   distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Perform swap if it improves at least one objective\n        if (obj1_new < obj1_current or obj2_new < obj2_current or obj3_new < obj3_current):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6964794725482599,
            0.39282975196838377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = random.choice(archive)[0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical segments based on objective contributions\n    segment_length = max(2, n // 5)\n    segment_starts = np.random.choice(range(n - segment_length + 1), size=3, replace=False)\n\n    for start in segment_starts:\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Calculate segment contribution to each objective\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        obj3_contrib = sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Invert segment if it contributes significantly to any objective\n        if (obj1_contrib > np.mean(distance_matrix_1) or\n            obj2_contrib > np.mean(distance_matrix_2) or\n            obj3_contrib > np.mean(distance_matrix_3)):\n            new_solution[start:end] = segment[::-1]\n\n    # Apply targeted edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i < 2:\n            continue\n\n        # Calculate current and potential costs for each objective\n        obj1_current = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                       distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        obj2_current = (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                       distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        obj3_current = (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                       distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        obj1_new = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                   distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n        obj2_new = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                   distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n        obj3_new = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                   distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Perform swap if it improves at least one objective\n        if (obj1_new < obj1_current or obj2_new < obj2_current or obj3_new < obj3_current):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{This new algorithm selects solutions from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2-opt with objective-aware node swaps and path reversal, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    for _ in range(3):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7066080794771703,
            0.5164440989494323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    for _ in range(3):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{A new algorithm that selects a solution from the archive based on a lexicographic ordering of objectives, then applies a hybrid 2-opt and edge-swap local search with objective-aware segment selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.lexsort(objectives.T[::-1])\n    selected_idx = sorted_indices[np.random.randint(0, min(5, len(sorted_indices)))]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        if np.random.rand() < 0.5:\n            new_solution[c:c+2] = new_solution[c+1:c-1:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.696821870978082,
            0.39823687076568604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.lexsort(objectives.T[::-1])\n    selected_idx = sorted_indices[np.random.randint(0, min(5, len(sorted_indices)))]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n    new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        if np.random.rand() < 0.5:\n            new_solution[c:c+2] = new_solution[c+1:c-1:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{This new algorithm employs a multi-objective segment exchange strategy that combines path segments from randomly selected archive solutions with a preference for solutions with balanced objective improvements, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements while ensuring solution feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    n = len(archive[0][0])\n\n    # Select two solutions with balanced objectives\n    candidates = sorted(archive, key=lambda x: max(x[1]) - min(x[1]))\n    sol1, sol2 = candidates[0][0], candidates[1][0]\n\n    # Create new solution by alternating segments\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7143105627513664,
            0.19304444789886474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    n = len(archive[0][0])\n\n    # Select two solutions with balanced objectives\n    candidates = sorted(archive, key=lambda x: max(x[1]) - min(x[1]))\n    sol1, sol2 = candidates[0][0], candidates[1][0]\n\n    # Create new solution by alternating segments\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{An algorithm that selects a solution from the archive based on a weighted sum of objectives with dynamic weights adjusted by objective correlation, then applies a hybrid 2-opt and edge-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    corr_matrix = np.corrcoef(objectives.T)\n    avg_corr = np.mean(corr_matrix, axis=1)\n    weights = 1 / (1 + np.exp(-avg_corr))  # Sigmoid function to balance weights\n\n    scores = np.dot(objectives, weights)\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        if np.random.rand() < 0.5:\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            if k != i and l != j and k != j and l != i:\n                old_cost = edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n])\n                new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.770503879483042,
            0.48073890209198
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    corr_matrix = np.corrcoef(objectives.T)\n    avg_corr = np.mean(corr_matrix, axis=1)\n    weights = 1 / (1 + np.exp(-avg_corr))  # Sigmoid function to balance weights\n\n    scores = np.dot(objectives, weights)\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        if np.random.rand() < 0.5:\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            if k != i and l != j and k != j and l != i:\n                old_cost = edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n])\n                new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with lower variance, then applies a hybrid local search combining 2-opt with objective-aware edge reversal to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = 1.0 / (variances + 1e-8)  # Avoid division by zero\n    weights = weights / np.sum(weights)\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.array(scores) / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge reversal\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware edge reversal\n    for _ in range(3):\n        i = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n])\n        new_cost = edge_cost(new_solution[(i+1)%n], new_solution[i])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[(i+1)%n] = new_solution[(i+1)%n], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8013317939854318,
            0.5205652952194214
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = 1.0 / (variances + 1e-8)  # Avoid division by zero\n    weights = weights / np.sum(weights)\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.array(scores) / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge reversal\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware edge reversal\n    for _ in range(3):\n        i = np.random.randint(0, n)\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n])\n        new_cost = edge_cost(new_solution[(i+1)%n], new_solution[i])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[(i+1)%n] = new_solution[(i+1)%n], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid of objective diversity and solution quality, then applies a novel combination of 4-opt and objective-aware segment inversion with adaptive perturbation to generate a neighbor solution, ensuring feasibility and balanced improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    quality = 1 - np.mean(normalized, axis=0)\n    weights = diversity * quality\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 4-opt with objective-aware segment selection\n    for _ in range(5):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def segment_cost(a, b, c, d):\n            return (distance_matrix_1[a, b] + distance_matrix_1[c, d],\n                    distance_matrix_2[a, b] + distance_matrix_2[c, d],\n                    distance_matrix_3[a, b] + distance_matrix_3[c, d])\n\n        old_cost = segment_cost(new_solution[i], new_solution[(i+1)%n], new_solution[j], new_solution[(j+1)%n]) + segment_cost(new_solution[k], new_solution[(k+1)%n], new_solution[l], new_solution[(l+1)%n])\n        new_cost = segment_cost(new_solution[i], new_solution[j], new_solution[k], new_solution[l]) + segment_cost(new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n\n    # Adaptive perturbation\n    if np.random.rand() < 0.3:\n        for _ in range(2):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if abs(a - b) > 1:\n                segment = new_solution[a:b+1]\n                new_solution[a:b+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6735692508403968,
            0.48466973304748534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    quality = 1 - np.mean(normalized, axis=0)\n    weights = diversity * quality\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 4-opt with objective-aware segment selection\n    for _ in range(5):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def segment_cost(a, b, c, d):\n            return (distance_matrix_1[a, b] + distance_matrix_1[c, d],\n                    distance_matrix_2[a, b] + distance_matrix_2[c, d],\n                    distance_matrix_3[a, b] + distance_matrix_3[c, d])\n\n        old_cost = segment_cost(new_solution[i], new_solution[(i+1)%n], new_solution[j], new_solution[(j+1)%n]) + segment_cost(new_solution[k], new_solution[(k+1)%n], new_solution[l], new_solution[(l+1)%n])\n        new_cost = segment_cost(new_solution[i], new_solution[j], new_solution[k], new_solution[l]) + segment_cost(new_solution[(i+1)%n], new_solution[(j+1)%n], new_solution[(k+1)%n], new_solution[(l+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n\n    # Adaptive perturbation\n    if np.random.rand() < 0.3:\n        for _ in range(2):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if abs(a - b) > 1:\n                segment = new_solution[a:b+1]\n                new_solution[a:b+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.2 for each objective), then applies a hybrid local search combining 3-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective segment fusion operator that combines path segments from multiple archive solutions with weighted selection based on objective-specific improvements, followed by a dynamic objective-aware edge refinement step that adaptively prioritizes edge swaps based on the current solution's Pareto front position.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    n = len(base_solution)\n\n    # Create weighted selection of segments from multiple solutions\n    segment_length = max(2, n // 4)\n    new_solution = []\n    used_indices = set()\n\n    for i in range(0, n, segment_length):\n        # Select segment from random solution with probability based on objective weights\n        selected_sol = random.choice(archive)[0]\n        segment_start = random.randint(0, n - segment_length)\n        segment = selected_sol[segment_start:segment_start+segment_length]\n\n        # Add segment while maintaining feasibility\n        for node in segment:\n            if node not in used_indices:\n                new_solution.append(node)\n                used_indices.add(node)\n\n    # Fill remaining nodes\n    remaining_nodes = [node for node in range(n) if node not in used_indices]\n    random.shuffle(remaining_nodes)\n    new_solution.extend(remaining_nodes)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Dynamic objective-aware edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential costs\n        current_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        ]\n\n        # Calculate improvement counts\n        improvements = sum(1 for c, p in zip(current_costs, potential_costs) if p < c)\n\n        # Perform swap with probability based on improvement count\n        if improvements > 1 or (improvements == 1 and random.random() < 0.7):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions of the Pareto front, then applies a novel multi-objective edge insertion operator that selectively inserts nodes based on their potential to improve the solution's Pareto front position, followed by a dynamic objective-aware path reversal operator that adaptively reverses segments based on the current solution's trade-off between objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(archive)\n    n_objectives = 3\n    crowding_distances = np.zeros(n_solutions)\n\n    for m in range(n_objectives):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, n_solutions-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m] + 1e-8)\n\n    # Select solution with minimum crowding distance (most isolated in objective space)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge insertion operator\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate potential insertion costs\n        current_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]\n        ]\n\n        # Count improvements\n        improvements = sum(1 for c, p in zip(current_costs, potential_costs) if p < c)\n\n        # Perform insertion if beneficial\n        if improvements >= 2 or (improvements == 1 and np.random.random() < 0.6):\n            if i < j:\n                new_solution = np.concatenate([new_solution[:i+1], new_solution[j:j+1], new_solution[i+1:j], new_solution[j+1:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j+1], new_solution[i:i+1], new_solution[j+1:i], new_solution[i+1:]])\n\n    # Dynamic objective-aware path reversal operator\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Calculate current and potential segment costs\n        current_costs = [\n            sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment))),\n            sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment))),\n            sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        ]\n\n        reversed_segment = segment[::-1]\n        potential_costs = [\n            sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment))),\n            sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment))),\n            sum(distance_matrix_3[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n        ]\n\n        # Calculate objective improvements\n        improvements = sum(1 for c, p in zip(current_costs, potential_costs) if p < c)\n\n        # Perform reversal if beneficial\n        if improvements >= 2 or (improvements == 1 and np.random.random() < 0.5):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.6289893796591675,
            1.2627806067466736
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(archive)\n    n_objectives = 3\n    crowding_distances = np.zeros(n_solutions)\n\n    for m in range(n_objectives):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, n_solutions-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m] + 1e-8)\n\n    # Select solution with minimum crowding distance (most isolated in objective space)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge insertion operator\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate potential insertion costs\n        current_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]\n        ]\n\n        # Count improvements\n        improvements = sum(1 for c, p in zip(current_costs, potential_costs) if p < c)\n\n        # Perform insertion if beneficial\n        if improvements >= 2 or (improvements == 1 and np.random.random() < 0.6):\n            if i < j:\n                new_solution = np.concatenate([new_solution[:i+1], new_solution[j:j+1], new_solution[i+1:j], new_solution[j+1:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j+1], new_solution[i:i+1], new_solution[j+1:i], new_solution[i+1:]])\n\n    # Dynamic objective-aware path reversal operator\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Calculate current and potential segment costs\n        current_costs = [\n            sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment))),\n            sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment))),\n            sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        ]\n\n        reversed_segment = segment[::-1]\n        potential_costs = [\n            sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment))),\n            sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment))),\n            sum(distance_matrix_3[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n        ]\n\n        # Calculate objective improvements\n        improvements = sum(1 for c, p in zip(current_costs, potential_costs) if p < c)\n\n        # Perform reversal if beneficial\n        if improvements >= 2 or (improvements == 1 and np.random.random() < 0.5):\n            new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective segment fusion operator that combines path segments from multiple archive solutions with weighted selection based on objective-specific improvements, followed by a dynamic objective-aware edge refinement step that adaptively prioritizes edge swaps based on the current solution's Pareto front position.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    n = len(base_solution)\n\n    # Create weighted selection of segments from multiple solutions\n    segment_length = max(2, n // 4)\n    new_solution = []\n    used_indices = set()\n\n    for i in range(0, n, segment_length):\n        # Select segment from random solution with probability based on objective weights\n        selected_sol = random.choice(archive)[0]\n        segment_start = random.randint(0, n - segment_length)\n        segment = selected_sol[segment_start:segment_start+segment_length]\n\n        # Add segment while maintaining feasibility\n        for node in segment:\n            if node not in used_indices:\n                new_solution.append(node)\n                used_indices.add(node)\n\n    # Fill remaining nodes\n    remaining_nodes = [node for node in range(n) if node not in used_indices]\n    random.shuffle(remaining_nodes)\n    new_solution.extend(remaining_nodes)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Dynamic objective-aware edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential costs\n        current_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        ]\n\n        # Calculate improvement counts\n        improvements = sum(1 for c, p in zip(current_costs, potential_costs) if p < c)\n\n        # Perform swap with probability based on improvement count\n        if improvements > 1 or (improvements == 1 and random.random() < 0.7):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{This new algorithm employs a multi-objective path fusion and adaptive objective-weighted edge sampling strategy that combines path segments from multiple solutions with weighted probability based on their objective-specific improvement potential, followed by a dynamic edge sampling and refinement process that adaptively selects and refines edges based on their multi-objective improvement potential across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvements = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    weights = improvements / np.sum(improvements) if np.sum(improvements) > 0 else np.array([1.0, 1.0, 1.0])\n\n    # Path fusion with weighted selection\n    segment_length = max(2, n // 5)\n    new_solution = []\n    used_indices = set()\n\n    for i in range(0, n, segment_length):\n        # Select segment from random solution with weighted probability\n        sol_probs = [np.dot(obj, weights) for _, obj in archive]\n        sol_probs = np.exp(-np.array(sol_probs)) / np.sum(np.exp(-np.array(sol_probs)))\n        selected_idx = np.random.choice(len(archive), p=sol_probs)\n        selected_sol = archive[selected_idx][0]\n\n        # Select segment that shows potential for improvement\n        best_segment = None\n        best_improvement = -float('inf')\n\n        for j in range(0, n, segment_length):\n            segment = selected_sol[j:j+segment_length]\n            # Calculate potential improvement if this segment is used\n            current_cost = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(i, i+segment_length))\n            new_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%segment_length]] for k in range(segment_length-1))\n            improvement = current_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_segment = segment\n\n        if best_segment is not None:\n            for node in best_segment:\n                if node not in used_indices:\n                    new_solution.append(node)\n                    used_indices.add(node)\n\n    # Fill remaining nodes\n    remaining_nodes = [node for node in range(n) if node not in used_indices]\n    random.shuffle(remaining_nodes)\n    new_solution.extend(remaining_nodes)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Adaptive edge sampling and refinement\n    for _ in range(5):\n        # Select edge with highest weighted improvement potential\n        best_edge = None\n        best_improvement = -float('inf')\n\n        for i in range(n):\n            for j in range(i+1, min(i+5, n)):\n                current_costs = [\n                    distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n                ]\n\n                potential_costs = [\n                    distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]]\n                ]\n\n                weighted_improvement = sum((c - p) * w for c, p, w in zip(current_costs, potential_costs, weights))\n\n                if weighted_improvement > best_improvement:\n                    best_improvement = weighted_improvement\n                    best_edge = (i, j)\n\n        if best_edge is not None:\n            i, j = best_edge\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7677338526382134,
            2.1979783296585085
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective weights based on improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvements = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    weights = improvements / np.sum(improvements) if np.sum(improvements) > 0 else np.array([1.0, 1.0, 1.0])\n\n    # Path fusion with weighted selection\n    segment_length = max(2, n // 5)\n    new_solution = []\n    used_indices = set()\n\n    for i in range(0, n, segment_length):\n        # Select segment from random solution with weighted probability\n        sol_probs = [np.dot(obj, weights) for _, obj in archive]\n        sol_probs = np.exp(-np.array(sol_probs)) / np.sum(np.exp(-np.array(sol_probs)))\n        selected_idx = np.random.choice(len(archive), p=sol_probs)\n        selected_sol = archive[selected_idx][0]\n\n        # Select segment that shows potential for improvement\n        best_segment = None\n        best_improvement = -float('inf')\n\n        for j in range(0, n, segment_length):\n            segment = selected_sol[j:j+segment_length]\n            # Calculate potential improvement if this segment is used\n            current_cost = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(i, i+segment_length))\n            new_cost = sum(distance_matrix_1[segment[k], segment[(k+1)%segment_length]] for k in range(segment_length-1))\n            improvement = current_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_segment = segment\n\n        if best_segment is not None:\n            for node in best_segment:\n                if node not in used_indices:\n                    new_solution.append(node)\n                    used_indices.add(node)\n\n    # Fill remaining nodes\n    remaining_nodes = [node for node in range(n) if node not in used_indices]\n    random.shuffle(remaining_nodes)\n    new_solution.extend(remaining_nodes)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Adaptive edge sampling and refinement\n    for _ in range(5):\n        # Select edge with highest weighted improvement potential\n        best_edge = None\n        best_improvement = -float('inf')\n\n        for i in range(n):\n            for j in range(i+1, min(i+5, n)):\n                current_costs = [\n                    distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n                ]\n\n                potential_costs = [\n                    distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]]\n                ]\n\n                weighted_improvement = sum((c - p) * w for c, p, w in zip(current_costs, potential_costs, weights))\n\n                if weighted_improvement > best_improvement:\n                    best_improvement = weighted_improvement\n                    best_edge = (i, j)\n\n        if best_edge is not None:\n            i, j = best_edge\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.2 for each objective), then applies a hybrid local search combining 3-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less explored regions, then applies a hybrid local search combining 4-opt with adaptive edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(3):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]) / (max_vals[m] - min_vals[m] + 1e-8)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply adaptive edge swap\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6592969581372871,
            0.5422969102859497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(3):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m]) / (max_vals[m] - min_vals[m] + 1e-8)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply adaptive edge swap\n    for _ in range(2):\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n or l == (k - 1) % n:\n            l = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                    distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a diversity-aware selection mechanism that prioritizes solutions with high objective diversity, then applies a novel segment-based local search that combines elements of both 2-opt and 3-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based hybrid local search\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 5))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Try both 2-opt and 3-opt moves on the selected segment\n    for _ in range(2):\n        if np.random.rand() < 0.5:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{This new algorithm selects a solution from the archive based on a multi-objective Pareto front dominance analysis combined with a novel node reinsertion operator that strategically reinserts selected nodes to improve objective diversity while maintaining feasibility, using a hybrid of 2-opt and node insertion moves tailored for tri-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            front.append(i)\n\n    if not front:\n        front = list(range(len(archive)))\n\n    selected_idx = np.random.choice(front)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Hybrid local search: 2-opt with strategic node reinsertion\n    for _ in range(5):\n        # Select a random segment\n        seg_length = max(2, min(5, n // 4))\n        start = np.random.randint(0, n - seg_length)\n        end = start + seg_length\n\n        # Try 2-opt on the segment\n        i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Strategic node reinsertion\n        if np.random.rand() < 0.6:\n            node = np.random.choice(range(n))\n            pos = np.random.choice(range(n))\n            if pos != node and (pos+1)%n != node:\n                old_cost = edge_cost(new_solution[node-1], new_solution[node]) + edge_cost(new_solution[node], new_solution[(node+1)%n])\n                new_cost = edge_cost(new_solution[node-1], new_solution[(node+1)%n]) + edge_cost(new_solution[pos], new_solution[node]) + edge_cost(new_solution[node], new_solution[(pos+1)%n])\n\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    # Remove node and reinsert at new position\n                    node_val = new_solution[node]\n                    new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n                    new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.7500825379925845,
            2.507616865634918
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            front.append(i)\n\n    if not front:\n        front = list(range(len(archive)))\n\n    selected_idx = np.random.choice(front)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Hybrid local search: 2-opt with strategic node reinsertion\n    for _ in range(5):\n        # Select a random segment\n        seg_length = max(2, min(5, n // 4))\n        start = np.random.randint(0, n - seg_length)\n        end = start + seg_length\n\n        # Try 2-opt on the segment\n        i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Strategic node reinsertion\n        if np.random.rand() < 0.6:\n            node = np.random.choice(range(n))\n            pos = np.random.choice(range(n))\n            if pos != node and (pos+1)%n != node:\n                old_cost = edge_cost(new_solution[node-1], new_solution[node]) + edge_cost(new_solution[node], new_solution[(node+1)%n])\n                new_cost = edge_cost(new_solution[node-1], new_solution[(node+1)%n]) + edge_cost(new_solution[pos], new_solution[node]) + edge_cost(new_solution[node], new_solution[(pos+1)%n])\n\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    # Remove node and reinsert at new position\n                    node_val = new_solution[node]\n                    new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n                    new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7428815401697535,
            0.15384857654571532
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective segment fusion operator that combines path segments from multiple archive solutions with weighted selection based on objective-specific improvements, followed by a dynamic objective-aware edge refinement step that adaptively prioritizes edge swaps based on the current solution's Pareto front position.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    n = len(base_solution)\n\n    # Create weighted selection of segments from multiple solutions\n    segment_length = max(2, n // 4)\n    new_solution = []\n    used_indices = set()\n\n    for i in range(0, n, segment_length):\n        # Select segment from random solution with probability based on objective weights\n        selected_sol = random.choice(archive)[0]\n        segment_start = random.randint(0, n - segment_length)\n        segment = selected_sol[segment_start:segment_start+segment_length]\n\n        # Add segment while maintaining feasibility\n        for node in segment:\n            if node not in used_indices:\n                new_solution.append(node)\n                used_indices.add(node)\n\n    # Fill remaining nodes\n    remaining_nodes = [node for node in range(n) if node not in used_indices]\n    random.shuffle(remaining_nodes)\n    new_solution.extend(remaining_nodes)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Dynamic objective-aware edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential costs\n        current_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        ]\n\n        # Calculate improvement counts\n        improvements = sum(1 for c, p in zip(current_costs, potential_costs) if p < c)\n\n        # Perform swap with probability based on improvement count\n        if improvements > 1 or (improvements == 1 and random.random() < 0.7):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{This new algorithm employs a multi-objective segment fusion operator that combines path segments from multiple archive solutions with weighted selection based on objective-specific improvements, followed by a dynamic objective-aware edge refinement step that adaptively prioritizes edge swaps based on the current solution's Pareto front position.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    n = len(base_solution)\n\n    segment_length = max(2, n // 3)\n    new_solution = []\n    used_indices = set()\n\n    for i in range(0, n, segment_length):\n        selected_sol = random.choice(archive)[0]\n        segment_start = random.randint(0, n - segment_length)\n        segment = selected_sol[segment_start:segment_start+segment_length]\n\n        for node in segment:\n            if node not in used_indices:\n                new_solution.append(node)\n                used_indices.add(node)\n\n    remaining_nodes = [node for node in range(n) if node not in used_indices]\n    random.shuffle(remaining_nodes)\n    new_solution.extend(remaining_nodes)\n\n    new_solution = np.array(new_solution)\n\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        current_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        ]\n\n        improvements = sum(1 for c, p in zip(current_costs, potential_costs) if p < c)\n\n        if improvements > 0 or random.random() < 0.5:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6880087505879929,
            0.3787625193595886
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    n = len(base_solution)\n\n    segment_length = max(2, n // 3)\n    new_solution = []\n    used_indices = set()\n\n    for i in range(0, n, segment_length):\n        selected_sol = random.choice(archive)[0]\n        segment_start = random.randint(0, n - segment_length)\n        segment = selected_sol[segment_start:segment_start+segment_length]\n\n        for node in segment:\n            if node not in used_indices:\n                new_solution.append(node)\n                used_indices.add(node)\n\n    remaining_nodes = [node for node in range(n) if node not in used_indices]\n    random.shuffle(remaining_nodes)\n    new_solution.extend(remaining_nodes)\n\n    new_solution = np.array(new_solution)\n\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        current_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        ]\n\n        potential_costs = [\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        ]\n\n        improvements = sum(1 for c, p in zip(current_costs, potential_costs) if p < c)\n\n        if improvements > 0 or random.random() < 0.5:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2-opt with objective-aware node swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware node swapping\n    for _ in range(3):\n        a, b = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7006047129178954,
            0.553646469116211
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware node swapping\n    for _ in range(3):\n        a, b = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{This algorithm employs a multi-objective segment insertion operator that randomly selects a segment from a high-quality solution and inserts it into a different position in a lower-quality solution, combined with an objective-aware edge swapping mechanism that selectively replaces edges based on Pareto dominance across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(best_solution)\n\n    # Randomly select a segment from the best solution\n    seg_start = np.random.randint(0, n)\n    seg_length = np.random.randint(2, min(5, n//2))\n    seg_end = (seg_start + seg_length) % n\n    if seg_end < seg_start:\n        segment = np.concatenate([best_solution[seg_start:], best_solution[:seg_end]])\n    else:\n        segment = best_solution[seg_start:seg_end]\n\n    # Select a random solution from the archive to modify\n    target_solution = random.choice(archive)[0].copy()\n\n    # Find a position to insert the segment\n    insert_pos = np.random.randint(0, n)\n    new_solution = np.concatenate([target_solution[:insert_pos], segment, target_solution[insert_pos:]])\n\n    # Remove duplicate nodes by keeping the first occurrence\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # Ensure all nodes are visited exactly once\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply objective-aware edge swapping\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_edges = [\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (new_solution[i], new_solution[j]),\n            (new_solution[(i+1)%n], new_solution[(j+1)%n])\n        ]\n\n        old_costs = [\n            (distance_matrix_1[old_edges[0][0], old_edges[0][1]],\n             distance_matrix_2[old_edges[0][0], old_edges[0][1]],\n             distance_matrix_3[old_edges[0][0], old_edges[0][1]]),\n            (distance_matrix_1[old_edges[1][0], old_edges[1][1]],\n             distance_matrix_2[old_edges[1][0], old_edges[1][1]],\n             distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n        ]\n\n        new_costs = [\n            (distance_matrix_1[new_edges[0][0], new_edges[0][1]],\n             distance_matrix_2[new_edges[0][0], new_edges[0][1]],\n             distance_matrix_3[new_edges[0][0], new_edges[0][1]]),\n            (distance_matrix_1[new_edges[1][0], new_edges[1][1]],\n             distance_matrix_2[new_edges[1][0], new_edges[1][1]],\n             distance_matrix_3[new_edges[1][0], new_edges[1][1]])\n        ]\n\n        # Check if the new edges Pareto dominate the old edges\n        if (all(nc1 <= oc1 and nc2 <= oc2 and nc3 <= oc3 for (nc1, nc2, nc3), (oc1, oc2, oc3) in zip(new_costs, old_costs)) and\n            any(nc1 < oc1 or nc2 < oc2 or nc3 < oc3 for (nc1, nc2, nc3), (oc1, oc2, oc3) in zip(new_costs, old_costs))):\n            # Perform the swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6935304794873044,
            0.5443733215332032
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(best_solution)\n\n    # Randomly select a segment from the best solution\n    seg_start = np.random.randint(0, n)\n    seg_length = np.random.randint(2, min(5, n//2))\n    seg_end = (seg_start + seg_length) % n\n    if seg_end < seg_start:\n        segment = np.concatenate([best_solution[seg_start:], best_solution[:seg_end]])\n    else:\n        segment = best_solution[seg_start:seg_end]\n\n    # Select a random solution from the archive to modify\n    target_solution = random.choice(archive)[0].copy()\n\n    # Find a position to insert the segment\n    insert_pos = np.random.randint(0, n)\n    new_solution = np.concatenate([target_solution[:insert_pos], segment, target_solution[insert_pos:]])\n\n    # Remove duplicate nodes by keeping the first occurrence\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # Ensure all nodes are visited exactly once\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply objective-aware edge swapping\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_edges = [\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (new_solution[i], new_solution[j]),\n            (new_solution[(i+1)%n], new_solution[(j+1)%n])\n        ]\n\n        old_costs = [\n            (distance_matrix_1[old_edges[0][0], old_edges[0][1]],\n             distance_matrix_2[old_edges[0][0], old_edges[0][1]],\n             distance_matrix_3[old_edges[0][0], old_edges[0][1]]),\n            (distance_matrix_1[old_edges[1][0], old_edges[1][1]],\n             distance_matrix_2[old_edges[1][0], old_edges[1][1]],\n             distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n        ]\n\n        new_costs = [\n            (distance_matrix_1[new_edges[0][0], new_edges[0][1]],\n             distance_matrix_2[new_edges[0][0], new_edges[0][1]],\n             distance_matrix_3[new_edges[0][0], new_edges[0][1]]),\n            (distance_matrix_1[new_edges[1][0], new_edges[1][1]],\n             distance_matrix_2[new_edges[1][0], new_edges[1][1]],\n             distance_matrix_3[new_edges[1][0], new_edges[1][1]])\n        ]\n\n        # Check if the new edges Pareto dominate the old edges\n        if (all(nc1 <= oc1 and nc2 <= oc2 and nc3 <= oc3 for (nc1, nc2, nc3), (oc1, oc2, oc3) in zip(new_costs, old_costs)) and\n            any(nc1 < oc1 or nc2 < oc2 or nc3 < oc3 for (nc1, nc2, nc3), (oc1, oc2, oc3) in zip(new_costs, old_costs))):\n            # Perform the swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.2 for each objective), then applies a hybrid local search combining 3-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel multi-objective local search that combines adaptive 2-opt with objective-aware segment reversal and node reinsertion, using a dynamic acceptance criterion to balance exploration and exploitation across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate diversity score (variance across objectives)\n    diversity = np.var(normalized, axis=1)\n    # Calculate quality score (inverse of weighted sum)\n    weights = np.array([0.3, 0.4, 0.3])  # Different weights for objectives\n    quality = 1.0 / (np.dot(normalized, weights) + 1e-8)\n\n    # Combined score\n    scores = diversity + quality\n    probs = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive 2-opt with objective-aware segment reversal\n    for _ in range(5):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        def segment_cost(start, end):\n            total = (0.0, 0.0, 0.0)\n            for i in range(start, end):\n                total = (total[0] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                        total[1] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                        total[2] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n            return total\n\n        old_cost = segment_cost(a, b)\n        reversed_segment = new_solution[a:b][::-1]\n        new_solution[a:b] = reversed_segment\n\n        new_cost = segment_cost(a, b)\n\n        # Dynamic acceptance criterion\n        improvement = (old_cost[0] - new_cost[0], old_cost[1] - new_cost[1], old_cost[2] - new_cost[2])\n        if not any(imp < 0 for imp in improvement):\n            # Accept with probability based on relative improvement\n            total_improvement = sum(improvement)\n            accept_prob = min(1.0, 0.5 + 0.5 * total_improvement / (sum(old_cost) + 1e-8))\n            if np.random.rand() > accept_prob:\n                new_solution[a:b] = reversed_segment[::-1]  # Revert if not accepted\n\n    # Objective-aware node reinsertion\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        current_pos = np.where(new_solution == new_solution[node])[0][0]\n        new_pos = np.random.randint(0, n)\n\n        if new_pos == current_pos or new_pos == (current_pos + 1) % n or new_pos == (current_pos - 1) % n:\n            continue\n\n        # Calculate cost difference\n        old_cost = (distance_matrix_1[new_solution[current_pos], new_solution[(current_pos-1)%n]] +\n                   distance_matrix_1[new_solution[current_pos], new_solution[(current_pos+1)%n]],\n                   distance_matrix_2[new_solution[current_pos], new_solution[(current_pos-1)%n]] +\n                   distance_matrix_2[new_solution[current_pos], new_solution[(current_pos+1)%n]],\n                   distance_matrix_3[new_solution[current_pos], new_solution[(current_pos-1)%n]] +\n                   distance_matrix_3[new_solution[current_pos], new_solution[(current_pos+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[current_pos], new_solution[new_pos]] +\n                   distance_matrix_1[new_solution[current_pos], new_solution[(new_pos+1)%n]],\n                   distance_matrix_2[new_solution[current_pos], new_solution[new_pos]] +\n                   distance_matrix_2[new_solution[current_pos], new_solution[(new_pos+1)%n]],\n                   distance_matrix_3[new_solution[current_pos], new_solution[new_pos]] +\n                   distance_matrix_3[new_solution[current_pos], new_solution[(new_pos+1)%n]])\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[current_pos]\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.6810441904073132,
            0.5782500743865967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate diversity score (variance across objectives)\n    diversity = np.var(normalized, axis=1)\n    # Calculate quality score (inverse of weighted sum)\n    weights = np.array([0.3, 0.4, 0.3])  # Different weights for objectives\n    quality = 1.0 / (np.dot(normalized, weights) + 1e-8)\n\n    # Combined score\n    scores = diversity + quality\n    probs = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive 2-opt with objective-aware segment reversal\n    for _ in range(5):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        def segment_cost(start, end):\n            total = (0.0, 0.0, 0.0)\n            for i in range(start, end):\n                total = (total[0] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                        total[1] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                        total[2] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n            return total\n\n        old_cost = segment_cost(a, b)\n        reversed_segment = new_solution[a:b][::-1]\n        new_solution[a:b] = reversed_segment\n\n        new_cost = segment_cost(a, b)\n\n        # Dynamic acceptance criterion\n        improvement = (old_cost[0] - new_cost[0], old_cost[1] - new_cost[1], old_cost[2] - new_cost[2])\n        if not any(imp < 0 for imp in improvement):\n            # Accept with probability based on relative improvement\n            total_improvement = sum(improvement)\n            accept_prob = min(1.0, 0.5 + 0.5 * total_improvement / (sum(old_cost) + 1e-8))\n            if np.random.rand() > accept_prob:\n                new_solution[a:b] = reversed_segment[::-1]  # Revert if not accepted\n\n    # Objective-aware node reinsertion\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        current_pos = np.where(new_solution == new_solution[node])[0][0]\n        new_pos = np.random.randint(0, n)\n\n        if new_pos == current_pos or new_pos == (current_pos + 1) % n or new_pos == (current_pos - 1) % n:\n            continue\n\n        # Calculate cost difference\n        old_cost = (distance_matrix_1[new_solution[current_pos], new_solution[(current_pos-1)%n]] +\n                   distance_matrix_1[new_solution[current_pos], new_solution[(current_pos+1)%n]],\n                   distance_matrix_2[new_solution[current_pos], new_solution[(current_pos-1)%n]] +\n                   distance_matrix_2[new_solution[current_pos], new_solution[(current_pos+1)%n]],\n                   distance_matrix_3[new_solution[current_pos], new_solution[(current_pos-1)%n]] +\n                   distance_matrix_3[new_solution[current_pos], new_solution[(current_pos+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[current_pos], new_solution[new_pos]] +\n                   distance_matrix_1[new_solution[current_pos], new_solution[(new_pos+1)%n]],\n                   distance_matrix_2[new_solution[current_pos], new_solution[new_pos]] +\n                   distance_matrix_2[new_solution[current_pos], new_solution[(new_pos+1)%n]],\n                   distance_matrix_3[new_solution[current_pos], new_solution[new_pos]] +\n                   distance_matrix_3[new_solution[current_pos], new_solution[(new_pos+1)%n]])\n\n        # Accept if at least one objective improves\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[current_pos]\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{This new algorithm selects a solution from the archive with the best combined objective value, then performs a multi-objective aware 2-opt swap that prioritizes improving at least one objective while maintaining feasibility, with additional node reinsertion steps to ensure all nodes are visited exactly once.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Accept if at least one objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7857785219516787,
            0.3704549789428711
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Accept if at least one objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.2 for each objective), then applies a hybrid local search combining 3-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[l]] + distance_matrix_3[new_solution[(k+1)%n], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance aware selection to identify solutions in less crowded regions of the Pareto front, then applies a hybrid local search combining 2.5-opt with objective-balanced edge swaps to generate a neighbor solution, ensuring feasibility while promoting multi-objective improvement by balancing improvements across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate crowding distance\n    sorted_indices = np.argsort(normalized, axis=0)\n    crowding_distance = np.zeros(len(archive))\n    for m in range(3):\n        for i in range(1, len(archive)-1):\n            idx = sorted_indices[i, m]\n            crowding_distance[idx] += (normalized[sorted_indices[i+1, m], m] - normalized[sorted_indices[i-1, m], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt local search\n    for _ in range(5):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-balanced edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]],\n                distance_matrix_2[new_solution[k], new_solution[l]],\n                distance_matrix_3[new_solution[k], new_solution[l]])\n\n    if all(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.779597887487216,
            0.5419801473617554
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate crowding distance\n    sorted_indices = np.argsort(normalized, axis=0)\n    crowding_distance = np.zeros(len(archive))\n    for m in range(3):\n        for i in range(1, len(archive)-1):\n            idx = sorted_indices[i, m]\n            crowding_distance[idx] += (normalized[sorted_indices[i+1, m], m] - normalized[sorted_indices[i-1, m], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt local search\n    for _ in range(5):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[d], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-balanced edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[l]],\n                distance_matrix_2[new_solution[k], new_solution[l]],\n                distance_matrix_3[new_solution[k], new_solution[l]])\n\n    if all(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized weighted sum of objectives using adaptive weights (0.2, 0.3, 0.5) and applies a hybrid local search combining 3-opt with objective-aware edge flips to generate a neighbor solution, ensuring feasibility and multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(5):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge flip\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.720580065238672,
            0.4469372630119324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.2, 0.3, 0.5])\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(5):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware edge flip\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2-opt with objective-aware edge swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge swapping\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware edge swapping\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    return new_solution\n\n",
        "score": [
            -0.782795189862861,
            0.530463433265686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge swapping\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware edge swapping\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This new algorithm combines the strengths of both existing approaches by first selecting a solution from the archive using a dynamic weight vector that prioritizes objectives with higher variance, then applies a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.661438466326386,
            0.39553972482681277
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{This algorithm selects a solution from the archive using a crowding-distance-based selection to prioritize solutions in less crowded regions, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(objectives)\n\n    # Calculate crowding distance for each objective\n    crowding_distances = np.zeros(n_solutions)\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n\n        # Assign infinite distance to boundary solutions\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n\n        # Calculate crowding distance for intermediate solutions\n        for i in range(1, n_solutions - 1):\n            crowding_distances[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-8)\n\n    # Select solution with highest crowding distance (less crowded regions)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform node insertion\n        node = new_solution[l]\n        new_solution = np.delete(new_solution, l)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.754838551560215,
            0.6349957585334778
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(objectives)\n\n    # Calculate crowding distance for each objective\n    crowding_distances = np.zeros(n_solutions)\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n\n        # Assign infinite distance to boundary solutions\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n\n        # Calculate crowding distance for intermediate solutions\n        for i in range(1, n_solutions - 1):\n            crowding_distances[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-8)\n\n    # Select solution with highest crowding distance (less crowded regions)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt local search\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[c]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Apply objective-aware node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        # Perform node insertion\n        node = new_solution[l]\n        new_solution = np.delete(new_solution, l)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that considers both objective variance and dominance relationships, then applies a hybrid local search combining multi-objective edge insertion with objective-aware segment reversal to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    # Calculate dominance scores\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if all(archive[i][1][k] <= archive[j][1][k] for k in range(3)) and any(archive[i][1][k] < archive[j][1][k] for k in range(3)):\n                dominance[i] += 1\n\n    # Combine weights and dominance scores\n    combined_scores = np.dot(objectives, weights) - 0.5 * dominance\n    probs = np.exp(-combined_scores) / np.sum(np.exp(-combined_scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge insertion\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or i == (j+1)%n or j == (i+1)%n:\n            continue\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Objective-aware segment reversal\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or i == (j+1)%n or j == (i+1)%n:\n            continue\n\n        def segment_cost(start, end):\n            total = (0, 0, 0)\n            for k in range(start, end):\n                total = (total[0] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n                         total[1] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n                         total[2] + distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n            return total\n\n        old_cost = segment_cost(i, j+1)\n        reversed_segment = new_solution[i:j+1][::-1]\n        new_solution[i:j+1] = reversed_segment\n        new_cost = segment_cost(i, j+1)\n\n        if not any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i:j+1] = reversed_segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7614395428921428,
            1.8643874645233154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    # Calculate dominance scores\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if all(archive[i][1][k] <= archive[j][1][k] for k in range(3)) and any(archive[i][1][k] < archive[j][1][k] for k in range(3)):\n                dominance[i] += 1\n\n    # Combine weights and dominance scores\n    combined_scores = np.dot(objectives, weights) - 0.5 * dominance\n    probs = np.exp(-combined_scores) / np.sum(np.exp(-combined_scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge insertion\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or i == (j+1)%n or j == (i+1)%n:\n            continue\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Objective-aware segment reversal\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or i == (j+1)%n or j == (i+1)%n:\n            continue\n\n        def segment_cost(start, end):\n            total = (0, 0, 0)\n            for k in range(start, end):\n                total = (total[0] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n                         total[1] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n                         total[2] + distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n            return total\n\n        old_cost = segment_cost(i, j+1)\n        reversed_segment = new_solution[i:j+1][::-1]\n        new_solution[i:j+1] = reversed_segment\n        new_cost = segment_cost(i, j+1)\n\n        if not any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i:j+1] = reversed_segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware edge swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Apply objective-aware edge swapping\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7690004911563573,
            0.5526687860488891
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Apply objective-aware edge swapping\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2-opt with objective-aware node swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware node swapping\n    for _ in range(3):\n        i, j = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                     distance_matrix_2[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                     distance_matrix_3[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_3[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[(j-1)%n]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i-1)%n]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]],\n                     distance_matrix_2[new_solution[i], new_solution[(j-1)%n]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i-1)%n]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]],\n                     distance_matrix_3[new_solution[i], new_solution[(j-1)%n]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] +\n                     distance_matrix_3[new_solution[j], new_solution[(i-1)%n]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7593011610758464,
            0.5972116947174072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware node swapping\n    for _ in range(3):\n        i, j = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                     distance_matrix_2[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                     distance_matrix_3[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_3[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[(j-1)%n]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i-1)%n]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]],\n                     distance_matrix_2[new_solution[i], new_solution[(j-1)%n]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i-1)%n]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]],\n                     distance_matrix_3[new_solution[i], new_solution[(j-1)%n]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] +\n                     distance_matrix_3[new_solution[j], new_solution[(i-1)%n]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This new algorithm combines the strengths of both approaches by first selecting solutions based on their non-dominated fronts and then applying a novel segment crossover that preserves common edges across objectives while incorporating a dynamic objective-aware edge swapping mechanism to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    front_indices = [0]\n    current_front = 0\n    while len(front_indices) < 3 and len(front_indices) < len(archive):\n        current_front += 1\n        front_indices.append(current_front)\n\n    selected_indices = np.random.choice(front_indices, size=3, replace=False)\n    sol1, sol2, sol3 = archive[selected_indices[0]][0], archive[selected_indices[1]][0], archive[selected_indices[2]][0]\n    n = len(sol1)\n\n    # Create new solution using segment crossover\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        elif i % 3 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply dynamic objective-aware edge swapping\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Calculate objective improvements\n        improvements = [oc - nc for nc, oc in zip(new_cost, old_cost)]\n        total_improvement = sum(improvements)\n\n        if total_improvement > 0:\n            # Perform segment swap with probability proportional to improvement\n            if np.random.rand() < (total_improvement / sum(old_cost)):\n                temp = new_solution[i+1:j+1].copy()\n                new_solution[i+1:j+1] = new_solution[j:j-(j-i):-1]\n                new_solution[j:j-(j-i):-1] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.6936696145185758,
            0.13687461614608765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    front_indices = [0]\n    current_front = 0\n    while len(front_indices) < 3 and len(front_indices) < len(archive):\n        current_front += 1\n        front_indices.append(current_front)\n\n    selected_indices = np.random.choice(front_indices, size=3, replace=False)\n    sol1, sol2, sol3 = archive[selected_indices[0]][0], archive[selected_indices[1]][0], archive[selected_indices[2]][0]\n    n = len(sol1)\n\n    # Create new solution using segment crossover\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        elif i % 3 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply dynamic objective-aware edge swapping\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Calculate objective improvements\n        improvements = [oc - nc for nc, oc in zip(new_cost, old_cost)]\n        total_improvement = sum(improvements)\n\n        if total_improvement > 0:\n            # Perform segment swap with probability proportional to improvement\n            if np.random.rand() < (total_improvement / sum(old_cost)):\n                temp = new_solution[i+1:j+1].copy()\n                new_solution[i+1:j+1] = new_solution[j:j-(j-i):-1]\n                new_solution[j:j-(j-i):-1] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized weighted sum of objectives using different weights (0.3 for each objective), then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.3, 0.3, 0.4])  # Different weights for objectives\n    scores = np.dot(normalized, weights)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt local search\n    for _ in range(3):\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        def edge_cost(u, v):\n            return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[d]) + edge_cost(new_solution[b], new_solution[(a+1)%n]) + edge_cost(new_solution[c], new_solution[(b+1)%n]) + edge_cost(new_solution[d], new_solution[(c+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n            new_solution[(c+1):(d+1)] = new_solution[(c+1):(d+1)][::-1]\n\n    # Apply objective-aware edge swap\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = np.random.randint(0, n)\n\n    old_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    new_cost = (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]],\n                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This new algorithm employs a multi-objective evolutionary strategy that combines adaptive solution blending with a novel objective-driven segment insertion mechanism, leveraging Pareto dominance information to guide the selection of parent solutions and ensuring diverse neighborhood exploration through dynamic segment reversal and insertion based on objective-specific improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    # Select two parent solutions with good objective diversity\n    selected_indices = np.random.choice(pareto_front, size=2, replace=False)\n    parent1, parent2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Create a new solution by blending segments from parents\n    n = len(parent1)\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(parent1[i])\n        else:\n            new_solution.append(parent2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-driven segment insertion\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n        old_cost = (sum(distance_matrix_1[new_solution[(k-1)%n], new_solution[k]] for k in range(i, j)),\n                    sum(distance_matrix_2[new_solution[(k-1)%n], new_solution[k]] for k in range(i, j)),\n                    sum(distance_matrix_3[new_solution[(k-1)%n], new_solution[k]] for k in range(i, j)))\n\n        # Try inserting segment in a different position\n        insert_pos = np.random.randint(0, n)\n        temp_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n        temp_solution = temp_solution[:n]  # Ensure length is preserved\n\n        new_cost = (sum(distance_matrix_1[temp_solution[(k-1)%n], temp_solution[k]] for k in range(n)),\n                    sum(distance_matrix_2[temp_solution[(k-1)%n], temp_solution[k]] for k in range(n)),\n                    sum(distance_matrix_3[temp_solution[(k-1)%n], temp_solution[k]] for k in range(n)))\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7840209078864833,
            3.1001354694366454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    # Select two parent solutions with good objective diversity\n    selected_indices = np.random.choice(pareto_front, size=2, replace=False)\n    parent1, parent2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Create a new solution by blending segments from parents\n    n = len(parent1)\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(parent1[i])\n        else:\n            new_solution.append(parent2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-driven segment insertion\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n        old_cost = (sum(distance_matrix_1[new_solution[(k-1)%n], new_solution[k]] for k in range(i, j)),\n                    sum(distance_matrix_2[new_solution[(k-1)%n], new_solution[k]] for k in range(i, j)),\n                    sum(distance_matrix_3[new_solution[(k-1)%n], new_solution[k]] for k in range(i, j)))\n\n        # Try inserting segment in a different position\n        insert_pos = np.random.randint(0, n)\n        temp_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n        temp_solution = temp_solution[:n]  # Ensure length is preserved\n\n        new_cost = (sum(distance_matrix_1[temp_solution[(k-1)%n], temp_solution[k]] for k in range(n)),\n                    sum(distance_matrix_2[temp_solution[(k-1)%n], temp_solution[k]] for k in range(n)),\n                    sum(distance_matrix_3[temp_solution[(k-1)%n], temp_solution[k]] for k in range(n)))\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware edge reversal to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge reversal\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_edges = [edge_cost(new_solution[i], new_solution[(i+1)%n]),\n                     edge_cost(new_solution[j], new_solution[(j+1)%n]),\n                     edge_cost(new_solution[k], new_solution[(k+1)%n])]\n\n        # Try different 3-opt configurations\n        for config in [(i, j, k), (i, k, j)]:\n            a, b, c = config\n            new_edges = [edge_cost(new_solution[a], new_solution[b]),\n                         edge_cost(new_solution[b], new_solution[c]),\n                         edge_cost(new_solution[c], new_solution[(c+1)%n])]\n\n            if any(sum(new) < sum(old) for new, old in zip(new_edges, old_edges)):\n                # Apply the 3-opt move\n                segment = new_solution[b:(c+1)]\n                new_solution[b:(c+1)] = segment[::-1]\n                break\n\n    # Apply objective-aware edge reversal\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.753038665983939,
            0.6020064234733582
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge reversal\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_edges = [edge_cost(new_solution[i], new_solution[(i+1)%n]),\n                     edge_cost(new_solution[j], new_solution[(j+1)%n]),\n                     edge_cost(new_solution[k], new_solution[(k+1)%n])]\n\n        # Try different 3-opt configurations\n        for config in [(i, j, k), (i, k, j)]:\n            a, b, c = config\n            new_edges = [edge_cost(new_solution[a], new_solution[b]),\n                         edge_cost(new_solution[b], new_solution[c]),\n                         edge_cost(new_solution[c], new_solution[(c+1)%n])]\n\n            if any(sum(new) < sum(old) for new, old in zip(new_edges, old_edges)):\n                # Apply the 3-opt move\n                segment = new_solution[b:(c+1)]\n                new_solution[b:(c+1)] = segment[::-1]\n                break\n\n    # Apply objective-aware edge reversal\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This algorithm implements a multi-objective local search by first selecting a solution from the archive with a probability inversely proportional to its combined objective value, then applies a hybrid operator that combines 2-opt moves with objective-specific edge swaps, followed by a novel segment insertion mechanism that prioritizes edges with balanced improvements across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [sum(obj) for _, obj in archive]\n    probs = [1/(obj + 1e-6) for obj in objectives]\n    probs = [p/sum(probs) for p in probs]\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid 2-opt with objective-specific edge swaps\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            # Try 2-opt move\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = reversed_segment\n\n            # Check improvement in at least one objective\n            old_costs = [distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                         distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]]\n\n            new_costs = [distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] +\n                         distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] +\n                         distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]],\n                         distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]] +\n                         distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]] +\n                         distance_matrix_3[temp_solution[j], temp_solution[(j+1)%n]]]\n\n            if sum(new_costs) < sum(old_costs):\n                new_solution = temp_solution\n\n    # Apply segment insertion with balanced objective improvements\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            temp_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n            # Check for balanced improvements\n            old_cost = sum([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]])\n\n            new_cost = sum([distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] +\n                            distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] +\n                            distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]],\n                            distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]] +\n                            distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]] +\n                            distance_matrix_3[temp_solution[j], temp_solution[(j+1)%n]]])\n\n            if new_cost < old_cost:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7508967857319713,
            1.3225993275642396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [sum(obj) for _, obj in archive]\n    probs = [1/(obj + 1e-6) for obj in objectives]\n    probs = [p/sum(probs) for p in probs]\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid 2-opt with objective-specific edge swaps\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            # Try 2-opt move\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = reversed_segment\n\n            # Check improvement in at least one objective\n            old_costs = [distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                         distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]]\n\n            new_costs = [distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] +\n                         distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] +\n                         distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]],\n                         distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]] +\n                         distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]] +\n                         distance_matrix_3[temp_solution[j], temp_solution[(j+1)%n]]]\n\n            if sum(new_costs) < sum(old_costs):\n                new_solution = temp_solution\n\n    # Apply segment insertion with balanced objective improvements\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            temp_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n            # Check for balanced improvements\n            old_cost = sum([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]])\n\n            new_cost = sum([distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] +\n                            distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] +\n                            distance_matrix_3[temp_solution[i], temp_solution[(i+1)%n]],\n                            distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]] +\n                            distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]] +\n                            distance_matrix_3[temp_solution[j], temp_solution[(j+1)%n]]])\n\n            if new_cost < old_cost:\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7147234944678542,
            0.13851935863494874
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{This new algorithm selects a solution from the archive based on a multi-objective dominance rank, then applies a novel path reversal and segment rotation operator that considers the trade-off between all three objectives to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    dominance_ranks = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            dominance_ranks[i] = 1\n\n    selected_idx = np.argmax(dominance_ranks)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply path reversal and segment rotation\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Calculate current cost\n        current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                       distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                       distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        # Try reversed segment\n        reversed_cost = (distance_matrix_1[new_solution[a-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(b+1)%n]],\n                        distance_matrix_2[new_solution[a-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(b+1)%n]],\n                        distance_matrix_3[new_solution[a-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(b+1)%n]])\n\n        # Try rotated segment\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] + distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%n]],\n                        distance_matrix_2[new_solution[a-1], rotated_segment[0]] + distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%n]],\n                        distance_matrix_3[new_solution[a-1], rotated_segment[0]] + distance_matrix_3[rotated_segment[-1], new_solution[(b+1)%n]])\n\n        # Select best option considering all objectives\n        if any(r < c for r, c in zip(reversed_cost, current_cost)):\n            new_solution[a:b+1] = segment[::-1]\n        elif any(r < c for r, c in zip(rotated_cost, current_cost)):\n            new_solution[a:b+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.7227134048676958,
            3.5201785922050477
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    dominance_ranks = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            dominance_ranks[i] = 1\n\n    selected_idx = np.argmax(dominance_ranks)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply path reversal and segment rotation\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Calculate current cost\n        current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                       distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                       distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        # Try reversed segment\n        reversed_cost = (distance_matrix_1[new_solution[a-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(b+1)%n]],\n                        distance_matrix_2[new_solution[a-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(b+1)%n]],\n                        distance_matrix_3[new_solution[a-1], segment[-1]] + distance_matrix_3[segment[0], new_solution[(b+1)%n]])\n\n        # Try rotated segment\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] + distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%n]],\n                        distance_matrix_2[new_solution[a-1], rotated_segment[0]] + distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%n]],\n                        distance_matrix_3[new_solution[a-1], rotated_segment[0]] + distance_matrix_3[rotated_segment[-1], new_solution[(b+1)%n]])\n\n        # Select best option considering all objectives\n        if any(r < c for r, c in zip(reversed_cost, current_cost)):\n            new_solution[a:b+1] = segment[::-1]\n        elif any(r < c for r, c in zip(rotated_cost, current_cost)):\n            new_solution[a:b+1] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This new algorithm employs a multi-objective segment insertion operator that intelligently combines segments from two randomly selected archive solutions while dynamically adjusting the segment length based on the relative performance of the objectives, followed by an adaptive edge optimization step that prioritizes edges with the highest potential for improvement across all three objectives using a normalized weighted improvement metric.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Calculate objective weights based on relative performance\n    obj1 = np.mean([s[1][0] for s in archive])\n    obj2 = np.mean([s[1][1] for s in archive])\n    obj3 = np.mean([s[1][2] for s in archive])\n    total = obj1 + obj2 + obj3\n    w1, w2, w3 = obj1/total, obj2/total, obj3/total\n\n    # Dynamic segment length selection\n    segment_length = max(2, int(n * (1 - (w1 + w2 + w3)/3)))\n\n    # Create new solution by inserting segments from sol2 into sol1\n    new_solution = sol1.copy()\n    pos = np.random.randint(0, n)\n    segment = sol2[pos:pos+segment_length]\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos+segment_length:]])\n\n    # Remove duplicates and insert missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Adaptive edge optimization with weighted improvement\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] * w1 +\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] * w2 +\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] * w3,\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] * w1 +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] * w2 +\n                    distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] * w3)\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] * w1 +\n                    distance_matrix_2[new_solution[i], new_solution[j]] * w2 +\n                    distance_matrix_3[new_solution[i], new_solution[j]] * w3,\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] * w1 +\n                    distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] * w2 +\n                    distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] * w3)\n\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6580643562744997,
            0.22152429819107056
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Calculate objective weights based on relative performance\n    obj1 = np.mean([s[1][0] for s in archive])\n    obj2 = np.mean([s[1][1] for s in archive])\n    obj3 = np.mean([s[1][2] for s in archive])\n    total = obj1 + obj2 + obj3\n    w1, w2, w3 = obj1/total, obj2/total, obj3/total\n\n    # Dynamic segment length selection\n    segment_length = max(2, int(n * (1 - (w1 + w2 + w3)/3)))\n\n    # Create new solution by inserting segments from sol2 into sol1\n    new_solution = sol1.copy()\n    pos = np.random.randint(0, n)\n    segment = sol2[pos:pos+segment_length]\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos+segment_length:]])\n\n    # Remove duplicates and insert missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Adaptive edge optimization with weighted improvement\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] * w1 +\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] * w2 +\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] * w3,\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] * w1 +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] * w2 +\n                    distance_matrix_3[new_solution[j], new_solution[(j+1)%n]] * w3)\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] * w1 +\n                    distance_matrix_2[new_solution[i], new_solution[j]] * w2 +\n                    distance_matrix_3[new_solution[i], new_solution[j]] * w3,\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] * w1 +\n                    distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] * w2 +\n                    distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] * w3)\n\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2-opt with objective-aware node swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware node swapping\n    for _ in range(3):\n        a, b = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]],\n                    distance_matrix_2[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]],\n                    distance_matrix_3[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6782829979018341,
            0.566353702545166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware node swapping\n    for _ in range(3):\n        a, b = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]],\n                    distance_matrix_2[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]],\n                    distance_matrix_3[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]] +\n                    distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{This new algorithm employs a multi-objective segment exchange strategy that combines path segments from three randomly selected archive solutions with adaptive weighting based on Pareto dominance, followed by a dynamic edge refinement process that selectively reverses segments based on their contribution to objective improvements, while ensuring feasibility through a novel node reassignment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 3:\n        return archive[0][0].copy()\n\n    # Select three solutions with bias towards better solutions\n    weights = [1/(1 + sum(obj)) for _, obj in archive]\n    total_weight = sum(weights)\n    probs = [w/total_weight for w in weights]\n    indices = np.random.choice(len(archive), size=3, p=probs, replace=False)\n    sol1, sol2, sol3 = archive[indices[0]][0], archive[indices[1]][0], archive[indices[2]][0]\n\n    n = len(sol1)\n    new_solution = np.zeros(n, dtype=int)\n\n    # Combine segments with adaptive weighting\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution[i] = sol1[i]\n        elif i % 3 == 1:\n            new_solution[i] = sol2[i]\n        else:\n            new_solution[i] = sol3[i]\n\n    # Ensure all nodes are visited exactly once\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        new_solution = new_solution[:n]\n\n    # Dynamic edge refinement with segment reversal\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Calculate current and potential costs\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j+1)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j+1)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j+1))\n        ]\n\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        new_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j+1)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j+1)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j+1))\n        ]\n\n        # Revert if no improvement in any objective\n        if not any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[i:j+1] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.6628288848088201,
            0.396112334728241
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 3:\n        return archive[0][0].copy()\n\n    # Select three solutions with bias towards better solutions\n    weights = [1/(1 + sum(obj)) for _, obj in archive]\n    total_weight = sum(weights)\n    probs = [w/total_weight for w in weights]\n    indices = np.random.choice(len(archive), size=3, p=probs, replace=False)\n    sol1, sol2, sol3 = archive[indices[0]][0], archive[indices[1]][0], archive[indices[2]][0]\n\n    n = len(sol1)\n    new_solution = np.zeros(n, dtype=int)\n\n    # Combine segments with adaptive weighting\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution[i] = sol1[i]\n        elif i % 3 == 1:\n            new_solution[i] = sol2[i]\n        else:\n            new_solution[i] = sol3[i]\n\n    # Ensure all nodes are visited exactly once\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        new_solution = new_solution[:n]\n\n    # Dynamic edge refinement with segment reversal\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Calculate current and potential costs\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j+1)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j+1)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j+1))\n        ]\n\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        new_costs = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j+1)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j+1)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j+1))\n        ]\n\n        # Revert if no improvement in any objective\n        if not any(new_cost < current_cost for new_cost, current_cost in zip(new_costs, current_costs)):\n            new_solution[i:j+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive with the best combined objective value, then performs a multi-objective aware 2-opt swap that prioritizes improving at least one objective while maintaining feasibility, with additional node reinsertion steps to ensure all nodes are visited exactly once.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Accept if at least one objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid objective score combining Pareto dominance and objective space partitioning, then applies a novel \"multi-objective inversion\" operator that reverses segments of the tour while prioritizing improvement in the least improved objective, with adaptive segment length selection to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate dominance scores\n    dominance_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                dominated += 1\n        dominance_scores[i] = dominated\n\n    # Calculate objective space partitioning scores\n    partition_scores = np.zeros(len(archive))\n    for i in range(3):\n        sorted_idx = np.argsort(normalized[:, i])\n        for j in range(len(archive)):\n            partition_scores[j] += (j - sorted_idx[j])**2\n\n    # Combine scores with adaptive weights\n    total_scores = 0.7 * dominance_scores + 0.3 * partition_scores\n    selected_idx = np.argmax(total_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective inversion operator\n    for _ in range(3):\n        # Select segment length based on objective improvement history\n        segment_length = np.random.randint(2, min(6, n//2))\n\n        # Select segment start point\n        start = np.random.randint(0, n - segment_length)\n\n        # Calculate current costs for the segment\n        current_costs = []\n        for i in range(start, start + segment_length):\n            current_costs.append((\n                distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n            ))\n\n        # Reverse the segment\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Calculate new costs for the segment\n        new_costs = []\n        for i in range(start, start + segment_length):\n            new_costs.append((\n                distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n            ))\n\n        # Identify the least improved objective and prioritize it\n        improvements = [\n            (sum(old) - sum(new)) for old, new in zip(zip(*current_costs), zip(*new_costs))\n        ]\n        worst_obj = np.argmin(improvements)\n\n        # If the least improved objective didn't improve, revert the change\n        if improvements[worst_obj] <= 0:\n            new_solution[start:start+segment_length] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.6910657114365186,
            3.2793149948120117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate dominance scores\n    dominance_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                dominated += 1\n        dominance_scores[i] = dominated\n\n    # Calculate objective space partitioning scores\n    partition_scores = np.zeros(len(archive))\n    for i in range(3):\n        sorted_idx = np.argsort(normalized[:, i])\n        for j in range(len(archive)):\n            partition_scores[j] += (j - sorted_idx[j])**2\n\n    # Combine scores with adaptive weights\n    total_scores = 0.7 * dominance_scores + 0.3 * partition_scores\n    selected_idx = np.argmax(total_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective inversion operator\n    for _ in range(3):\n        # Select segment length based on objective improvement history\n        segment_length = np.random.randint(2, min(6, n//2))\n\n        # Select segment start point\n        start = np.random.randint(0, n - segment_length)\n\n        # Calculate current costs for the segment\n        current_costs = []\n        for i in range(start, start + segment_length):\n            current_costs.append((\n                distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n            ))\n\n        # Reverse the segment\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Calculate new costs for the segment\n        new_costs = []\n        for i in range(start, start + segment_length):\n            new_costs.append((\n                distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n            ))\n\n        # Identify the least improved objective and prioritize it\n        improvements = [\n            (sum(old) - sum(new)) for old, new in zip(zip(*current_costs), zip(*new_costs))\n        ]\n        worst_obj = np.argmin(improvements)\n\n        # If the least improved objective didn't improve, revert the change\n        if improvements[worst_obj] <= 0:\n            new_solution[start:start+segment_length] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid of dominance rank and crowding distance, then applies a novel \"objective-aware segment inversion\" operator that inverts segments of the tour while considering the trade-off between all three objectives, followed by a \"multi-objective insertion\" step that intelligently places nodes to improve the solution across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            ranks[i] = 1\n    crowding_distances = np.zeros(len(archive))\n    for m in range(3):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[i] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    # Select based on hybrid of rank and crowding distance\n    combined_scores = ranks * crowding_distances\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply objective-aware segment inversion\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        old_cost = (sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n                    sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n                    sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n)))\n        new_solution[i:j+1] = segment[::-1]\n        new_cost = (sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n                    sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n                    sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n)))\n\n        # Revert if not improving any objective\n        if all(new >= old for new, old in zip(new_cost, old_cost)):\n            new_solution[i:j+1] = segment\n\n    # Apply multi-objective insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n        if pos == node or pos == (node-1)%n:\n            continue\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.6908193787529078,
            3.6860318899154665
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            ranks[i] = 1\n    crowding_distances = np.zeros(len(archive))\n    for m in range(3):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[i] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    # Select based on hybrid of rank and crowding distance\n    combined_scores = ranks * crowding_distances\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply objective-aware segment inversion\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        old_cost = (sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n                    sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n                    sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n)))\n        new_solution[i:j+1] = segment[::-1]\n        new_cost = (sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n                    sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n                    sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n)))\n\n        # Revert if not improving any objective\n        if all(new >= old for new, old in zip(new_cost, old_cost)):\n            new_solution[i:j+1] = segment\n\n    # Apply multi-objective insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n        if pos == node or pos == (node-1)%n:\n            continue\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive with the best combined objective value, then performs a multi-objective aware 2-opt swap that prioritizes improving at least one objective while maintaining feasibility, with additional node reinsertion steps to ensure all nodes are visited exactly once.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Accept if at least one objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a multi-objective aware segment relocation strategy that intelligently reorders segments of the tour while considering trade-offs across all three objectives, ensuring feasibility and potential for balanced improvement across multiple dimensions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.sum(objectives, axis=1)\n    diversity = np.std(objectives, axis=0)\n    combined_scores = scores - 0.5 * np.dot(objectives, diversity)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment relocation\n    for _ in range(5):\n        # Select a segment of random length\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find insertion position that improves at least one objective\n        best_pos = None\n        best_improvement = 0\n\n        for pos in range(0, n - segment_length + 1):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Calculate cost difference\n            old_cost = (\n                distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                distance_matrix_1[new_solution[start+segment_length-1], new_solution[(start+segment_length)%n]],\n                distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                distance_matrix_2[new_solution[start+segment_length-1], new_solution[(start+segment_length)%n]],\n                distance_matrix_3[new_solution[start-1], new_solution[start]] +\n                distance_matrix_3[new_solution[start+segment_length-1], new_solution[(start+segment_length)%n]]\n            )\n\n            new_cost = (\n                distance_matrix_1[new_solution[pos-1], segment[0]] +\n                distance_matrix_1[segment[-1], new_solution[(pos+segment_length)%n]],\n                distance_matrix_2[new_solution[pos-1], segment[0]] +\n                distance_matrix_2[segment[-1], new_solution[(pos+segment_length)%n]],\n                distance_matrix_3[new_solution[pos-1], segment[0]] +\n                distance_matrix_3[segment[-1], new_solution[(pos+segment_length)%n]]\n            )\n\n            # Calculate improvement across all objectives\n            improvement = sum(1 for nc, oc in zip(new_cost, old_cost) if nc < oc)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos is not None and best_pos != start:\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n            # Insert the segment at new position\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.7052261554979676,
            0.8622439861297607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.sum(objectives, axis=1)\n    diversity = np.std(objectives, axis=0)\n    combined_scores = scores - 0.5 * np.dot(objectives, diversity)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment relocation\n    for _ in range(5):\n        # Select a segment of random length\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find insertion position that improves at least one objective\n        best_pos = None\n        best_improvement = 0\n\n        for pos in range(0, n - segment_length + 1):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Calculate cost difference\n            old_cost = (\n                distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                distance_matrix_1[new_solution[start+segment_length-1], new_solution[(start+segment_length)%n]],\n                distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                distance_matrix_2[new_solution[start+segment_length-1], new_solution[(start+segment_length)%n]],\n                distance_matrix_3[new_solution[start-1], new_solution[start]] +\n                distance_matrix_3[new_solution[start+segment_length-1], new_solution[(start+segment_length)%n]]\n            )\n\n            new_cost = (\n                distance_matrix_1[new_solution[pos-1], segment[0]] +\n                distance_matrix_1[segment[-1], new_solution[(pos+segment_length)%n]],\n                distance_matrix_2[new_solution[pos-1], segment[0]] +\n                distance_matrix_2[segment[-1], new_solution[(pos+segment_length)%n]],\n                distance_matrix_3[new_solution[pos-1], segment[0]] +\n                distance_matrix_3[segment[-1], new_solution[(pos+segment_length)%n]]\n            )\n\n            # Calculate improvement across all objectives\n            improvement = sum(1 for nc, oc in zip(new_cost, old_cost) if nc < oc)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos is not None and best_pos != start:\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n            # Insert the segment at new position\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{This new algorithm employs a multi-objective crossover operator that combines path segments from multiple archive solutions with adaptive weighting based on Pareto dominance, followed by a biased edge refinement step that prioritizes edges with better individual objective improvements and incorporates a novel segment rotation mechanism to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: sum(x[1]))[:3]\n    sol1, sol2, sol3 = top_solutions[0][0], top_solutions[1][0], top_solutions[2][0]\n    n = len(sol1)\n\n    # Create new solution with adaptive segment selection\n    new_solution = []\n    weights = [0.5, 0.3, 0.2]  # Adaptive weights based on solution quality\n    for i in range(n):\n        r = np.random.random()\n        if r < weights[0]:\n            new_solution.append(sol1[i])\n        elif r < weights[0] + weights[1]:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply biased edge refinement with segment rotation\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Check for improvement in at least one objective\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment rotation\n            segment = new_solution[(i+1):(j+1)]\n            k = np.random.randint(1, len(segment))\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k:], segment[:k]])\n\n    return new_solution\n\n",
        "score": [
            -0.6516905339169812,
            0.19971615076065063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: sum(x[1]))[:3]\n    sol1, sol2, sol3 = top_solutions[0][0], top_solutions[1][0], top_solutions[2][0]\n    n = len(sol1)\n\n    # Create new solution with adaptive segment selection\n    new_solution = []\n    weights = [0.5, 0.3, 0.2]  # Adaptive weights based on solution quality\n    for i in range(n):\n        r = np.random.random()\n        if r < weights[0]:\n            new_solution.append(sol1[i])\n        elif r < weights[0] + weights[1]:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply biased edge refinement with segment rotation\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Check for improvement in at least one objective\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment rotation\n            segment = new_solution[(i+1):(j+1)]\n            k = np.random.randint(1, len(segment))\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k:], segment[:k]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{This algorithm employs a multi-objective segment insertion strategy that probabilistically selects and inserts path segments from the archive solutions into a base solution, with acceptance based on Pareto dominance in the objective space, followed by a novel three-objective-aware edge inversion step to refine the solution across all dimensions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_counts = []\n    for i, (sol1, obj1) in enumerate(archive):\n        count = 0\n        for sol2, obj2 in archive:\n            if all(o1 <= o2 for o1, o2 in zip(obj1, obj2)) and any(o1 < o2 for o1, o2 in zip(obj1, obj2)):\n                count += 1\n        dominance_counts.append(count)\n\n    if not dominance_counts:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        total = sum(dominance_counts)\n        if total == 0:\n            base_solution = random.choice(archive)[0].copy()\n        else:\n            probs = [count / total for count in dominance_counts]\n            base_solution = random.choices(archive, weights=probs)[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment insertion\n    for _ in range(3):\n        # Select a random segment from another archive solution\n        other_sol = random.choice(archive)[0]\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        segment = other_sol[start:end]\n\n        # Find insertion point that doesn't create duplicates\n        possible_positions = []\n        for i in range(n):\n            if new_solution[i] not in segment:\n                possible_positions.append(i)\n\n        if possible_positions:\n            insert_pos = random.choice(possible_positions)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n            # Remove duplicates while maintaining order\n            _, unique_indices = np.unique(new_solution, return_index=True)\n            new_solution = new_solution[np.sort(unique_indices)]\n\n    # Three-objective-aware edge inversion\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[j]],\n            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        )\n\n        # Accept if any individual objective improves or if total cost improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)) or sum(new_cost) < sum(old_cost):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7302447345772782,
            2.6150064706802367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_counts = []\n    for i, (sol1, obj1) in enumerate(archive):\n        count = 0\n        for sol2, obj2 in archive:\n            if all(o1 <= o2 for o1, o2 in zip(obj1, obj2)) and any(o1 < o2 for o1, o2 in zip(obj1, obj2)):\n                count += 1\n        dominance_counts.append(count)\n\n    if not dominance_counts:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        total = sum(dominance_counts)\n        if total == 0:\n            base_solution = random.choice(archive)[0].copy()\n        else:\n            probs = [count / total for count in dominance_counts]\n            base_solution = random.choices(archive, weights=probs)[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment insertion\n    for _ in range(3):\n        # Select a random segment from another archive solution\n        other_sol = random.choice(archive)[0]\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        segment = other_sol[start:end]\n\n        # Find insertion point that doesn't create duplicates\n        possible_positions = []\n        for i in range(n):\n            if new_solution[i] not in segment:\n                possible_positions.append(i)\n\n        if possible_positions:\n            insert_pos = random.choice(possible_positions)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n            # Remove duplicates while maintaining order\n            _, unique_indices = np.unique(new_solution, return_index=True)\n            new_solution = new_solution[np.sort(unique_indices)]\n\n    # Three-objective-aware edge inversion\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[j]],\n            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        )\n\n        # Accept if any individual objective improves or if total cost improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)) or sum(new_cost) < sum(old_cost):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{This new algorithm employs a multi-objective crossover operator that combines segments from two randomly selected archive solutions with a preference for solutions with better individual objective values, followed by a novel 3D edge refinement step that considers the combined improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Randomly select two solutions with preference for better objectives\n    weights = [1/(1 + sum(obj)) for _, obj in archive]\n    sol1, sol2 = random.choices([s for s, _ in archive], weights=weights, k=2)\n\n    n = len(sol1)\n    new_solution = np.zeros(n, dtype=int)\n\n    # Multi-objective crossover\n    for i in range(n):\n        obj1 = (distance_matrix_1[sol1[i], sol1[(i+1)%n]] + distance_matrix_2[sol1[i], sol1[(i+1)%n]] + distance_matrix_3[sol1[i], sol1[(i+1)%n]]) / 3\n        obj2 = (distance_matrix_1[sol2[i], sol2[(i+1)%n]] + distance_matrix_2[sol2[i], sol2[(i+1)%n]] + distance_matrix_3[sol2[i], sol2[(i+1)%n]]) / 3\n\n        if obj1 < obj2:\n            new_solution[i] = sol1[i]\n        else:\n            new_solution[i] = sol2[i]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = list(set(range(n)) - set(unique_nodes))\n        for i, node in enumerate(missing_nodes):\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # 3D edge refinement\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if combined improvement is positive\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5804376208451798,
            0.2630734443664551
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Randomly select two solutions with preference for better objectives\n    weights = [1/(1 + sum(obj)) for _, obj in archive]\n    sol1, sol2 = random.choices([s for s, _ in archive], weights=weights, k=2)\n\n    n = len(sol1)\n    new_solution = np.zeros(n, dtype=int)\n\n    # Multi-objective crossover\n    for i in range(n):\n        obj1 = (distance_matrix_1[sol1[i], sol1[(i+1)%n]] + distance_matrix_2[sol1[i], sol1[(i+1)%n]] + distance_matrix_3[sol1[i], sol1[(i+1)%n]]) / 3\n        obj2 = (distance_matrix_1[sol2[i], sol2[(i+1)%n]] + distance_matrix_2[sol2[i], sol2[(i+1)%n]] + distance_matrix_3[sol2[i], sol2[(i+1)%n]]) / 3\n\n        if obj1 < obj2:\n            new_solution[i] = sol1[i]\n        else:\n            new_solution[i] = sol2[i]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = list(set(range(n)) - set(unique_nodes))\n        for i, node in enumerate(missing_nodes):\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # 3D edge refinement\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if combined improvement is positive\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that emphasizes objectives with higher variance, then applies a hybrid local search combining 2-opt with objective-aware edge swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware edge swapping\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7601271842401275,
            0.569593894481659
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware edge swapping\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive with the best combined objective value, then performs a multi-objective aware 2-opt swap that prioritizes improving at least one objective while maintaining feasibility, with additional node reinsertion steps to ensure all nodes are visited exactly once.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Accept if at least one objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{This new algorithm selects a solution from the archive with the best combined objective value, then performs a multi-objective aware 3-opt swap that prioritizes improving at least two objectives while maintaining feasibility, with additional node reinsertion steps to ensure all nodes are visited exactly once.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 3-opt\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[j]],\n             distance_matrix_2[new_solution[i], new_solution[j]],\n             distance_matrix_3[new_solution[i], new_solution[j]]),\n            (distance_matrix_1[new_solution[j], new_solution[k]],\n             distance_matrix_2[new_solution[j], new_solution[k]],\n             distance_matrix_3[new_solution[j], new_solution[k]]),\n            (distance_matrix_1[new_solution[k], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(i+1)%n]])\n        ]\n\n        # Count improvements across all objectives\n        improvements = [sum(nc < oc for nc, oc in zip(new_cost, old_cost))\n                       for new_cost, old_cost in zip(new_costs, old_costs)]\n\n        # Accept if at least two objectives improve in total\n        if sum(improvements) >= 2:\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment2, segment1])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6831941446233603,
            0.43944101333618163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 3-opt\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[j]],\n             distance_matrix_2[new_solution[i], new_solution[j]],\n             distance_matrix_3[new_solution[i], new_solution[j]]),\n            (distance_matrix_1[new_solution[j], new_solution[k]],\n             distance_matrix_2[new_solution[j], new_solution[k]],\n             distance_matrix_3[new_solution[j], new_solution[k]]),\n            (distance_matrix_1[new_solution[k], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(i+1)%n]])\n        ]\n\n        # Count improvements across all objectives\n        improvements = [sum(nc < oc for nc, oc in zip(new_cost, old_cost))\n                       for new_cost, old_cost in zip(new_costs, old_costs)]\n\n        # Accept if at least two objectives improve in total\n        if sum(improvements) >= 2:\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment2, segment1])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive with the best combined objective value, then performs a multi-objective aware 2-opt swap that prioritizes improving at least one objective while maintaining feasibility, with additional node reinsertion steps to ensure all nodes are visited exactly once.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Accept if at least one objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{This new algorithm selects a solution from the archive with the best balance across all three objectives, then performs a multi-objective-aware node relocation that intelligently moves nodes between segments while prioritizing improvement in the most underperforming objective, followed by a segment inversion step to further optimize the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective is most underperforming\n    current_costs = [sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))]\n    most_underperforming = current_costs.index(max(current_costs))\n\n    # Perform multi-objective-aware node relocation\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i == j:\n            continue\n\n        # Calculate cost change for the most underperforming objective\n        old_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[(i+1)%n]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[(i-1)%n], new_solution[i])\n\n        new_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[j]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[(i-1)%n], new_solution[(j+1)%n])\n\n        if new_cost < old_cost:\n            # Perform relocation\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = (j+1) % n\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Perform segment inversion for further optimization\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7936362470453648,
            0.4110574245452881
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective is most underperforming\n    current_costs = [sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))]\n    most_underperforming = current_costs.index(max(current_costs))\n\n    # Perform multi-objective-aware node relocation\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i == j:\n            continue\n\n        # Calculate cost change for the most underperforming objective\n        old_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[(i+1)%n]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[(i-1)%n], new_solution[i])\n\n        new_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[j]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[(i-1)%n], new_solution[(j+1)%n])\n\n        if new_cost < old_cost:\n            # Perform relocation\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = (j+1) % n\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Perform segment inversion for further optimization\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{This new algorithm employs a multi-objective crossover strategy that combines path segments from multiple archive solutions, followed by a dynamic objective-aware edge swapping mechanism that selectively replaces edges based on their potential to improve the worst-performing objective, while maintaining feasibility through a novel segment merging and reversal process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = [sol for sol, _ in sorted(archive, key=lambda x: sum(x[1]))[:3]]\n    n = len(top_solutions[0])\n\n    # Create a new solution by alternating segments from top solutions\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(top_solutions[0][i])\n        elif i % 3 == 1:\n            new_solution.append(top_solutions[1][i])\n        else:\n            new_solution.append(top_solutions[2][i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Dynamic objective-aware edge swapping\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential costs\n        current_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        potential_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[j]],\n             distance_matrix_2[new_solution[i], new_solution[j]],\n             distance_matrix_3[new_solution[i], new_solution[j]]),\n            (distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n        ]\n\n        # Calculate improvements for each objective\n        improvements = [\n            [pot - curr for pot, curr in zip(pot, curr)]\n            for pot, curr in zip(potential_costs, current_costs)\n        ]\n\n        # Find the objective with the worst performance\n        worst_obj = np.argmax([sum(curr) for curr in current_costs])\n\n        # Perform swap if it improves the worst objective\n        if improvements[0][worst_obj] < 0 or improvements[1][worst_obj] < 0:\n            new_solution[i+1], new_solution[j+1] = new_solution[j+1], new_solution[i+1]\n\n    # Segment merging and reversal\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate segment costs\n        segment_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        # Find the segment with the worst performance\n        worst_seg = np.argmax([sum(cost) for cost in segment_costs])\n\n        # Reverse the worst segment\n        if worst_seg == 0:\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif worst_seg == 1:\n            new_solution[(j+1):(k+1)] = new_solution[(j+1):(k+1)][::-1]\n        else:\n            segment = new_solution[(i+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment[(k-i)//2:], segment[:(k-i)//2]])\n\n    return new_solution\n\n",
        "score": [
            -0.7074729118886786,
            0.2871219992637634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = [sol for sol, _ in sorted(archive, key=lambda x: sum(x[1]))[:3]]\n    n = len(top_solutions[0])\n\n    # Create a new solution by alternating segments from top solutions\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(top_solutions[0][i])\n        elif i % 3 == 1:\n            new_solution.append(top_solutions[1][i])\n        else:\n            new_solution.append(top_solutions[2][i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Dynamic objective-aware edge swapping\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential costs\n        current_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        potential_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[j]],\n             distance_matrix_2[new_solution[i], new_solution[j]],\n             distance_matrix_3[new_solution[i], new_solution[j]]),\n            (distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n        ]\n\n        # Calculate improvements for each objective\n        improvements = [\n            [pot - curr for pot, curr in zip(pot, curr)]\n            for pot, curr in zip(potential_costs, current_costs)\n        ]\n\n        # Find the objective with the worst performance\n        worst_obj = np.argmax([sum(curr) for curr in current_costs])\n\n        # Perform swap if it improves the worst objective\n        if improvements[0][worst_obj] < 0 or improvements[1][worst_obj] < 0:\n            new_solution[i+1], new_solution[j+1] = new_solution[j+1], new_solution[i+1]\n\n    # Segment merging and reversal\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate segment costs\n        segment_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        # Find the segment with the worst performance\n        worst_seg = np.argmax([sum(cost) for cost in segment_costs])\n\n        # Reverse the worst segment\n        if worst_seg == 0:\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif worst_seg == 1:\n            new_solution[(j+1):(k+1)] = new_solution[(j+1):(k+1)][::-1]\n        else:\n            segment = new_solution[(i+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment[(k-i)//2:], segment[:(k-i)//2]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{This algorithm employs a multi-objective segment-swap operator that intelligently combines diverse segments from two randomly selected archive solutions while maintaining feasibility, followed by a Pareto-aware edge refinement process that prioritizes improvements across all three objectives using a weighted sum approach.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_sols = sorted(archive, key=lambda x: sum(x[1]))[:min(5, len(archive))]\n    sol1, sol2 = random.sample(selected_sols, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments from both solutions\n    new_solution = []\n    segment_length = max(2, n // 4)\n    for i in range(0, n, segment_length):\n        if random.random() < 0.5:\n            new_solution.extend(sol1[i:i+segment_length])\n        else:\n            new_solution.extend(sol2[i:i+segment_length])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply Pareto-aware edge refinement\n    for _ in range(10):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        obj_weights = np.random.dirichlet([1, 1, 1], 1)[0]\n\n        old_cost = (obj_weights[0] * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n                   obj_weights[1] * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n                   obj_weights[2] * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]))\n\n        new_cost = (obj_weights[0] * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]),\n                   obj_weights[1] * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]),\n                   obj_weights[2] * (distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]))\n\n        if sum(new_cost) < sum(old_cost):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5942907224597368,
            1.948035991191864
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_sols = sorted(archive, key=lambda x: sum(x[1]))[:min(5, len(archive))]\n    sol1, sol2 = random.sample(selected_sols, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments from both solutions\n    new_solution = []\n    segment_length = max(2, n // 4)\n    for i in range(0, n, segment_length):\n        if random.random() < 0.5:\n            new_solution.extend(sol1[i:i+segment_length])\n        else:\n            new_solution.extend(sol2[i:i+segment_length])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply Pareto-aware edge refinement\n    for _ in range(10):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        obj_weights = np.random.dirichlet([1, 1, 1], 1)[0]\n\n        old_cost = (obj_weights[0] * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]),\n                   obj_weights[1] * (distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]),\n                   obj_weights[2] * (distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]))\n\n        new_cost = (obj_weights[0] * (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]),\n                   obj_weights[1] * (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]),\n                   obj_weights[2] * (distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]))\n\n        if sum(new_cost) < sum(old_cost):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive with the best combined objective value, then performs a multi-objective aware 2-opt swap that prioritizes improving at least one objective while maintaining feasibility, with additional node reinsertion steps to ensure all nodes are visited exactly once.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Accept if at least one objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{This new algorithm selects a solution from the archive based on the most crowded objective space, then applies a novel multi-objective-aware segment reversal that prioritizes improving the most crowded objective while maintaining feasibility, followed by an adaptive node reordering step to balance all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    obj1 = [o[0] for o in objectives]\n    obj2 = [o[1] for o in objectives]\n    obj3 = [o[2] for o in objectives]\n\n    std1 = np.std(obj1)\n    std2 = np.std(obj2)\n    std3 = np.std(obj3)\n\n    if std1 >= std2 and std1 >= std3:\n        target_obj = 0\n    elif std2 >= std1 and std2 >= std3:\n        target_obj = 1\n    else:\n        target_obj = 2\n\n    selected_solution = min(archive, key=lambda x: x[1][target_obj])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware segment reversal\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        old_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[i-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], reversed_segment[0]] + distance_matrix_3[reversed_segment[-1], new_solution[(j+1)%n]]\n        )\n\n        if new_cost[target_obj] < old_cost[target_obj]:\n            new_solution[i:j+1] = reversed_segment\n\n    # Adaptive node reordering\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        current_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        swapped_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        )\n\n        if sum(swapped_cost) < sum(current_cost):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4044276406623818,
            2.261518716812134
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    obj1 = [o[0] for o in objectives]\n    obj2 = [o[1] for o in objectives]\n    obj3 = [o[2] for o in objectives]\n\n    std1 = np.std(obj1)\n    std2 = np.std(obj2)\n    std3 = np.std(obj3)\n\n    if std1 >= std2 and std1 >= std3:\n        target_obj = 0\n    elif std2 >= std1 and std2 >= std3:\n        target_obj = 1\n    else:\n        target_obj = 2\n\n    selected_solution = min(archive, key=lambda x: x[1][target_obj])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware segment reversal\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        old_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[i-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], reversed_segment[0]] + distance_matrix_3[reversed_segment[-1], new_solution[(j+1)%n]]\n        )\n\n        if new_cost[target_obj] < old_cost[target_obj]:\n            new_solution[i:j+1] = reversed_segment\n\n    # Adaptive node reordering\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        current_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        swapped_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        )\n\n        if sum(swapped_cost) < sum(current_cost):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This new algorithm employs a multi-objective crossover operator that combines segments from the top three solutions in the archive, with selection probabilities inversely proportional to their combined objective values, followed by an adaptive neighborhood exploration step that prioritizes edges with Pareto-improving potential and applies a dynamic segment reversal mechanism based on objective-specific improvement ratios.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_costs = [sum(obj) for _, obj in archive]\n    total_cost = sum(combined_costs)\n    probabilities = [1 - (cost / total_cost) for cost in combined_costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    selected_indices = np.random.choice(len(archive), size=3, replace=False, p=probabilities)\n    sol1, sol2, sol3 = archive[selected_indices[0]][0], archive[selected_indices[1]][0], archive[selected_indices[2]][0]\n\n    n = len(sol1)\n    new_solution = []\n\n    # Multi-objective crossover with dynamic segment selection\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        elif i % 3 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Adaptive neighborhood exploration\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        ]\n\n        # Calculate improvement ratios for each objective\n        improvements = [old - new for old, new in zip(old_costs, new_costs)]\n        improvement_ratios = [imp / old if old > 0 else 0 for imp, old in zip(improvements, old_costs)]\n\n        # Apply segment reversal if any objective shows significant improvement\n        if any(ratio > 0.1 for ratio in improvement_ratios):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.652247409564933,
            0.7518951296806335
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_costs = [sum(obj) for _, obj in archive]\n    total_cost = sum(combined_costs)\n    probabilities = [1 - (cost / total_cost) for cost in combined_costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    selected_indices = np.random.choice(len(archive), size=3, replace=False, p=probabilities)\n    sol1, sol2, sol3 = archive[selected_indices[0]][0], archive[selected_indices[1]][0], archive[selected_indices[2]][0]\n\n    n = len(sol1)\n    new_solution = []\n\n    # Multi-objective crossover with dynamic segment selection\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        elif i % 3 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Adaptive neighborhood exploration\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        ]\n\n        # Calculate improvement ratios for each objective\n        improvements = [old - new for old, new in zip(old_costs, new_costs)]\n        improvement_ratios = [imp / old if old > 0 else 0 for imp, old in zip(improvements, old_costs)]\n\n        # Apply segment reversal if any objective shows significant improvement\n        if any(ratio > 0.1 for ratio in improvement_ratios):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive with the best combined objective value, then performs a multi-objective aware 2-opt swap that prioritizes improving at least one objective while maintaining feasibility, with additional node reinsertion steps to ensure all nodes are visited exactly once.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Accept if at least one objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This new algorithm selects a solution from the archive with the best hypervolume contribution, then performs a multi-objective aware 3-opt swap that prioritizes improving multiple objectives while maintaining feasibility, with additional node reinsertion steps to ensure all nodes are visited exactly once.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = max(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 3-opt\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[j]],\n             distance_matrix_2[new_solution[i], new_solution[j]],\n             distance_matrix_3[new_solution[i], new_solution[j]]),\n            (distance_matrix_1[new_solution[j], new_solution[k]],\n             distance_matrix_2[new_solution[j], new_solution[k]],\n             distance_matrix_3[new_solution[j], new_solution[k]])\n        ]\n\n        # Accept if at least two objectives improve\n        if sum(sum(nc < oc for nc, oc in zip(new_cost, old_cost)) for new_cost, old_cost in zip(new_costs, old_costs)) >= 2:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n            segment = new_solution[(j+1):(k+1)]\n            new_solution[(j+1):(k+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.663000847976774,
            0.4191861867904663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = max(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 3-opt\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[j]],\n             distance_matrix_2[new_solution[i], new_solution[j]],\n             distance_matrix_3[new_solution[i], new_solution[j]]),\n            (distance_matrix_1[new_solution[j], new_solution[k]],\n             distance_matrix_2[new_solution[j], new_solution[k]],\n             distance_matrix_3[new_solution[j], new_solution[k]])\n        ]\n\n        # Accept if at least two objectives improve\n        if sum(sum(nc < oc for nc, oc in zip(new_cost, old_cost)) for new_cost, old_cost in zip(new_costs, old_costs)) >= 2:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n            segment = new_solution[(j+1):(k+1)]\n            new_solution[(j+1):(k+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a diversity-aware selection mechanism that prioritizes solutions with high objective diversity, then applies a novel segment-based local search that combines elements of both 2-opt and 3-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores * objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based hybrid local search\n    n = len(new_solution)\n    segment_length = max(2, min(5, n // 5))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    # Try both 2-opt and 3-opt moves on the selected segment\n    for _ in range(2):\n        if np.random.rand() < 0.5:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(range(start, end), 3, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) + edge_cost(new_solution[c], new_solution[(c+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) + edge_cost(new_solution[c], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                new_solution[(a+1):(c+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto-frontier proximity score that emphasizes solutions with balanced objective values, then applies a novel edge-swapping local search that combines both 2-opt and 4-opt moves while incorporating objective-aware edge selection to balance improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    balance_scores = np.std(normalized, axis=1)\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_length = max(3, min(7, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    for _ in range(3):\n        if np.random.rand() < 0.4:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 4-opt move\n            a, b, c, d = sorted(np.random.choice(range(start, end), 4, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) +\n                          edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) +\n                          edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                segment3 = new_solution[(c+1):(d+1)]\n                new_solution[(a+1):(d+1)] = np.concatenate([segment3[::-1], segment2, segment1[::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.6058362887298154,
            1.7027657985687257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    balance_scores = np.std(normalized, axis=1)\n    selected_idx = np.argmax(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_length = max(3, min(7, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    for _ in range(3):\n        if np.random.rand() < 0.4:\n            # 2-opt move\n            i, j = sorted(np.random.choice(range(start, end), 2, replace=False))\n            old_cost = sum(edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]))\n            new_cost = sum(edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]))\n\n            if new_cost < old_cost:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n        else:\n            # 4-opt move\n            a, b, c, d = sorted(np.random.choice(range(start, end), 4, replace=False))\n            old_cost = sum(edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n]) +\n                          edge_cost(new_solution[c], new_solution[(c+1)%n]) + edge_cost(new_solution[d], new_solution[(d+1)%n]))\n            new_cost = sum(edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[b], new_solution[c]) +\n                          edge_cost(new_solution[c], new_solution[d]) + edge_cost(new_solution[d], new_solution[(a+1)%n]))\n\n            if new_cost < old_cost:\n                segment1 = new_solution[(a+1):(b+1)]\n                segment2 = new_solution[(b+1):(c+1)]\n                segment3 = new_solution[(c+1):(d+1)]\n                new_solution[(a+1):(d+1)] = np.concatenate([segment3[::-1], segment2, segment1[::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This new algorithm prioritizes solutions with diverse objective values by selecting a base solution based on a dynamic trade-off between objective improvements and spatial diversity, then applies a hybrid local search combining adaptive 2.5-opt with objective-weighted node relocation to generate a neighbor solution that balances multi-objective progress and solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    weights = objective_ranges / np.sum(objective_ranges) if np.sum(objective_ranges) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) + np.linalg.norm(instance[np.argsort(sol)[0]] - instance[np.argsort(sol)[-1]])\n              for sol, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive 2.5-opt with objective-weighted edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j])\n        new_cost2 = edge_cost(new_solution[j], new_solution[(j+1)%n])\n\n        weighted_old = sum(w * c for w, c in zip(weights, old_cost))\n        weighted_new = sum(w * c for w, c in zip(weights, new_cost1)) + sum(w * c for w, c in zip(weights, new_cost2))\n\n        if weighted_new < weighted_old:\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Objective-weighted node relocation\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (sum(w * distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] for w in weights),\n                    sum(w * distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] for w in weights),\n                    sum(w * distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] for w in weights))\n        new_cost = (sum(w * distance_matrix_1[new_solution[node], new_solution[pos]] for w in weights),\n                    sum(w * distance_matrix_2[new_solution[node], new_solution[pos]] for w in weights),\n                    sum(w * distance_matrix_3[new_solution[node], new_solution[pos]] for w in weights))\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.7802939765709827,
            1.3888121843338013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    weights = objective_ranges / np.sum(objective_ranges) if np.sum(objective_ranges) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) + np.linalg.norm(instance[np.argsort(sol)[0]] - instance[np.argsort(sol)[-1]])\n              for sol, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive 2.5-opt with objective-weighted edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j])\n        new_cost2 = edge_cost(new_solution[j], new_solution[(j+1)%n])\n\n        weighted_old = sum(w * c for w, c in zip(weights, old_cost))\n        weighted_new = sum(w * c for w, c in zip(weights, new_cost1)) + sum(w * c for w, c in zip(weights, new_cost2))\n\n        if weighted_new < weighted_old:\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Objective-weighted node relocation\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (sum(w * distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] for w in weights),\n                    sum(w * distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] for w in weights),\n                    sum(w * distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] for w in weights))\n        new_cost = (sum(w * distance_matrix_1[new_solution[node], new_solution[pos]] for w in weights),\n                    sum(w * distance_matrix_2[new_solution[node], new_solution[pos]] for w in weights),\n                    sum(w * distance_matrix_3[new_solution[node], new_solution[pos]] for w in weights))\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic crowding distance metric that identifies solutions in less crowded regions of the objective space, then applies a hybrid local search combining a novel \"objective-aware swap chain\" operator with a multi-objective edge insertion mechanism to generate a neighbor solution, ensuring feasibility and potential improvement across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for obj_idx in range(3):\n        sorted_idx = np.argsort(objectives[:, obj_idx])\n        sorted_obj = objectives[sorted_idx, obj_idx]\n        crowding_distances[sorted_idx[1:-1]] += (sorted_obj[2:] - sorted_obj[:-2]) / (sorted_obj[-1] - sorted_obj[0] + 1e-8)\n\n    # Select solution with highest crowding distance (least crowded region)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply objective-aware swap chain operator\n    for _ in range(3):\n        chain_length = np.random.randint(2, 5)\n        nodes = np.random.choice(n, chain_length, replace=False)\n        nodes = sorted(nodes)\n\n        # Calculate current and potential costs\n        current_cost = [0, 0, 0]\n        for i in range(chain_length):\n            node_idx = nodes[i]\n            next_idx = nodes[(i+1)%chain_length]\n            current_cost[0] += distance_matrix_1[new_solution[node_idx], new_solution[next_idx]]\n            current_cost[1] += distance_matrix_2[new_solution[node_idx], new_solution[next_idx]]\n            current_cost[2] += distance_matrix_3[new_solution[node_idx], new_solution[next_idx]]\n\n        # Try different permutations of the chain\n        best_perm = nodes\n        best_cost = current_cost\n        for _ in range(3):\n            perm = nodes.copy()\n            np.random.shuffle(perm)\n            perm_cost = [0, 0, 0]\n            for i in range(chain_length):\n                node_idx = perm[i]\n                next_idx = perm[(i+1)%chain_length]\n                perm_cost[0] += distance_matrix_1[new_solution[node_idx], new_solution[next_idx]]\n                perm_cost[1] += distance_matrix_2[new_solution[node_idx], new_solution[next_idx]]\n                perm_cost[2] += distance_matrix_3[new_solution[node_idx], new_solution[next_idx]]\n\n            if sum(perm_cost) < sum(best_cost):\n                best_perm = perm\n                best_cost = perm_cost\n\n        # Apply the best permutation if it improves any objective\n        if any(bc < cc for bc, cc in zip(best_cost, current_cost)):\n            for i in range(chain_length):\n                new_solution[nodes[i]] = base_solution[best_perm[i]]\n\n    # Apply multi-objective edge insertion\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform edge insertion\n            if i > j:\n                i, j = j, i\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7346184022641944,
            0.5179571747779846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for obj_idx in range(3):\n        sorted_idx = np.argsort(objectives[:, obj_idx])\n        sorted_obj = objectives[sorted_idx, obj_idx]\n        crowding_distances[sorted_idx[1:-1]] += (sorted_obj[2:] - sorted_obj[:-2]) / (sorted_obj[-1] - sorted_obj[0] + 1e-8)\n\n    # Select solution with highest crowding distance (least crowded region)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply objective-aware swap chain operator\n    for _ in range(3):\n        chain_length = np.random.randint(2, 5)\n        nodes = np.random.choice(n, chain_length, replace=False)\n        nodes = sorted(nodes)\n\n        # Calculate current and potential costs\n        current_cost = [0, 0, 0]\n        for i in range(chain_length):\n            node_idx = nodes[i]\n            next_idx = nodes[(i+1)%chain_length]\n            current_cost[0] += distance_matrix_1[new_solution[node_idx], new_solution[next_idx]]\n            current_cost[1] += distance_matrix_2[new_solution[node_idx], new_solution[next_idx]]\n            current_cost[2] += distance_matrix_3[new_solution[node_idx], new_solution[next_idx]]\n\n        # Try different permutations of the chain\n        best_perm = nodes\n        best_cost = current_cost\n        for _ in range(3):\n            perm = nodes.copy()\n            np.random.shuffle(perm)\n            perm_cost = [0, 0, 0]\n            for i in range(chain_length):\n                node_idx = perm[i]\n                next_idx = perm[(i+1)%chain_length]\n                perm_cost[0] += distance_matrix_1[new_solution[node_idx], new_solution[next_idx]]\n                perm_cost[1] += distance_matrix_2[new_solution[node_idx], new_solution[next_idx]]\n                perm_cost[2] += distance_matrix_3[new_solution[node_idx], new_solution[next_idx]]\n\n            if sum(perm_cost) < sum(best_cost):\n                best_perm = perm\n                best_cost = perm_cost\n\n        # Apply the best permutation if it improves any objective\n        if any(bc < cc for bc, cc in zip(best_cost, current_cost)):\n            for i in range(chain_length):\n                new_solution[nodes[i]] = base_solution[best_perm[i]]\n\n    # Apply multi-objective edge insertion\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform edge insertion\n            if i > j:\n                i, j = j, i\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive with the best combined objective value, then performs a multi-objective aware 2-opt swap that prioritizes improving at least one objective while maintaining feasibility, with additional node reinsertion steps to ensure all nodes are visited exactly once.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Accept if at least one objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto-frontier dominance score that considers both objective values and their diversity, then applies a multi-segment inversion strategy that adaptively selects segments to invert based on their potential for multi-objective improvement, while maintaining feasibility through a node reinsertion mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        dominates = 0\n        for j in range(len(archive)):\n            if i != j and all(objectives[i][k] <= objectives[j][k] for k in range(3)) and any(objectives[i][k] < objectives[j][k] for k in range(3)):\n                dominates += 1\n        dominance_scores[i] = dominates\n\n    # Select solution with highest dominance score (or random if tied)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion strategy\n    for _ in range(4):\n        # Select multiple segments to invert\n        num_segments = np.random.randint(1, 4)\n        segments = []\n        for _ in range(num_segments):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segments.append((i, j))\n\n        # Evaluate potential improvement\n        old_costs = []\n        new_costs = []\n        for i, j in segments:\n            old_costs.append((\n                distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n            ))\n            new_costs.append((\n                distance_matrix_1[new_solution[i], new_solution[j]],\n                distance_matrix_2[new_solution[i], new_solution[j]],\n                distance_matrix_3[new_solution[i], new_solution[j]]\n            ))\n\n        # Accept if at least one objective improves in any segment\n        if any(any(nc < oc for nc, oc in zip(new_cost, old_cost)) for new_cost, old_cost in zip(new_costs, old_costs)):\n            for i, j in segments:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6838893949778787,
            2.951138210296631
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        dominates = 0\n        for j in range(len(archive)):\n            if i != j and all(objectives[i][k] <= objectives[j][k] for k in range(3)) and any(objectives[i][k] < objectives[j][k] for k in range(3)):\n                dominates += 1\n        dominance_scores[i] = dominates\n\n    # Select solution with highest dominance score (or random if tied)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion strategy\n    for _ in range(4):\n        # Select multiple segments to invert\n        num_segments = np.random.randint(1, 4)\n        segments = []\n        for _ in range(num_segments):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segments.append((i, j))\n\n        # Evaluate potential improvement\n        old_costs = []\n        new_costs = []\n        for i, j in segments:\n            old_costs.append((\n                distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n            ))\n            new_costs.append((\n                distance_matrix_1[new_solution[i], new_solution[j]],\n                distance_matrix_2[new_solution[i], new_solution[j]],\n                distance_matrix_3[new_solution[i], new_solution[j]]\n            ))\n\n        # Accept if at least one objective improves in any segment\n        if any(any(nc < oc for nc, oc in zip(new_cost, old_cost)) for new_cost, old_cost in zip(new_costs, old_costs)):\n            for i, j in segments:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive with the best balance across all three objectives, then performs a multi-objective-aware node relocation that intelligently moves nodes between segments while prioritizing improvement in the most underperforming objective, followed by a segment inversion step to further optimize the tour structure.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective is most underperforming\n    current_costs = [sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))]\n    most_underperforming = current_costs.index(max(current_costs))\n\n    # Perform multi-objective-aware node relocation\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i == j:\n            continue\n\n        # Calculate cost change for the most underperforming objective\n        old_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[(i+1)%n]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[(i-1)%n], new_solution[i])\n\n        new_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[j]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[(i-1)%n], new_solution[(j+1)%n])\n\n        if new_cost < old_cost:\n            # Perform relocation\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = (j+1) % n\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Perform segment inversion for further optimization\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{This new algorithm selects a solution from the archive with the best balance across all three objectives, then performs a hybrid local search combining multi-objective-aware 2-opt moves with objective-specific edge swaps to simultaneously improve multiple objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective is most underperforming\n    current_costs = [sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))]\n    most_underperforming = current_costs.index(max(current_costs))\n\n    # Hybrid local search: 2-opt moves combined with objective-specific edge swaps\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if (j - i) <= 1:\n            continue\n\n        # 2-opt move\n        segment = new_solution[i:j]\n        new_solution[i:j] = segment[::-1]\n\n        # Objective-specific edge swap\n        if most_underperforming == 0:\n            swap_matrix = distance_matrix_1\n        elif most_underperforming == 1:\n            swap_matrix = distance_matrix_2\n        else:\n            swap_matrix = distance_matrix_3\n\n        for k in range(i, j):\n            if swap_matrix[new_solution[k], new_solution[(k+1)%n]] > swap_matrix[new_solution[k], new_solution[(k+2)%n]]:\n                new_solution[k+1], new_solution[(k+2)%n] = new_solution[(k+2)%n], new_solution[k+1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7589815185945292,
            0.43523249626159666
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective is most underperforming\n    current_costs = [sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))]\n    most_underperforming = current_costs.index(max(current_costs))\n\n    # Hybrid local search: 2-opt moves combined with objective-specific edge swaps\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if (j - i) <= 1:\n            continue\n\n        # 2-opt move\n        segment = new_solution[i:j]\n        new_solution[i:j] = segment[::-1]\n\n        # Objective-specific edge swap\n        if most_underperforming == 0:\n            swap_matrix = distance_matrix_1\n        elif most_underperforming == 1:\n            swap_matrix = distance_matrix_2\n        else:\n            swap_matrix = distance_matrix_3\n\n        for k in range(i, j):\n            if swap_matrix[new_solution[k], new_solution[(k+1)%n]] > swap_matrix[new_solution[k], new_solution[(k+2)%n]]:\n                new_solution[k+1], new_solution[(k+2)%n] = new_solution[(k+2)%n], new_solution[k+1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{This new algorithm employs a multi-objective path relinking operator that blends segments from two archive solutions while maintaining feasibility, followed by a dominance-aware edge replacement step that selectively swaps edges based on their potential to improve the Pareto front across all three objectives, using a weighted sum of normalized objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = random.choice(archive)[0].copy()\n    n = len(base_solution)\n\n    # Generate a target solution by blending segments from two random archive solutions\n    target1, target2 = random.sample(archive, 2)\n    target1, target2 = target1[0], target2[0]\n\n    # Create a new solution by alternating segments from target solutions\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(target1[i])\n        else:\n            new_solution.append(target2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply dominance-aware edge replacement\n    for _ in range(10):  # Perform 10 replacement steps\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        potential_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                          distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement\n        improvement = (current_cost[0] - potential_cost[0]) + (current_cost[1] - potential_cost[1])\n\n        if improvement > 0:\n            # Perform edge replacement\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7372251740961039,
            0.15679270029067993
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = random.choice(archive)[0].copy()\n    n = len(base_solution)\n\n    # Generate a target solution by blending segments from two random archive solutions\n    target1, target2 = random.sample(archive, 2)\n    target1, target2 = target1[0], target2[0]\n\n    # Create a new solution by alternating segments from target solutions\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(target1[i])\n        else:\n            new_solution.append(target2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply dominance-aware edge replacement\n    for _ in range(10):  # Perform 10 replacement steps\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        potential_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                          distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement\n        improvement = (current_cost[0] - potential_cost[0]) + (current_cost[1] - potential_cost[1])\n\n        if improvement > 0:\n            # Perform edge replacement\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware metric that combines objective values and solution structure, then applies a novel segment-based crossover with objective-aware segment selection and subsequent multi-objective edge refinement using adaptive weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, obj in archive:\n        # Calculate diversity as combination of objective values and solution structure\n        obj_diversity = np.std([o for o in obj])\n        struct_diversity = len(set(sol[:len(sol)//2]) & set(sol[len(sol)//2:]))\n        diversity_scores.append(obj_diversity + struct_diversity)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment-based crossover with objective-aware segment selection\n    segments = []\n    for _ in range(3):\n        start = np.random.randint(0, n)\n        length = np.random.randint(2, n//2)\n        end = (start + length) % n\n        segment = new_solution[start:end] if start < end else np.concatenate([new_solution[start:], new_solution[:end]])\n\n        # Calculate segment quality based on objective improvements\n        segment_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        segment_cost += sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        segment_cost += sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        segments.append((segment, segment_cost))\n\n    # Select best segments and combine them\n    segments.sort(key=lambda x: x[1])\n    selected_segments = [seg[0] for seg in segments[:2]]\n\n    # Create new solution by alternating between selected segments\n    combined = []\n    for i in range(max(len(selected_segments[0]), len(selected_segments[1]))):\n        if i < len(selected_segments[0]):\n            combined.append(selected_segments[0][i])\n        if i < len(selected_segments[1]):\n            combined.append(selected_segments[1][i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(combined)\n    missing_nodes = set(range(n)) - set(unique_nodes)\n    for node in missing_nodes:\n        insert_pos = np.random.randint(0, len(combined))\n        combined.insert(insert_pos, node)\n\n    new_solution = np.array(combined[:n])\n\n    # Apply multi-objective edge refinement with adaptive weights\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential costs across all objectives\n        old_costs = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        new_costs = (\n            distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        )\n\n        # Calculate adaptive weights based on current objective values\n        weights = np.array([1.0, 1.0, 1.0])\n        if archive[selected_idx][1][0] > archive[selected_idx][1][1] > archive[selected_idx][1][2]:\n            weights = np.array([0.6, 0.3, 0.1])\n        elif archive[selected_idx][1][1] > archive[selected_idx][1][0] > archive[selected_idx][1][2]:\n            weights = np.array([0.3, 0.6, 0.1])\n        else:\n            weights = np.array([0.3, 0.1, 0.6])\n\n        # Calculate weighted improvement\n        improvement = sum((old - new) * w for old, new, w in zip(old_costs, new_costs, weights))\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7966195142925606,
            1.0661648750305175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, obj in archive:\n        # Calculate diversity as combination of objective values and solution structure\n        obj_diversity = np.std([o for o in obj])\n        struct_diversity = len(set(sol[:len(sol)//2]) & set(sol[len(sol)//2:]))\n        diversity_scores.append(obj_diversity + struct_diversity)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment-based crossover with objective-aware segment selection\n    segments = []\n    for _ in range(3):\n        start = np.random.randint(0, n)\n        length = np.random.randint(2, n//2)\n        end = (start + length) % n\n        segment = new_solution[start:end] if start < end else np.concatenate([new_solution[start:], new_solution[:end]])\n\n        # Calculate segment quality based on objective improvements\n        segment_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        segment_cost += sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        segment_cost += sum(distance_matrix_3[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        segments.append((segment, segment_cost))\n\n    # Select best segments and combine them\n    segments.sort(key=lambda x: x[1])\n    selected_segments = [seg[0] for seg in segments[:2]]\n\n    # Create new solution by alternating between selected segments\n    combined = []\n    for i in range(max(len(selected_segments[0]), len(selected_segments[1]))):\n        if i < len(selected_segments[0]):\n            combined.append(selected_segments[0][i])\n        if i < len(selected_segments[1]):\n            combined.append(selected_segments[1][i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(combined)\n    missing_nodes = set(range(n)) - set(unique_nodes)\n    for node in missing_nodes:\n        insert_pos = np.random.randint(0, len(combined))\n        combined.insert(insert_pos, node)\n\n    new_solution = np.array(combined[:n])\n\n    # Apply multi-objective edge refinement with adaptive weights\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate current and potential costs across all objectives\n        old_costs = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        new_costs = (\n            distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        )\n\n        # Calculate adaptive weights based on current objective values\n        weights = np.array([1.0, 1.0, 1.0])\n        if archive[selected_idx][1][0] > archive[selected_idx][1][1] > archive[selected_idx][1][2]:\n            weights = np.array([0.6, 0.3, 0.1])\n        elif archive[selected_idx][1][1] > archive[selected_idx][1][0] > archive[selected_idx][1][2]:\n            weights = np.array([0.3, 0.6, 0.1])\n        else:\n            weights = np.array([0.3, 0.1, 0.6])\n\n        # Calculate weighted improvement\n        improvement = sum((old - new) * w for old, new, w in zip(old_costs, new_costs, weights))\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining objective-aware edge flipping with multi-objective node swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[(a-1)%n], new_solution[a]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[(a-1)%n], new_solution[b]) + edge_cost(new_solution[a], new_solution[(b+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[a:(b+1)]\n            new_solution[a:(b+1)] = segment[::-1]\n\n    for _ in range(3):\n        i, j = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_3[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_3[new_solution[j], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6653489174712666,
            0.5501634359359742
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[(a-1)%n], new_solution[a]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[(a-1)%n], new_solution[b]) + edge_cost(new_solution[a], new_solution[(b+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[a:(b+1)]\n            new_solution[a:(b+1)] = segment[::-1]\n\n    for _ in range(3):\n        i, j = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i-1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_3[new_solution[j], new_solution[(j-1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_3[new_solution[j], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{This novel algorithm employs a multi-objective-aware segment recombination strategy that combines path segments from top-performing solutions in each objective space, followed by an adaptive edge refinement process that prioritizes edges with Pareto-improving potential and incorporates a dynamic segment reversal mechanism to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_by_obj1 = sorted(archive, key=lambda x: x[1][0])\n    sorted_by_obj2 = sorted(archive, key=lambda x: x[1][1])\n    sorted_by_obj3 = sorted(archive, key=lambda x: x[1][2])\n\n    # Select top solutions from each objective perspective\n    sol1 = sorted_by_obj1[0][0]\n    sol2 = sorted_by_obj2[0][0]\n    sol3 = sorted_by_obj3[0][0]\n\n    n = len(sol1)\n    new_solution = []\n\n    # Combine segments with adaptive weighting based on objective performance\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        elif i % 3 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Adaptive edge refinement with dynamic segment reversal\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_edges = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        # Check for Pareto improvement potential\n        if (old_edges[0][0] > distance_matrix_1[new_solution[i], new_solution[j]] or\n            old_edges[0][1] > distance_matrix_2[new_solution[i], new_solution[j]] or\n            old_edges[0][2] > distance_matrix_3[new_solution[i], new_solution[j]]):\n\n            # Perform dynamic segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6833649741329484,
            0.21159837245941163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_by_obj1 = sorted(archive, key=lambda x: x[1][0])\n    sorted_by_obj2 = sorted(archive, key=lambda x: x[1][1])\n    sorted_by_obj3 = sorted(archive, key=lambda x: x[1][2])\n\n    # Select top solutions from each objective perspective\n    sol1 = sorted_by_obj1[0][0]\n    sol2 = sorted_by_obj2[0][0]\n    sol3 = sorted_by_obj3[0][0]\n\n    n = len(sol1)\n    new_solution = []\n\n    # Combine segments with adaptive weighting based on objective performance\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        elif i % 3 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Adaptive edge refinement with dynamic segment reversal\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_edges = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        # Check for Pareto improvement potential\n        if (old_edges[0][0] > distance_matrix_1[new_solution[i], new_solution[j]] or\n            old_edges[0][1] > distance_matrix_2[new_solution[i], new_solution[j]] or\n            old_edges[0][2] > distance_matrix_3[new_solution[i], new_solution[j]]):\n\n            # Perform dynamic segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements, while also incorporating a novel adaptive segment selection mechanism based on objective diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Select solutions with diverse objectives\n    obj_weights = np.array([sum(obj) for _, obj in archive])\n    probs = np.exp(-obj_weights / np.max(obj_weights))\n    probs /= probs.sum()\n    idx1, idx2 = np.random.choice(len(archive), size=2, p=probs, replace=False)\n    sol1, sol2 = archive[idx1][0], archive[idx2][0]\n    n = len(sol1)\n\n    # Create new solution with adaptive segment selection\n    new_solution = []\n    obj1, obj2 = archive[idx1][1], archive[idx2][1]\n    for i in range(n):\n        if i % 4 == 0 or (obj1[0] < obj2[0] and i % 2 == 0) or (obj1[1] < obj2[1] and i % 3 == 0):\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with adaptive selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check for improvement in at least two objectives\n        if sum(nc < oc for nc, oc in zip(new_cost, old_cost)) >= 2:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7066181889362297,
            0.24297146797180175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Select solutions with diverse objectives\n    obj_weights = np.array([sum(obj) for _, obj in archive])\n    probs = np.exp(-obj_weights / np.max(obj_weights))\n    probs /= probs.sum()\n    idx1, idx2 = np.random.choice(len(archive), size=2, p=probs, replace=False)\n    sol1, sol2 = archive[idx1][0], archive[idx2][0]\n    n = len(sol1)\n\n    # Create new solution with adaptive segment selection\n    new_solution = []\n    obj1, obj2 = archive[idx1][1], archive[idx2][1]\n    for i in range(n):\n        if i % 4 == 0 or (obj1[0] < obj2[0] and i % 2 == 0) or (obj1[1] < obj2[1] and i % 3 == 0):\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with adaptive selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check for improvement in at least two objectives\n        if sum(nc < oc for nc, oc in zip(new_cost, old_cost)) >= 2:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive with the best combined objective value, then performs a multi-objective aware 2-opt swap that prioritizes improving at least one objective while maintaining feasibility, with additional node reinsertion steps to ensure all nodes are visited exactly once.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Accept if at least one objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{This new algorithm employs a multi-objective path relinking strategy that combines segments from two solutions while prioritizing nodes that show the most significant improvement in at least one objective, followed by a dynamic perturbation step to escape local optima while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Identify nodes that show significant improvement in at least one objective\n    improvement_nodes = set()\n    for node in range(n):\n        if node in sol1 and node in sol2:\n            pos1 = np.where(sol1 == node)[0][0]\n            pos2 = np.where(sol2 == node)[0][0]\n            cost1 = (distance_matrix_1[sol1[pos1-1], sol1[pos1]] +\n                    distance_matrix_2[sol1[pos1-1], sol1[pos1]] +\n                    distance_matrix_3[sol1[pos1-1], sol1[pos1]])\n            cost2 = (distance_matrix_1[sol2[pos2-1], sol2[pos2]] +\n                    distance_matrix_2[sol2[pos2-1], sol2[pos2]] +\n                    distance_matrix_3[sol2[pos2-1], sol2[pos2]])\n            if cost2 < cost1:\n                improvement_nodes.add(node)\n\n    # Create new solution by combining segments with improvement priority\n    new_solution = []\n    visited = set()\n    for node in sol1:\n        if node in improvement_nodes and node not in visited:\n            new_solution.append(node)\n            visited.add(node)\n    for node in sol2:\n        if node not in visited:\n            new_solution.append(node)\n            visited.add(node)\n\n    # Ensure all nodes are visited exactly once\n    new_solution = np.array(new_solution)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply dynamic perturbation to escape local optima\n    if np.random.random() < 0.3:  # 30% chance of perturbation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6942619523715932,
            0.5481927514076232
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Identify nodes that show significant improvement in at least one objective\n    improvement_nodes = set()\n    for node in range(n):\n        if node in sol1 and node in sol2:\n            pos1 = np.where(sol1 == node)[0][0]\n            pos2 = np.where(sol2 == node)[0][0]\n            cost1 = (distance_matrix_1[sol1[pos1-1], sol1[pos1]] +\n                    distance_matrix_2[sol1[pos1-1], sol1[pos1]] +\n                    distance_matrix_3[sol1[pos1-1], sol1[pos1]])\n            cost2 = (distance_matrix_1[sol2[pos2-1], sol2[pos2]] +\n                    distance_matrix_2[sol2[pos2-1], sol2[pos2]] +\n                    distance_matrix_3[sol2[pos2-1], sol2[pos2]])\n            if cost2 < cost1:\n                improvement_nodes.add(node)\n\n    # Create new solution by combining segments with improvement priority\n    new_solution = []\n    visited = set()\n    for node in sol1:\n        if node in improvement_nodes and node not in visited:\n            new_solution.append(node)\n            visited.add(node)\n    for node in sol2:\n        if node not in visited:\n            new_solution.append(node)\n            visited.add(node)\n\n    # Ensure all nodes are visited exactly once\n    new_solution = np.array(new_solution)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply dynamic perturbation to escape local optima\n    if np.random.random() < 0.3:  # 30% chance of perturbation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{This new algorithm employs a multi-objective aware segment crossover that combines path segments from top-performing solutions in each objective space, followed by a dynamic edge replacement mechanism that prioritizes edges with balanced improvements across all objectives using a Pareto dominance check, while maintaining tour feasibility through a novel node reinsertion strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_obj1 = sorted(archive, key=lambda x: x[1][0])\n    sorted_obj2 = sorted(archive, key=lambda x: x[1][1])\n    sorted_obj3 = sorted(archive, key=lambda x: x[1][2])\n\n    # Combine segments from top solutions\n    new_solution = []\n    n = len(sorted_obj1[0][0])\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sorted_obj1[0][0][i])\n        elif i % 3 == 1:\n            new_solution.append(sorted_obj2[0][0][i])\n        else:\n            new_solution.append(sorted_obj3[0][0][i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Dynamic edge replacement with Pareto dominance check\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_edges = [\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (new_solution[i], new_solution[j]),\n            (new_solution[(i+1)%n], new_solution[(j+1)%n])\n        ]\n\n        old_costs = [\n            (distance_matrix_1[old_edges[0][0], old_edges[0][1]],\n             distance_matrix_2[old_edges[0][0], old_edges[0][1]],\n             distance_matrix_3[old_edges[0][0], old_edges[0][1]]),\n            (distance_matrix_1[old_edges[1][0], old_edges[1][1]],\n             distance_matrix_2[old_edges[1][0], old_edges[1][1]],\n             distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n        ]\n        new_costs = [\n            (distance_matrix_1[new_edges[0][0], new_edges[0][1]],\n             distance_matrix_2[new_edges[0][0], new_edges[0][1]],\n             distance_matrix_3[new_edges[0][0], new_edges[0][1]]),\n            (distance_matrix_1[new_edges[1][0], new_edges[1][1]],\n             distance_matrix_2[new_edges[1][0], new_edges[1][1]],\n             distance_matrix_3[new_edges[1][0], new_edges[1][1]])\n        ]\n\n        # Check if new edges Pareto dominate old edges\n        pareto_improvement = True\n        for old, new in zip(old_costs, new_costs):\n            if not all(n <= o for n, o in zip(new, old)):\n                pareto_improvement = False\n                break\n\n        if pareto_improvement:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7060237433062582,
            0.20523566007614136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_obj1 = sorted(archive, key=lambda x: x[1][0])\n    sorted_obj2 = sorted(archive, key=lambda x: x[1][1])\n    sorted_obj3 = sorted(archive, key=lambda x: x[1][2])\n\n    # Combine segments from top solutions\n    new_solution = []\n    n = len(sorted_obj1[0][0])\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sorted_obj1[0][0][i])\n        elif i % 3 == 1:\n            new_solution.append(sorted_obj2[0][0][i])\n        else:\n            new_solution.append(sorted_obj3[0][0][i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Dynamic edge replacement with Pareto dominance check\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_edges = [\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (new_solution[i], new_solution[j]),\n            (new_solution[(i+1)%n], new_solution[(j+1)%n])\n        ]\n\n        old_costs = [\n            (distance_matrix_1[old_edges[0][0], old_edges[0][1]],\n             distance_matrix_2[old_edges[0][0], old_edges[0][1]],\n             distance_matrix_3[old_edges[0][0], old_edges[0][1]]),\n            (distance_matrix_1[old_edges[1][0], old_edges[1][1]],\n             distance_matrix_2[old_edges[1][0], old_edges[1][1]],\n             distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n        ]\n        new_costs = [\n            (distance_matrix_1[new_edges[0][0], new_edges[0][1]],\n             distance_matrix_2[new_edges[0][0], new_edges[0][1]],\n             distance_matrix_3[new_edges[0][0], new_edges[0][1]]),\n            (distance_matrix_1[new_edges[1][0], new_edges[1][1]],\n             distance_matrix_2[new_edges[1][0], new_edges[1][1]],\n             distance_matrix_3[new_edges[1][0], new_edges[1][1]])\n        ]\n\n        # Check if new edges Pareto dominate old edges\n        pareto_improvement = True\n        for old, new in zip(old_costs, new_costs):\n            if not all(n <= o for n, o in zip(new, old)):\n                pareto_improvement = False\n                break\n\n        if pareto_improvement:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This new algorithm selects a solution from the archive based on a multi-objective quality score that combines objective values with spatial diversity, then applies a novel segment-based crossover with objective-aware edge insertion to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate spatial diversity\n    spatial_diversity = []\n    for sol, _ in archive:\n        coords = instance[sol]\n        centroid = np.mean(coords, axis=0)\n        diversity = np.mean(np.linalg.norm(coords - centroid, axis=1))\n        spatial_diversity.append(diversity)\n    spatial_diversity = np.array(spatial_diversity)\n\n    # Combine scores\n    combined_scores = np.sum(normalized, axis=1) * spatial_diversity\n    selected_idx = np.random.choice(len(archive), p=combined_scores/np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based crossover with objective-aware edge insertion\n    n = len(new_solution)\n    segment_length = max(2, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Find insertion point that minimizes total cost across objectives\n    best_insert = start\n    best_cost = np.inf\n    for i in range(n - segment_length + 1):\n        if i == start:\n            continue\n        # Create candidate solution\n        candidate = np.concatenate([\n            new_solution[:i],\n            segment,\n            np.setdiff1d(new_solution, segment)\n        ])\n        # Calculate total cost\n        total_cost = 0\n        for j in range(n):\n            u, v = candidate[j], candidate[(j+1)%n]\n            total_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    # Apply the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_insert],\n        segment,\n        np.setdiff1d(new_solution, segment)\n    ])\n\n    # Local refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                   distance_matrix_2[new_solution[i], new_solution[j]] +\n                   distance_matrix_3[new_solution[i], new_solution[j]] +\n                   distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                   distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                   distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if new_cost < old_cost:\n            new_solution[i+1:j+1] = new_solution[j:i:-1] if i+1 < j else new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5767065114169396,
            1.9863605141639709
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate spatial diversity\n    spatial_diversity = []\n    for sol, _ in archive:\n        coords = instance[sol]\n        centroid = np.mean(coords, axis=0)\n        diversity = np.mean(np.linalg.norm(coords - centroid, axis=1))\n        spatial_diversity.append(diversity)\n    spatial_diversity = np.array(spatial_diversity)\n\n    # Combine scores\n    combined_scores = np.sum(normalized, axis=1) * spatial_diversity\n    selected_idx = np.random.choice(len(archive), p=combined_scores/np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment-based crossover with objective-aware edge insertion\n    n = len(new_solution)\n    segment_length = max(2, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Find insertion point that minimizes total cost across objectives\n    best_insert = start\n    best_cost = np.inf\n    for i in range(n - segment_length + 1):\n        if i == start:\n            continue\n        # Create candidate solution\n        candidate = np.concatenate([\n            new_solution[:i],\n            segment,\n            np.setdiff1d(new_solution, segment)\n        ])\n        # Calculate total cost\n        total_cost = 0\n        for j in range(n):\n            u, v = candidate[j], candidate[(j+1)%n]\n            total_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    # Apply the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_insert],\n        segment,\n        np.setdiff1d(new_solution, segment)\n    ])\n\n    # Local refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                   distance_matrix_2[new_solution[i], new_solution[j]] +\n                   distance_matrix_3[new_solution[i], new_solution[j]] +\n                   distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                   distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] +\n                   distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if new_cost < old_cost:\n            new_solution[i+1:j+1] = new_solution[j:i:-1] if i+1 < j else new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2-opt with objective-aware node swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware node swapping\n    for _ in range(2):\n        a, b = np.random.choice(n, 2, replace=False)\n\n        def node_cost(node, prev, next):\n            return (distance_matrix_1[prev, node] + distance_matrix_1[node, next],\n                    distance_matrix_2[prev, node] + distance_matrix_2[node, next],\n                    distance_matrix_3[prev, node] + distance_matrix_3[node, next])\n\n        old_cost = node_cost(new_solution[a], new_solution[(a-1)%n], new_solution[(a+1)%n]) + node_cost(new_solution[b], new_solution[(b-1)%n], new_solution[(b+1)%n])\n        new_cost = node_cost(new_solution[a], new_solution[(a-1)%n], new_solution[b]) + node_cost(new_solution[b], new_solution[a], new_solution[(b+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7678117108265259,
            0.4815901517868042
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware node swapping\n    for _ in range(2):\n        a, b = np.random.choice(n, 2, replace=False)\n\n        def node_cost(node, prev, next):\n            return (distance_matrix_1[prev, node] + distance_matrix_1[node, next],\n                    distance_matrix_2[prev, node] + distance_matrix_2[node, next],\n                    distance_matrix_3[prev, node] + distance_matrix_3[node, next])\n\n        old_cost = node_cost(new_solution[a], new_solution[(a-1)%n], new_solution[(a+1)%n]) + node_cost(new_solution[b], new_solution[(b-1)%n], new_solution[(b+1)%n])\n        new_cost = node_cost(new_solution[a], new_solution[(a-1)%n], new_solution[b]) + node_cost(new_solution[b], new_solution[a], new_solution[(b+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{This new algorithm combines segments from the top three solutions in the archive with a weighted selection based on their normalized objective values, followed by an adaptive edge refinement step that prioritizes edges with balanced improvements across all three objectives and includes a dynamic segment reversal mechanism that adapts to the current solution's objective profile.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select top solutions\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized.sum(axis=1)\n    top_indices = np.argsort(combined_scores)[:3]\n\n    if len(top_indices) < 3:\n        top_indices = np.random.choice(len(archive), 3, replace=True)\n\n    sol1, sol2, sol3 = archive[top_indices[0]][0], archive[top_indices[1]][0], archive[top_indices[2]][0]\n    n = len(sol1)\n\n    # Create new solution with weighted segment selection\n    weights = np.array([0.5, 0.3, 0.2])  # Higher weight for better solutions\n    new_solution = []\n    for i in range(n):\n        choice = np.random.choice([sol1[i], sol2[i], sol3[i]], p=weights)\n        new_solution.append(choice)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Adaptive edge refinement with dynamic segment reversal\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Calculate improvement balance\n        improvements = [oc - nc for nc, oc in zip(new_cost, old_cost)]\n        balance = np.std(improvements)  # Lower balance is better\n\n        if balance < np.mean(improvements) * 0.7:  # Adaptive threshold\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7575494146754729,
            0.6301729679107666
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select top solutions\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized.sum(axis=1)\n    top_indices = np.argsort(combined_scores)[:3]\n\n    if len(top_indices) < 3:\n        top_indices = np.random.choice(len(archive), 3, replace=True)\n\n    sol1, sol2, sol3 = archive[top_indices[0]][0], archive[top_indices[1]][0], archive[top_indices[2]][0]\n    n = len(sol1)\n\n    # Create new solution with weighted segment selection\n    weights = np.array([0.5, 0.3, 0.2])  # Higher weight for better solutions\n    new_solution = []\n    for i in range(n):\n        choice = np.random.choice([sol1[i], sol2[i], sol3[i]], p=weights)\n        new_solution.append(choice)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Adaptive edge refinement with dynamic segment reversal\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Calculate improvement balance\n        improvements = [oc - nc for nc, oc in zip(new_cost, old_cost)]\n        balance = np.std(improvements)  # Lower balance is better\n\n        if balance < np.mean(improvements) * 0.7:  # Adaptive threshold\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{This new algorithm employs a hybrid of multi-objective segment crossover and objective-aware edge refinement, where it first combines segments from two solutions while prioritizing nodes that show better performance in the combined objectives, followed by an adaptive refinement step that selectively improves edges based on their contribution to all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better nodes\n    new_solution = []\n    visited = set()\n    for i in range(n):\n        if random.random() < 0.5:\n            candidate = sol1[i]\n        else:\n            candidate = sol2[i]\n\n        if candidate not in visited:\n            new_solution.append(candidate)\n            visited.add(candidate)\n\n    # Fill remaining nodes in order\n    remaining_nodes = [node for node in range(n) if node not in visited]\n    new_solution.extend(remaining_nodes)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply adaptive objective-aware refinement\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate combined objective improvement\n        improvement = sum(old_cost) - sum(new_cost)\n\n        # Accept if improvement is positive or with a small probability otherwise\n        if improvement > 0 or random.random() < 0.1:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7169729398329239,
            0.36539947986602783
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better nodes\n    new_solution = []\n    visited = set()\n    for i in range(n):\n        if random.random() < 0.5:\n            candidate = sol1[i]\n        else:\n            candidate = sol2[i]\n\n        if candidate not in visited:\n            new_solution.append(candidate)\n            visited.add(candidate)\n\n    # Fill remaining nodes in order\n    remaining_nodes = [node for node in range(n) if node not in visited]\n    new_solution.extend(remaining_nodes)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply adaptive objective-aware refinement\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate combined objective improvement\n        improvement = sum(old_cost) - sum(new_cost)\n\n        # Accept if improvement is positive or with a small probability otherwise\n        if improvement > 0 or random.random() < 0.1:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This new algorithm employs a multi-objective segment exchange operator that intelligently combines segments from two archive solutions while maintaining feasibility, followed by a Pareto-dominance guided edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a normalized Pareto improvement metric.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments from both solutions\n    new_solution = []\n    segment_length = max(2, n // 5)\n    start = np.random.randint(0, n - segment_length)\n    new_solution.extend(sol1[start:start+segment_length])\n\n    # Fill remaining nodes from sol2 while maintaining feasibility\n    remaining_nodes = [node for node in sol2 if node not in new_solution]\n    new_solution.extend(remaining_nodes)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply Pareto-dominance guided edge refinement\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        old_cost2 = (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                     distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n        new_cost2 = (distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                     distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                     distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate Pareto improvement\n        old_dominated = sum((oc1 < nc1 and oc2 < nc2 and oc3 < nc3) for (oc1, oc2, oc3), (nc1, nc2, nc3) in\n                           [(old_cost, new_cost), (old_cost2, new_cost2)])\n        new_dominated = sum((nc1 < oc1 and nc2 < oc2 and nc3 < oc3) for (oc1, oc2, oc3), (nc1, nc2, nc3) in\n                           [(old_cost, new_cost), (old_cost2, new_cost2)])\n\n        if new_dominated > old_dominated:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7506560918046046,
            0.4228465437889099
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments from both solutions\n    new_solution = []\n    segment_length = max(2, n // 5)\n    start = np.random.randint(0, n - segment_length)\n    new_solution.extend(sol1[start:start+segment_length])\n\n    # Fill remaining nodes from sol2 while maintaining feasibility\n    remaining_nodes = [node for node in sol2 if node not in new_solution]\n    new_solution.extend(remaining_nodes)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply Pareto-dominance guided edge refinement\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        old_cost2 = (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                     distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n        new_cost2 = (distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                     distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                     distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate Pareto improvement\n        old_dominated = sum((oc1 < nc1 and oc2 < nc2 and oc3 < nc3) for (oc1, oc2, oc3), (nc1, nc2, nc3) in\n                           [(old_cost, new_cost), (old_cost2, new_cost2)])\n        new_dominated = sum((nc1 < oc1 and nc2 < oc2 and nc3 < oc3) for (oc1, oc2, oc3), (nc1, nc2, nc3) in\n                           [(old_cost, new_cost), (old_cost2, new_cost2)])\n\n        if new_dominated > old_dominated:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 4-opt with objective-aware segment rotation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n        new_cost3 = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[l]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n        elif any(new < old for new, old in zip(new_cost3, old_cost)):\n            segment = new_solution[(i+1):(l+1)]\n            new_solution[(i+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware segment rotation\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k = np.random.randint(i, j+1)\n\n        old_cost = edge_cost(new_solution[(i-1)%n], new_solution[i]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[(i-1)%n], new_solution[k]) + edge_cost(new_solution[j], new_solution[i])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[k-i:], segment[:k-i]])\n            new_solution[i:j+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.7547618038236966,
            0.6103000044822693
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n        new_cost3 = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[l]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n        elif any(new < old for new, old in zip(new_cost3, old_cost)):\n            segment = new_solution[(i+1):(l+1)]\n            new_solution[(i+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware segment rotation\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k = np.random.randint(i, j+1)\n\n        old_cost = edge_cost(new_solution[(i-1)%n], new_solution[i]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[(i-1)%n], new_solution[k]) + edge_cost(new_solution[j], new_solution[i])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[k-i:], segment[:k-i]])\n            new_solution[i:j+1] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new algorithm that selects a solution from the archive based on a normalized objective score with dynamic weights adjusted by objective diversity, then applies a hybrid 3-opt and node-swap local search with objective-aware edge selection to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity = np.std(normalized, axis=0)\n    weights = diversity * np.exp(-normalized.mean(axis=0))  # Weight by diversity and inverse objective\n    scores = np.dot(normalized, weights)\n\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    def edge_cost(u, v):\n        return (distance_matrix_1[u, v], distance_matrix_2[u, v], distance_matrix_3[u, v])\n\n    old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n    new_cost = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[j], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(j+1)%n])\n\n    if any(new < old for new, old in zip(new_cost, old_cost)):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        new_solution[j+1:k+1] = new_solution[j+1:k+1][::-1]\n    else:\n        if np.random.rand() < 0.4:\n            l, m = sorted(np.random.choice(n, 2, replace=False))\n            if l != i and m != j and l != j and m != i and l != k and m != k:\n                old_cost = edge_cost(new_solution[l], new_solution[(l+1)%n]) + edge_cost(new_solution[m], new_solution[(m+1)%n])\n                new_cost = edge_cost(new_solution[l], new_solution[m]) + edge_cost(new_solution[(l+1)%n], new_solution[(m+1)%n])\n                if any(new < old for new, old in zip(new_cost, old_cost)):\n                    new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{This new algorithm employs a multi-objective path relinking strategy that combines segments from elite solutions while dynamically adjusting segment selection based on objective improvement potential, followed by an adaptive 2.5-opt local search that prioritizes edges with the highest potential for cost reduction across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    elite_size = max(1, len(sorted_archive) // 10)\n    elite_solutions = [sol[0] for sol in sorted_archive[:elite_size]]\n\n    if len(elite_solutions) < 2:\n        base_solution = archive[0][0].copy()\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n    # Path relinking between two elite solutions\n    sol1, sol2 = random.sample(elite_solutions, 2)\n    n = len(sol1)\n    new_solution = []\n\n    # Find common segments between the two solutions\n    common_segments = []\n    for i in range(n):\n        if sol1[i] == sol2[i]:\n            common_segments.append(i)\n\n    if len(common_segments) > 1:\n        # Use common segments as anchors\n        start = common_segments[0]\n        end = common_segments[-1]\n        new_solution = sol1[start:end+1].tolist()\n\n        # Fill gaps with alternating segments from both solutions\n        for i in range(start):\n            if i % 2 == 0:\n                new_solution.insert(0, sol1[i])\n            else:\n                new_solution.insert(0, sol2[i])\n\n        for i in range(end+1, n):\n            if i % 2 == 0:\n                new_solution.append(sol1[i])\n            else:\n                new_solution.append(sol2[i])\n    else:\n        # Alternate between both solutions when no common segments\n        new_solution = [sol1[i] if i % 2 == 0 else sol2[i] for i in range(n)]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Adaptive 2.5-opt local search\n    for _ in range(10):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate current cost\n        current_edges = [\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j], new_solution[(j+1)%n]),\n            (new_solution[k], new_solution[(k+1)%n])\n        ]\n        current_cost = sum([\n            distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n            for u, v in current_edges\n        ])\n\n        # Try different 2.5-opt moves\n        possible_moves = [\n            # Move 1: Reverse segment between i and j\n            lambda: [(new_solution[i], new_solution[j]), (new_solution[(i+1)%n], new_solution[(j+1)%n])],\n            # Move 2: Reverse segment between j and k\n            lambda: [(new_solution[j], new_solution[k]), (new_solution[(j+1)%n], new_solution[(k+1)%n])],\n            # Move 3: Reverse segment between i and k\n            lambda: [(new_solution[i], new_solution[k]), (new_solution[(i+1)%n], new_solution[(k+1)%n])],\n            # Move 4: Swap nodes at i and j\n            lambda: [(new_solution[i], new_solution[j]), (new_solution[(i+1)%n], new_solution[(j+1)%n])],\n            # Move 5: Swap nodes at j and k\n            lambda: [(new_solution[j], new_solution[k]), (new_solution[(j+1)%n], new_solution[(k+1)%n])],\n        ]\n\n        best_move = None\n        best_improvement = 0\n\n        for move in possible_moves:\n            edges = move()\n            new_cost = sum([\n                distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n                for u, v in edges\n            ])\n            improvement = current_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_move = move\n\n        if best_move is not None and best_improvement > 0:\n            # Apply the best move\n            edges = best_move()\n            if len(edges) == 2:\n                # For reverse operations\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n            else:\n                # For swap operations\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7376072065138862,
            0.408653199672699
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    elite_size = max(1, len(sorted_archive) // 10)\n    elite_solutions = [sol[0] for sol in sorted_archive[:elite_size]]\n\n    if len(elite_solutions) < 2:\n        base_solution = archive[0][0].copy()\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n    # Path relinking between two elite solutions\n    sol1, sol2 = random.sample(elite_solutions, 2)\n    n = len(sol1)\n    new_solution = []\n\n    # Find common segments between the two solutions\n    common_segments = []\n    for i in range(n):\n        if sol1[i] == sol2[i]:\n            common_segments.append(i)\n\n    if len(common_segments) > 1:\n        # Use common segments as anchors\n        start = common_segments[0]\n        end = common_segments[-1]\n        new_solution = sol1[start:end+1].tolist()\n\n        # Fill gaps with alternating segments from both solutions\n        for i in range(start):\n            if i % 2 == 0:\n                new_solution.insert(0, sol1[i])\n            else:\n                new_solution.insert(0, sol2[i])\n\n        for i in range(end+1, n):\n            if i % 2 == 0:\n                new_solution.append(sol1[i])\n            else:\n                new_solution.append(sol2[i])\n    else:\n        # Alternate between both solutions when no common segments\n        new_solution = [sol1[i] if i % 2 == 0 else sol2[i] for i in range(n)]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Adaptive 2.5-opt local search\n    for _ in range(10):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate current cost\n        current_edges = [\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j], new_solution[(j+1)%n]),\n            (new_solution[k], new_solution[(k+1)%n])\n        ]\n        current_cost = sum([\n            distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n            for u, v in current_edges\n        ])\n\n        # Try different 2.5-opt moves\n        possible_moves = [\n            # Move 1: Reverse segment between i and j\n            lambda: [(new_solution[i], new_solution[j]), (new_solution[(i+1)%n], new_solution[(j+1)%n])],\n            # Move 2: Reverse segment between j and k\n            lambda: [(new_solution[j], new_solution[k]), (new_solution[(j+1)%n], new_solution[(k+1)%n])],\n            # Move 3: Reverse segment between i and k\n            lambda: [(new_solution[i], new_solution[k]), (new_solution[(i+1)%n], new_solution[(k+1)%n])],\n            # Move 4: Swap nodes at i and j\n            lambda: [(new_solution[i], new_solution[j]), (new_solution[(i+1)%n], new_solution[(j+1)%n])],\n            # Move 5: Swap nodes at j and k\n            lambda: [(new_solution[j], new_solution[k]), (new_solution[(j+1)%n], new_solution[(k+1)%n])],\n        ]\n\n        best_move = None\n        best_improvement = 0\n\n        for move in possible_moves:\n            edges = move()\n            new_cost = sum([\n                distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n                for u, v in edges\n            ])\n            improvement = current_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_move = move\n\n        if best_move is not None and best_improvement > 0:\n            # Apply the best move\n            edges = best_move()\n            if len(edges) == 2:\n                # For reverse operations\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n            else:\n                # For swap operations\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive with the best combined objective value, then performs a multi-objective aware 2-opt swap that prioritizes improving at least one objective while maintaining feasibility, with additional node reinsertion steps to ensure all nodes are visited exactly once.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Accept if at least one objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{This new algorithm selects a solution from the archive with the highest diversity in its objective values, then applies a multi-objective aware segment exchange operator that combines path segments from three different solutions while prioritizing edges that improve at least one objective, followed by a novel segment rotation mechanism to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = [max(obj) - min(obj) for (sol, obj) in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Select three diverse solutions for segment exchange\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n\n    # Create new solution with segment exchange\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        elif i % 3 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply segment rotation mechanism\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n\n        # Check if segment rotation improves any objective\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]],\n                    distance_matrix_2[new_solution[i-1], new_solution[i]],\n                    distance_matrix_3[new_solution[i-1], new_solution[i]])\n        new_cost = (distance_matrix_1[new_solution[i-1], segment[-1]],\n                    distance_matrix_2[new_solution[i-1], segment[-1]],\n                    distance_matrix_3[new_solution[i-1], segment[-1]])\n\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            new_solution[i:j] = np.roll(segment, 1)\n\n    return new_solution\n\n",
        "score": [
            -0.654809545274847,
            0.22506272792816162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = [max(obj) - min(obj) for (sol, obj) in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Select three diverse solutions for segment exchange\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n\n    # Create new solution with segment exchange\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        elif i % 3 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply segment rotation mechanism\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j]\n\n        # Check if segment rotation improves any objective\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]],\n                    distance_matrix_2[new_solution[i-1], new_solution[i]],\n                    distance_matrix_3[new_solution[i-1], new_solution[i]])\n        new_cost = (distance_matrix_1[new_solution[i-1], segment[-1]],\n                    distance_matrix_2[new_solution[i-1], segment[-1]],\n                    distance_matrix_3[new_solution[i-1], segment[-1]])\n\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            new_solution[i:j] = np.roll(segment, 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with lower variance, then applies a hybrid local search combining 3-opt with objective-aware edge swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = 1 / (variances + 1e-6)  # Inverse variance weighting\n    weights = weights / np.sum(weights) if np.sum(weights) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(np.array(scores)) / np.sum(np.exp(np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            # Reconnect the path in a different order\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(j+1)] = segment1[::-1]\n            new_solution[(j+1):(k+1)] = segment2[::-1]\n\n        # Additional edge swap move\n        if np.random.rand() < 0.3:\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            new_cost = edge_cost(new_solution[a], new_solution[b])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Apply objective-aware edge swapping\n    for _ in range(4):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            # Swap edges to create a new tour\n            segment = new_solution[(a+1):(b+1)]\n            new_solution[(a+1):(b+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7293313615550873,
            0.5800849795341492
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = 1 / (variances + 1e-6)  # Inverse variance weighting\n    weights = weights / np.sum(weights) if np.sum(weights) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(np.array(scores)) / np.sum(np.exp(np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            # Reconnect the path in a different order\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(j+1)] = segment1[::-1]\n            new_solution[(j+1):(k+1)] = segment2[::-1]\n\n        # Additional edge swap move\n        if np.random.rand() < 0.3:\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            new_cost = edge_cost(new_solution[a], new_solution[b])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Apply objective-aware edge swapping\n    for _ in range(4):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = edge_cost(new_solution[a], new_solution[(a+1)%n]) + edge_cost(new_solution[b], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            # Swap edges to create a new tour\n            segment = new_solution[(a+1):(b+1)]\n            new_solution[(a+1):(b+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2-opt with objective-aware edge swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge swapping\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware edge swapping\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7458545746234757,
            0.5264954090118408
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge swapping\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware edge swapping\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{This new algorithm employs a multi-objective guided segment crossover that selectively combines path segments from top-performing solutions in each objective space, followed by a dynamic edge refinement process that adaptsively prioritizes edges based on their combined objective improvement potential and incorporates a probabilistic segment inversion mechanism to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_obj1 = sorted(archive, key=lambda x: x[1][0])\n    sorted_obj2 = sorted(archive, key=lambda x: x[1][1])\n    sorted_obj3 = sorted(archive, key=lambda x: x[1][2])\n\n    # Combine segments with preference for better objectives\n    n = len(archive[0][0])\n    new_solution = np.zeros(n, dtype=int)\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution[i] = sorted_obj1[0][0][i]\n        elif i % 3 == 1:\n            new_solution[i] = sorted_obj2[0][0][i]\n        else:\n            new_solution[i] = sorted_obj3[0][0][i]\n\n    # Ensure all nodes are visited exactly once\n    missing = set(range(n)) - set(new_solution)\n    for node in missing:\n        pos = np.random.randint(0, n)\n        new_solution[pos] = node\n\n    # Apply dynamic edge refinement with probabilistic inversion\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        potential_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                          distance_matrix_2[new_solution[i], new_solution[j]] +\n                          distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Accept with probability based on improvement\n        if potential_cost < current_cost or np.random.rand() < 0.3:\n            # Perform segment inversion with probability\n            if np.random.rand() < 0.4:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7063530821128523,
            0.1624051332473755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_obj1 = sorted(archive, key=lambda x: x[1][0])\n    sorted_obj2 = sorted(archive, key=lambda x: x[1][1])\n    sorted_obj3 = sorted(archive, key=lambda x: x[1][2])\n\n    # Combine segments with preference for better objectives\n    n = len(archive[0][0])\n    new_solution = np.zeros(n, dtype=int)\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution[i] = sorted_obj1[0][0][i]\n        elif i % 3 == 1:\n            new_solution[i] = sorted_obj2[0][0][i]\n        else:\n            new_solution[i] = sorted_obj3[0][0][i]\n\n    # Ensure all nodes are visited exactly once\n    missing = set(range(n)) - set(new_solution)\n    for node in missing:\n        pos = np.random.randint(0, n)\n        new_solution[pos] = node\n\n    # Apply dynamic edge refinement with probabilistic inversion\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        potential_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                          distance_matrix_2[new_solution[i], new_solution[j]] +\n                          distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Accept with probability based on improvement\n        if potential_cost < current_cost or np.random.rand() < 0.3:\n            # Perform segment inversion with probability\n            if np.random.rand() < 0.4:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This new algorithm uses a multi-objective path relinking approach that combines segments from two promising archive solutions while maintaining feasibility, followed by an objective-balanced 2-opt refinement step that prioritizes edges with the highest potential for improvement across all three objectives using a normalized geometric mean of objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: sum(x[1]))[:3]\n    sol1, sol2 = random.sample(top_solutions, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create new solution with alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-balanced 2-opt refinement\n    for _ in range(7):  # Perform 7 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        old_cost3 = distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        next_old_cost1 = distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        next_old_cost2 = distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        next_old_cost3 = distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost3 = distance_matrix_3[new_solution[i], new_solution[j]]\n        next_new_cost1 = distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        next_new_cost2 = distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        next_new_cost3 = distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        # Calculate geometric mean of normalized improvements\n        improvement1 = (old_cost1 + next_old_cost1) - (new_cost1 + next_new_cost1)\n        improvement2 = (old_cost2 + next_old_cost2) - (new_cost2 + next_new_cost2)\n        improvement3 = (old_cost3 + next_old_cost3) - (new_cost3 + next_new_cost3)\n\n        if improvement1 > 0 or improvement2 > 0 or improvement3 > 0:\n            # Calculate geometric mean of improvements\n            geo_mean = (improvement1 * improvement2 * improvement3) ** (1/3)\n            if geo_mean > 0:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7181439765696674,
            0.22283194065093995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: sum(x[1]))[:3]\n    sol1, sol2 = random.sample(top_solutions, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create new solution with alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-balanced 2-opt refinement\n    for _ in range(7):  # Perform 7 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        old_cost3 = distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        next_old_cost1 = distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        next_old_cost2 = distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        next_old_cost3 = distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost3 = distance_matrix_3[new_solution[i], new_solution[j]]\n        next_new_cost1 = distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        next_new_cost2 = distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        next_new_cost3 = distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        # Calculate geometric mean of normalized improvements\n        improvement1 = (old_cost1 + next_old_cost1) - (new_cost1 + next_new_cost1)\n        improvement2 = (old_cost2 + next_old_cost2) - (new_cost2 + next_new_cost2)\n        improvement3 = (old_cost3 + next_old_cost3) - (new_cost3 + next_new_cost3)\n\n        if improvement1 > 0 or improvement2 > 0 or improvement3 > 0:\n            # Calculate geometric mean of improvements\n            geo_mean = (improvement1 * improvement2 * improvement3) ** (1/3)\n            if geo_mean > 0:\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 4-opt with objective-aware node swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(k+1):(l+1)] = new_solution[(k+1):(l+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n            segment = new_solution[(j+1):(l+1)]\n            new_solution[(j+1):(l+1)] = np.concatenate([segment[(l-j)-1:], segment[:(l-j)-1]])\n\n    # Apply objective-aware node swapping\n    for _ in range(3):\n        node1, node2 = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[node1], new_solution[(node1-1)%n]] + distance_matrix_1[new_solution[node1], new_solution[(node1+1)%n]] + distance_matrix_1[new_solution[node2], new_solution[(node2-1)%n]] + distance_matrix_1[new_solution[node2], new_solution[(node2+1)%n]],\n                    distance_matrix_2[new_solution[node1], new_solution[(node1-1)%n]] + distance_matrix_2[new_solution[node1], new_solution[(node1+1)%n]] + distance_matrix_2[new_solution[node2], new_solution[(node2-1)%n]] + distance_matrix_2[new_solution[node2], new_solution[(node2+1)%n]],\n                    distance_matrix_3[new_solution[node1], new_solution[(node1-1)%n]] + distance_matrix_3[new_solution[node1], new_solution[(node1+1)%n]] + distance_matrix_3[new_solution[node2], new_solution[(node2-1)%n]] + distance_matrix_3[new_solution[node2], new_solution[(node2+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node1], new_solution[(node2-1)%n]] + distance_matrix_1[new_solution[node1], new_solution[(node2+1)%n]] + distance_matrix_1[new_solution[node2], new_solution[(node1-1)%n]] + distance_matrix_1[new_solution[node2], new_solution[(node1+1)%n]],\n                    distance_matrix_2[new_solution[node1], new_solution[(node2-1)%n]] + distance_matrix_2[new_solution[node1], new_solution[(node2+1)%n]] + distance_matrix_2[new_solution[node2], new_solution[(node1-1)%n]] + distance_matrix_2[new_solution[node2], new_solution[(node1+1)%n]],\n                    distance_matrix_3[new_solution[node1], new_solution[(node2-1)%n]] + distance_matrix_3[new_solution[node1], new_solution[(node2+1)%n]] + distance_matrix_3[new_solution[node2], new_solution[(node1-1)%n]] + distance_matrix_3[new_solution[node2], new_solution[(node1+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    return new_solution\n\n",
        "score": [
            -0.7679441939633334,
            0.5601843237876892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(k+1):(l+1)] = new_solution[(k+1):(l+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n            segment = new_solution[(j+1):(l+1)]\n            new_solution[(j+1):(l+1)] = np.concatenate([segment[(l-j)-1:], segment[:(l-j)-1]])\n\n    # Apply objective-aware node swapping\n    for _ in range(3):\n        node1, node2 = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[node1], new_solution[(node1-1)%n]] + distance_matrix_1[new_solution[node1], new_solution[(node1+1)%n]] + distance_matrix_1[new_solution[node2], new_solution[(node2-1)%n]] + distance_matrix_1[new_solution[node2], new_solution[(node2+1)%n]],\n                    distance_matrix_2[new_solution[node1], new_solution[(node1-1)%n]] + distance_matrix_2[new_solution[node1], new_solution[(node1+1)%n]] + distance_matrix_2[new_solution[node2], new_solution[(node2-1)%n]] + distance_matrix_2[new_solution[node2], new_solution[(node2+1)%n]],\n                    distance_matrix_3[new_solution[node1], new_solution[(node1-1)%n]] + distance_matrix_3[new_solution[node1], new_solution[(node1+1)%n]] + distance_matrix_3[new_solution[node2], new_solution[(node2-1)%n]] + distance_matrix_3[new_solution[node2], new_solution[(node2+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node1], new_solution[(node2-1)%n]] + distance_matrix_1[new_solution[node1], new_solution[(node2+1)%n]] + distance_matrix_1[new_solution[node2], new_solution[(node1-1)%n]] + distance_matrix_1[new_solution[node2], new_solution[(node1+1)%n]],\n                    distance_matrix_2[new_solution[node1], new_solution[(node2-1)%n]] + distance_matrix_2[new_solution[node1], new_solution[(node2+1)%n]] + distance_matrix_2[new_solution[node2], new_solution[(node1-1)%n]] + distance_matrix_2[new_solution[node2], new_solution[(node1+1)%n]],\n                    distance_matrix_3[new_solution[node1], new_solution[(node2-1)%n]] + distance_matrix_3[new_solution[node1], new_solution[(node2+1)%n]] + distance_matrix_3[new_solution[node2], new_solution[(node1-1)%n]] + distance_matrix_3[new_solution[node2], new_solution[(node1+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This new algorithm employs a multi-objective segment reassembly operator that intelligently decomposes the tour into non-overlapping segments, reorders them based on their combined objective improvement potential, and reconstructs the tour while applying objective-specific edge swaps to enhance solution quality across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = sorted(archive, key=lambda x: sum(x[1]))[0][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Decompose into segments and reorder based on objective improvement potential\n    segment_size = max(2, n // 5)\n    segments = [new_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Calculate improvement potential for each segment\n    segment_potentials = []\n    for segment in segments:\n        total_improvement = 0\n        for i in range(len(segment)):\n            current = segment[i]\n            next_node = segment[(i+1)%len(segment)]\n            # Calculate potential improvement by considering alternative edges\n            for j in range(n):\n                if j not in segment:\n                    alt_cost = (distance_matrix_1[current, j] + distance_matrix_1[j, next_node] +\n                                distance_matrix_2[current, j] + distance_matrix_2[j, next_node] +\n                                distance_matrix_3[current, j] + distance_matrix_3[j, next_node])\n                    original_cost = (distance_matrix_1[current, next_node] +\n                                    distance_matrix_2[current, next_node] +\n                                    distance_matrix_3[current, next_node])\n                    improvement = original_cost - alt_cost\n                    total_improvement += improvement\n        segment_potentials.append(total_improvement)\n\n    # Reorder segments based on improvement potential\n    sorted_indices = sorted(range(len(segments)), key=lambda i: segment_potentials[i], reverse=True)\n    segments = [segments[i] for i in sorted_indices]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Apply objective-specific edge swaps\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        obj1_improvement = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_1[new_solution[i], new_solution[j]]\n        obj2_improvement = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_2[new_solution[i], new_solution[j]]\n        obj3_improvement = distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_3[new_solution[i], new_solution[j]]\n\n        if (obj1_improvement > 0 or obj2_improvement > 0 or obj3_improvement > 0):\n            # Perform swap if any objective improves\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6490150234259144,
            2.213275933265686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = sorted(archive, key=lambda x: sum(x[1]))[0][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Decompose into segments and reorder based on objective improvement potential\n    segment_size = max(2, n // 5)\n    segments = [new_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Calculate improvement potential for each segment\n    segment_potentials = []\n    for segment in segments:\n        total_improvement = 0\n        for i in range(len(segment)):\n            current = segment[i]\n            next_node = segment[(i+1)%len(segment)]\n            # Calculate potential improvement by considering alternative edges\n            for j in range(n):\n                if j not in segment:\n                    alt_cost = (distance_matrix_1[current, j] + distance_matrix_1[j, next_node] +\n                                distance_matrix_2[current, j] + distance_matrix_2[j, next_node] +\n                                distance_matrix_3[current, j] + distance_matrix_3[j, next_node])\n                    original_cost = (distance_matrix_1[current, next_node] +\n                                    distance_matrix_2[current, next_node] +\n                                    distance_matrix_3[current, next_node])\n                    improvement = original_cost - alt_cost\n                    total_improvement += improvement\n        segment_potentials.append(total_improvement)\n\n    # Reorder segments based on improvement potential\n    sorted_indices = sorted(range(len(segments)), key=lambda i: segment_potentials[i], reverse=True)\n    segments = [segments[i] for i in sorted_indices]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(segments)\n\n    # Apply objective-specific edge swaps\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        obj1_improvement = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_1[new_solution[i], new_solution[j]]\n        obj2_improvement = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_2[new_solution[i], new_solution[j]]\n        obj3_improvement = distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_3[new_solution[i], new_solution[j]]\n\n        if (obj1_improvement > 0 or obj2_improvement > 0 or obj3_improvement > 0):\n            # Perform swap if any objective improves\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive with the best balance across all three objectives, then performs a multi-objective-aware node relocation that intelligently moves nodes between segments while prioritizing improvement in the most underperforming objective, followed by a segment inversion step to further optimize the tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective is most underperforming\n    current_costs = [sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))]\n    most_underperforming = current_costs.index(max(current_costs))\n\n    # Perform multi-objective-aware node relocation\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i == j:\n            continue\n\n        # Calculate cost change for the most underperforming objective\n        old_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[(i+1)%n]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[(i-1)%n], new_solution[i])\n\n        new_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[j]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[(i-1)%n], new_solution[(j+1)%n])\n\n        if new_cost < old_cost:\n            # Perform relocation\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = (j+1) % n\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Perform segment inversion for further optimization\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic balance between objective improvements and tour structure diversity, then applies a hybrid local search combining multi-objective-aware edge swapping with a novel \"objective-aware tour segmentation\" operator that intelligently reorders segments based on their contribution to different objectives, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity_scores = [np.std(normalized[i]) for i in range(len(archive))]\n    scores = [np.mean(normalized[i]) + 0.3 * diversity_scores[i] for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware edge swapping\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new < old for new, old in zip(new_cost, old_cost)) >= 2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Objective-aware tour segmentation\n    segment_length = max(3, n // 5)\n    for _ in range(3):\n        start = np.random.randint(0, n - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment contribution to each objective\n        segment_costs = [\n            sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length)),\n            sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length)),\n            sum(distance_matrix_3[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n        ]\n\n        # Determine which objective this segment should prioritize\n        target_obj = segment_costs.index(max(segment_costs))\n\n        # Reorder segment to minimize the target objective\n        if target_obj == 0:\n            segment = sorted(segment, key=lambda x: instance[x, 0])\n        elif target_obj == 1:\n            segment = sorted(segment, key=lambda x: instance[x, 2])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 1] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.6374245262130703,
            1.2981013894081115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity_scores = [np.std(normalized[i]) for i in range(len(archive))]\n    scores = [np.mean(normalized[i]) + 0.3 * diversity_scores[i] for i in range(len(archive))]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware edge swapping\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new < old for new, old in zip(new_cost, old_cost)) >= 2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Objective-aware tour segmentation\n    segment_length = max(3, n // 5)\n    for _ in range(3):\n        start = np.random.randint(0, n - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment contribution to each objective\n        segment_costs = [\n            sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length)),\n            sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length)),\n            sum(distance_matrix_3[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n        ]\n\n        # Determine which objective this segment should prioritize\n        target_obj = segment_costs.index(max(segment_costs))\n\n        # Reorder segment to minimize the target objective\n        if target_obj == 0:\n            segment = sorted(segment, key=lambda x: instance[x, 0])\n        elif target_obj == 1:\n            segment = sorted(segment, key=lambda x: instance[x, 2])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 1] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection mechanism that prioritizes solutions with unique objective trade-offs, then applies a novel segment-based crossover with objective-aware mutation that combines multiple segments from different archive solutions while maintaining feasibility and potentially improving all three objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n\n    # Calculate diversity scores\n    diversity_scores = []\n    for i in range(len(archive)):\n        distances = np.linalg.norm(normalized_obj[i] - normalized_obj, axis=1)\n        diversity_scores.append(np.mean(distances))\n\n    # Select solution with highest diversity\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create multiple segments from different archive solutions\n    segments = []\n    for _ in range(3):\n        sol = random.choice(archive)[0]\n        start = np.random.randint(0, len(sol)-3)\n        end = np.random.randint(start+1, len(sol))\n        segments.append(sol[start:end])\n\n    # Combine segments with base solution\n    new_solution = []\n    current_pos = 0\n    for seg in segments:\n        if current_pos + len(seg) > len(base_solution):\n            break\n        new_solution.extend(base_solution[current_pos:current_pos+len(seg)])\n        current_pos += len(seg)\n\n    # Add remaining nodes\n    remaining_nodes = set(base_solution) - set(new_solution)\n    new_solution.extend(list(remaining_nodes))\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(base_solution):\n        missing_nodes = set(base_solution) - set(new_solution)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware mutation\n    for _ in range(4):\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%len(new_solution)]] +\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%len(new_solution)]] +\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%len(new_solution)]],\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%len(new_solution)]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%len(new_solution)]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%len(new_solution)]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[j]],\n            distance_matrix_1[new_solution[(i+1)%len(new_solution)], new_solution[(j+1)%len(new_solution)]] +\n            distance_matrix_2[new_solution[(i+1)%len(new_solution)], new_solution[(j+1)%len(new_solution)]] +\n            distance_matrix_3[new_solution[(i+1)%len(new_solution)], new_solution[(j+1)%len(new_solution)]]\n        )\n\n        if sum(new_cost) < sum(old_cost):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7679050145939201,
            2.849888336658478
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n\n    # Calculate diversity scores\n    diversity_scores = []\n    for i in range(len(archive)):\n        distances = np.linalg.norm(normalized_obj[i] - normalized_obj, axis=1)\n        diversity_scores.append(np.mean(distances))\n\n    # Select solution with highest diversity\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create multiple segments from different archive solutions\n    segments = []\n    for _ in range(3):\n        sol = random.choice(archive)[0]\n        start = np.random.randint(0, len(sol)-3)\n        end = np.random.randint(start+1, len(sol))\n        segments.append(sol[start:end])\n\n    # Combine segments with base solution\n    new_solution = []\n    current_pos = 0\n    for seg in segments:\n        if current_pos + len(seg) > len(base_solution):\n            break\n        new_solution.extend(base_solution[current_pos:current_pos+len(seg)])\n        current_pos += len(seg)\n\n    # Add remaining nodes\n    remaining_nodes = set(base_solution) - set(new_solution)\n    new_solution.extend(list(remaining_nodes))\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != len(base_solution):\n        missing_nodes = set(base_solution) - set(new_solution)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware mutation\n    for _ in range(4):\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%len(new_solution)]] +\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%len(new_solution)]] +\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%len(new_solution)]],\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%len(new_solution)]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%len(new_solution)]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%len(new_solution)]]\n        )\n\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[j]],\n            distance_matrix_1[new_solution[(i+1)%len(new_solution)], new_solution[(j+1)%len(new_solution)]] +\n            distance_matrix_2[new_solution[(i+1)%len(new_solution)], new_solution[(j+1)%len(new_solution)]] +\n            distance_matrix_3[new_solution[(i+1)%len(new_solution)], new_solution[(j+1)%len(new_solution)]]\n        )\n\n        if sum(new_cost) < sum(old_cost):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive with the best combined objective value, then performs a multi-objective aware 2-opt swap that prioritizes improving at least one objective while maintaining feasibility, with additional node reinsertion steps to ensure all nodes are visited exactly once.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Accept if at least one objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{This new algorithm selects a solution from the archive with the best combined objective value, then performs a multi-objective aware hybrid operator that combines 2-opt swaps with node reinsertion, while prioritizing edges that show potential for improving at least one objective, and includes a novel segment rotation mechanism to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.roll(segment, shift=np.random.randint(1, len(segment)))\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7458461187590345,
            0.4027211546897888
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.roll(segment, shift=np.random.randint(1, len(segment)))\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This new algorithm employs a multi-objective segment fusion strategy that combines high-quality path segments from multiple archive solutions while using a dynamic objective weighting scheme to prioritize diverse improvement opportunities across all three objectives, followed by a novel adaptive 2-opt refinement that intelligently balances exploration and exploitation based on the current solution's objective landscape.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([sol[1] for sol in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_weights = 1 / (objective_ranges + 1e-6)\n    diversity_scores = np.dot(objectives, diversity_weights)\n    selected_idx = np.argmin(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Create new solution by combining segments from top solutions\n    top_k = min(5, len(archive))\n    top_solutions = sorted(archive, key=lambda x: sum(x[1]))[:top_k]\n    new_solution = []\n    segment_length = max(2, n // top_k)\n\n    for i in range(0, n, segment_length):\n        sol_idx = i // segment_length % top_k\n        segment = top_solutions[sol_idx][0][i:i+segment_length]\n        new_solution.extend(segment)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply adaptive 2-opt refinement with objective-aware selection\n    for _ in range(10):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_edges = [(new_solution[i], new_solution[(i+1)%n]),\n                    (new_solution[j], new_solution[(j+1)%n])]\n        new_edges = [(new_solution[i], new_solution[j]),\n                    (new_solution[(i+1)%n], new_solution[(j+1)%n])]\n\n        # Calculate objective improvements\n        old_cost = (distance_matrix_1[old_edges[0][0], old_edges[0][1]] +\n                    distance_matrix_2[old_edges[0][0], old_edges[0][1]] +\n                    distance_matrix_3[old_edges[0][0], old_edges[0][1]] +\n                    distance_matrix_1[old_edges[1][0], old_edges[1][1]] +\n                    distance_matrix_2[old_edges[1][0], old_edges[1][1]] +\n                    distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n\n        new_cost = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                    distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                    distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                    distance_matrix_1[new_edges[1][0], new_edges[1][1]] +\n                    distance_matrix_2[new_edges[1][0], new_edges[1][1]] +\n                    distance_matrix_3[new_edges[1][0], new_edges[1][1]])\n\n        # Adaptive acceptance probability based on cost difference\n        cost_diff = old_cost - new_cost\n        if cost_diff > 0 or np.random.rand() < np.exp(cost_diff / (1 + np.abs(cost_diff))):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6380829591378083,
            0.35676189661026003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([sol[1] for sol in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_weights = 1 / (objective_ranges + 1e-6)\n    diversity_scores = np.dot(objectives, diversity_weights)\n    selected_idx = np.argmin(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Create new solution by combining segments from top solutions\n    top_k = min(5, len(archive))\n    top_solutions = sorted(archive, key=lambda x: sum(x[1]))[:top_k]\n    new_solution = []\n    segment_length = max(2, n // top_k)\n\n    for i in range(0, n, segment_length):\n        sol_idx = i // segment_length % top_k\n        segment = top_solutions[sol_idx][0][i:i+segment_length]\n        new_solution.extend(segment)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply adaptive 2-opt refinement with objective-aware selection\n    for _ in range(10):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_edges = [(new_solution[i], new_solution[(i+1)%n]),\n                    (new_solution[j], new_solution[(j+1)%n])]\n        new_edges = [(new_solution[i], new_solution[j]),\n                    (new_solution[(i+1)%n], new_solution[(j+1)%n])]\n\n        # Calculate objective improvements\n        old_cost = (distance_matrix_1[old_edges[0][0], old_edges[0][1]] +\n                    distance_matrix_2[old_edges[0][0], old_edges[0][1]] +\n                    distance_matrix_3[old_edges[0][0], old_edges[0][1]] +\n                    distance_matrix_1[old_edges[1][0], old_edges[1][1]] +\n                    distance_matrix_2[old_edges[1][0], old_edges[1][1]] +\n                    distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n\n        new_cost = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                    distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                    distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                    distance_matrix_1[new_edges[1][0], new_edges[1][1]] +\n                    distance_matrix_2[new_edges[1][0], new_edges[1][1]] +\n                    distance_matrix_3[new_edges[1][0], new_edges[1][1]])\n\n        # Adaptive acceptance probability based on cost difference\n        cost_diff = old_cost - new_cost\n        if cost_diff > 0 or np.random.rand() < np.exp(cost_diff / (1 + np.abs(cost_diff))):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive with the best combined objective value, then performs a multi-objective aware 2-opt swap that prioritizes improving at least one objective while maintaining feasibility, with additional node reinsertion steps to ensure all nodes are visited exactly once.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Accept if at least one objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{This new algorithm selects a solution from the archive using a weighted random selection based on Pareto dominance and objective diversity, then applies a hybrid local search combining 3-opt with multi-objective aware node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([1.0 / (1 + sum(x[1])) for x in archive])\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with multi-objective awareness\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        # Reverse the middle segment\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(j-1)%n], new_solution[j]])\n        ]\n\n        # Accept if at least one objective improves\n        if any(any(nc < oc for nc, oc in zip(nc, oc)) for nc, oc in zip(new_costs, old_costs[:2])):\n            break\n        else:\n            # Revert if no improvement\n            new_solution[(i+1):(j+1)] = segment\n\n    # Multi-objective aware node reinsertion\n    for _ in range(3):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8064080545030695,
            0.43735852241516116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([1.0 / (1 + sum(x[1])) for x in archive])\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with multi-objective awareness\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        # Reverse the middle segment\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(j-1)%n], new_solution[j]])\n        ]\n\n        # Accept if at least one objective improves\n        if any(any(nc < oc for nc, oc in zip(nc, oc)) for nc, oc in zip(new_costs, old_costs[:2])):\n            break\n        else:\n            # Revert if no improvement\n            new_solution[(i+1):(j+1)] = segment\n\n    # Multi-objective aware node reinsertion\n    for _ in range(3):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{This new algorithm employs a multi-objective biased selection mechanism that combines segments from top-performing solutions in each objective space, followed by a dynamic edge refinement process that prioritizes edges with the best individual improvements while incorporating a probabilistic segment reversal mechanism to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_obj1 = sorted(archive, key=lambda x: x[1][0])\n    sorted_obj2 = sorted(archive, key=lambda x: x[1][1])\n    sorted_obj3 = sorted(archive, key=lambda x: x[1][2])\n\n    # Combine segments with bias towards better objectives\n    n = len(archive[0][0])\n    new_solution = np.zeros(n, dtype=int)\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution[i] = sorted_obj1[0][0][i]\n        elif i % 3 == 1:\n            new_solution[i] = sorted_obj2[0][0][i]\n        else:\n            new_solution[i] = sorted_obj3[0][0][i]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic edge refinement with probabilistic segment reversal\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Probabilistic acceptance based on improvement\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            if np.random.rand() < 0.7:  # Higher probability to accept good moves\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6729372357357369,
            0.22300444841384887
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_obj1 = sorted(archive, key=lambda x: x[1][0])\n    sorted_obj2 = sorted(archive, key=lambda x: x[1][1])\n    sorted_obj3 = sorted(archive, key=lambda x: x[1][2])\n\n    # Combine segments with bias towards better objectives\n    n = len(archive[0][0])\n    new_solution = np.zeros(n, dtype=int)\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution[i] = sorted_obj1[0][0][i]\n        elif i % 3 == 1:\n            new_solution[i] = sorted_obj2[0][0][i]\n        else:\n            new_solution[i] = sorted_obj3[0][0][i]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic edge refinement with probabilistic segment reversal\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Probabilistic acceptance based on improvement\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            if np.random.rand() < 0.7:  # Higher probability to accept good moves\n                segment = new_solution[(i+1):(j+1)]\n                new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining edge-swapping with objective-aware segment inversion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply edge-swapping with objective-aware selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Additional edge-swap\n        if np.random.rand() < 0.3:\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            old_cost = edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n])\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                new_solution[k+1], new_solution[l] = new_solution[l], new_solution[k+1]\n\n    # Apply objective-aware segment inversion\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[a:b+1]\n            new_solution[a:b+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7311703443485589,
            0.5571025371551513
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply edge-swapping with objective-aware selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Additional edge-swap\n        if np.random.rand() < 0.3:\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            old_cost = edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n])\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                new_solution[k+1], new_solution[l] = new_solution[l], new_solution[k+1]\n\n    # Apply objective-aware segment inversion\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[a:b+1]\n            new_solution[a:b+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{This new algorithm employs a multi-objective segment blending strategy that combines path segments from three archive solutions with adaptive weighting based on Pareto dominance, followed by an objective-aware segment replacement mechanism that replaces entire segments with better-performing segments from non-dominated solutions while maintaining feasibility through a novel node reinsertion process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by blending segments with adaptive weighting\n    new_solution = []\n    weights = [0.6, 0.3, 0.1]  # Higher weight for better solutions\n    for i in range(n):\n        rand_val = np.random.random()\n        if rand_val < weights[0]:\n            new_solution.append(sol1[i])\n        elif rand_val < weights[0] + weights[1]:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            # Find a segment from a non-dominated solution to insert\n            for sol in [sol1, sol2, sol3]:\n                if node in sol:\n                    insert_pos = np.random.randint(0, len(new_solution))\n                    new_solution.insert(insert_pos, node)\n                    break\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware segment replacement\n    for _ in range(3):\n        # Select a random segment length\n        seg_length = np.random.randint(3, min(10, n//2))\n        start_pos = np.random.randint(0, n - seg_length)\n\n        # Evaluate current segment cost\n        current_segment = new_solution[start_pos:start_pos+seg_length]\n        current_cost = (\n            sum(distance_matrix_1[current_segment[i], current_segment[(i+1)%seg_length]] for i in range(seg_length)),\n            sum(distance_matrix_2[current_segment[i], current_segment[(i+1)%seg_length]] for i in range(seg_length)),\n            sum(distance_matrix_3[current_segment[i], current_segment[(i+1)%seg_length]] for i in range(seg_length))\n        )\n\n        # Find a better segment from non-dominated solutions\n        best_replacement = None\n        best_improvement = 0\n\n        for sol in [sol1, sol2, sol3]:\n            for i in range(n - seg_length):\n                candidate_segment = sol[i:i+seg_length]\n                candidate_cost = (\n                    sum(distance_matrix_1[candidate_segment[j], candidate_segment[(j+1)%seg_length]] for j in range(seg_length)),\n                    sum(distance_matrix_2[candidate_segment[j], candidate_segment[(j+1)%seg_length]] for j in range(seg_length)),\n                    sum(distance_matrix_3[candidate_segment[j], candidate_segment[(j+1)%seg_length]] for j in range(seg_length))\n                )\n\n                # Calculate improvement\n                improvement = sum((cc - nc) for cc, nc in zip(current_cost, candidate_cost))\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_replacement = candidate_segment\n\n        if best_replacement is not None:\n            new_solution[start_pos:start_pos+seg_length] = best_replacement\n\n    return new_solution\n\n",
        "score": [
            -0.6623506412961124,
            1.604359233379364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by blending segments with adaptive weighting\n    new_solution = []\n    weights = [0.6, 0.3, 0.1]  # Higher weight for better solutions\n    for i in range(n):\n        rand_val = np.random.random()\n        if rand_val < weights[0]:\n            new_solution.append(sol1[i])\n        elif rand_val < weights[0] + weights[1]:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            # Find a segment from a non-dominated solution to insert\n            for sol in [sol1, sol2, sol3]:\n                if node in sol:\n                    insert_pos = np.random.randint(0, len(new_solution))\n                    new_solution.insert(insert_pos, node)\n                    break\n\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware segment replacement\n    for _ in range(3):\n        # Select a random segment length\n        seg_length = np.random.randint(3, min(10, n//2))\n        start_pos = np.random.randint(0, n - seg_length)\n\n        # Evaluate current segment cost\n        current_segment = new_solution[start_pos:start_pos+seg_length]\n        current_cost = (\n            sum(distance_matrix_1[current_segment[i], current_segment[(i+1)%seg_length]] for i in range(seg_length)),\n            sum(distance_matrix_2[current_segment[i], current_segment[(i+1)%seg_length]] for i in range(seg_length)),\n            sum(distance_matrix_3[current_segment[i], current_segment[(i+1)%seg_length]] for i in range(seg_length))\n        )\n\n        # Find a better segment from non-dominated solutions\n        best_replacement = None\n        best_improvement = 0\n\n        for sol in [sol1, sol2, sol3]:\n            for i in range(n - seg_length):\n                candidate_segment = sol[i:i+seg_length]\n                candidate_cost = (\n                    sum(distance_matrix_1[candidate_segment[j], candidate_segment[(j+1)%seg_length]] for j in range(seg_length)),\n                    sum(distance_matrix_2[candidate_segment[j], candidate_segment[(j+1)%seg_length]] for j in range(seg_length)),\n                    sum(distance_matrix_3[candidate_segment[j], candidate_segment[(j+1)%seg_length]] for j in range(seg_length))\n                )\n\n                # Calculate improvement\n                improvement = sum((cc - nc) for cc, nc in zip(current_cost, candidate_cost))\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_replacement = candidate_segment\n\n        if best_replacement is not None:\n            new_solution[start_pos:start_pos+seg_length] = best_replacement\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This new algorithm combines path segments from multiple archive solutions with adaptive weighting based on objective dominance, followed by a multi-objective edge swap operator that prioritizes Pareto-improving moves and incorporates a dynamic segment inversion mechanism to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return None\n\n    # Select solutions with adaptive weighting based on objective dominance\n    weights = np.array([sum(x[1]) for x in archive])\n    weights = np.max(weights) - weights + 1e-6  # Inverse weighting with small epsilon\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Create initial neighbor by combining segments with adaptive weights\n    new_solution = np.zeros(n, dtype=int)\n    segment_length = max(2, n // 4)\n    for i in range(0, n, segment_length):\n        segment_weights = np.array([sum(archive[j][1]) for j in range(min(3, len(archive)))])\n        segment_weights = np.max(segment_weights) - segment_weights + 1e-6\n        segment_weights = segment_weights / np.sum(segment_weights)\n        selected_segment = np.random.choice(min(3, len(archive)), p=segment_weights)\n        end = min(i + segment_length, n)\n        new_solution[i:end] = archive[selected_segment][0][i:end]\n\n    # Ensure all nodes are visited exactly once\n    missing_nodes = set(range(n)) - set(new_solution)\n    for node in missing_nodes:\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply multi-objective edge swap operator\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Calculate current and potential costs\n        current_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        ]\n\n        # Check for Pareto improvement\n        dominates = all(nc <= cc for nc, cc in zip(new_costs, current_costs)) and \\\n                    any(nc < cc for nc, cc in zip(new_costs, current_costs))\n        if dominates:\n            # Perform dynamic segment inversion\n            segment = new_solution[i+1:j+1]\n            if len(segment) > 1:\n                if np.random.rand() < 0.7:  # Higher probability for inversion\n                    new_solution[i+1:j+1] = segment[::-1]\n                else:\n                    # Random shuffle for diversity\n                    np.random.shuffle(segment)\n                    new_solution[i+1:j+1] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.6512202895129311,
            0.44331190586090086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return None\n\n    # Select solutions with adaptive weighting based on objective dominance\n    weights = np.array([sum(x[1]) for x in archive])\n    weights = np.max(weights) - weights + 1e-6  # Inverse weighting with small epsilon\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Create initial neighbor by combining segments with adaptive weights\n    new_solution = np.zeros(n, dtype=int)\n    segment_length = max(2, n // 4)\n    for i in range(0, n, segment_length):\n        segment_weights = np.array([sum(archive[j][1]) for j in range(min(3, len(archive)))])\n        segment_weights = np.max(segment_weights) - segment_weights + 1e-6\n        segment_weights = segment_weights / np.sum(segment_weights)\n        selected_segment = np.random.choice(min(3, len(archive)), p=segment_weights)\n        end = min(i + segment_length, n)\n        new_solution[i:end] = archive[selected_segment][0][i:end]\n\n    # Ensure all nodes are visited exactly once\n    missing_nodes = set(range(n)) - set(new_solution)\n    for node in missing_nodes:\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Apply multi-objective edge swap operator\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j:\n            continue\n\n        # Calculate current and potential costs\n        current_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        ]\n\n        # Check for Pareto improvement\n        dominates = all(nc <= cc for nc, cc in zip(new_costs, current_costs)) and \\\n                    any(nc < cc for nc, cc in zip(new_costs, current_costs))\n        if dominates:\n            # Perform dynamic segment inversion\n            segment = new_solution[i+1:j+1]\n            if len(segment) > 1:\n                if np.random.rand() < 0.7:  # Higher probability for inversion\n                    new_solution[i+1:j+1] = segment[::-1]\n                else:\n                    # Random shuffle for diversity\n                    np.random.shuffle(segment)\n                    new_solution[i+1:j+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive with the best balance across all three objectives, then performs a multi-objective-aware node relocation that intelligently moves nodes between segments while prioritizing improvement in the most underperforming objective, followed by a segment inversion step to further optimize the tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    base_solution = min(archive, key=lambda x: max(x[1]) - min(x[1]))[0]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective is most underperforming\n    current_costs = [sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))]\n    most_underperforming = current_costs.index(max(current_costs))\n\n    # Perform multi-objective-aware node relocation\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i == j:\n            continue\n\n        # Calculate cost change for the most underperforming objective\n        old_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[(i+1)%n]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[(i-1)%n], new_solution[i])\n\n        new_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[j]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[(i-1)%n], new_solution[(j+1)%n])\n\n        if new_cost < old_cost:\n            # Perform relocation\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = (j+1) % n\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Perform segment inversion for further optimization\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{This algorithm selects a solution from the archive with the highest diversity in objective performance, then performs a multi-objective crossover by combining path segments from multiple solutions while maintaining feasibility, followed by an adaptive edge optimization step that dynamically selects the best edge swaps based on their potential to improve the most underperforming objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = [max(obj) - min(obj) for (_, obj) in archive]\n    base_solution = archive[diversity_scores.index(max(diversity_scores))][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective crossover with random segment exchange\n    for _ in range(3):\n        other_sol = archive[np.random.randint(0, len(archive))][0]\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = other_sol[i:j]\n        new_solution[i:j] = segment\n\n    # Adaptive edge optimization\n    current_costs = [sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))]\n    most_underperforming = current_costs.index(max(current_costs))\n\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[(i+1)%n]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[j], new_solution[(j+1)%n])\n\n        new_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[j]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if new_cost < old_cost:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6446676669891698,
            0.28199890851974485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = [max(obj) - min(obj) for (_, obj) in archive]\n    base_solution = archive[diversity_scores.index(max(diversity_scores))][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective crossover with random segment exchange\n    for _ in range(3):\n        other_sol = archive[np.random.randint(0, len(archive))][0]\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = other_sol[i:j]\n        new_solution[i:j] = segment\n\n    # Adaptive edge optimization\n    current_costs = [sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                     sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))]\n    most_underperforming = current_costs.index(max(current_costs))\n\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[(i+1)%n]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[j], new_solution[(j+1)%n])\n\n        new_cost = getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[i], new_solution[j]) + \\\n                   getattr(distance_matrix_1 if most_underperforming == 0 else\n                          (distance_matrix_2 if most_underperforming == 1 else distance_matrix_3),\n                          'item')(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if new_cost < old_cost:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This new algorithm employs a diversity-aware selection mechanism that prioritizes solutions with high variance in their objective values, followed by a multi-phase local search that combines 2-opt swaps with objective-specific edge insertions to balance improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    obj_variances = np.var(objectives, axis=0)\n    weighted_scores = np.dot(objectives, obj_variances)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Initialize new solution\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: 2-opt swaps with objective-aware selection\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_costs = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n        new_costs = (\n            distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        )\n\n        if sum(new_costs) < sum(old_costs):\n            segment = new_solution[(i+1):(j+1)].copy()\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Phase 2: Objective-specific edge insertions\n    for _ in range(2):\n        obj_idx = np.random.choice([0, 1, 2])\n        if obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        while j == i or j == (i+1)%n:\n            j = np.random.randint(n)\n\n        if dist_matrix[new_solution[i], new_solution[j]] + dist_matrix[new_solution[(i+1)%n], new_solution[(j+1)%n]] < \\\n           dist_matrix[new_solution[i], new_solution[(i+1)%n]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]:\n            segment = new_solution[(i+1):(j+1)].copy()\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5933249587273041,
            0.5028881311416626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    obj_variances = np.var(objectives, axis=0)\n    weighted_scores = np.dot(objectives, obj_variances)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Initialize new solution\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: 2-opt swaps with objective-aware selection\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_costs = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n        new_costs = (\n            distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        )\n\n        if sum(new_costs) < sum(old_costs):\n            segment = new_solution[(i+1):(j+1)].copy()\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Phase 2: Objective-specific edge insertions\n    for _ in range(2):\n        obj_idx = np.random.choice([0, 1, 2])\n        if obj_idx == 0:\n            dist_matrix = distance_matrix_1\n        elif obj_idx == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        while j == i or j == (i+1)%n:\n            j = np.random.randint(n)\n\n        if dist_matrix[new_solution[i], new_solution[j]] + dist_matrix[new_solution[(i+1)%n], new_solution[(j+1)%n]] < \\\n           dist_matrix[new_solution[i], new_solution[(i+1)%n]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]:\n            segment = new_solution[(i+1):(j+1)].copy()\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from three archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements and includes a novel segment reversal mechanism to explore diverse neighborhoods.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2, sol3 = sorted_archive[0][0], sorted_archive[1][0], sorted_archive[2][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 4 == 0:\n            new_solution.append(sol1[i])\n        elif i % 4 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement with segment reversal\n    for _ in range(4):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform segment reversal\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{This new algorithm employs a multi-objective path merging strategy that interleaves segments from the top solutions in the archive with a probabilistic selection bias towards nodes that show improvement in at least one objective, followed by a dynamic 2-opt refinement that adaptively selects segments based on their potential to improve multiple objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0/(i+1) for i in range(min(5, len(archive)))]\n    weights = [w/sum(weights) for w in weights]\n    selected_indices = np.random.choice(min(5, len(archive)), 3, p=weights, replace=False)\n    selected_solutions = [archive[i][0] for i in selected_indices]\n\n    # Create new solution by interleaving segments with multi-objective improvement check\n    new_solution = []\n    n = len(selected_solutions[0])\n    for i in range(n):\n        # Select node from solution that shows improvement in at least one objective\n        candidates = []\n        for sol in selected_solutions:\n            node = sol[i]\n            if not node in new_solution:\n                # Check if this node improves any objective\n                if len(new_solution) > 0:\n                    last_node = new_solution[-1]\n                    old_cost = (distance_matrix_1[last_node, sol[i-1]] if i > 0 else 0,\n                               distance_matrix_2[last_node, sol[i-1]] if i > 0 else 0,\n                               distance_matrix_3[last_node, sol[i-1]] if i > 0 else 0)\n                    new_cost = (distance_matrix_1[last_node, node],\n                               distance_matrix_2[last_node, node],\n                               distance_matrix_3[last_node, node])\n                    if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n                        candidates.append(node)\n                else:\n                    candidates.append(node)\n\n        if candidates:\n            new_solution.append(np.random.choice(candidates))\n        else:\n            # If no improving nodes found, add any remaining node\n            remaining_nodes = set(range(n)) - set(new_solution)\n            if remaining_nodes:\n                new_solution.append(np.random.choice(list(remaining_nodes)))\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply dynamic 2-opt refinement based on multi-objective potential\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if segment reversal improves at least two objectives\n        improvement_count = sum(1 for nc, oc in zip(new_cost, old_cost) if nc < oc)\n        if improvement_count >= 2:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6810836775824002,
            0.7233720779418945
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0/(i+1) for i in range(min(5, len(archive)))]\n    weights = [w/sum(weights) for w in weights]\n    selected_indices = np.random.choice(min(5, len(archive)), 3, p=weights, replace=False)\n    selected_solutions = [archive[i][0] for i in selected_indices]\n\n    # Create new solution by interleaving segments with multi-objective improvement check\n    new_solution = []\n    n = len(selected_solutions[0])\n    for i in range(n):\n        # Select node from solution that shows improvement in at least one objective\n        candidates = []\n        for sol in selected_solutions:\n            node = sol[i]\n            if not node in new_solution:\n                # Check if this node improves any objective\n                if len(new_solution) > 0:\n                    last_node = new_solution[-1]\n                    old_cost = (distance_matrix_1[last_node, sol[i-1]] if i > 0 else 0,\n                               distance_matrix_2[last_node, sol[i-1]] if i > 0 else 0,\n                               distance_matrix_3[last_node, sol[i-1]] if i > 0 else 0)\n                    new_cost = (distance_matrix_1[last_node, node],\n                               distance_matrix_2[last_node, node],\n                               distance_matrix_3[last_node, node])\n                    if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n                        candidates.append(node)\n                else:\n                    candidates.append(node)\n\n        if candidates:\n            new_solution.append(np.random.choice(candidates))\n        else:\n            # If no improving nodes found, add any remaining node\n            remaining_nodes = set(range(n)) - set(new_solution)\n            if remaining_nodes:\n                new_solution.append(np.random.choice(list(remaining_nodes)))\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Apply dynamic 2-opt refinement based on multi-objective potential\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if segment reversal improves at least two objectives\n        improvement_count = sum(1 for nc, oc in zip(new_cost, old_cost) if nc < oc)\n        if improvement_count >= 2:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This new algorithm combines the strengths of both approaches by first selecting a solution based on a dynamic objective weighting scheme, then applies a multi-segment crossover with objective-aware edge refinement, followed by a hybrid 3-opt and node insertion local search to generate a neighbor solution while ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Multi-segment crossover with objective-aware selection\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        elif i % 3 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(base_solution[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Hybrid 3-opt and node insertion\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.6613416074246645,
            0.41277446746826174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Multi-segment crossover with objective-aware selection\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        elif i % 3 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(base_solution[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Hybrid 3-opt and node insertion\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{This new algorithm employs a multi-objective segment exchange operator that intelligently combines segments from two high-quality archive solutions while prioritizing edges that show improvement across all three objectives, followed by an adaptive 2-opt refinement step that dynamically adjusts the number of refinement iterations based on the solution's current quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = sorted(archive, key=lambda x: (x[1][0], x[1][1], x[1][2]))[0][0], sorted(archive, key=lambda x: (-x[1][0], -x[1][1], -x[1][2]))[0][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with improved edges\n    new_solution = []\n    i = 0\n    while i < n:\n        if i % 3 == 0:\n            # Take segment from sol1\n            segment_length = min(3, n - i)\n            new_solution.extend(sol1[i:i+segment_length])\n            i += segment_length\n        else:\n            # Take segment from sol2\n            segment_length = min(2, n - i)\n            new_solution.extend(sol2[i:i+segment_length])\n            i += segment_length\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Adaptive 2-opt refinement based on current solution quality\n    current_cost = sum(distance_matrix_1[new_solution, np.roll(new_solution, -1)] +\n                       distance_matrix_2[new_solution, np.roll(new_solution, -1)] +\n                       distance_matrix_3[new_solution, np.roll(new_solution, -1)])\n    max_refinements = 10 if current_cost > np.mean([sum(obj) for _, obj in archive]) else 5\n\n    for _ in range(max_refinements):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7032378557205325,
            3.5521695256233214
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = sorted(archive, key=lambda x: (x[1][0], x[1][1], x[1][2]))[0][0], sorted(archive, key=lambda x: (-x[1][0], -x[1][1], -x[1][2]))[0][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with improved edges\n    new_solution = []\n    i = 0\n    while i < n:\n        if i % 3 == 0:\n            # Take segment from sol1\n            segment_length = min(3, n - i)\n            new_solution.extend(sol1[i:i+segment_length])\n            i += segment_length\n        else:\n            # Take segment from sol2\n            segment_length = min(2, n - i)\n            new_solution.extend(sol2[i:i+segment_length])\n            i += segment_length\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Adaptive 2-opt refinement based on current solution quality\n    current_cost = sum(distance_matrix_1[new_solution, np.roll(new_solution, -1)] +\n                       distance_matrix_2[new_solution, np.roll(new_solution, -1)] +\n                       distance_matrix_3[new_solution, np.roll(new_solution, -1)])\n    max_refinements = 10 if current_cost > np.mean([sum(obj) for _, obj in archive]) else 5\n\n    for _ in range(max_refinements):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic weight vector that emphasizes objectives with higher variance, then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = (edge_cost(new_solution[i], new_solution[(i+1)%n])[0] + edge_cost(new_solution[j], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[(k+1)%n])[0] + edge_cost(new_solution[l], new_solution[(l+1)%n])[0],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[1] + edge_cost(new_solution[j], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[(k+1)%n])[1] + edge_cost(new_solution[l], new_solution[(l+1)%n])[1],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[2] + edge_cost(new_solution[j], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[(k+1)%n])[2] + edge_cost(new_solution[l], new_solution[(l+1)%n])[2])\n\n        new_cost1 = (edge_cost(new_solution[i], new_solution[j])[0] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[l])[0] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[0],\n                     edge_cost(new_solution[i], new_solution[j])[1] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[l])[1] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[1],\n                     edge_cost(new_solution[i], new_solution[j])[2] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[l])[2] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[2])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(k+1):(l+1)] = new_solution[(k+1):(l+1)][::-1]\n\n    # Apply objective-aware edge swaps\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8395743243752836,
            0.5916208982467651
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = (edge_cost(new_solution[i], new_solution[(i+1)%n])[0] + edge_cost(new_solution[j], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[(k+1)%n])[0] + edge_cost(new_solution[l], new_solution[(l+1)%n])[0],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[1] + edge_cost(new_solution[j], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[(k+1)%n])[1] + edge_cost(new_solution[l], new_solution[(l+1)%n])[1],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[2] + edge_cost(new_solution[j], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[(k+1)%n])[2] + edge_cost(new_solution[l], new_solution[(l+1)%n])[2])\n\n        new_cost1 = (edge_cost(new_solution[i], new_solution[j])[0] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[l])[0] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[0],\n                     edge_cost(new_solution[i], new_solution[j])[1] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[l])[1] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[1],\n                     edge_cost(new_solution[i], new_solution[j])[2] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[l])[2] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[2])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(k+1):(l+1)] = new_solution[(k+1):(l+1)][::-1]\n\n    # Apply objective-aware edge swaps\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{This new algorithm selects a solution from the archive using a dynamic weight vector that emphasizes objectives with higher variance, then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = (edge_cost(new_solution[i], new_solution[(i+1)%n])[0] + edge_cost(new_solution[j], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[(k+1)%n])[0] + edge_cost(new_solution[l], new_solution[(l+1)%n])[0],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[1] + edge_cost(new_solution[j], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[(k+1)%n])[1] + edge_cost(new_solution[l], new_solution[(l+1)%n])[1],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[2] + edge_cost(new_solution[j], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[(k+1)%n])[2] + edge_cost(new_solution[l], new_solution[(l+1)%n])[2])\n\n        new_cost1 = (edge_cost(new_solution[i], new_solution[j])[0] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[l])[0] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[0],\n                     edge_cost(new_solution[i], new_solution[j])[1] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[l])[1] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[1],\n                     edge_cost(new_solution[i], new_solution[j])[2] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[l])[2] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[2])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(k+1):(l+1)] = new_solution[(k+1):(l+1)][::-1]\n\n    # Apply objective-aware edge swaps\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8395743243752836,
            0.5916208982467651
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = (edge_cost(new_solution[i], new_solution[(i+1)%n])[0] + edge_cost(new_solution[j], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[(k+1)%n])[0] + edge_cost(new_solution[l], new_solution[(l+1)%n])[0],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[1] + edge_cost(new_solution[j], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[(k+1)%n])[1] + edge_cost(new_solution[l], new_solution[(l+1)%n])[1],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[2] + edge_cost(new_solution[j], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[(k+1)%n])[2] + edge_cost(new_solution[l], new_solution[(l+1)%n])[2])\n\n        new_cost1 = (edge_cost(new_solution[i], new_solution[j])[0] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[l])[0] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[0],\n                     edge_cost(new_solution[i], new_solution[j])[1] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[l])[1] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[1],\n                     edge_cost(new_solution[i], new_solution[j])[2] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[l])[2] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[2])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(k+1):(l+1)] = new_solution[(k+1):(l+1)][::-1]\n\n    # Apply objective-aware edge swaps\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This new algorithm employs a multi-objective crossover operator that combines segments from top-performing solutions in each objective space separately, followed by a guided local search that prioritizes edges with balanced improvements across all three objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive1 = sorted(archive, key=lambda x: x[1][0])\n    sorted_archive2 = sorted(archive, key=lambda x: x[1][1])\n    sorted_archive3 = sorted(archive, key=lambda x: x[1][2])\n\n    sol1 = sorted_archive1[0][0]\n    sol2 = sorted_archive2[0][0]\n    sol3 = sorted_archive3[0][0]\n    n = len(sol1)\n\n    # Create new solution by interleaving segments from top solutions\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        elif i % 3 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Guided local search with balanced objective improvements\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check for balanced improvement across all objectives\n        if sum(nc < oc for nc, oc in zip(new_cost, old_cost)) >= 2:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7078878527541026,
            0.21047203540802
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive1 = sorted(archive, key=lambda x: x[1][0])\n    sorted_archive2 = sorted(archive, key=lambda x: x[1][1])\n    sorted_archive3 = sorted(archive, key=lambda x: x[1][2])\n\n    sol1 = sorted_archive1[0][0]\n    sol2 = sorted_archive2[0][0]\n    sol3 = sorted_archive3[0][0]\n    n = len(sol1)\n\n    # Create new solution by interleaving segments from top solutions\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        elif i % 3 == 1:\n            new_solution.append(sol2[i])\n        else:\n            new_solution.append(sol3[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    new_solution = np.array(new_solution)\n\n    # Guided local search with balanced objective improvements\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check for balanced improvement across all objectives\n        if sum(nc < oc for nc, oc in zip(new_cost, old_cost)) >= 2:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a hybrid local search operator that combines path segments from two archive solutions with a biased selection towards solutions with lower combined objective values, followed by an objective-specific edge refinement step that prioritizes edges with better individual objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    sol1, sol2 = sorted_archive[0][0], sorted_archive[1][0]\n    n = len(sol1)\n\n    # Create a new solution by combining segments with preference for better objectives\n    new_solution = []\n    for i in range(n):\n        if i % 3 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-specific edge refinement\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]],\n                    distance_matrix_2[new_solution[i], new_solution[j]],\n                    distance_matrix_3[new_solution[i], new_solution[j]])\n\n        # Check if any individual objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware path reversal to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware path reversal\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional path reversal between i and k\n        if i != j and j != k:\n            old_cost_rev = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n            new_cost_rev = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[(i+1)%n], new_solution[(k+1)%n])\n\n            if any(new < old for new, old in zip(new_cost_rev, old_cost_rev)):\n                segment = new_solution[(i+1):(k+1)]\n                new_solution[(i+1):(k+1)] = segment[::-1]\n\n    # Apply objective-aware node swap\n    for _ in range(2):\n        a, b = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        if not any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7678666899023968,
            0.5283010244369507
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware path reversal\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional path reversal between i and k\n        if i != j and j != k:\n            old_cost_rev = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n            new_cost_rev = edge_cost(new_solution[i], new_solution[k]) + edge_cost(new_solution[(i+1)%n], new_solution[(k+1)%n])\n\n            if any(new < old for new, old in zip(new_cost_rev, old_cost_rev)):\n                segment = new_solution[(i+1):(k+1)]\n                new_solution[(i+1):(k+1)] = segment[::-1]\n\n    # Apply objective-aware node swap\n    for _ in range(2):\n        a, b = np.random.choice(n, 2, replace=False)\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        if not any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive using a weighted random selection based on Pareto dominance and objective diversity, then applies a hybrid local search combining 3-opt with multi-objective aware node reinsertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0 / (1 + sum(x[1])) for x in archive])\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with multi-objective awareness\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        # Reverse the middle segment\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(j-1)%n], new_solution[j]])\n        ]\n\n        # Accept if at least one objective improves\n        if any(any(nc < oc for nc, oc in zip(nc, oc)) for nc, oc in zip(new_costs, old_costs[:2])):\n            break\n        else:\n            # Revert if no improvement\n            new_solution[(i+1):(j+1)] = segment\n\n    # Multi-objective aware node reinsertion\n    for _ in range(3):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This new algorithm selects a solution from the archive using a diversity-aware tournament selection based on the spread of objective values, then applies a novel multi-objective edge exchange operator that considers both local and global improvement potential across all three objectives, followed by a Pareto-optimality preserving node reinsertion step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = archive[0]\n    for candidate in random.sample(archive, min(5, len(archive))):\n        if (sum(candidate[1]) > sum(selected[1])) or \\\n           (sum(candidate[1]) == sum(selected[1]) and random.random() > 0.5):\n            selected = candidate\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge exchange operator\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        old_edges = [\n            (new_solution[a], new_solution[(a+1)%n]),\n            (new_solution[b], new_solution[(b+1)%n]),\n            (new_solution[c], new_solution[(c+1)%n])\n        ]\n        old_costs = [\n            (distance_matrix_1[e1, e2], distance_matrix_2[e1, e2], distance_matrix_3[e1, e2])\n            for e1, e2 in old_edges\n        ]\n\n        # Create new edges by connecting nodes in a different order\n        new_edges = [\n            (new_solution[a], new_solution[c]),\n            (new_solution[b], new_solution[a]),\n            (new_solution[c], new_solution[b])\n        ]\n        new_costs = [\n            (distance_matrix_1[e1, e2], distance_matrix_2[e1, e2], distance_matrix_3[e1, e2])\n            for e1, e2 in new_edges\n        ]\n\n        # Calculate improvement across all objectives\n        improvement = sum(\n            sum(oc - nc for oc, nc in zip(oc, nc))\n            for oc, nc in zip(old_costs, new_costs)\n        )\n\n        if improvement > 0:\n            # Perform the edge exchange\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Pareto-optimality preserving node reinsertion\n    for _ in range(2):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        best_pos = 0\n        best_improvement = 0\n\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, node)\n            old_edges = [\n                (temp_solution[pos-1], temp_solution[pos]),\n                (temp_solution[pos], temp_solution[(pos+1)%n])\n            ]\n            new_edges = [\n                (temp_solution[pos-1], temp_solution[pos]),\n                (temp_solution[pos], temp_solution[(pos+1)%n])\n            ]\n            old_costs = [\n                (distance_matrix_1[e1, e2], distance_matrix_2[e1, e2], distance_matrix_3[e1, e2])\n                for e1, e2 in old_edges\n            ]\n            new_costs = [\n                (distance_matrix_1[e1, e2], distance_matrix_2[e1, e2], distance_matrix_3[e1, e2])\n                for e1, e2 in new_edges\n            ]\n            improvement = sum(\n                sum(oc - nc for oc, nc in zip(oc, nc))\n                for oc, nc in zip(old_costs, new_costs)\n            )\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.722911983536689,
            1.0259348630905152
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = archive[0]\n    for candidate in random.sample(archive, min(5, len(archive))):\n        if (sum(candidate[1]) > sum(selected[1])) or \\\n           (sum(candidate[1]) == sum(selected[1]) and random.random() > 0.5):\n            selected = candidate\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge exchange operator\n    for _ in range(3):\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        old_edges = [\n            (new_solution[a], new_solution[(a+1)%n]),\n            (new_solution[b], new_solution[(b+1)%n]),\n            (new_solution[c], new_solution[(c+1)%n])\n        ]\n        old_costs = [\n            (distance_matrix_1[e1, e2], distance_matrix_2[e1, e2], distance_matrix_3[e1, e2])\n            for e1, e2 in old_edges\n        ]\n\n        # Create new edges by connecting nodes in a different order\n        new_edges = [\n            (new_solution[a], new_solution[c]),\n            (new_solution[b], new_solution[a]),\n            (new_solution[c], new_solution[b])\n        ]\n        new_costs = [\n            (distance_matrix_1[e1, e2], distance_matrix_2[e1, e2], distance_matrix_3[e1, e2])\n            for e1, e2 in new_edges\n        ]\n\n        # Calculate improvement across all objectives\n        improvement = sum(\n            sum(oc - nc for oc, nc in zip(oc, nc))\n            for oc, nc in zip(old_costs, new_costs)\n        )\n\n        if improvement > 0:\n            # Perform the edge exchange\n            new_solution[(a+1):(b+1)] = new_solution[(a+1):(b+1)][::-1]\n            new_solution[(b+1):(c+1)] = new_solution[(b+1):(c+1)][::-1]\n\n    # Pareto-optimality preserving node reinsertion\n    for _ in range(2):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        best_pos = 0\n        best_improvement = 0\n\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, node)\n            old_edges = [\n                (temp_solution[pos-1], temp_solution[pos]),\n                (temp_solution[pos], temp_solution[(pos+1)%n])\n            ]\n            new_edges = [\n                (temp_solution[pos-1], temp_solution[pos]),\n                (temp_solution[pos], temp_solution[(pos+1)%n])\n            ]\n            old_costs = [\n                (distance_matrix_1[e1, e2], distance_matrix_2[e1, e2], distance_matrix_3[e1, e2])\n                for e1, e2 in old_edges\n            ]\n            new_costs = [\n                (distance_matrix_1[e1, e2], distance_matrix_2[e1, e2], distance_matrix_3[e1, e2])\n                for e1, e2 in new_edges\n            ]\n            improvement = sum(\n                sum(oc - nc for oc, nc in zip(oc, nc))\n                for oc, nc in zip(old_costs, new_costs)\n            )\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive with the best combined objective value, then performs a multi-objective aware 2-opt swap that prioritizes improving at least one objective while maintaining feasibility, with additional node reinsertion steps to ensure all nodes are visited exactly once.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Accept if at least one objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This new algorithm selects a solution from the archive based on the most balanced objective values (minimizing the maximum objective) and performs a multi-objective aware 3-opt swap that ensures at least two objectives improve while maintaining feasibility, followed by a node reinsertion step to guarantee all nodes are visited exactly once.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: max(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 3-opt\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[k], new_solution[(i+1)%n]]\n        )\n\n        # Accept if at least two objectives improve\n        if sum(nc < oc for nc, oc in zip(new_cost, old_cost)) >= 2:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6736936233158375,
            1.8776280760765076
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: max(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 3-opt\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[k], new_solution[(i+1)%n]]\n        )\n\n        # Accept if at least two objectives improve\n        if sum(nc < oc for nc, oc in zip(new_cost, old_cost)) >= 2:\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive using a weighted random selection based on Pareto dominance and objective diversity, then applies a hybrid local search combining 3-opt with multi-objective aware node reinsertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0 / (1 + sum(x[1])) for x in archive])\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with multi-objective awareness\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        # Reverse the middle segment\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(j-1)%n], new_solution[j]])\n        ]\n\n        # Accept if at least one objective improves\n        if any(any(nc < oc for nc, oc in zip(nc, oc)) for nc, oc in zip(new_costs, old_costs[:2])):\n            break\n        else:\n            # Revert if no improvement\n            new_solution[(i+1):(j+1)] = segment\n\n    # Multi-objective aware node reinsertion\n    for _ in range(3):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This new algorithm selects a solution from the archive using a crowding-distance-based selection, then applies a multi-objective guided segment inversion that prioritizes improving the most under-represented objective in the archive, while ensuring feasibility through a node reinsertion mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the most under-represented objective\n    obj_counts = np.array([len(np.where(objectives[:, m] == objectives[selected_idx, m])[0]) for m in range(3)])\n    target_obj = np.argmin(obj_counts)\n\n    # Apply multi-objective guided segment inversion\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(j-1)%n], new_solution[j]])\n        ]\n\n        # Accept if the target objective improves\n        if new_costs[0][target_obj] + new_costs[1][target_obj] < old_costs[0][target_obj] + old_costs[1][target_obj]:\n            break\n        else:\n            new_solution[(i+1):(j+1)] = segment\n\n    # Ensure feasibility through node reinsertion\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.616081829139089,
            0.9163853645324707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(3):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the most under-represented objective\n    obj_counts = np.array([len(np.where(objectives[:, m] == objectives[selected_idx, m])[0]) for m in range(3)])\n    target_obj = np.argmin(obj_counts)\n\n    # Apply multi-objective guided segment inversion\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(j-1)%n], new_solution[j]])\n        ]\n\n        # Accept if the target objective improves\n        if new_costs[0][target_obj] + new_costs[1][target_obj] < old_costs[0][target_obj] + old_costs[1][target_obj]:\n            break\n        else:\n            new_solution[(i+1):(j+1)] = segment\n\n    # Ensure feasibility through node reinsertion\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2-opt with objective-aware node swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware node swapping\n    for _ in range(3):\n        i, j = np.random.choice(n, 2, replace=False)\n\n        def node_cost(a, b):\n            return (distance_matrix_1[a, b] + distance_matrix_1[b, a], distance_matrix_2[a, b] + distance_matrix_2[b, a], distance_matrix_3[a, b] + distance_matrix_3[b, a])\n\n        old_cost = node_cost(new_solution[i], new_solution[(i-1)%n]) + node_cost(new_solution[i], new_solution[(i+1)%n])\n        new_cost = node_cost(new_solution[j], new_solution[(i-1)%n]) + node_cost(new_solution[j], new_solution[(i+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7773789317105858,
            0.5579061388969422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge selection\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n\n    # Apply objective-aware node swapping\n    for _ in range(3):\n        i, j = np.random.choice(n, 2, replace=False)\n\n        def node_cost(a, b):\n            return (distance_matrix_1[a, b] + distance_matrix_1[b, a], distance_matrix_2[a, b] + distance_matrix_2[b, a], distance_matrix_3[a, b] + distance_matrix_3[b, a])\n\n        old_cost = node_cost(new_solution[i], new_solution[(i-1)%n]) + node_cost(new_solution[i], new_solution[(i+1)%n])\n        new_cost = node_cost(new_solution[j], new_solution[(i-1)%n]) + node_cost(new_solution[j], new_solution[(i+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive using a dynamic weight vector that emphasizes objectives with higher variance, then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = (edge_cost(new_solution[i], new_solution[(i+1)%n])[0] + edge_cost(new_solution[j], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[(k+1)%n])[0] + edge_cost(new_solution[l], new_solution[(l+1)%n])[0],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[1] + edge_cost(new_solution[j], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[(k+1)%n])[1] + edge_cost(new_solution[l], new_solution[(l+1)%n])[1],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[2] + edge_cost(new_solution[j], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[(k+1)%n])[2] + edge_cost(new_solution[l], new_solution[(l+1)%n])[2])\n\n        new_cost1 = (edge_cost(new_solution[i], new_solution[j])[0] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[l])[0] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[0],\n                     edge_cost(new_solution[i], new_solution[j])[1] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[l])[1] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[1],\n                     edge_cost(new_solution[i], new_solution[j])[2] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[l])[2] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[2])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(k+1):(l+1)] = new_solution[(k+1):(l+1)][::-1]\n\n    # Apply objective-aware edge swaps\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step to further optimize the solution across all three objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if sum(new_cost) < sum(old_cost):\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This new algorithm selects a solution from the archive based on a composite score combining objective improvements and spatial diversity, then applies a novel \"multi-objective edge insertion\" operator that intelligently reinserts segments of the tour while balancing improvements across all three objectives and maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity = np.mean(np.std([sol for sol, _ in archive], axis=0))\n    scores = np.sum(normalized, axis=1) + 0.3 * diversity\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge insertion operator\n    for _ in range(3):\n        # Select a random segment\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Calculate current segment cost\n        current_cost = (sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1)),\n                        sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1)),\n                        sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1)))\n\n        # Find best insertion point\n        best_pos = -1\n        best_improvement = 0\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Calculate insertion cost\n            left = new_solution[pos]\n            right = new_solution[(pos+1)%n]\n            new_cost = (distance_matrix_1[left, segment[0]] + distance_matrix_1[segment[-1], right] - distance_matrix_1[left, right],\n                        distance_matrix_2[left, segment[0]] + distance_matrix_2[segment[-1], right] - distance_matrix_2[left, right],\n                        distance_matrix_3[left, segment[0]] + distance_matrix_3[segment[-1], right] - distance_matrix_3[left, right])\n\n            # Calculate improvement score (weighted sum of normalized improvements)\n            improvement = np.sum((np.array(current_cost) - np.array(new_cost)) / (np.array(current_cost) + 1e-8))\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Perform insertion\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos+1],\n                segment,\n                new_solution[best_pos+1:]\n            ])\n            new_solution = new_solution[:n]  # Ensure correct length\n\n    return new_solution\n\n",
        "score": [
            -0.6789607706694457,
            0.6510940670967102
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity = np.mean(np.std([sol for sol, _ in archive], axis=0))\n    scores = np.sum(normalized, axis=1) + 0.3 * diversity\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge insertion operator\n    for _ in range(3):\n        # Select a random segment\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Calculate current segment cost\n        current_cost = (sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1)),\n                        sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1)),\n                        sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1)))\n\n        # Find best insertion point\n        best_pos = -1\n        best_improvement = 0\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Calculate insertion cost\n            left = new_solution[pos]\n            right = new_solution[(pos+1)%n]\n            new_cost = (distance_matrix_1[left, segment[0]] + distance_matrix_1[segment[-1], right] - distance_matrix_1[left, right],\n                        distance_matrix_2[left, segment[0]] + distance_matrix_2[segment[-1], right] - distance_matrix_2[left, right],\n                        distance_matrix_3[left, segment[0]] + distance_matrix_3[segment[-1], right] - distance_matrix_3[left, right])\n\n            # Calculate improvement score (weighted sum of normalized improvements)\n            improvement = np.sum((np.array(current_cost) - np.array(new_cost)) / (np.array(current_cost) + 1e-8))\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Perform insertion\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos+1],\n                segment,\n                new_solution[best_pos+1:]\n            ])\n            new_solution = new_solution[:n]  # Ensure correct length\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{This new algorithm dynamically selects a solution from the archive based on a Pareto-frontier proximity metric, then applies a hybrid local search combining 2-opt with multi-objective edge swapping to generate a neighbor solution, ensuring feasibility and potential improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = objectives[np.all(np.logical_or.reduce([objectives <= obj for obj in objectives]), axis=1)]\n    if len(pareto_front) == 0:\n        pareto_front = objectives\n\n    # Select solution closest to the Pareto frontier\n    distances = [np.min(np.sum(np.abs(objectives - pf), axis=1)) for pf in pareto_front]\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with multi-objective edge swapping\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Apply multi-objective edge swapping\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[(b+1)%n]) + edge_cost(new_solution[b], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a+1], new_solution[b] = new_solution[b], new_solution[a+1]\n\n    return new_solution\n\n",
        "score": [
            -0.6454129020030381,
            0.8469435334205627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = objectives[np.all(np.logical_or.reduce([objectives <= obj for obj in objectives]), axis=1)]\n    if len(pareto_front) == 0:\n        pareto_front = objectives\n\n    # Select solution closest to the Pareto frontier\n    distances = [np.min(np.sum(np.abs(objectives - pf), axis=1)) for pf in pareto_front]\n    selected_idx = np.argmin(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with multi-objective edge swapping\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Apply multi-objective edge swapping\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[a], new_solution[b]) + edge_cost(new_solution[(a+1)%n], new_solution[(b+1)%n])\n        new_cost = edge_cost(new_solution[a], new_solution[(b+1)%n]) + edge_cost(new_solution[b], new_solution[(a+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a+1], new_solution[b] = new_solution[b], new_solution[a+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive with the best combined objective value, then performs a multi-objective aware 2-opt swap that prioritizes improving at least one objective while maintaining feasibility, with additional node reinsertion steps to ensure all nodes are visited exactly once.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Perform multi-objective aware 2-opt\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]\n        )\n        new_cost = (\n            distance_matrix_1[new_solution[i], new_solution[j]],\n            distance_matrix_2[new_solution[i], new_solution[j]],\n            distance_matrix_3[new_solution[i], new_solution[j]]\n        )\n\n        # Accept if at least one objective improves\n        if any(nc < oc for nc, oc in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive using a weighted random selection based on Pareto dominance and objective diversity, then applies a hybrid local search combining 3-opt with multi-objective aware node reinsertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0 / (1 + sum(x[1])) for x in archive])\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with multi-objective awareness\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        # Reverse the middle segment\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(j-1)%n], new_solution[j]])\n        ]\n\n        # Accept if at least one objective improves\n        if any(any(nc < oc for nc, oc in zip(nc, oc)) for nc, oc in zip(new_costs, old_costs[:2])):\n            break\n        else:\n            # Revert if no improvement\n            new_solution[(i+1):(j+1)] = segment\n\n    # Multi-objective aware node reinsertion\n    for _ in range(3):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{This new algorithm selects a solution from the archive with the highest objective diversity, then applies a multi-objective aware segment inversion with adaptive step size and probabilistic acceptance based on Pareto dominance, while ensuring feasibility through a novel node reallocation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = [max(x[1]) - min(x[1]) for x in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion with probabilistic acceptance\n    for step_size in range(2, min(6, n//2)):\n        i = np.random.randint(0, n - step_size)\n        segment = new_solution[i:i+step_size]\n        old_costs = [\n            (distance_matrix_1[new_solution[i-1], new_solution[i]],\n             distance_matrix_2[new_solution[i-1], new_solution[i]],\n             distance_matrix_3[new_solution[i-1], new_solution[i]]),\n            (distance_matrix_1[new_solution[i+step_size-1], new_solution[(i+step_size)%n]],\n             distance_matrix_2[new_solution[i+step_size-1], new_solution[(i+step_size)%n]],\n             distance_matrix_3[new_solution[i+step_size-1], new_solution[(i+step_size)%n]])\n        ]\n\n        new_solution[i:i+step_size] = segment[::-1]\n        new_costs = [\n            (distance_matrix_1[new_solution[i-1], new_solution[i]],\n             distance_matrix_2[new_solution[i-1], new_solution[i]],\n             distance_matrix_3[new_solution[i-1], new_solution[i]]),\n            (distance_matrix_1[new_solution[i+step_size-1], new_solution[(i+step_size)%n]],\n             distance_matrix_2[new_solution[i+step_size-1], new_solution[(i+step_size)%n]],\n             distance_matrix_3[new_solution[i+step_size-1], new_solution[(i+step_size)%n]])\n        ]\n\n        # Probabilistic acceptance based on Pareto dominance\n        improvement = sum(1 for nc, oc in zip(new_costs, old_costs) if any(n < o for n, o in zip(nc, oc)))\n        if improvement < 2 and np.random.random() > 0.3:\n            new_solution[i:i+step_size] = segment\n\n    # Node reallocation mechanism\n    for _ in range(3):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        # Find best insertion position considering all objectives\n        best_pos = 0\n        min_cost = float('inf')\n        for pos in range(len(new_solution)):\n            cost = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                    distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]] +\n                    distance_matrix_3[new_solution[pos-1], node] + distance_matrix_3[node, new_solution[pos]])\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            new_solution = np.append(new_solution, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5624661907329997,
            0.5303039431571961
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = [max(x[1]) - min(x[1]) for x in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion with probabilistic acceptance\n    for step_size in range(2, min(6, n//2)):\n        i = np.random.randint(0, n - step_size)\n        segment = new_solution[i:i+step_size]\n        old_costs = [\n            (distance_matrix_1[new_solution[i-1], new_solution[i]],\n             distance_matrix_2[new_solution[i-1], new_solution[i]],\n             distance_matrix_3[new_solution[i-1], new_solution[i]]),\n            (distance_matrix_1[new_solution[i+step_size-1], new_solution[(i+step_size)%n]],\n             distance_matrix_2[new_solution[i+step_size-1], new_solution[(i+step_size)%n]],\n             distance_matrix_3[new_solution[i+step_size-1], new_solution[(i+step_size)%n]])\n        ]\n\n        new_solution[i:i+step_size] = segment[::-1]\n        new_costs = [\n            (distance_matrix_1[new_solution[i-1], new_solution[i]],\n             distance_matrix_2[new_solution[i-1], new_solution[i]],\n             distance_matrix_3[new_solution[i-1], new_solution[i]]),\n            (distance_matrix_1[new_solution[i+step_size-1], new_solution[(i+step_size)%n]],\n             distance_matrix_2[new_solution[i+step_size-1], new_solution[(i+step_size)%n]],\n             distance_matrix_3[new_solution[i+step_size-1], new_solution[(i+step_size)%n]])\n        ]\n\n        # Probabilistic acceptance based on Pareto dominance\n        improvement = sum(1 for nc, oc in zip(new_costs, old_costs) if any(n < o for n, o in zip(nc, oc)))\n        if improvement < 2 and np.random.random() > 0.3:\n            new_solution[i:i+step_size] = segment\n\n    # Node reallocation mechanism\n    for _ in range(3):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        # Find best insertion position considering all objectives\n        best_pos = 0\n        min_cost = float('inf')\n        for pos in range(len(new_solution)):\n            cost = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                    distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]] +\n                    distance_matrix_3[new_solution[pos-1], node] + distance_matrix_3[node, new_solution[pos]])\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            new_solution = np.append(new_solution, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm employs a multi-objective crossover-inspired operator that combines segments from two randomly selected archive solutions while maintaining feasibility, followed by an objective-aware edge refinement step that prioritizes edges with the highest potential for improvement across all three objectives, using a weighted sum of normalized objective improvements.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Create a new solution by alternating segments from both solutions\n    new_solution = []\n    for i in range(n):\n        if i % 2 == 0:\n            new_solution.append(sol1[i])\n        else:\n            new_solution.append(sol2[i])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution.insert(insert_pos, node)\n\n    # Convert to numpy array\n    new_solution = np.array(new_solution)\n\n    # Apply objective-aware edge refinement with weighted improvement\n    for _ in range(5):  # Perform 5 refinement steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[i], new_solution[(i+1)%n]],\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j]],\n                    distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        # Calculate weighted improvement across objectives\n        improvement = (old_cost[0] - new_cost[0]) + (old_cost[1] - new_cost[1])\n\n        if improvement > 0:\n            # Perform 2-opt swap\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{This new algorithm employs a multi-objective path relinking approach that combines segments from two solutions while prioritizing edges that show the highest potential for improvement across all three objectives, followed by a dynamic edge insertion step that selectively inserts promising nodes based on their normalized objective contributions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Initialize new solution with first solution\n    new_solution = sol1.copy()\n\n    # Path relinking with dynamic edge selection\n    for i in range(n):\n        # Calculate potential edges between current and target solutions\n        current_node = new_solution[i]\n        target_node = sol2[i]\n\n        # Calculate potential improvements for all possible edges\n        improvements = []\n        for j in range(n):\n            if j != i:\n                old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n                new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[i], new_solution[j]])\n                improvement = old_cost - new_cost\n                improvements.append((improvement, j))\n\n        # Select the edge with the highest improvement\n        improvements.sort(reverse=True, key=lambda x: x[0])\n        if improvements and improvements[0][0] > 0:\n            best_j = improvements[0][1]\n            # Perform swap to improve the solution\n            new_solution[i], new_solution[best_j] = new_solution[best_j], new_solution[i]\n\n    # Dynamic edge insertion step\n    for _ in range(3):\n        # Select a random segment to modify\n        start = np.random.randint(0, n)\n        end = np.random.randint(start, n)\n        segment = new_solution[start:end+1]\n\n        # Calculate potential nodes to insert\n        candidates = set(range(n)) - set(segment)\n        if not candidates:\n            continue\n\n        best_node = None\n        best_improvement = 0\n\n        for node in candidates:\n            for pos in range(len(segment)):\n                # Calculate improvement for inserting node at position pos\n                old_cost = (distance_matrix_1[segment[pos-1], segment[pos]] +\n                            distance_matrix_2[segment[pos-1], segment[pos]] +\n                            distance_matrix_3[segment[pos-1], segment[pos]])\n                new_cost = (distance_matrix_1[segment[pos-1], node] +\n                            distance_matrix_2[segment[pos-1], node] +\n                            distance_matrix_3[segment[pos-1], node] +\n                            distance_matrix_1[node, segment[pos]] +\n                            distance_matrix_2[node, segment[pos]] +\n                            distance_matrix_3[node, segment[pos]])\n                improvement = old_cost - new_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_node = node\n                    best_pos = pos\n\n        if best_node is not None:\n            # Insert the best node\n            new_segment = np.insert(segment, best_pos, best_node)\n            new_solution = np.concatenate([new_solution[:start], new_segment, new_solution[end+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6119485452623945,
            3.1824317455291746
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, sol2 = random.sample(archive, 2)\n    sol1, sol2 = sol1[0], sol2[0]\n    n = len(sol1)\n\n    # Initialize new solution with first solution\n    new_solution = sol1.copy()\n\n    # Path relinking with dynamic edge selection\n    for i in range(n):\n        # Calculate potential edges between current and target solutions\n        current_node = new_solution[i]\n        target_node = sol2[i]\n\n        # Calculate potential improvements for all possible edges\n        improvements = []\n        for j in range(n):\n            if j != i:\n                old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n                new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                            distance_matrix_2[new_solution[i], new_solution[j]] +\n                            distance_matrix_3[new_solution[i], new_solution[j]])\n                improvement = old_cost - new_cost\n                improvements.append((improvement, j))\n\n        # Select the edge with the highest improvement\n        improvements.sort(reverse=True, key=lambda x: x[0])\n        if improvements and improvements[0][0] > 0:\n            best_j = improvements[0][1]\n            # Perform swap to improve the solution\n            new_solution[i], new_solution[best_j] = new_solution[best_j], new_solution[i]\n\n    # Dynamic edge insertion step\n    for _ in range(3):\n        # Select a random segment to modify\n        start = np.random.randint(0, n)\n        end = np.random.randint(start, n)\n        segment = new_solution[start:end+1]\n\n        # Calculate potential nodes to insert\n        candidates = set(range(n)) - set(segment)\n        if not candidates:\n            continue\n\n        best_node = None\n        best_improvement = 0\n\n        for node in candidates:\n            for pos in range(len(segment)):\n                # Calculate improvement for inserting node at position pos\n                old_cost = (distance_matrix_1[segment[pos-1], segment[pos]] +\n                            distance_matrix_2[segment[pos-1], segment[pos]] +\n                            distance_matrix_3[segment[pos-1], segment[pos]])\n                new_cost = (distance_matrix_1[segment[pos-1], node] +\n                            distance_matrix_2[segment[pos-1], node] +\n                            distance_matrix_3[segment[pos-1], node] +\n                            distance_matrix_1[node, segment[pos]] +\n                            distance_matrix_2[node, segment[pos]] +\n                            distance_matrix_3[node, segment[pos]])\n                improvement = old_cost - new_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_node = node\n                    best_pos = pos\n\n        if best_node is not None:\n            # Insert the best node\n            new_segment = np.insert(segment, best_pos, best_node)\n            new_solution = np.concatenate([new_solution[:start], new_segment, new_solution[end+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost1 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost2 = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = np.concatenate([segment[k-i:], segment[:k-i]])\n\n    # Apply objective-aware node insertion\n    for _ in range(2):\n        node = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[pos]] + distance_matrix_1[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[pos]] + distance_matrix_2[new_solution[node], new_solution[(pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[pos]] + distance_matrix_3[new_solution[node], new_solution[(pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 4-opt with objective-aware edge swapping to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = (edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) +\n                     edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n]))\n\n        new_cost1 = (edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) +\n                     edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n]))\n\n        new_cost2 = (edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) +\n                     edge_cost(new_solution[(j+1)%n], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n]))\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(k+1):(l+1)] = new_solution[(k+1):(l+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment2, segment1])\n\n    # Apply objective-aware edge swapping\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7838822476641332,
            0.5566498279571533
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = (edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) +\n                     edge_cost(new_solution[k], new_solution[(k+1)%n]) + edge_cost(new_solution[l], new_solution[(l+1)%n]))\n\n        new_cost1 = (edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n]) +\n                     edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n]))\n\n        new_cost2 = (edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[k]) +\n                     edge_cost(new_solution[(j+1)%n], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n]))\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(k+1):(l+1)] = new_solution[(k+1):(l+1)][::-1]\n        elif any(new < old for new, old in zip(new_cost2, old_cost)):\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment2, segment1])\n\n    # Apply objective-aware edge swapping\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                    distance_matrix_1[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                    distance_matrix_2[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] +\n                    distance_matrix_3[new_solution[b], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(b+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 2.5-opt with objective-aware node relocation to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2.5-opt with objective-aware edge selection\n    for _ in range(4):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment = new_solution[(i+1):(j+1)]\n            new_solution[(i+1):(j+1)] = segment[::-1]\n\n        # Additional 2.5-opt move\n        if np.random.rand() < 0.5:\n            l = np.random.randint(0, n)\n            new_cost = edge_cost(new_solution[k], new_solution[l]) + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])\n            if any(new < old for new, old in zip(new_cost, old_cost)):\n                segment = new_solution[(k+1):(l+1)]\n                new_solution[(k+1):(l+1)] = segment[::-1]\n\n    # Apply objective-aware node relocation\n    for _ in range(3):\n        node = np.random.randint(0, n)\n        old_pos = node\n        new_pos = np.random.randint(0, n)\n\n        old_cost = (distance_matrix_1[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[(node-1)%n]] + distance_matrix_3[new_solution[node], new_solution[(node+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[node], new_solution[new_pos]] + distance_matrix_1[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_2[new_solution[node], new_solution[new_pos]] + distance_matrix_2[new_solution[node], new_solution[(new_pos+1)%n]],\n                    distance_matrix_3[new_solution[node], new_solution[new_pos]] + distance_matrix_3[new_solution[node], new_solution[(new_pos+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            node_val = new_solution[node]\n            new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n            new_solution = np.insert(new_solution, new_pos, node_val)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[j], new_solution[k]) + edge_cost(new_solution[k], new_solution[(i+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Apply objective-aware edge swaps\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7474869840190346,
            0.49679983854293824
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = edge_cost(new_solution[i], new_solution[(i+1)%n]) + edge_cost(new_solution[j], new_solution[(j+1)%n]) + edge_cost(new_solution[k], new_solution[(k+1)%n])\n        new_cost = edge_cost(new_solution[i], new_solution[j]) + edge_cost(new_solution[j], new_solution[k]) + edge_cost(new_solution[k], new_solution[(i+1)%n])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            segment1 = new_solution[(i+1):(j+1)]\n            segment2 = new_solution[(j+1):(k+1)]\n            new_solution[(i+1):(k+1)] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Apply objective-aware edge swaps\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n                    distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive using a dynamic weight vector that emphasizes objectives with higher variance, then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = (edge_cost(new_solution[i], new_solution[(i+1)%n])[0] + edge_cost(new_solution[j], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[(k+1)%n])[0] + edge_cost(new_solution[l], new_solution[(l+1)%n])[0],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[1] + edge_cost(new_solution[j], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[(k+1)%n])[1] + edge_cost(new_solution[l], new_solution[(l+1)%n])[1],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[2] + edge_cost(new_solution[j], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[(k+1)%n])[2] + edge_cost(new_solution[l], new_solution[(l+1)%n])[2])\n\n        new_cost1 = (edge_cost(new_solution[i], new_solution[j])[0] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[l])[0] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[0],\n                     edge_cost(new_solution[i], new_solution[j])[1] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[l])[1] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[1],\n                     edge_cost(new_solution[i], new_solution[j])[2] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[l])[2] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[2])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(k+1):(l+1)] = new_solution[(k+1):(l+1)][::-1]\n\n    # Apply objective-aware edge swaps\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{This new algorithm selects a solution from the archive using an adaptive weight vector that prioritizes objectives with higher variance, then applies a hybrid local search combining 3-opt with objective-aware node insertions to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = (edge_cost(new_solution[i], new_solution[(i+1)%n])[0] + edge_cost(new_solution[j], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[(k+1)%n])[0],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[1] + edge_cost(new_solution[j], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[(k+1)%n])[1],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[2] + edge_cost(new_solution[j], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[(k+1)%n])[2])\n\n        new_cost1 = (edge_cost(new_solution[i], new_solution[j])[0] + edge_cost(new_solution[(i+1)%n], new_solution[k])[0] + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])[0],\n                     edge_cost(new_solution[i], new_solution[j])[1] + edge_cost(new_solution[(i+1)%n], new_solution[k])[1] + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])[1],\n                     edge_cost(new_solution[i], new_solution[j])[2] + edge_cost(new_solution[(i+1)%n], new_solution[k])[2] + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])[2])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(j+1):(k+1)] = new_solution[(j+1):(k+1)][::-1]\n\n    # Apply objective-aware node insertions\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[(a+1)%n], new_solution[(b+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            temp = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, temp)\n\n    return new_solution\n\n",
        "score": [
            -0.7888460240155714,
            0.6314863681793212
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 3-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = (edge_cost(new_solution[i], new_solution[(i+1)%n])[0] + edge_cost(new_solution[j], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[(k+1)%n])[0],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[1] + edge_cost(new_solution[j], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[(k+1)%n])[1],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[2] + edge_cost(new_solution[j], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[(k+1)%n])[2])\n\n        new_cost1 = (edge_cost(new_solution[i], new_solution[j])[0] + edge_cost(new_solution[(i+1)%n], new_solution[k])[0] + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])[0],\n                     edge_cost(new_solution[i], new_solution[j])[1] + edge_cost(new_solution[(i+1)%n], new_solution[k])[1] + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])[1],\n                     edge_cost(new_solution[i], new_solution[j])[2] + edge_cost(new_solution[(i+1)%n], new_solution[k])[2] + edge_cost(new_solution[(j+1)%n], new_solution[(k+1)%n])[2])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(j+1):(k+1)] = new_solution[(j+1):(k+1)][::-1]\n\n    # Apply objective-aware node insertions\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[(a+1)%n], new_solution[(b+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            temp = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, temp)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive using a dynamic weight vector that emphasizes objectives with higher variance, then applies a hybrid local search combining 4-opt with objective-aware edge swaps to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances) if np.sum(variances) > 0 else np.array([1.0, 1.0, 1.0])\n\n    scores = [np.dot(obj, weights) for _, obj in archive]\n    probs = np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores)))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 4-opt with objective-aware edge selection\n    for _ in range(3):\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n\n        def edge_cost(a, b):\n            return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n        old_cost = (edge_cost(new_solution[i], new_solution[(i+1)%n])[0] + edge_cost(new_solution[j], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[(k+1)%n])[0] + edge_cost(new_solution[l], new_solution[(l+1)%n])[0],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[1] + edge_cost(new_solution[j], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[(k+1)%n])[1] + edge_cost(new_solution[l], new_solution[(l+1)%n])[1],\n                    edge_cost(new_solution[i], new_solution[(i+1)%n])[2] + edge_cost(new_solution[j], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[(k+1)%n])[2] + edge_cost(new_solution[l], new_solution[(l+1)%n])[2])\n\n        new_cost1 = (edge_cost(new_solution[i], new_solution[j])[0] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[0] + edge_cost(new_solution[k], new_solution[l])[0] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[0],\n                     edge_cost(new_solution[i], new_solution[j])[1] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[1] + edge_cost(new_solution[k], new_solution[l])[1] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[1],\n                     edge_cost(new_solution[i], new_solution[j])[2] + edge_cost(new_solution[(i+1)%n], new_solution[(j+1)%n])[2] + edge_cost(new_solution[k], new_solution[l])[2] + edge_cost(new_solution[(k+1)%n], new_solution[(l+1)%n])[2])\n\n        if any(new < old for new, old in zip(new_cost1, old_cost)):\n            new_solution[(i+1):(j+1)] = new_solution[(i+1):(j+1)][::-1]\n            new_solution[(k+1):(l+1)] = new_solution[(k+1):(l+1)][::-1]\n\n    # Apply objective-aware edge swaps\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        old_cost = (distance_matrix_1[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(a-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_2[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]],\n                    distance_matrix_3[new_solution[a], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_3[new_solution[b], new_solution[(b-1)%n]] + distance_matrix_3[new_solution[a], new_solution[(a+1)%n]])\n\n        if any(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive using a weighted random selection based on Pareto dominance and objective diversity, then applies a hybrid local search combining 3-opt with multi-objective aware node reinsertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0 / (1 + sum(x[1])) for x in archive])\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3-opt with multi-objective awareness\n    for _ in range(5):\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        old_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]),\n            (distance_matrix_1[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_2[new_solution[k], new_solution[(k+1)%n]],\n             distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n        ]\n\n        # Reverse the middle segment\n        segment = new_solution[(i+1):(j+1)]\n        new_solution[(i+1):(j+1)] = segment[::-1]\n\n        new_costs = [\n            (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]],\n             distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]),\n            (distance_matrix_1[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_2[new_solution[(j-1)%n], new_solution[j]],\n             distance_matrix_3[new_solution[(j-1)%n], new_solution[j]])\n        ]\n\n        # Accept if at least one objective improves\n        if any(any(nc < oc for nc, oc in zip(nc, oc)) for nc, oc in zip(new_costs, old_costs[:2])):\n            break\n        else:\n            # Revert if no improvement\n            new_solution[(i+1):(j+1)] = segment\n\n    # Multi-objective aware node reinsertion\n    for _ in range(3):\n        node = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This new algorithm selects a solution from the archive using a clustering-based approach to identify well-dispersed solutions, then applies a novel multi-objective edge inversion operator combined with adaptive segment reversal to explore diverse regions of the Pareto front while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-8)\n\n    from sklearn.cluster import KMeans\n    k = min(3, len(archive))\n    kmeans = KMeans(n_clusters=k, random_state=42).fit(normalized_objectives)\n    cluster_sizes = np.bincount(kmeans.labels_)\n    selected_cluster = np.argmax(cluster_sizes)\n    cluster_indices = np.where(kmeans.labels_ == selected_cluster)[0]\n    selected_idx = np.random.choice(cluster_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply multi-objective edge inversion\n    for _ in range(4):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b]\n\n        old_cost = (sum(distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] for i in range(a, b+1)),\n                    sum(distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] for i in range(a, b+1)),\n                    sum(distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] for i in range(a, b+1)))\n\n        new_solution[a:b] = segment[::-1]\n\n        new_cost = (sum(distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] for i in range(a, b+1)),\n                    sum(distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] for i in range(a, b+1)),\n                    sum(distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] for i in range(a, b+1)))\n\n        if not all(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a:b] = segment\n\n    # Apply adaptive segment reversal\n    for _ in range(3):\n        segment_length = np.random.randint(2, min(6, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        old_cost = (sum(distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] for i in range(start, start+segment_length+1)),\n                    sum(distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] for i in range(start, start+segment_length+1)),\n                    sum(distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] for i in range(start, start+segment_length+1)))\n\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        new_cost = (sum(distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] for i in range(start, start+segment_length+1)),\n                    sum(distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] for i in range(start, start+segment_length+1)),\n                    sum(distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] for i in range(start, start+segment_length+1)))\n\n        if not all(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[start:start+segment_length] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.7038664346612113,
            2.1455109834671022
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-8)\n\n    from sklearn.cluster import KMeans\n    k = min(3, len(archive))\n    kmeans = KMeans(n_clusters=k, random_state=42).fit(normalized_objectives)\n    cluster_sizes = np.bincount(kmeans.labels_)\n    selected_cluster = np.argmax(cluster_sizes)\n    cluster_indices = np.where(kmeans.labels_ == selected_cluster)[0]\n    selected_idx = np.random.choice(cluster_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply multi-objective edge inversion\n    for _ in range(4):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b]\n\n        old_cost = (sum(distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] for i in range(a, b+1)),\n                    sum(distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] for i in range(a, b+1)),\n                    sum(distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] for i in range(a, b+1)))\n\n        new_solution[a:b] = segment[::-1]\n\n        new_cost = (sum(distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] for i in range(a, b+1)),\n                    sum(distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] for i in range(a, b+1)),\n                    sum(distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] for i in range(a, b+1)))\n\n        if not all(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[a:b] = segment\n\n    # Apply adaptive segment reversal\n    for _ in range(3):\n        segment_length = np.random.randint(2, min(6, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        old_cost = (sum(distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] for i in range(start, start+segment_length+1)),\n                    sum(distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] for i in range(start, start+segment_length+1)),\n                    sum(distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] for i in range(start, start+segment_length+1)))\n\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        new_cost = (sum(distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] for i in range(start, start+segment_length+1)),\n                    sum(distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] for i in range(start, start+segment_length+1)),\n                    sum(distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] for i in range(start, start+segment_length+1)))\n\n        if not all(new < old for new, old in zip(new_cost, old_cost)):\n            new_solution[start:start+segment_length] = segment\n\n    return new_solution\n\n"
    }
]