[
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7823.964994376115,
            0.8197442173957825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7823.964994376115,
            0.8197442173957825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7823.964994376115,
            0.8197442173957825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\n",
        "score": [
            -7816.6322728059795,
            1.1020054340362548
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt combined with a novel 3-objective-aware swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the worst objective\n    worst_obj = np.argmax([sum(x[1]) for x in archive])\n    worst_solution = archive[worst_obj][0].copy()\n\n    # Find the worst edge in the worst solution\n    worst_edge = None\n    max_distance = -1\n    for i in range(n):\n        u, v = worst_solution[i], worst_solution[(i + 1) % n]\n        total_dist = distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n        if total_dist > max_distance:\n            max_distance = total_dist\n            worst_edge = (i, (i + 1) % n)\n\n    # Perform 2-opt on the worst edge\n    if worst_edge:\n        i, j = worst_edge\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Then apply a novel 3-objective-aware swap\n    # For each node, find the best swap that improves at least one objective\n    for i in range(n):\n        best_swap = None\n        best_improvement = 0\n\n        for j in range(i + 1, n):\n            # Calculate the change in all three objectives\n            old_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            old_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            old_dist3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n            new_dist3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n            # Check if at least one objective improves\n            if (new_dist1 < old_dist1) or (new_dist2 < old_dist2) or (new_dist3 < old_dist3):\n                total_improvement = (old_dist1 - new_dist1) + (old_dist2 - new_dist2) + (old_dist3 - new_dist3)\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_swap = j\n\n        if best_swap is not None:\n            new_solution[i], new_solution[best_swap] = new_solution[best_swap], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -7815.459342788238,
            2.0758976101875306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt combined with a novel 3-objective-aware swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move to improve the worst objective\n    worst_obj = np.argmax([sum(x[1]) for x in archive])\n    worst_solution = archive[worst_obj][0].copy()\n\n    # Find the worst edge in the worst solution\n    worst_edge = None\n    max_distance = -1\n    for i in range(n):\n        u, v = worst_solution[i], worst_solution[(i + 1) % n]\n        total_dist = distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n        if total_dist > max_distance:\n            max_distance = total_dist\n            worst_edge = (i, (i + 1) % n)\n\n    # Perform 2-opt on the worst edge\n    if worst_edge:\n        i, j = worst_edge\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Then apply a novel 3-objective-aware swap\n    # For each node, find the best swap that improves at least one objective\n    for i in range(n):\n        best_swap = None\n        best_improvement = 0\n\n        for j in range(i + 1, n):\n            # Calculate the change in all three objectives\n            old_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            old_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            old_dist3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n            new_dist3 = distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j-1], new_solution[i]]\n\n            # Check if at least one objective improves\n            if (new_dist1 < old_dist1) or (new_dist2 < old_dist2) or (new_dist3 < old_dist3):\n                total_improvement = (old_dist1 - new_dist1) + (old_dist2 - new_dist2) + (old_dist3 - new_dist3)\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_swap = j\n\n        if best_swap is not None:\n            new_solution[i], new_solution[best_swap] = new_solution[best_swap], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on objective diversity and applies a novel 3D path optimization operator that combines edge swaps, segment reversals, and objective-aware node insertions to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    def objective_diversity(obj):\n        return max(obj) - min(obj)\n\n    ranked_solutions = sorted(archive, key=lambda x: -objective_diversity(x[1]))\n    selected_idx = np.random.choice(min(5, len(ranked_solutions)))\n    base_solution = ranked_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between three different operators\n    operator = np.random.choice(['edge_swap', 'segment_reversal', 'node_insertion'])\n\n    if operator == 'edge_swap':\n        # Multi-objective edge swap\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'segment_reversal':\n        # Objective-aware segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    else:  # node_insertion\n        # Objective-aware node insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j:\n            j = np.random.randint(0, n)\n\n        # Calculate improvement\n        delta1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -7703.440317649794,
            0.4500385165214539
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    def objective_diversity(obj):\n        return max(obj) - min(obj)\n\n    ranked_solutions = sorted(archive, key=lambda x: -objective_diversity(x[1]))\n    selected_idx = np.random.choice(min(5, len(ranked_solutions)))\n    base_solution = ranked_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between three different operators\n    operator = np.random.choice(['edge_swap', 'segment_reversal', 'node_insertion'])\n\n    if operator == 'edge_swap':\n        # Multi-objective edge swap\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'segment_reversal':\n        # Objective-aware segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    else:  # node_insertion\n        # Objective-aware node insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j:\n            j = np.random.randint(0, n)\n\n        # Calculate improvement\n        delta1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on objective diversity and applies a novel 3D path optimization operator that combines edge swaps, segment reversals, and objective-aware node insertions to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    def objective_diversity(obj):\n        return max(obj) - min(obj)\n\n    ranked_solutions = sorted(archive, key=lambda x: -objective_diversity(x[1]))\n    selected_idx = np.random.choice(min(5, len(ranked_solutions)))\n    base_solution = ranked_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between three different operators\n    operator = np.random.choice(['edge_swap', 'segment_reversal', 'node_insertion'])\n\n    if operator == 'edge_swap':\n        # Multi-objective edge swap\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'segment_reversal':\n        # Objective-aware segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    else:  # node_insertion\n        # Objective-aware node insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j:\n            j = np.random.randint(0, n)\n\n        # Calculate improvement\n        delta1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -7703.440317649794,
            0.4500385165214539
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    def objective_diversity(obj):\n        return max(obj) - min(obj)\n\n    ranked_solutions = sorted(archive, key=lambda x: -objective_diversity(x[1]))\n    selected_idx = np.random.choice(min(5, len(ranked_solutions)))\n    base_solution = ranked_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between three different operators\n    operator = np.random.choice(['edge_swap', 'segment_reversal', 'node_insertion'])\n\n    if operator == 'edge_swap':\n        # Multi-objective edge swap\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'segment_reversal':\n        # Objective-aware segment reversal\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n\n        # Calculate combined improvement\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    else:  # node_insertion\n        # Objective-aware node insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j:\n            j = np.random.randint(0, n)\n\n        # Calculate improvement\n        delta1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[(i-1)%n], new_solution[j]] +\n                 distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] +\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[(i-1)%n], new_solution[i]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[(j-1)%n], new_solution[j]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a 3D two-opt* operator with dynamic segment selection based on objective dominance, and ensures feasibility by maintaining the TSP tour structure while considering the trade-offs between objectives}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives (most balanced)\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = normalized.std(axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection based on objective dominance\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    if obj1 < obj2 and obj1 < obj3:\n        # Focus on first objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        if delta < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif obj2 < obj1 and obj2 < obj3:\n        # Focus on second objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        if delta < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Focus on third objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        if delta < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional 2-opt* move for further improvement\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7788.1073385244745,
            1.1389009952545166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives (most balanced)\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = normalized.std(axis=1)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection based on objective dominance\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    if obj1 < obj2 and obj1 < obj3:\n        # Focus on first objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        if delta < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif obj2 < obj1 and obj2 < obj3:\n        # Focus on second objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        if delta < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Focus on third objective\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        if delta < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional 2-opt* move for further improvement\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Perform a multi-objective edge insertion move\n    for _ in range(5):\n        # Randomly select two distinct edges\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n\n        # Perform the insertion\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(base_solution)\n\n        # Accept if the solution is non-dominated or improves at least one objective\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            base_solution = new_solution.copy()\n\n    return base_solution\n\n",
        "score": [
            -7807.360617696031,
            1.3040217638015748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Perform a multi-objective edge insertion move\n    for _ in range(5):\n        # Randomly select two distinct edges\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n\n        # Perform the insertion\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(base_solution)\n\n        # Accept if the solution is non-dominated or improves at least one objective\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            base_solution = new_solution.copy()\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D segment-shuffling and objective-biased edge-insertion operator, and ensures feasibility by preserving the TSP tour structure while dynamically balancing improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    def objective_diversity(sol):\n        obj = sol[1]\n        return (max(obj) - min(obj)) / sum(obj)\n\n    selected = max(archive, key=objective_diversity)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment shuffling with objective awareness\n    if np.random.random() < 0.6:\n        # Select a segment and move it to a new position\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find insertion point that improves at least one objective\n        best_pos = -1\n        best_improvement = -1\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Evaluate the move\n            old_edges = [\n                (new_solution[start-1], new_solution[start]),\n                (new_solution[start+segment_length-1], new_solution[(start+segment_length)%n])\n            ]\n            new_edges = [\n                (new_solution[start-1], new_solution[(start+segment_length)%n]),\n                (segment[0], segment[-1])\n            ]\n\n            if pos > 0:\n                new_edges.append((new_solution[pos-1], segment[0]))\n            if pos + segment_length < n:\n                new_edges.append((segment[-1], new_solution[pos+segment_length]))\n\n            # Calculate objective improvements\n            delta1 = sum(distance_matrix_1[a,b] for a,b in new_edges) - sum(distance_matrix_1[a,b] for a,b in old_edges)\n            delta2 = sum(distance_matrix_2[a,b] for a,b in new_edges) - sum(distance_matrix_2[a,b] for a,b in old_edges)\n            delta3 = sum(distance_matrix_3[a,b] for a,b in new_edges) - sum(distance_matrix_3[a,b] for a,b in old_edges)\n\n            improvement = sum(1 for d in [delta1, delta2, delta3] if d < 0)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n            # Insert at new position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n    else:\n        # Apply objective-biased edge insertion\n        worst_obj = np.argmax(selected[1])\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst edge in the selected objective\n        max_edge = -1\n        max_dist = -1\n        for i in range(n):\n            dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n            if dist > max_dist:\n                max_dist = dist\n                max_edge = i\n\n        # Try to replace this edge with a better one\n        a, b = new_solution[max_edge], new_solution[(max_edge+1)%n]\n        candidates = []\n        for i in range(n):\n            if i != max_edge and i != (max_edge+1)%n:\n                dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n                if dist < max_dist:\n                    candidates.append(i)\n\n        if candidates:\n            best_candidate = min(candidates, key=lambda x: dist_matrix[new_solution[x], new_solution[(x+1)%n]])\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:max_edge+1],\n                new_solution[best_candidate+1:],\n                new_solution[best_candidate:best_candidate+1],\n                new_solution[max_edge+1:best_candidate+1]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -7695.799031100536,
            0.4392615079879761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    def objective_diversity(sol):\n        obj = sol[1]\n        return (max(obj) - min(obj)) / sum(obj)\n\n    selected = max(archive, key=objective_diversity)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment shuffling with objective awareness\n    if np.random.random() < 0.6:\n        # Select a segment and move it to a new position\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find insertion point that improves at least one objective\n        best_pos = -1\n        best_improvement = -1\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Evaluate the move\n            old_edges = [\n                (new_solution[start-1], new_solution[start]),\n                (new_solution[start+segment_length-1], new_solution[(start+segment_length)%n])\n            ]\n            new_edges = [\n                (new_solution[start-1], new_solution[(start+segment_length)%n]),\n                (segment[0], segment[-1])\n            ]\n\n            if pos > 0:\n                new_edges.append((new_solution[pos-1], segment[0]))\n            if pos + segment_length < n:\n                new_edges.append((segment[-1], new_solution[pos+segment_length]))\n\n            # Calculate objective improvements\n            delta1 = sum(distance_matrix_1[a,b] for a,b in new_edges) - sum(distance_matrix_1[a,b] for a,b in old_edges)\n            delta2 = sum(distance_matrix_2[a,b] for a,b in new_edges) - sum(distance_matrix_2[a,b] for a,b in old_edges)\n            delta3 = sum(distance_matrix_3[a,b] for a,b in new_edges) - sum(distance_matrix_3[a,b] for a,b in old_edges)\n\n            improvement = sum(1 for d in [delta1, delta2, delta3] if d < 0)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n            # Insert at new position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n    else:\n        # Apply objective-biased edge insertion\n        worst_obj = np.argmax(selected[1])\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst edge in the selected objective\n        max_edge = -1\n        max_dist = -1\n        for i in range(n):\n            dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n            if dist > max_dist:\n                max_dist = dist\n                max_edge = i\n\n        # Try to replace this edge with a better one\n        a, b = new_solution[max_edge], new_solution[(max_edge+1)%n]\n        candidates = []\n        for i in range(n):\n            if i != max_edge and i != (max_edge+1)%n:\n                dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n                if dist < max_dist:\n                    candidates.append(i)\n\n        if candidates:\n            best_candidate = min(candidates, key=lambda x: dist_matrix[new_solution[x], new_solution[(x+1)%n]])\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:max_edge+1],\n                new_solution[best_candidate+1:],\n                new_solution[best_candidate:best_candidate+1],\n                new_solution[max_edge+1:best_candidate+1]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D segment-shuffling and objective-biased edge-insertion operator, and ensures feasibility by preserving the TSP tour structure while dynamically balancing improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    def objective_diversity(sol):\n        obj = sol[1]\n        return (max(obj) - min(obj)) / sum(obj)\n\n    selected = max(archive, key=objective_diversity)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment shuffling with objective awareness\n    if np.random.random() < 0.6:\n        # Select a segment and move it to a new position\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find insertion point that improves at least one objective\n        best_pos = -1\n        best_improvement = -1\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Evaluate the move\n            old_edges = [\n                (new_solution[start-1], new_solution[start]),\n                (new_solution[start+segment_length-1], new_solution[(start+segment_length)%n])\n            ]\n            new_edges = [\n                (new_solution[start-1], new_solution[(start+segment_length)%n]),\n                (segment[0], segment[-1])\n            ]\n\n            if pos > 0:\n                new_edges.append((new_solution[pos-1], segment[0]))\n            if pos + segment_length < n:\n                new_edges.append((segment[-1], new_solution[pos+segment_length]))\n\n            # Calculate objective improvements\n            delta1 = sum(distance_matrix_1[a,b] for a,b in new_edges) - sum(distance_matrix_1[a,b] for a,b in old_edges)\n            delta2 = sum(distance_matrix_2[a,b] for a,b in new_edges) - sum(distance_matrix_2[a,b] for a,b in old_edges)\n            delta3 = sum(distance_matrix_3[a,b] for a,b in new_edges) - sum(distance_matrix_3[a,b] for a,b in old_edges)\n\n            improvement = sum(1 for d in [delta1, delta2, delta3] if d < 0)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n            # Insert at new position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n    else:\n        # Apply objective-biased edge insertion\n        worst_obj = np.argmax(selected[1])\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst edge in the selected objective\n        max_edge = -1\n        max_dist = -1\n        for i in range(n):\n            dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n            if dist > max_dist:\n                max_dist = dist\n                max_edge = i\n\n        # Try to replace this edge with a better one\n        a, b = new_solution[max_edge], new_solution[(max_edge+1)%n]\n        candidates = []\n        for i in range(n):\n            if i != max_edge and i != (max_edge+1)%n:\n                dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n                if dist < max_dist:\n                    candidates.append(i)\n\n        if candidates:\n            best_candidate = min(candidates, key=lambda x: dist_matrix[new_solution[x], new_solution[(x+1)%n]])\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:max_edge+1],\n                new_solution[best_candidate+1:],\n                new_solution[best_candidate:best_candidate+1],\n                new_solution[max_edge+1:best_candidate+1]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -7695.799031100536,
            0.4392615079879761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    def objective_diversity(sol):\n        obj = sol[1]\n        return (max(obj) - min(obj)) / sum(obj)\n\n    selected = max(archive, key=objective_diversity)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply segment shuffling with objective awareness\n    if np.random.random() < 0.6:\n        # Select a segment and move it to a new position\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find insertion point that improves at least one objective\n        best_pos = -1\n        best_improvement = -1\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Evaluate the move\n            old_edges = [\n                (new_solution[start-1], new_solution[start]),\n                (new_solution[start+segment_length-1], new_solution[(start+segment_length)%n])\n            ]\n            new_edges = [\n                (new_solution[start-1], new_solution[(start+segment_length)%n]),\n                (segment[0], segment[-1])\n            ]\n\n            if pos > 0:\n                new_edges.append((new_solution[pos-1], segment[0]))\n            if pos + segment_length < n:\n                new_edges.append((segment[-1], new_solution[pos+segment_length]))\n\n            # Calculate objective improvements\n            delta1 = sum(distance_matrix_1[a,b] for a,b in new_edges) - sum(distance_matrix_1[a,b] for a,b in old_edges)\n            delta2 = sum(distance_matrix_2[a,b] for a,b in new_edges) - sum(distance_matrix_2[a,b] for a,b in old_edges)\n            delta3 = sum(distance_matrix_3[a,b] for a,b in new_edges) - sum(distance_matrix_3[a,b] for a,b in old_edges)\n\n            improvement = sum(1 for d in [delta1, delta2, delta3] if d < 0)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove the segment\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n            # Insert at new position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n    else:\n        # Apply objective-biased edge insertion\n        worst_obj = np.argmax(selected[1])\n        if worst_obj == 0:\n            dist_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            dist_matrix = distance_matrix_2\n        else:\n            dist_matrix = distance_matrix_3\n\n        # Find the worst edge in the selected objective\n        max_edge = -1\n        max_dist = -1\n        for i in range(n):\n            dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n            if dist > max_dist:\n                max_dist = dist\n                max_edge = i\n\n        # Try to replace this edge with a better one\n        a, b = new_solution[max_edge], new_solution[(max_edge+1)%n]\n        candidates = []\n        for i in range(n):\n            if i != max_edge and i != (max_edge+1)%n:\n                dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]]\n                if dist < max_dist:\n                    candidates.append(i)\n\n        if candidates:\n            best_candidate = min(candidates, key=lambda x: dist_matrix[new_solution[x], new_solution[(x+1)%n]])\n            # Perform the insertion\n            new_solution = np.concatenate([\n                new_solution[:max_edge+1],\n                new_solution[best_candidate+1:],\n                new_solution[best_candidate:best_candidate+1],\n                new_solution[max_edge+1:best_candidate+1]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Perform a multi-objective path relinking operation\n    n = len(new_solution)\n    for _ in range(5):  # Limit iterations\n        # Randomly select a segment to relink\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Find the best position to insert this segment in a different order\n        best_pos = i\n        best_obj = (float('inf'), float('inf'), float('inf'))\n\n        for k in range(n):\n            if k >= i and k < j+1:\n                continue  # Skip the original segment position\n\n            # Try inserting the segment in reverse order\n            candidate = np.concatenate([new_solution[:k], segment[::-1], new_solution[k:]])\n\n            # Calculate objectives\n            def calculate_objective(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n                cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n                cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n                return (cost1, cost2, cost3)\n\n            current_obj = calculate_objective(candidate)\n\n            # Update best position if the solution is non-dominated\n            if all(current_obj[i] <= best_obj[i] for i in range(3)) and any(current_obj[i] < best_obj[i] for i in range(3)):\n                best_pos = k\n                best_obj = current_obj\n\n        # Apply the best insertion if found\n        if best_pos != i:\n            new_solution = np.concatenate([new_solution[:best_pos], segment[::-1], new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -7780.296003338277,
            2.039249610900879
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Perform a multi-objective path relinking operation\n    n = len(new_solution)\n    for _ in range(5):  # Limit iterations\n        # Randomly select a segment to relink\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Find the best position to insert this segment in a different order\n        best_pos = i\n        best_obj = (float('inf'), float('inf'), float('inf'))\n\n        for k in range(n):\n            if k >= i and k < j+1:\n                continue  # Skip the original segment position\n\n            # Try inserting the segment in reverse order\n            candidate = np.concatenate([new_solution[:k], segment[::-1], new_solution[k:]])\n\n            # Calculate objectives\n            def calculate_objective(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n                cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n                cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n                return (cost1, cost2, cost3)\n\n            current_obj = calculate_objective(candidate)\n\n            # Update best position if the solution is non-dominated\n            if all(current_obj[i] <= best_obj[i] for i in range(3)) and any(current_obj[i] < best_obj[i] for i in range(3)):\n                best_pos = k\n                best_obj = current_obj\n\n        # Apply the best insertion if found\n        if best_pos != i:\n            new_solution = np.concatenate([new_solution[:best_pos], segment[::-1], new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a solution from the archive based on objective diversity, applies a hybrid 3D edge-swapping and segment-reversal operator with adaptive intensity, and ensures feasibility by preserving the TSP tour structure while leveraging objective-specific distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective diversity (maximize spread across objectives)\n    objectives = np.array([sol[1] for sol in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive intensity based on solution quality\n    intensity = min(0.3 + (len(archive) - selected_idx) / len(archive) * 0.7, 1.0)\n\n    if np.random.random() < intensity:\n        # 3D edge-swap with objective-specific consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Weighted acceptance based on objective improvements\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # More lenient acceptance for multi-objective optimization\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with objective balance\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Balance improvements across objectives\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.15):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7853.03067691646,
            1.5377792239189148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective diversity (maximize spread across objectives)\n    objectives = np.array([sol[1] for sol in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive intensity based on solution quality\n    intensity = min(0.3 + (len(archive) - selected_idx) / len(archive) * 0.7, 1.0)\n\n    if np.random.random() < intensity:\n        # 3D edge-swap with objective-specific consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Weighted acceptance based on objective improvements\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # More lenient acceptance for multi-objective optimization\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with objective balance\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Balance improvements across objectives\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.15):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a solution from the archive based on objective diversity, applies a hybrid 3D edge-swapping and segment-reversal operator with adaptive intensity, and ensures feasibility by preserving the TSP tour structure while leveraging objective-specific distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective diversity (maximize spread across objectives)\n    objectives = np.array([sol[1] for sol in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive intensity based on solution quality\n    intensity = min(0.3 + (len(archive) - selected_idx) / len(archive) * 0.7, 1.0)\n\n    if np.random.random() < intensity:\n        # 3D edge-swap with objective-specific consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Weighted acceptance based on objective improvements\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # More lenient acceptance for multi-objective optimization\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with objective balance\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Balance improvements across objectives\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.15):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7853.03067691646,
            1.5377792239189148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective diversity (maximize spread across objectives)\n    objectives = np.array([sol[1] for sol in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive intensity based on solution quality\n    intensity = min(0.3 + (len(archive) - selected_idx) / len(archive) * 0.7, 1.0)\n\n    if np.random.random() < intensity:\n        # 3D edge-swap with objective-specific consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Weighted acceptance based on objective improvements\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # More lenient acceptance for multi-objective optimization\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with objective balance\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Balance improvements across objectives\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.15):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 3-opt and a multi-objective edge insertion strategy to generate an improved neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Adjust weights based on objective importance\n    selected_solution = min(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 3-opt with multi-objective edge insertion\n    n = len(new_solution)\n    for _ in range(15):  # More iterations for better exploration\n        # Randomly select three edges to modify\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Perform 3-opt move\n        temp = new_solution.copy()\n        temp[a:b+1] = temp[a:b+1][::-1]\n        temp[b:c+1] = temp[b:c+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(temp)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves or solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            new_solution = temp.copy()\n\n        # Additional multi-objective edge insertion\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:  # Ensure we have at least one node to move\n            # Insert segment between i and j before position k\n            k = np.random.randint(0, n)\n            if k > j or k < i:\n                segment = new_solution[i:j+1]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    return new_solution\n\n",
        "score": [
            -7772.978189578765,
            1.3918166399002074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.4, 0.3, 0.3]  # Adjust weights based on objective importance\n    selected_solution = min(archive, key=lambda x: sum(w * o for w, o in zip(weights, x[1])))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 3-opt with multi-objective edge insertion\n    n = len(new_solution)\n    for _ in range(15):  # More iterations for better exploration\n        # Randomly select three edges to modify\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n        # Perform 3-opt move\n        temp = new_solution.copy()\n        temp[a:b+1] = temp[a:b+1][::-1]\n        temp[b:c+1] = temp[b:c+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(temp)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves or solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            new_solution = temp.copy()\n\n        # Additional multi-objective edge insertion\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 1:  # Ensure we have at least one node to move\n            # Insert segment between i and j before position k\n            k = np.random.randint(0, n)\n            if k > j or k < i:\n                segment = new_solution[i:j+1]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search operator that considers all three objectives simultaneously, and ensures feasibility through careful edge-swapping and segment-reversal operations tailored to multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on a weighted sum of objectives (weights can be adjusted)\n    weights = [0.4, 0.3, 0.3]  # Adjust weights based on objective importance\n    ranked_solutions = sorted(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n\n    # Select the top 30% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or 2-opt with consideration for all three objectives\n    if np.random.random() < 0.6:  # Higher probability for edge-swap\n        # Edge-swap with multi-objective consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least two objectives improve\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 2-opt with multi-objective consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7779.9995118898705,
            1.2579894423484803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on a weighted sum of objectives (weights can be adjusted)\n    weights = [0.4, 0.3, 0.3]  # Adjust weights based on objective importance\n    ranked_solutions = sorted(archive, key=lambda x: sum(w * obj for w, obj in zip(weights, x[1])))\n\n    # Select the top 30% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or 2-opt with consideration for all three objectives\n    if np.random.random() < 0.6:  # Higher probability for edge-swap\n        # Edge-swap with multi-objective consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least two objectives improve\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 2-opt with multi-objective consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best balance across objectives\n    def dominance_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions that are balanced\n\n    ranked_solutions = sorted(archive, key=lambda x: dominance_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware local search operator\n    for _ in range(5):  # Limit iterations\n        # Choose a segment to modify\n        seg_start = np.random.randint(0, n)\n        seg_length = min(3, np.random.randint(1, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Consider different types of modifications\n        if np.random.random() < 0.6:  # Edge swap\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) <= 1 or abs(i - j) >= n - 1:\n                j = np.random.randint(0, n)\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Segment reversal\n            if seg_start < seg_end:\n                segment = new_solution[seg_start:seg_end+1][::-1]\n                new_solution[seg_start:seg_end+1] = segment\n            else:\n                segment1 = new_solution[seg_start:][::-1]\n                segment2 = new_solution[:seg_end+1][::-1]\n                new_solution = np.concatenate([segment1, new_solution[seg_end+1:seg_start], segment2])\n\n    return new_solution\n\n",
        "score": [
            -7787.720528352528,
            0.36901015043258667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best balance across objectives\n    def dominance_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions that are balanced\n\n    ranked_solutions = sorted(archive, key=lambda x: dominance_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware local search operator\n    for _ in range(5):  # Limit iterations\n        # Choose a segment to modify\n        seg_start = np.random.randint(0, n)\n        seg_length = min(3, np.random.randint(1, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Consider different types of modifications\n        if np.random.random() < 0.6:  # Edge swap\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) <= 1 or abs(i - j) >= n - 1:\n                j = np.random.randint(0, n)\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Segment reversal\n            if seg_start < seg_end:\n                segment = new_solution[seg_start:seg_end+1][::-1]\n                new_solution[seg_start:seg_end+1] = segment\n            else:\n                segment1 = new_solution[seg_start:][::-1]\n                segment2 = new_solution[:seg_end+1][::-1]\n                new_solution = np.concatenate([segment1, new_solution[seg_end+1:seg_start], segment2])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 2-opt with a custom multi-objective edge swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Perform two 2-opt swaps to explore multi-objective trade-offs\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Evaluate the new solution's objectives\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return (cost1, cost2, cost3)\n\n        new_obj = calculate_objective(new_solution)\n        old_obj = calculate_objective(selected_solution)\n\n        # Accept if any objective improves, or if the solution is non-dominated\n        if any(new_obj[i] < old_obj[i] for i in range(3)) or all(new_obj[i] <= old_obj[i] for i in range(3)):\n            selected_solution = new_solution.copy()\n\n    return selected_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best balance across objectives\n    def dominance_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions that are balanced\n\n    ranked_solutions = sorted(archive, key=lambda x: dominance_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware local search operator\n    for _ in range(5):  # Limit iterations\n        # Choose a segment to modify\n        seg_start = np.random.randint(0, n)\n        seg_length = min(3, np.random.randint(1, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Consider different types of modifications\n        if np.random.random() < 0.6:  # Edge swap\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) <= 1 or abs(i - j) >= n - 1:\n                j = np.random.randint(0, n)\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Segment reversal\n            if seg_start < seg_end:\n                segment = new_solution[seg_start:seg_end+1][::-1]\n                new_solution[seg_start:seg_end+1] = segment\n            else:\n                segment1 = new_solution[seg_start:][::-1]\n                segment2 = new_solution[:seg_end+1][::-1]\n                new_solution = np.concatenate([segment1, new_solution[seg_end+1:seg_start], segment2])\n\n    return new_solution\n\n",
        "score": [
            -7787.720528352528,
            0.36901015043258667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best balance across objectives\n    def dominance_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions that are balanced\n\n    ranked_solutions = sorted(archive, key=lambda x: dominance_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware local search operator\n    for _ in range(5):  # Limit iterations\n        # Choose a segment to modify\n        seg_start = np.random.randint(0, n)\n        seg_length = min(3, np.random.randint(1, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Consider different types of modifications\n        if np.random.random() < 0.6:  # Edge swap\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) <= 1 or abs(i - j) >= n - 1:\n                j = np.random.randint(0, n)\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Segment reversal\n            if seg_start < seg_end:\n                segment = new_solution[seg_start:seg_end+1][::-1]\n                new_solution[seg_start:seg_end+1] = segment\n            else:\n                segment1 = new_solution[seg_start:][::-1]\n                segment2 = new_solution[:seg_end+1][::-1]\n                new_solution = np.concatenate([segment1, new_solution[seg_end+1:seg_start], segment2])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best balance across objectives\n    def dominance_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions that are balanced\n\n    ranked_solutions = sorted(archive, key=lambda x: dominance_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware local search operator\n    for _ in range(5):  # Limit iterations\n        # Choose a segment to modify\n        seg_start = np.random.randint(0, n)\n        seg_length = min(3, np.random.randint(1, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Consider different types of modifications\n        if np.random.random() < 0.6:  # Edge swap\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) <= 1 or abs(i - j) >= n - 1:\n                j = np.random.randint(0, n)\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Segment reversal\n            if seg_start < seg_end:\n                segment = new_solution[seg_start:seg_end+1][::-1]\n                new_solution[seg_start:seg_end+1] = segment\n            else:\n                segment1 = new_solution[seg_start:][::-1]\n                segment2 = new_solution[:seg_end+1][::-1]\n                new_solution = np.concatenate([segment1, new_solution[seg_end+1:seg_start], segment2])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best balance across objectives\n    def dominance_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions that are balanced\n\n    ranked_solutions = sorted(archive, key=lambda x: dominance_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware local search operator\n    for _ in range(5):  # Limit iterations\n        # Choose a segment to modify\n        seg_start = np.random.randint(0, n)\n        seg_length = min(3, np.random.randint(1, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        # Consider different types of modifications\n        if np.random.random() < 0.6:  # Edge swap\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) <= 1 or abs(i - j) >= n - 1:\n                j = np.random.randint(0, n)\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                      distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # Segment reversal\n            if seg_start < seg_end:\n                segment = new_solution[seg_start:seg_end+1][::-1]\n                new_solution[seg_start:seg_end+1] = segment\n            else:\n                segment1 = new_solution[seg_start:][::-1]\n                segment2 = new_solution[:seg_end+1][::-1]\n                new_solution = np.concatenate([segment1, new_solution[seg_end+1:seg_start], segment2])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{This novel algorithm combines multi-objective selection with a 3D-aware node insertion heuristic that intelligently balances objective improvements by considering the trade-offs between the three objectives during node insertion and removal operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives\n    def tradeoff_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions with balanced trade-offs\n\n    ranked_solutions = sorted(archive, key=lambda x: tradeoff_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware node insertion heuristic\n    for _ in range(5):  # Limit iterations\n        # Choose a node to remove and reinsert\n        node_to_move = np.random.randint(0, n)\n        node = new_solution[node_to_move]\n\n        # Remove the node from the solution\n        new_solution = np.delete(new_solution, node_to_move)\n\n        # Find the best insertion position considering all three objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution)):\n            prev_node = new_solution[pos]\n            next_node = new_solution[(pos + 1) % len(new_solution)]\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[prev_node, node] +\n                      distance_matrix_1[node, next_node] -\n                      distance_matrix_1[prev_node, next_node])\n\n            delta2 = (distance_matrix_2[prev_node, node] +\n                      distance_matrix_2[node, next_node] -\n                      distance_matrix_2[prev_node, next_node])\n\n            delta3 = (distance_matrix_3[prev_node, node] +\n                      distance_matrix_3[node, next_node] -\n                      distance_matrix_3[prev_node, next_node])\n\n            # Calculate a combined score considering all three objectives\n            combined_score = delta1 + delta2 + delta3\n\n            if combined_score < best_score:\n                best_score = combined_score\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -7771.659040863579,
            0.6725802540779113
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off across objectives\n    def tradeoff_score(obj):\n        return sum(obj) - max(obj)  # Prefer solutions with balanced trade-offs\n\n    ranked_solutions = sorted(archive, key=lambda x: tradeoff_score(x[1]))\n    base_solution = ranked_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a 3D-aware node insertion heuristic\n    for _ in range(5):  # Limit iterations\n        # Choose a node to remove and reinsert\n        node_to_move = np.random.randint(0, n)\n        node = new_solution[node_to_move]\n\n        # Remove the node from the solution\n        new_solution = np.delete(new_solution, node_to_move)\n\n        # Find the best insertion position considering all three objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution)):\n            prev_node = new_solution[pos]\n            next_node = new_solution[(pos + 1) % len(new_solution)]\n\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[prev_node, node] +\n                      distance_matrix_1[node, next_node] -\n                      distance_matrix_1[prev_node, next_node])\n\n            delta2 = (distance_matrix_2[prev_node, node] +\n                      distance_matrix_2[node, next_node] -\n                      distance_matrix_2[prev_node, next_node])\n\n            delta3 = (distance_matrix_3[prev_node, node] +\n                      distance_matrix_3[node, next_node] -\n                      distance_matrix_3[prev_node, next_node])\n\n            # Calculate a combined score considering all three objectives\n            combined_score = delta1 + delta2 + delta3\n\n            if combined_score < best_score:\n                best_score = combined_score\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a 3D node insertion operator that considers the trade-off between the three objectives, and ensures feasibility by maintaining the TSP tour structure while intelligently selecting insertion points based on objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a random node to remove\n    remove_idx = np.random.randint(0, n)\n    node_to_remove = new_solution[remove_idx]\n\n    # Remove the node from the tour\n    new_solution = np.delete(new_solution, remove_idx)\n\n    # Find the best insertion point considering all three objectives\n    best_insert_pos = 0\n    best_improvement = (float('inf'), float('inf'), float('inf'))\n\n    for i in range(n - 1):\n        current_node = new_solution[i]\n        next_node = new_solution[(i + 1) % (n - 1)]\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[current_node, node_to_remove] +\n                  distance_matrix_1[node_to_remove, next_node] -\n                  distance_matrix_1[current_node, next_node])\n\n        delta2 = (distance_matrix_2[current_node, node_to_remove] +\n                  distance_matrix_2[node_to_remove, next_node] -\n                  distance_matrix_2[current_node, next_node])\n\n        delta3 = (distance_matrix_3[current_node, node_to_remove] +\n                  distance_matrix_3[node_to_remove, next_node] -\n                  distance_matrix_3[current_node, next_node])\n\n        # Calculate the total improvement (sum of deltas)\n        total_improvement = (delta1, delta2, delta3)\n\n        # Update best insertion point if this is better\n        if sum(total_improvement) < sum(best_improvement):\n            best_improvement = total_improvement\n            best_insert_pos = i + 1\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_insert_pos, node_to_remove)\n\n    return new_solution\n\n",
        "score": [
            -7651.219460570613,
            3.285051941871643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a random node to remove\n    remove_idx = np.random.randint(0, n)\n    node_to_remove = new_solution[remove_idx]\n\n    # Remove the node from the tour\n    new_solution = np.delete(new_solution, remove_idx)\n\n    # Find the best insertion point considering all three objectives\n    best_insert_pos = 0\n    best_improvement = (float('inf'), float('inf'), float('inf'))\n\n    for i in range(n - 1):\n        current_node = new_solution[i]\n        next_node = new_solution[(i + 1) % (n - 1)]\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[current_node, node_to_remove] +\n                  distance_matrix_1[node_to_remove, next_node] -\n                  distance_matrix_1[current_node, next_node])\n\n        delta2 = (distance_matrix_2[current_node, node_to_remove] +\n                  distance_matrix_2[node_to_remove, next_node] -\n                  distance_matrix_2[current_node, next_node])\n\n        delta3 = (distance_matrix_3[current_node, node_to_remove] +\n                  distance_matrix_3[node_to_remove, next_node] -\n                  distance_matrix_3[current_node, next_node])\n\n        # Calculate the total improvement (sum of deltas)\n        total_improvement = (delta1, delta2, delta3)\n\n        # Update best insertion point if this is better\n        if sum(total_improvement) < sum(best_improvement):\n            best_improvement = total_improvement\n            best_insert_pos = i + 1\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_insert_pos, node_to_remove)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search heuristic that intelligently selects a solution from the archive based on objective diversity, applies a hybrid 3D edge-swapping and segment-reversal operator with adaptive intensity, and ensures feasibility by preserving the TSP tour structure while leveraging objective-specific distance matrices.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on objective diversity (maximize spread across objectives)\n    objectives = np.array([sol[1] for sol in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objective_ranges)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive intensity based on solution quality\n    intensity = min(0.3 + (len(archive) - selected_idx) / len(archive) * 0.7, 1.0)\n\n    if np.random.random() < intensity:\n        # 3D edge-swap with objective-specific consideration\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Weighted acceptance based on objective improvements\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # More lenient acceptance for multi-objective optimization\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with objective balance\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Balance improvements across objectives\n        if (delta1 < 0 or delta2 < 0 or delta3 < 0) or (np.random.random() < 0.15):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{An adaptive multi-objective local search heuristic that combines objective-aware node insertion with probabilistic segment inversion, dynamically balancing exploration of diverse solution spaces through weighted objective improvements and adaptive neighborhood intensity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective variance (diversity)\n    objectives = np.array([sol[1] for sol in archive])\n    objective_variance = np.var(objectives, axis=0)\n    diversity_scores = np.sum(objective_variance)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive intensity based on solution quality\n    intensity = min(0.2 + (len(archive) - selected_idx) / len(archive) * 0.8, 1.0)\n\n    if np.random.random() < intensity:\n        # Objective-aware node insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        # Calculate weighted improvement\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Weighted acceptance\n        weighted_delta = (delta1 + delta2 + delta3) / 3\n        if weighted_delta < 0 or np.random.random() < 0.1 * (1 - weighted_delta/100):\n            # Perform insertion\n            if i < j:\n                new_solution[i+1:j+1] = np.roll(new_solution[i+1:j+1], -1)\n            else:\n                new_solution[j+1:i+1] = np.roll(new_solution[j+1:i+1], 1)\n    else:\n        # Probabilistic segment inversion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate objective improvements\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Probabilistic acceptance based on improvement balance\n        improvement_count = sum(1 for d in [delta1, delta2, delta3] if d < 0)\n        if improvement_count >= 2 or np.random.random() < 0.2 * improvement_count:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7733.702153616345,
            0.4582378029823303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective variance (diversity)\n    objectives = np.array([sol[1] for sol in archive])\n    objective_variance = np.var(objectives, axis=0)\n    diversity_scores = np.sum(objective_variance)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive intensity based on solution quality\n    intensity = min(0.2 + (len(archive) - selected_idx) / len(archive) * 0.8, 1.0)\n\n    if np.random.random() < intensity:\n        # Objective-aware node insertion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        # Calculate weighted improvement\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                 distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                 distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                 distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Weighted acceptance\n        weighted_delta = (delta1 + delta2 + delta3) / 3\n        if weighted_delta < 0 or np.random.random() < 0.1 * (1 - weighted_delta/100):\n            # Perform insertion\n            if i < j:\n                new_solution[i+1:j+1] = np.roll(new_solution[i+1:j+1], -1)\n            else:\n                new_solution[j+1:i+1] = np.roll(new_solution[j+1:i+1], 1)\n    else:\n        # Probabilistic segment inversion\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate objective improvements\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                 distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Probabilistic acceptance based on improvement balance\n        improvement_count = sum(1 for d in [delta1, delta2, delta3] if d < 0)\n        if improvement_count >= 2 or np.random.random() < 0.2 * improvement_count:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{A novel multi-objective local search heuristic that selects solutions based on objective diversity, applies a hybrid 3D edge-swap and segment-reversal operator with adaptive probabilities, and ensures feasibility by maintaining the TSP tour structure while prioritizing solutions that show improvement in at least two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the diversity of each solution based on objective values\n    diversity_scores = []\n    for sol, obj in archive:\n        obj1, obj2, obj3 = obj\n        diversity = abs(obj1 - obj2) + abs(obj2 - obj3) + abs(obj3 - obj1)\n        diversity_scores.append(diversity)\n\n    # Select solutions with above-average diversity\n    avg_diversity = np.mean(diversity_scores)\n    promising_indices = [i for i, score in enumerate(diversity_scores) if score >= avg_diversity]\n    selected_idx = np.random.choice(promising_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive probability based on diversity\n    prob_edge_swap = 0.6 if diversity_scores[selected_idx] > avg_diversity else 0.4\n\n    if np.random.random() < prob_edge_swap:\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least two objectives improve\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least two objectives improve\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -7773.95083408706,
            0.8561256289482116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the diversity of each solution based on objective values\n    diversity_scores = []\n    for sol, obj in archive:\n        obj1, obj2, obj3 = obj\n        diversity = abs(obj1 - obj2) + abs(obj2 - obj3) + abs(obj3 - obj1)\n        diversity_scores.append(diversity)\n\n    # Select solutions with above-average diversity\n    avg_diversity = np.mean(diversity_scores)\n    promising_indices = [i for i, score in enumerate(diversity_scores) if score >= avg_diversity]\n    selected_idx = np.random.choice(promising_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive probability based on diversity\n    prob_edge_swap = 0.6 if diversity_scores[selected_idx] > avg_diversity else 0.4\n\n    if np.random.random() < prob_edge_swap:\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least two objectives improve\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least two objectives improve\n        if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a 3D node insertion operator with objective-aware selection, and ensures feasibility by maintaining the TSP tour structure while considering the combined impact of all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective diversity\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.prod(norm_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node insertion with objective-aware selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) < 2:\n        j = np.random.randint(0, n)\n\n    # Calculate the change in all three objectives\n    delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n              distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_1[new_solution[i-1], new_solution[i]] -\n              distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n\n    delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n              distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_2[new_solution[i-1], new_solution[i]] -\n              distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n    delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n              distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_3[new_solution[i-1], new_solution[i]] -\n              distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n    # Accept if at least two objectives improve\n    if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n        # Perform the insertion\n        node_to_move = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -7784.5633248624845,
            0.3356810688972473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective diversity\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.prod(norm_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node insertion with objective-aware selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) < 2:\n        j = np.random.randint(0, n)\n\n    # Calculate the change in all three objectives\n    delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n              distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_1[new_solution[i-1], new_solution[i]] -\n              distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n\n    delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n              distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_2[new_solution[i-1], new_solution[i]] -\n              distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n    delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n              distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_3[new_solution[i-1], new_solution[i]] -\n              distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n    # Accept if at least two objectives improve\n    if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n        # Perform the insertion\n        node_to_move = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 3D edge-swapping and segment-reversal operator tailored to the three objectives, and ensures feasibility by preserving the TSP tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on the sum of objectives (lower is better)\n    ranked_solutions = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 20% of solutions\n    top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose between edge-swap or segment-reversal based on objective diversity\n    if np.random.random() < 0.7:  # Higher probability for edge-swap\n        # Edge-swap with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = np.random.randint(0, n)\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                  distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment reversal with consideration for all three objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] -\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a promising solution from the archive, applies a 3D node insertion operator with objective-aware selection, and ensures feasibility by maintaining the TSP tour structure while considering the combined impact of all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective diversity\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.prod(norm_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node insertion with objective-aware selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) < 2:\n        j = np.random.randint(0, n)\n\n    # Calculate the change in all three objectives\n    delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n              distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_1[new_solution[i-1], new_solution[i]] -\n              distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n\n    delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n              distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_2[new_solution[i-1], new_solution[i]] -\n              distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n    delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n              distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_3[new_solution[i-1], new_solution[i]] -\n              distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n    # Accept if at least two objectives improve\n    if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n        # Perform the insertion\n        node_to_move = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -7784.5633248624845,
            0.3356810688972473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective diversity\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.prod(norm_objectives, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node insertion with objective-aware selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) < 2:\n        j = np.random.randint(0, n)\n\n    # Calculate the change in all three objectives\n    delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n              distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_1[new_solution[i-1], new_solution[i]] -\n              distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n\n    delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n              distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_2[new_solution[i-1], new_solution[i]] -\n              distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n    delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n              distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n              distance_matrix_3[new_solution[i-1], new_solution[i]] -\n              distance_matrix_3[new_solution[i], new_solution[(i+1)%n]])\n\n    # Accept if at least two objectives improve\n    if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and delta3 < 0) or (delta2 < 0 and delta3 < 0):\n        # Perform the insertion\n        node_to_move = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node_to_move)\n\n    return new_solution\n\n"
    }
]