[
    {
        "algorithm": "{The new algorithm combines route merging with demand-aware rebalancing by first merging two routes into one if their combined demand fits within capacity, then redistributing customers between the new route and a third route to balance loads and reduce makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Randomly select two routes to potentially merge\n    route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Check if merging these routes is feasible\n    total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n    if total_demand > capacity:\n        return new_solution\n\n    # Merge the two routes by combining their customers\n    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n    np.random.shuffle(merged_route)  # Randomize order for rebalancing\n    merged_route = np.insert(merged_route, 0, 0)\n    merged_route = np.append(merged_route, 0)\n\n    # Try to rebalance by redistributing customers to another route\n    if len(new_solution) > 2:\n        other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i not in (route1_idx, route2_idx)])\n        other_route = new_solution[other_route_idx]\n\n        # Calculate remaining capacity of the other route\n        other_load = sum(demand[node] for node in other_route[1:-1])\n        available_capacity = capacity - other_load\n\n        # Move customers from merged route to other route if possible\n        for i in range(len(merged_route) - 2, 0, -1):\n            node = merged_route[i]\n            if demand[node] <= available_capacity:\n                # Insert node into other route at the best position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    temp_route = np.insert(other_route, pos, node)\n                    new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n\n                # Perform the move\n                other_route = np.insert(other_route, best_pos, node)\n                merged_route = np.delete(merged_route, i)\n                available_capacity -= demand[node]\n\n        # Update the solution\n        new_solution[other_route_idx] = other_route\n        new_solution[route1_idx] = merged_route\n        del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7710716440369542,
            0.1315108835697174
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with demand-aware rebalancing by first splitting a long route into two shorter routes if their demands fit within capacity, then redistributing customers between the new routes and an existing route to balance loads and reduce makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Randomly select a route to potentially split\n    route_idx = np.random.choice(len(new_solution))\n    route = new_solution[route_idx]\n    customers = route[1:-1]\n\n    if len(customers) < 2:\n        return new_solution\n\n    # Split the route into two parts\n    split_pos = np.random.randint(1, len(customers))\n    part1 = customers[:split_pos]\n    part2 = customers[split_pos:]\n\n    # Check if both parts fit within capacity\n    demand_part1 = sum(demand[node] for node in part1)\n    demand_part2 = sum(demand[node] for node in part2)\n\n    if demand_part1 > capacity or demand_part2 > capacity:\n        return new_solution\n\n    # Create two new routes\n    new_route1 = np.insert(part1, 0, 0)\n    new_route1 = np.append(new_route1, 0)\n    new_route2 = np.insert(part2, 0, 0)\n    new_route2 = np.append(new_route2, 0)\n\n    # Replace the original route with the two new routes\n    new_solution[route_idx] = new_route1\n    new_solution.insert(route_idx + 1, new_route2)\n\n    # Try to rebalance by redistributing customers to another route\n    if len(new_solution) > 2:\n        other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n        other_route = new_solution[other_route_idx]\n\n        # Calculate remaining capacity of the other route\n        other_load = sum(demand[node] for node in other_route[1:-1])\n        available_capacity = capacity - other_load\n\n        # Move customers from new routes to other route if possible\n        for new_route in [new_route1, new_route2]:\n            for i in range(len(new_route) - 2, 0, -1):\n                node = new_route[i]\n                if demand[node] <= available_capacity:\n                    # Insert node into other route at the best position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(other_route)):\n                        temp_route = np.insert(other_route, pos, node)\n                        new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                        if new_cost < best_cost:\n                            best_cost = new_cost\n                            best_pos = pos\n\n                    # Perform the move\n                    other_route = np.insert(other_route, best_pos, node)\n                    new_route = np.delete(new_route, i)\n                    available_capacity -= demand[node]\n\n        # Update the solution\n        new_solution[other_route_idx] = other_route\n\n    return new_solution\n\n",
        "score": [
            -0.8015843910753389,
            0.424274742603302
        ]
    },
    {
        "algorithm": "{This new algorithm implements a demand-aware route splitting and reinsertion strategy that first identifies the longest route in the solution, splits it into smaller segments based on capacity constraints, and then intelligently reinserts the segments into the solution while optimizing both total distance and makespan by considering spatial proximity and demand balance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Select the longest route for splitting\n    longest_route_idx = np.argmax([len(route) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:  # Route has only depot and one customer\n        return new_solution\n\n    # Calculate cumulative demand along the route\n    cumulative_demand = np.cumsum([demand[node] for node in longest_route[1:-1]])\n\n    # Find split points where cumulative demand exceeds capacity\n    split_points = [0] + [i+1 for i in range(len(cumulative_demand)-1) if cumulative_demand[i] <= capacity and cumulative_demand[i+1] > capacity]\n\n    if len(split_points) <= 1:\n        return new_solution\n\n    # Split the route into segments\n    segments = []\n    for i in range(len(split_points)-1):\n        start = split_points[i]\n        end = split_points[i+1]\n        segment = longest_route[start+1:end+1]\n        segments.append(segment)\n\n    # Remove the original long route\n    del new_solution[longest_route_idx]\n\n    # Reinsert segments into the solution\n    for segment in segments:\n        best_route_idx = -1\n        best_insertion_cost = float('inf')\n        best_position = -1\n\n        # Find the best route and position to insert the segment\n        for route_idx, route in enumerate(new_solution):\n            for pos in range(1, len(route)):\n                # Check capacity constraint\n                segment_demand = sum(demand[node] for node in segment)\n                route_demand = sum(demand[node] for node in route[1:-1])\n                if route_demand + segment_demand > capacity:\n                    continue\n\n                # Calculate insertion cost\n                temp_route = np.insert(route, pos, segment)\n                insertion_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n\n                if insertion_cost < best_insertion_cost:\n                    best_insertion_cost = insertion_cost\n                    best_route_idx = route_idx\n                    best_position = pos\n\n        # Insert the segment into the best position\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_position, segment)\n        else:\n            # If no suitable position found, create a new route\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7390465425489432,
            0.11352488398551941
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining route merging, customer reinsertion, and intra-route optimization to generate a neighbor solution while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))\n    selected = random.choice(archive[:max(1, len(archive)//2)])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n    routes = [route for route in base_solution if len(route) > 2]\n\n    # Try route merging\n    if len(routes) > 1:\n        route1_idx = random.randint(0, len(routes)-1)\n        route2_idx = random.randint(0, len(routes)-1)\n        if route1_idx != route2_idx:\n            route1 = routes[route1_idx]\n            route2 = routes[route2_idx]\n\n            # Check if merging is possible\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Merge routes by connecting them at closest points\n                min_dist = float('inf')\n                best_pos1, best_pos2 = 0, 0\n\n                for i in range(1, len(route1)-1):\n                    for j in range(1, len(route2)-1):\n                        dist = distance_matrix[route1[i], route2[j]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pos1, best_pos2 = i, j\n\n                # Create merged route\n                merged_route = np.concatenate([\n                    route1[:best_pos1+1],\n                    route2[best_pos2:],\n                    route1[best_pos1+1:]\n                ])\n                new_solution.append(merged_route)\n\n                # Remove merged routes\n                routes = [r for idx, r in enumerate(routes) if idx not in [route1_idx, route2_idx]]\n                routes.extend(new_solution)\n            else:\n                new_solution.extend(routes)\n        else:\n            new_solution.extend(routes)\n    else:\n        new_solution.extend(routes)\n\n    # Customer reinsertion with optimization\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Sort customers by demand (descending) to prioritize larger customers\n        missing_customers = sorted(missing_customers, key=lambda x: -demand[x])\n\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_score = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion position considering both distance and balance\n                for j in range(len(route)-1):\n                    dist_increase = (distance_matrix[route[j], customer] +\n                                   distance_matrix[customer, route[j+1]] -\n                                   distance_matrix[route[j], route[j+1]])\n\n                    # Score combines distance increase and demand balance\n                    new_demand = current_demand + demand[customer]\n                    balance_score = abs(new_demand - capacity/2)\n                    score = dist_increase + 0.5 * balance_score\n\n                    if score < best_score:\n                        best_score = score\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    # Intra-route optimization (2.5-opt for routes with >4 customers)\n    for i, route in enumerate(new_solution):\n        if len(route) > 6:  # Only optimize longer routes\n            for _ in range(2):  # Limited attempts\n                # Select 5 random positions (excluding depot)\n                positions = sorted(random.sample(range(1, len(route)-1), 5))\n\n                # Try different configurations\n                configs = [\n                    [positions[0], positions[1], positions[2], positions[3], positions[4]],\n                    [positions[0], positions[2], positions[1], positions[3], positions[4]],\n                    [positions[0], positions[1], positions[3], positions[2], positions[4]],\n                    [positions[0], positions[2], positions[3], positions[1], positions[4]]\n                ]\n\n                best_config = None\n                min_cost = float('inf')\n\n                for config in configs:\n                    # Reconstruct route with this configuration\n                    temp_route = np.array([0] + [route[pos] for pos in [0] + config + [len(route)-1]] + [0])\n\n                    # Calculate total distance\n                    total_dist = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n\n                    if total_dist < min_cost:\n                        min_cost = total_dist\n                        best_config = config\n\n                if best_config:\n                    # Apply best configuration\n                    new_route = np.array([0] + [route[pos] for pos in [0] + best_config + [len(route)-1]] + [0])\n                    new_solution[i] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8718531319664314,
            0.805967390537262
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route merging, customer reinsertion with demand-aware positioning, and inter-route segment swaps to generate a neighbor solution while ensuring feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    selected = random.choice(archive[:max(1, len(archive)//3)])\n    base_solution = selected[0].copy()\n\n    new_solution = []\n    routes = [route for route in base_solution if len(route) > 2]\n\n    if len(routes) > 1:\n        route1_idx = random.randint(0, len(routes)-1)\n        route2_idx = random.randint(0, len(routes)-1)\n        if route1_idx != route2_idx:\n            route1 = routes[route1_idx]\n            route2 = routes[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if demand1 + demand2 <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [r for i, r in enumerate(routes) if i not in {route1_idx, route2_idx}]\n                new_solution.append(merged_route)\n            else:\n                new_solution = routes.copy()\n\n            if random.random() < 0.5 and len(new_solution) > 1:\n                route_idx = random.randint(0, len(new_solution)-1)\n                route = new_solution[route_idx]\n                if len(route) > 4:\n                    split_pos = random.randint(1, len(route)-2)\n                    part1 = route[:split_pos+1]\n                    part2 = route[split_pos:]\n\n                    demand_part1 = sum(demand[part1[1:-1]])\n                    demand_part2 = sum(demand[part2[1:-1]])\n\n                    if demand_part1 <= capacity and demand_part2 <= capacity:\n                        new_solution[route_idx] = part1\n                        new_solution.append(part2)\n    else:\n        new_solution = routes.copy()\n\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 3:\n                pos1 = random.randint(1, len(route1)-3)\n                pos2 = random.randint(1, len(route2)-3)\n\n                segment1 = route1[pos1:pos1+2]\n                segment2 = route2[pos2:pos2+2]\n\n                demand_route1 = sum(demand[route1[1:-1]]) - sum(demand[segment1[1:-1]]) + sum(demand[segment2[1:-1]])\n                demand_route2 = sum(demand[route2[1:-1]]) - sum(demand[segment2[1:-1]]) + sum(demand[segment1[1:-1]])\n\n                if demand_route1 <= capacity and demand_route2 <= capacity:\n                    new_route1 = np.concatenate([route1[:pos1], segment2, route1[pos1+2:]])\n                    new_route2 = np.concatenate([route2[:pos2], segment1, route2[pos2+2:]])\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_improvement = -float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                for j in range(len(route)-1):\n                    dist_before = distance_matrix[route[j], route[j+1]]\n                    dist_after = distance_matrix[route[j], customer] + distance_matrix[customer, route[j+1]]\n                    improvement = dist_before - dist_after\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5525269048812648,
            0.12736353278160095
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with balanced objectives, then applies a hybrid local search combining route merging, customer reinsertion, and intra-route segment reversals to generate a neighbor solution while ensuring feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))  # Weighted by importance\n    selected = random.choice(archive[:max(1, len(archive)//2)])  # Pick from top half\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # 1. Route merging: Try to merge two routes if their combined demand is within capacity\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes by connecting them\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    # 2. Customer reinsertion: Remove a random customer and reinsert it optimally\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Need at least 3 nodes (depot + 1 customer + depot)\n            pos = random.randint(1, len(route)-2)\n            customer = route[pos]\n            # Remove customer\n            new_route = np.concatenate([route[:pos], route[pos+1:]])\n            new_solution[route_idx] = new_route\n\n            # Find best reinsertion position\n            best_route = None\n            best_pos = None\n            best_distance_increase = float('inf')\n\n            for i, candidate_route in enumerate(new_solution):\n                current_demand = sum(demand[candidate_route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                for j in range(len(candidate_route)-1):\n                    dist_increase = (distance_matrix[candidate_route[j], customer] +\n                                   distance_matrix[customer, candidate_route[j+1]] -\n                                   distance_matrix[candidate_route[j], candidate_route[j+1]])\n\n                    if dist_increase < best_distance_increase:\n                        best_distance_increase = dist_increase\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    # 3. Intra-route segment reversal: Reverse a random segment of a route\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Need at least 5 nodes for a meaningful reversal\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            reversed_segment = route[start:end][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end:]])\n            new_solution[i] = new_route\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Assign missing customers to routes with available capacity\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_distance_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion position\n                for j in range(len(route)-1):\n                    dist_increase = (distance_matrix[route[j], customer] +\n                                   distance_matrix[customer, route[j+1]] -\n                                   distance_matrix[route[j], route[j+1]])\n\n                    if dist_increase < best_distance_increase:\n                        best_distance_increase = dist_increase\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7183359669900888,
            0.24442437291145325
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a novel combination of Pareto dominance and objective correlation, then applies a hybrid local search that combines route reversal, customer migration, and adaptive route merging to generate a neighbor solution while maintaining feasibility and improving both objectives through a dynamic balance of distance and makespan optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + 0.5*x[1][1]))  # Weighted sum prioritizing distance but considering makespan\n    selected = random.choice(archive[:max(1, len(archive)//2)])  # Wider selection range\n    base_solution = selected[0].copy()\n\n    new_solution = []\n    for route in base_solution:\n        if len(route) > 3:\n            # Adaptive route reversal with capacity check\n            reversed_route = route[::-1]\n            reversed_demand = sum(demand[reversed_route[1:-1]])\n            if reversed_demand <= capacity:\n                new_solution.append(reversed_route)\n            else:\n                # If reversal exceeds capacity, try partial reversal\n                for i in range(1, len(route)-1):\n                    partial_reversed = np.concatenate([route[:i], route[i:][::-1]])\n                    partial_demand = sum(demand[partial_reversed[1:-1]])\n                    if partial_demand <= capacity:\n                        new_solution.append(partial_reversed)\n                        break\n                else:\n                    new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Customer migration between routes\n    if len(new_solution) > 1:\n        for _ in range(2):  # Perform multiple migrations\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 2:\n                    # Select random customer to migrate\n                    customer_pos = random.randint(1, len(route1)-2)\n                    customer = route1[customer_pos]\n\n                    # Check capacity constraints\n                    demand_route1 = sum(demand[route1[1:-1]]) - demand[customer]\n                    demand_route2 = sum(demand[route2[1:-1]]) + demand[customer]\n\n                    if demand_route1 <= capacity and demand_route2 <= capacity:\n                        # Find best insertion point in route2\n                        best_pos = None\n                        best_gain = -float('inf')\n\n                        for i in range(len(route2)-1):\n                            gain = (distance_matrix[route2[i], customer] +\n                                   distance_matrix[customer, route2[i+1]] -\n                                   distance_matrix[route2[i], route2[i+1]])\n\n                            if gain > best_gain:\n                                best_gain = gain\n                                best_pos = i\n\n                        if best_pos is not None:\n                            # Perform migration\n                            new_route1 = np.delete(route1, customer_pos)\n                            new_route2 = np.insert(route2, best_pos+1, customer)\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n\n    # Adaptive route merging\n    if len(new_solution) > 2:\n        for _ in range(2):  # Try multiple merges\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                # Check capacity constraint\n                total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Calculate potential distance improvement\n                    dist_before = (distance_matrix[route1[-2], 0] +\n                                 distance_matrix[route2[-2], 0] +\n                                 distance_matrix[0, route1[1]] +\n                                 distance_matrix[0, route2[1]])\n\n                    dist_after = (distance_matrix[route1[-2], route2[1]] +\n                                 distance_matrix[route2[-2], route1[1]])\n\n                    if dist_after < dist_before * 0.95:  # Only merge if significant improvement\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution[route1_idx] = merged_route\n                        new_solution.pop(route2_idx)\n                        break\n\n    # Remove empty routes and ensure all customers are served\n    new_solution = [route for route in new_solution if len(route) > 2]\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Assign missing customers to shortest possible route\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_distance = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                # Find insertion that minimizes route length\n                for j in range(len(route)-1):\n                    dist = (distance_matrix[route[j], customer] +\n                           distance_matrix[customer, route[j+1]] -\n                           distance_matrix[route[j], route[j+1]])\n\n                    if dist < best_distance:\n                        best_distance = dist\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n            else:\n                # If no feasible route found, create a new route\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.6448471339544957,
            0.2122381031513214
        ]
    },
    {
        "algorithm": "{This new algorithm employs a demand-weighted cluster merging strategy that first identifies clusters of customers with similar demands, then merges routes while prioritizing clusters to balance capacity utilization and minimize makespan through iterative load redistribution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Create demand clusters\n    demand_clusters = {}\n    for route in new_solution:\n        for node in route[1:-1]:\n            cluster_key = int(demand[node] // (capacity / 5))  # Divide into 5 demand ranges\n            if cluster_key not in demand_clusters:\n                demand_clusters[cluster_key] = []\n            demand_clusters[cluster_key].append(node)\n\n    # Select routes with customers from similar demand clusters\n    cluster_keys = list(demand_clusters.keys())\n    if len(cluster_keys) < 2:\n        return new_solution\n\n    key1, key2 = np.random.choice(cluster_keys, 2, replace=False)\n    route1_idx = next((i for i, route in enumerate(new_solution)\n                      if any(node in route for node in demand_clusters[key1])), -1)\n    route2_idx = next((i for i, route in enumerate(new_solution)\n                      if any(node in route for node in demand_clusters[key2])), -1)\n\n    if route1_idx == -1 or route2_idx == -1:\n        return new_solution\n\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Check if merging is feasible\n    total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n    if total_demand > capacity:\n        return new_solution\n\n    # Merge routes\n    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n    np.random.shuffle(merged_route)\n\n    # Rebalance by redistributing customers\n    if len(new_solution) > 2:\n        other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i not in (route1_idx, route2_idx)])\n        other_route = new_solution[other_route_idx]\n\n        other_load = sum(demand[node] for node in other_route[1:-1])\n        available_capacity = capacity - other_load\n\n        # Sort nodes by demand (descending) to try larger moves first\n        sorted_nodes = sorted(merged_route, key=lambda x: -demand[x])\n\n        for node in sorted_nodes:\n            if demand[node] <= available_capacity:\n                # Find best insertion position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    temp_route = np.insert(other_route, pos, node)\n                    new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n\n                other_route = np.insert(other_route, best_pos, node)\n                merged_route = np.delete(merged_route, np.where(merged_route == node)[0][0])\n                available_capacity -= demand[node]\n\n        new_solution[other_route_idx] = other_route\n\n    # Update merged route\n    merged_route = np.insert(merged_route, 0, 0)\n    merged_route = np.append(merged_route, 0)\n    new_solution[route1_idx] = merged_route\n    del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7702228511389017,
            0.6947624683380127
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0]\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    route = new_solution[route_idx]\n\n    # Apply a hybrid local search operator: Route Shuffling with Capacity-Aware Insertion\n    if len(route) > 3:  # Ensure route has at least one customer\n        # Step 1: Shuffle the internal nodes of the route (excluding depots)\n        internal_nodes = route[1:-1]\n        np.random.shuffle(internal_nodes)\n        route[1:-1] = internal_nodes\n\n        # Step 2: Attempt to insert a node from another route if capacity allows\n        if len(new_solution) > 1:\n            other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(other_route) > 3:  # If other route has customers\n                node_to_move = other_route[np.random.randint(1, len(other_route)-1)]\n\n                # Calculate remaining capacity of the current route\n                current_load = sum(demand[node] for node in route[1:-1])\n                if current_load + demand[node_to_move] <= capacity:\n                    # Find the best insertion position in the current route\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route)):\n                        # Insert node_to_move at position pos\n                        temp_route = np.insert(route, pos, node_to_move)\n                        # Calculate new cost (distance) of the modified route\n                        new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                        if new_cost < best_cost:\n                            best_cost = new_cost\n                            best_pos = pos\n\n                    # Perform the insertion\n                    route = np.insert(route, best_pos, node_to_move)\n                    # Remove the node from the other route\n                    other_route = np.delete(other_route, np.where(other_route == node_to_move)[0][0])\n                    # Update the solution\n                    new_solution[route_idx] = route\n                    new_solution[other_route_idx] = other_route\n\n    return new_solution\n\n",
        "score": [
            -0.49311093101338577,
            0.1904425323009491
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the highest makespan, then applies a novel local search combining route merging, customer reinsertion with spatial clustering, and adaptive inter-route swaps to generate a neighbor solution while balancing both objectives and ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    selected = archive[0]\n    base_solution = selected[0].copy()\n\n    # Route merging operator\n    new_solution = []\n    for i in range(len(base_solution)):\n        for j in range(i+1, len(base_solution)):\n            route1 = base_solution[i]\n            route2 = base_solution[j]\n\n            # Check if merging is feasible\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand > capacity:\n                continue\n\n            # Calculate merged route distance\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            route_distance = sum(distance_matrix[merged_route[k], merged_route[k+1]] for k in range(len(merged_route)-1))\n\n            # Calculate original routes distance\n            original_distance = (sum(distance_matrix[route1[k], route1[k+1]] for k in range(len(route1)-1)) +\n                                sum(distance_matrix[route2[k], route2[k+1]] for k in range(len(route2)-1)))\n\n            # Accept merge if it reduces total distance\n            if route_distance < original_distance:\n                new_solution.append(merged_route)\n                break\n        else:\n            new_solution.append(base_solution[i])\n\n    # Customer reinsertion with spatial clustering\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Cluster customers by spatial proximity\n        customer_coords = coords[list(missing_customers)]\n        from sklearn.cluster import KMeans\n        n_clusters = min(len(missing_customers), len(new_solution))\n        kmeans = KMeans(n_clusters=n_clusters, random_state=42).fit(customer_coords)\n        clusters = [[] for _ in range(n_clusters)]\n        for customer in missing_customers:\n            cluster = kmeans.predict([coords[customer]])[0]\n            clusters[cluster].append(customer)\n\n        # Reinsert customers to nearest route\n        for cluster in clusters:\n            for customer in cluster:\n                best_route = None\n                best_pos = None\n                best_distance = float('inf')\n\n                for i, route in enumerate(new_solution):\n                    current_demand = sum(demand[route[1:-1]])\n                    if current_demand + demand[customer] > capacity:\n                        continue\n\n                    # Find insertion position minimizing distance increase\n                    for j in range(len(route)-1):\n                        dist_increase = (distance_matrix[route[j], customer] +\n                                       distance_matrix[customer, route[j+1]] -\n                                       distance_matrix[route[j], route[j+1]])\n\n                        if dist_increase < best_distance:\n                            best_distance = dist_increase\n                            best_route = i\n                            best_pos = j\n\n                if best_route is not None:\n                    new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                    new_solution[best_route] = new_route\n\n    # Adaptive inter-route swaps\n    if len(new_solution) > 1:\n        for _ in range(min(3, len(new_solution))):\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 2 and len(route2) > 2:\n                    # Select segments to swap\n                    seg1_start = random.randint(1, len(route1)-2)\n                    seg1_end = random.randint(seg1_start, len(route1)-2)\n                    seg2_start = random.randint(1, len(route2)-2)\n                    seg2_end = random.randint(seg2_start, len(route2)-2)\n\n                    # Check capacity constraints\n                    demand_route1 = (sum(demand[route1[1:-1]]) -\n                                   sum(demand[route1[seg1_start:seg1_end]]) +\n                                   sum(demand[route2[seg2_start:seg2_end]]))\n\n                    demand_route2 = (sum(demand[route2[1:-1]]) -\n                                   sum(demand[route2[seg2_start:seg2_end]]) +\n                                   sum(demand[route1[seg1_start:seg1_end]]))\n\n                    if demand_route1 <= capacity and demand_route2 <= capacity:\n                        # Perform the swap\n                        new_route1 = np.concatenate([\n                            route1[:seg1_start],\n                            route2[seg2_start:seg2_end],\n                            route1[seg1_end:]\n                        ])\n                        new_route2 = np.concatenate([\n                            route2[:seg2_start],\n                            route1[seg1_start:seg1_end],\n                            route2[seg2_end:]\n                        ])\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Create new routes for missing customers\n        for customer in missing_customers:\n            new_route = np.array([0, customer, 0])\n            new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.6698456531446157,
            0.4068756699562073
        ]
    }
]