[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of crowding distance and objective normalization, then applies a novel route transformation operator that combines partial route reversal, segment migration, and demand-balanced insertion to generate a neighbor solution while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        # Normalize objectives\n        min_dist = min(s[1][0] for s in archive)\n        max_dist = max(s[1][0] for s in archive)\n        min_make = min(s[1][1] for s in archive)\n        max_make = max(s[1][1] for s in archive)\n\n        normalized = []\n        for sol in archive:\n            norm_dist = (sol[1][0] - min_dist) / (max_dist - min_dist + 1e-8)\n            norm_make = (sol[1][1] - min_make) / (max_make - min_make + 1e-8)\n            normalized.append((sol, norm_dist, norm_make))\n\n        # Sort by crowding distance\n        normalized.sort(key=lambda x: (x[1] + x[2]) / 2, reverse=True)\n        selected = normalized[0][0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route transformation operator\n    if len(new_solution) > 1:\n        # Select two distinct routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Partial route reversal with demand check\n        if len(route1) > 4:\n            start_pos = random.randint(1, len(route1)-3)\n            end_pos = random.randint(start_pos+1, len(route1)-2)\n            reversed_segment = route1[start_pos:end_pos][::-1]\n\n            # Check capacity after reversal\n            if (sum(demand[np.concatenate([route1[1:start_pos], reversed_segment, route1[end_pos:-1]])]) <= capacity):\n                new_route1 = np.concatenate([route1[:start_pos], reversed_segment, route1[end_pos:]])\n                new_solution[route1_idx] = new_route1\n\n        # Segment migration with demand balance\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segment from route1\n            start_pos = random.randint(1, len(route1)-3)\n            end_pos = random.randint(start_pos+1, len(route1)-2)\n            segment = route1[start_pos:end_pos]\n\n            # Check capacity after removal\n            if (sum(demand[route1[1:start_pos]]) + sum(demand[route1[end_pos:-1]]) <= capacity and\n                sum(demand[route2[1:-1]]) + sum(demand[segment]) <= capacity):\n\n                # Calculate potential demand balance\n                route1_new_demand = sum(demand[route1[1:start_pos]]) + sum(demand[route1[end_pos:-1]])\n                route2_new_demand = sum(demand[route2[1:-1]]) + sum(demand[segment])\n\n                # Only proceed if both routes remain balanced\n                if (abs(route1_new_demand - capacity/2) < abs(sum(demand[route1[1:-1]]) - capacity/2) and\n                    abs(route2_new_demand - capacity/2) < abs(sum(demand[route2[1:-1]]) - capacity/2)):\n\n                    # Create new routes\n                    new_route1 = np.concatenate([route1[:start_pos], route1[end_pos:]])\n                    new_route2 = np.concatenate([route2[:-1], segment, [0]])\n\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Demand-balanced insertion\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Sort customers by demand (descending) to prioritize larger customers\n        missing_customers = sorted(missing_customers, key=lambda x: -demand[x])\n\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_balance = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion position considering demand balance\n                for j in range(len(route)-1):\n                    new_demand = current_demand + demand[customer]\n                    balance_score = abs(new_demand - capacity/2)\n\n                    if balance_score < best_balance:\n                        best_balance = balance_score\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.9264798990634219,
            0.15741705894470215
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a non-dominated sorting approach, then applies a hybrid local search combining route splitting, customer swapping, and inter-route optimization to generate a neighbor solution while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    fronts = []\n    dominated_counts = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] <= archive[j][1][1] and\n                    (archive[i][1][0] < archive[j][1][0] or archive[i][1][1] < archive[j][1][1])):\n                    dominating_sets[i].append(j)\n                elif (archive[j][1][0] <= archive[i][1][0] and archive[j][1][1] <= archive[i][1][1] and\n                      (archive[j][1][0] < archive[i][1][0] or archive[j][1][1] < archive[i][1][1])):\n                    dominated_counts[i] += 1\n\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating_sets[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    # Select from the first non-dominated front\n    if fronts[0]:\n        selected_idx = random.choice(fronts[0])\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Route splitting with capacity check\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Only split long routes\n            split_pos = random.randint(2, len(route)-3)\n            first_part = route[:split_pos+1]\n            second_part = np.array([0] + route[split_pos:-1].tolist() + [0])\n\n            # Check capacity constraints\n            if (sum(demand[first_part[1:-1]]) <= capacity and\n                sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.append(second_part)\n\n    # Customer swapping between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select random customers from each route (excluding depots)\n            cust1_pos = random.randint(1, len(route1)-2)\n            cust2_pos = random.randint(1, len(route2)-2)\n\n            # Check capacity constraints after swap\n            if (sum(demand[route1[1:-1]]) - demand[route1[cust1_pos]] + demand[route2[cust2_pos]] <= capacity and\n                sum(demand[route2[1:-1]]) - demand[route2[cust2_pos]] + demand[route1[cust1_pos]] <= capacity):\n\n                # Perform swap\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[cust1_pos], new_route2[cust2_pos] = new_route2[cust2_pos], new_route1[cust1_pos]\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Inter-route optimization (cross-route 2-opt)\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select two random positions from each route (excluding depots)\n            pos1 = random.randint(1, len(route1)-2)\n            pos2 = random.randint(1, len(route2)-2)\n\n            # Try swapping segments\n            new_route1 = np.concatenate([route1[:pos1], route2[pos2:]])\n            new_route2 = np.concatenate([route2[:pos2], route1[pos1:]])\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n\n                # Calculate distance change\n                old_dist = (distance_matrix[route1[pos1-1], route1[pos1]] +\n                           distance_matrix[route1[-2], route1[-1]] +\n                           distance_matrix[route2[pos2-1], route2[pos2]] +\n                           distance_matrix[route2[-2], route2[-1]])\n\n                new_dist = (distance_matrix[new_route1[pos1-1], new_route1[pos1]] +\n                           distance_matrix[new_route1[-2], new_route1[-1]] +\n                           distance_matrix[new_route2[pos2-1], new_route2[pos2]] +\n                           distance_matrix[new_route2[-2], new_route2[-1]])\n\n                # Accept if distance decreases\n                if new_dist < old_dist:\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8252884346623004,
            0.08127644658088684
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with capacity-aware demand rebalancing by first splitting a long route into two shorter routes, then redistributing customers between the new routes to balance loads and reduce makespan while ensuring all capacity constraints are satisfied.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Randomly select a route to split\n    route_idx = np.random.choice(len(new_solution))\n    route = new_solution[route_idx]\n\n    # Calculate route demand and total distance\n    route_demand = sum(demand[node] for node in route[1:-1])\n    route_distance = sum(distance_matrix[route[i-1], route[i]] for i in range(1, len(route)))\n\n    # Calculate average demand per customer in the route\n    avg_demand = route_demand / (len(route) - 2) if len(route) > 2 else 0\n\n    # Split the route into two parts at a random position\n    split_pos = np.random.randint(1, len(route) - 1)\n    part1 = route[:split_pos + 1]\n    part2 = route[split_pos:]\n    part2[0] = 0  # Ensure part2 starts at depot\n\n    # Calculate demands for both parts\n    part1_demand = sum(demand[node] for node in part1[1:-1])\n    part2_demand = sum(demand[node] for node in part2[1:-1])\n\n    # Check if splitting is feasible (both parts must have demand <= capacity)\n    if part1_demand > capacity or part2_demand > capacity:\n        return new_solution\n\n    # Replace the original route with the two new routes\n    new_solution[route_idx] = part1\n    new_solution.insert(route_idx + 1, part2)\n\n    # Try to rebalance customers between the two new routes\n    for i in range(len(part1) - 2, 0, -1):\n        node = part1[i]\n        if demand[node] <= (capacity - part2_demand):\n            # Calculate insertion cost in part2\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(part2)):\n                temp_route = np.insert(part2, pos, node)\n                new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                if new_cost < best_cost:\n                    best_cost = new_cost\n                    best_pos = pos\n\n            # Perform the move\n            part2 = np.insert(part2, best_pos, node)\n            part1 = np.delete(part1, i)\n            part2_demand += demand[node]\n\n    # Update the solution\n    new_solution[route_idx] = part1\n    new_solution[route_idx + 1] = part2\n\n    return new_solution\n\n",
        "score": [
            -0.8519818579398478,
            0.4886901080608368
        ]
    },
    {
        "algorithm": "{This new algorithm implements a demand-aware route splitting and reinsertion strategy that first identifies the longest route in the solution, splits it into smaller segments based on capacity constraints, and then intelligently reinserts the segments into the solution while optimizing both total distance and makespan by considering spatial proximity and demand balance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Select the longest route for splitting\n    longest_route_idx = np.argmax([len(route) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:  # Route has only depot and one customer\n        return new_solution\n\n    # Calculate cumulative demand along the route\n    cumulative_demand = np.cumsum([demand[node] for node in longest_route[1:-1]])\n\n    # Find split points where cumulative demand exceeds capacity\n    split_points = [0] + [i+1 for i in range(len(cumulative_demand)-1) if cumulative_demand[i] <= capacity and cumulative_demand[i+1] > capacity]\n\n    if len(split_points) <= 1:\n        return new_solution\n\n    # Split the route into segments\n    segments = []\n    for i in range(len(split_points)-1):\n        start = split_points[i]\n        end = split_points[i+1]\n        segment = longest_route[start+1:end+1]\n        segments.append(segment)\n\n    # Remove the original long route\n    del new_solution[longest_route_idx]\n\n    # Reinsert segments into the solution\n    for segment in segments:\n        best_route_idx = -1\n        best_insertion_cost = float('inf')\n        best_position = -1\n\n        # Find the best route and position to insert the segment\n        for route_idx, route in enumerate(new_solution):\n            for pos in range(1, len(route)):\n                # Check capacity constraint\n                segment_demand = sum(demand[node] for node in segment)\n                route_demand = sum(demand[node] for node in route[1:-1])\n                if route_demand + segment_demand > capacity:\n                    continue\n\n                # Calculate insertion cost\n                temp_route = np.insert(route, pos, segment)\n                insertion_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n\n                if insertion_cost < best_insertion_cost:\n                    best_insertion_cost = insertion_cost\n                    best_route_idx = route_idx\n                    best_position = pos\n\n        # Insert the segment into the best position\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_position, segment)\n        else:\n            # If no suitable position found, create a new route\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7390465425489432,
            0.11352488398551941
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with demand-aware customer redistribution by first selecting two short routes with complementary demands, then merging them into one route while strategically redistributing customers to balance the load and minimize the makespan while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Select two routes to merge\n    route_indices = np.random.choice(len(new_solution), size=2, replace=False)\n    route1_idx, route2_idx = min(route_indices), max(route_indices)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Calculate demands and distances\n    demand1 = sum(demand[node] for node in route1[1:-1])\n    demand2 = sum(demand[node] for node in route2[1:-1])\n    total_demand = demand1 + demand2\n\n    if total_demand > capacity:\n        return new_solution\n\n    # Merge the two routes\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n    # Remove the two routes and add the merged one\n    new_solution.pop(route2_idx)\n    new_solution.pop(route1_idx)\n    new_solution.append(merged_route)\n\n    # Try to rebalance customers in the merged route\n    for i in range(1, len(merged_route) - 1):\n        node = merged_route[i]\n        if demand[node] <= (capacity - total_demand):\n            # Calculate removal cost\n            original_cost = distance_matrix[merged_route[i-1], merged_route[i]] + distance_matrix[merged_route[i], merged_route[i+1]]\n            new_cost = distance_matrix[merged_route[i-1], merged_route[i+1]]\n\n            if new_cost < original_cost:\n                # Remove the node from the route\n                merged_route = np.delete(merged_route, i)\n                total_demand -= demand[node]\n                i -= 1  # Adjust index after deletion\n\n    # Update the solution\n    new_solution[-1] = merged_route\n\n    return new_solution\n\n",
        "score": [
            -0.7652536488197371,
            0.11572450399398804
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with demand-aware rebalancing by first merging two routes into one if their combined demand fits within capacity, then redistributing customers between the new route and a third route to balance loads and reduce makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Randomly select two routes to potentially merge\n    route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Check if merging these routes is feasible\n    total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n    if total_demand > capacity:\n        return new_solution\n\n    # Merge the two routes by combining their customers\n    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n    np.random.shuffle(merged_route)  # Randomize order for rebalancing\n    merged_route = np.insert(merged_route, 0, 0)\n    merged_route = np.append(merged_route, 0)\n\n    # Try to rebalance by redistributing customers to another route\n    if len(new_solution) > 2:\n        other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i not in (route1_idx, route2_idx)])\n        other_route = new_solution[other_route_idx]\n\n        # Calculate remaining capacity of the other route\n        other_load = sum(demand[node] for node in other_route[1:-1])\n        available_capacity = capacity - other_load\n\n        # Move customers from merged route to other route if possible\n        for i in range(len(merged_route) - 2, 0, -1):\n            node = merged_route[i]\n            if demand[node] <= available_capacity:\n                # Insert node into other route at the best position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    temp_route = np.insert(other_route, pos, node)\n                    new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n\n                # Perform the move\n                other_route = np.insert(other_route, best_pos, node)\n                merged_route = np.delete(merged_route, i)\n                available_capacity -= demand[node]\n\n        # Update the solution\n        new_solution[other_route_idx] = other_route\n        new_solution[route1_idx] = merged_route\n        del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7710716440369542,
            0.1315108835697174
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining route merging, customer reinsertion, and intra-route optimization to generate a neighbor solution while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))\n    selected = random.choice(archive[:max(1, len(archive)//2)])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n    routes = [route for route in base_solution if len(route) > 2]\n\n    # Try route merging\n    if len(routes) > 1:\n        route1_idx = random.randint(0, len(routes)-1)\n        route2_idx = random.randint(0, len(routes)-1)\n        if route1_idx != route2_idx:\n            route1 = routes[route1_idx]\n            route2 = routes[route2_idx]\n\n            # Check if merging is possible\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Merge routes by connecting them at closest points\n                min_dist = float('inf')\n                best_pos1, best_pos2 = 0, 0\n\n                for i in range(1, len(route1)-1):\n                    for j in range(1, len(route2)-1):\n                        dist = distance_matrix[route1[i], route2[j]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pos1, best_pos2 = i, j\n\n                # Create merged route\n                merged_route = np.concatenate([\n                    route1[:best_pos1+1],\n                    route2[best_pos2:],\n                    route1[best_pos1+1:]\n                ])\n                new_solution.append(merged_route)\n\n                # Remove merged routes\n                routes = [r for idx, r in enumerate(routes) if idx not in [route1_idx, route2_idx]]\n                routes.extend(new_solution)\n            else:\n                new_solution.extend(routes)\n        else:\n            new_solution.extend(routes)\n    else:\n        new_solution.extend(routes)\n\n    # Customer reinsertion with optimization\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Sort customers by demand (descending) to prioritize larger customers\n        missing_customers = sorted(missing_customers, key=lambda x: -demand[x])\n\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_score = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion position considering both distance and balance\n                for j in range(len(route)-1):\n                    dist_increase = (distance_matrix[route[j], customer] +\n                                   distance_matrix[customer, route[j+1]] -\n                                   distance_matrix[route[j], route[j+1]])\n\n                    # Score combines distance increase and demand balance\n                    new_demand = current_demand + demand[customer]\n                    balance_score = abs(new_demand - capacity/2)\n                    score = dist_increase + 0.5 * balance_score\n\n                    if score < best_score:\n                        best_score = score\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    # Intra-route optimization (2.5-opt for routes with >4 customers)\n    for i, route in enumerate(new_solution):\n        if len(route) > 6:  # Only optimize longer routes\n            for _ in range(2):  # Limited attempts\n                # Select 5 random positions (excluding depot)\n                positions = sorted(random.sample(range(1, len(route)-1), 5))\n\n                # Try different configurations\n                configs = [\n                    [positions[0], positions[1], positions[2], positions[3], positions[4]],\n                    [positions[0], positions[2], positions[1], positions[3], positions[4]],\n                    [positions[0], positions[1], positions[3], positions[2], positions[4]],\n                    [positions[0], positions[2], positions[3], positions[1], positions[4]]\n                ]\n\n                best_config = None\n                min_cost = float('inf')\n\n                for config in configs:\n                    # Reconstruct route with this configuration\n                    temp_route = np.array([0] + [route[pos] for pos in [0] + config + [len(route)-1]] + [0])\n\n                    # Calculate total distance\n                    total_dist = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n\n                    if total_dist < min_cost:\n                        min_cost = total_dist\n                        best_config = config\n\n                if best_config:\n                    # Apply best configuration\n                    new_route = np.array([0] + [route[pos] for pos in [0] + best_config + [len(route)-1]] + [0])\n                    new_solution[i] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8718531319664314,
            0.805967390537262
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with demand-aware rebalancing by first splitting a long route into two shorter routes if their demands fit within capacity, then redistributing customers between the new routes and an existing route to balance loads and reduce makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Randomly select a route to potentially split\n    route_idx = np.random.choice(len(new_solution))\n    route = new_solution[route_idx]\n    customers = route[1:-1]\n\n    if len(customers) < 2:\n        return new_solution\n\n    # Split the route into two parts\n    split_pos = np.random.randint(1, len(customers))\n    part1 = customers[:split_pos]\n    part2 = customers[split_pos:]\n\n    # Check if both parts fit within capacity\n    demand_part1 = sum(demand[node] for node in part1)\n    demand_part2 = sum(demand[node] for node in part2)\n\n    if demand_part1 > capacity or demand_part2 > capacity:\n        return new_solution\n\n    # Create two new routes\n    new_route1 = np.insert(part1, 0, 0)\n    new_route1 = np.append(new_route1, 0)\n    new_route2 = np.insert(part2, 0, 0)\n    new_route2 = np.append(new_route2, 0)\n\n    # Replace the original route with the two new routes\n    new_solution[route_idx] = new_route1\n    new_solution.insert(route_idx + 1, new_route2)\n\n    # Try to rebalance by redistributing customers to another route\n    if len(new_solution) > 2:\n        other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n        other_route = new_solution[other_route_idx]\n\n        # Calculate remaining capacity of the other route\n        other_load = sum(demand[node] for node in other_route[1:-1])\n        available_capacity = capacity - other_load\n\n        # Move customers from new routes to other route if possible\n        for new_route in [new_route1, new_route2]:\n            for i in range(len(new_route) - 2, 0, -1):\n                node = new_route[i]\n                if demand[node] <= available_capacity:\n                    # Insert node into other route at the best position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(other_route)):\n                        temp_route = np.insert(other_route, pos, node)\n                        new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                        if new_cost < best_cost:\n                            best_cost = new_cost\n                            best_pos = pos\n\n                    # Perform the move\n                    other_route = np.insert(other_route, best_pos, node)\n                    new_route = np.delete(new_route, i)\n                    available_capacity -= demand[node]\n\n        # Update the solution\n        new_solution[other_route_idx] = other_route\n\n    return new_solution\n\n",
        "score": [
            -0.8015843910753389,
            0.424274742603302
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a crowding distance-based selection, then applies a hybrid local search combining route merging, customer insertion, and route balancing to generate a neighbor solution while maintaining feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    crowding_distances = []\n    for i in range(len(archive)):\n        left = archive[i][1]\n        right = archive[i][1]\n        for j in range(len(archive)):\n            if archive[j][1][0] < left[0] and archive[j][1][1] < left[1]:\n                left = archive[j][1]\n            if archive[j][1][0] > right[0] and archive[j][1][1] > right[1]:\n                right = archive[j][1]\n        distance = (right[0] - left[0]) + (right[1] - left[1])\n        crowding_distances.append(distance)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Route merging with capacity check\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 3 <= 2 * max(len(route1), len(route2)) - 4:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            if sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n    # Customer insertion with load balancing\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            cust_pos = random.randint(1, len(route)-2)\n            customer = route[cust_pos]\n\n            # Try inserting into another route\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx != route_idx:\n                    other_route = new_solution[other_route_idx]\n\n                    # Find best insertion position\n                    min_dist = float('inf')\n                    best_pos = 1\n                    for pos in range(1, len(other_route)):\n                        dist = (distance_matrix[other_route[pos-1], customer] +\n                               distance_matrix[customer, other_route[pos]] -\n                               distance_matrix[other_route[pos-1], other_route[pos]])\n\n                        if dist < min_dist and sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            min_dist = dist\n                            best_pos = pos\n\n                    if min_dist < float('inf'):\n                        # Perform insertion\n                        new_route = np.insert(other_route, best_pos, customer)\n                        new_solution[other_route_idx] = new_route\n\n                        # Remove from original route\n                        new_route = np.delete(route, cust_pos)\n                        if len(new_route) > 2:\n                            new_solution[route_idx] = new_route\n                        else:\n                            del new_solution[route_idx]\n                        break\n\n    # Route balancing\n    if len(new_solution) > 1:\n        # Find route with maximum makespan\n        max_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n\n        if len(new_solution[max_route_idx]) > 4:\n            max_route = new_solution[max_route_idx]\n\n            # Find customer to move\n            for cust_pos in range(1, len(max_route)-1):\n                customer = max_route[cust_pos]\n\n                # Try moving to another route\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx != max_route_idx:\n                        other_route = new_solution[other_route_idx]\n\n                        # Check capacity\n                        if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                            # Calculate distance improvement\n                            old_dist = (distance_matrix[max_route[cust_pos-1], customer] +\n                                       distance_matrix[customer, max_route[cust_pos+1]] -\n                                       distance_matrix[max_route[cust_pos-1], max_route[cust_pos+1]])\n\n                            new_dist = (distance_matrix[other_route[-2], customer] +\n                                       distance_matrix[customer, other_route[-1]] -\n                                       distance_matrix[other_route[-2], other_route[-1]])\n\n                            if new_dist < old_dist:\n                                # Perform move\n                                new_route = np.append(other_route, customer)\n                                new_solution[other_route_idx] = new_route\n\n                                # Remove from original route\n                                new_route = np.delete(max_route, cust_pos)\n                                if len(new_route) > 2:\n                                    new_solution[max_route_idx] = new_route\n                                else:\n                                    del new_solution[max_route_idx]\n                                break\n                else:\n                    continue\n                break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7784881275859686,
            0.32167282700538635
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route merging, customer reinsertion with demand-aware positioning, and inter-route segment swaps to generate a neighbor solution while ensuring feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    selected = random.choice(archive[:max(1, len(archive)//3)])\n    base_solution = selected[0].copy()\n\n    new_solution = []\n    routes = [route for route in base_solution if len(route) > 2]\n\n    if len(routes) > 1:\n        route1_idx = random.randint(0, len(routes)-1)\n        route2_idx = random.randint(0, len(routes)-1)\n        if route1_idx != route2_idx:\n            route1 = routes[route1_idx]\n            route2 = routes[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if demand1 + demand2 <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [r for i, r in enumerate(routes) if i not in {route1_idx, route2_idx}]\n                new_solution.append(merged_route)\n            else:\n                new_solution = routes.copy()\n\n            if random.random() < 0.5 and len(new_solution) > 1:\n                route_idx = random.randint(0, len(new_solution)-1)\n                route = new_solution[route_idx]\n                if len(route) > 4:\n                    split_pos = random.randint(1, len(route)-2)\n                    part1 = route[:split_pos+1]\n                    part2 = route[split_pos:]\n\n                    demand_part1 = sum(demand[part1[1:-1]])\n                    demand_part2 = sum(demand[part2[1:-1]])\n\n                    if demand_part1 <= capacity and demand_part2 <= capacity:\n                        new_solution[route_idx] = part1\n                        new_solution.append(part2)\n    else:\n        new_solution = routes.copy()\n\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 3:\n                pos1 = random.randint(1, len(route1)-3)\n                pos2 = random.randint(1, len(route2)-3)\n\n                segment1 = route1[pos1:pos1+2]\n                segment2 = route2[pos2:pos2+2]\n\n                demand_route1 = sum(demand[route1[1:-1]]) - sum(demand[segment1[1:-1]]) + sum(demand[segment2[1:-1]])\n                demand_route2 = sum(demand[route2[1:-1]]) - sum(demand[segment2[1:-1]]) + sum(demand[segment1[1:-1]])\n\n                if demand_route1 <= capacity and demand_route2 <= capacity:\n                    new_route1 = np.concatenate([route1[:pos1], segment2, route1[pos1+2:]])\n                    new_route2 = np.concatenate([route2[:pos2], segment1, route2[pos2+2:]])\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_improvement = -float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                for j in range(len(route)-1):\n                    dist_before = distance_matrix[route[j], route[j+1]]\n                    dist_after = distance_matrix[route[j], customer] + distance_matrix[customer, route[j+1]]\n                    improvement = dist_before - dist_after\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5525269048812648,
            0.12736353278160095
        ]
    }
]