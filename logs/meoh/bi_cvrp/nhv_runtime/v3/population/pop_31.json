[
    {
        "algorithm": "{This algorithm selects a solution with the highest total distance from the archive, then applies a \"route fragmentation and strategic customer redistribution\" operator that splits long routes into smaller segments and redistributes customers to create more balanced routes while minimizing both objectives and maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Find the longest route\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    # Split the longest route into two segments\n    split_pos = len(longest_route) // 2\n    segment1 = longest_route[:split_pos+1]\n    segment2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n    # Check feasibility of segments\n    if sum(demand[segment1[1:-1]]) <= capacity and sum(demand[segment2[1:-1]]) <= capacity:\n        new_solution[longest_route_idx] = segment1\n        new_solution.append(segment2)\n    else:\n        # If not feasible, try to redistribute customers to existing routes\n        customers = longest_route[1:-1].tolist()\n        while customers:\n            best_route = None\n            best_pos = None\n            best_improvement = 0\n\n            for route_idx in range(len(new_solution)):\n                if route_idx == longest_route_idx:\n                    continue\n                route = new_solution[route_idx]\n\n                for cust in customers:\n                    if sum(demand[route[1:-1]]) + demand[cust] > capacity:\n                        continue\n\n                    # Find best insertion position\n                    best_insert_pos = 1\n                    best_insert_cost = float('inf')\n\n                    for i in range(1, len(route)-1):\n                        cost = (distance_matrix[route[i-1], cust] +\n                              distance_matrix[cust, route[i]] -\n                              distance_matrix[route[i-1], route[i]])\n\n                        if cost < best_insert_cost:\n                            best_insert_cost = cost\n                            best_insert_pos = i\n\n                    if best_insert_cost < best_improvement:\n                        best_improvement = best_insert_cost\n                        best_route = route_idx\n                        best_pos = best_insert_pos\n                        best_cust = cust\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos, best_cust)\n                new_solution[best_route] = new_route\n                customers.remove(best_cust)\n            else:\n                break\n\n        # Add remaining customers to new routes if needed\n        while customers:\n            new_route = [0]\n            current_load = 0\n\n            for cust in customers[:]:\n                if current_load + demand[cust] <= capacity:\n                    new_route.append(cust)\n                    current_load += demand[cust]\n                    customers.remove(cust)\n\n            new_route.append(0)\n            if len(new_route) > 2:\n                new_solution.append(np.array(new_route))\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6958243394647611,
            0.027441442012786865
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with a better balance between total distance and makespan using a different weighted sum (0.3 for distance and 0.7 for makespan) before applying a novel \"route merging-splitting\" operator that merges short routes and splits long routes to better balance the load and improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Find the shortest and longest routes\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n    longest_route = new_solution[longest_route_idx]\n\n    if len(shortest_route) <= 3 or len(longest_route) <= 3:\n        return new_solution\n\n    # Try to merge the shortest route into another route\n    merged = False\n    for route in new_solution:\n        if route is not shortest_route and route is not longest_route:\n            combined_route = np.concatenate([route[:-1], shortest_route[1:]])\n            if sum(demand[combined_route[1:-1]]) <= capacity:\n                route = combined_route\n                new_solution.remove(shortest_route)\n                merged = True\n                break\n\n    if not merged:\n        # If merging fails, split the longest route\n        split_pos = len(longest_route) // 2\n        first_part = longest_route[:split_pos + 1]\n        second_part = [0] + longest_route[split_pos:-1].tolist() + [0]\n\n        first_load = sum(demand[first_part[1:-1]])\n        second_load = sum(demand[second_part[1:-1]])\n\n        if first_load <= capacity and second_load <= capacity:\n            new_solution[longest_route_idx] = np.array(first_part)\n            new_solution.insert(longest_route_idx + 1, np.array(second_part))\n        else:\n            # If splitting is not feasible, try to migrate customers to other routes\n            remaining_nodes = longest_route[1:-1].tolist()\n            new_routes = [route.copy() for route in new_solution if route is not longest_route]\n\n            while remaining_nodes:\n                best_route = None\n                best_improvement = 0\n                best_node = None\n\n                for route in new_routes:\n                    for node in remaining_nodes:\n                        if sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                            old_dist = sum(distance_matrix[route[i-1], route[i]] for i in range(1, len(route)))\n                            new_route = np.concatenate([route[:-1], [node], [0]])\n                            new_dist = sum(distance_matrix[new_route[i-1], new_route[i]] for i in range(1, len(new_route)))\n                            improvement = old_dist - new_dist\n\n                            if improvement > best_improvement:\n                                best_improvement = improvement\n                                best_route = route\n                                best_node = node\n\n                if best_node is not None:\n                    best_route = np.concatenate([best_route[:-1], [best_node], [0]])\n                    remaining_nodes.remove(best_node)\n                else:\n                    break\n\n            if remaining_nodes:\n                new_route = [0] + remaining_nodes + [0]\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_routes.append(np.array(new_route))\n\n            new_solution = new_routes\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.9112849592556458,
            0.06970933079719543
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a crowding-distance-based selection, then applies a hybrid local search combining route splitting, customer relocation, and route optimization to generate a neighbor solution while maintaining feasibility and balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        # Calculate crowding distances\n        distances = np.zeros(len(archive))\n        sorted_obj1 = sorted(range(len(archive)), key=lambda x: archive[x][1][0])\n        sorted_obj2 = sorted(range(len(archive)), key=lambda x: archive[x][1][1])\n\n        for i in range(1, len(archive)-1):\n            distances[sorted_obj1[i]] += (archive[sorted_obj1[i+1]][1][0] - archive[sorted_obj1[i-1]][1][0]) / (archive[sorted_obj1[-1]][1][0] - archive[sorted_obj1[0]][1][0])\n            distances[sorted_obj2[i]] += (archive[sorted_obj2[i+1]][1][1] - archive[sorted_obj2[i-1]][1][1]) / (archive[sorted_obj2[-1]][1][1] - archive[sorted_obj2[0]][1][1])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(distances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route splitting with capacity check\n    if len(new_solution) < 10:  # Limit maximum number of routes\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 5:\n            split_pos = random.randint(2, len(route)-3)\n            first_part = route[:split_pos+1]\n            second_part = np.concatenate([[0], route[split_pos+1:]])\n\n            if (sum(demand[first_part[1:-1]]) <= capacity and\n                sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx+1, second_part)\n\n    # Customer relocation between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3:\n            # Select random customer from first route\n            cust_pos = random.randint(1, len(route1)-2)\n            customer = route1[cust_pos]\n\n            # Find best insertion position in second route\n            best_pos = 1\n            best_cost = float('inf')\n\n            for i in range(1, len(route2)-1):\n                cost = (distance_matrix[route2[i-1], customer] +\n                       distance_matrix[customer, route2[i]] -\n                       distance_matrix[route2[i-1], route2[i]])\n\n                if cost < best_cost and sum(demand[route2[1:i]]) + demand[customer] <= capacity:\n                    best_cost = cost\n                    best_pos = i\n\n            if best_cost < float('inf'):\n                new_route1 = np.concatenate([route1[:cust_pos], route1[cust_pos+1:]])\n                new_route2 = np.insert(route2, best_pos, customer)\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Route optimization with 2-opt-like segment improvement\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            # Try optimizing a segment\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n\n            segment = route[start:end]\n            improved = False\n\n            # Try reversing the segment\n            reversed_segment = segment[::-1]\n            if (distance_matrix[route[start-1], reversed_segment[0]] +\n                distance_matrix[reversed_segment[-1], route[end]] <\n                distance_matrix[route[start-1], segment[0]] +\n                distance_matrix[segment[-1], route[end]]):\n                new_route = np.concatenate([route[:start], reversed_segment, route[end:]])\n                new_solution[route_idx] = new_route\n                improved = True\n\n            if not improved:\n                # Try shifting the segment to another position\n                for new_start in range(1, len(route)-len(segment)+1):\n                    if new_start < start or new_start > end:\n                        new_route = np.concatenate([\n                            route[:new_start],\n                            segment,\n                            route[new_start:start],\n                            route[end:]\n                        ])\n\n                        if (distance_matrix[route[new_start-1], segment[0]] +\n                            distance_matrix[segment[-1], route[new_start+len(segment)-1]] <\n                            distance_matrix[route[start-1], segment[0]] +\n                            distance_matrix[segment[-1], route[end]]):\n                            new_solution[route_idx] = new_route\n                            break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.9558154739355551,
            0.2582457363605499
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a crowding-distance-based selection to prioritize solutions with better diversity and then applies a hybrid local search combining route merging, customer relocation, and route-based 2-opt to generate a neighbor solution while maintaining feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    crowding_distances = np.zeros(len(archive))\n    objectives = np.array([obj for _, obj in archive])\n\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], m] == objectives[sorted_indices[0], m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (\n                objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]\n            ) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Route merging with capacity check\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if (sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity and\n            len(route1) + len(route2) - 2 < 2 * len(coords)):  # Prevent excessively long routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n    # Customer relocation between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3:\n            cust_pos = random.randint(1, len(route1)-2)\n            customer = route1[cust_pos]\n\n            if (sum(demand[route2[1:-1]]) + demand[customer] <= capacity and\n                len(route2) + 1 < 2 * len(coords)):\n\n                # Try inserting customer into route2\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(route2)):\n                    new_route = np.concatenate([route2[:pos], [customer], route2[pos:]])\n                    cost = (distance_matrix[new_route[pos-1], customer] +\n                           distance_matrix[customer, new_route[pos+1]] -\n                           distance_matrix[new_route[pos-1], new_route[pos+1]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                if best_cost < 0:  # Only accept if it improves the solution\n                    new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                    new_solution[route2_idx] = new_route2\n\n                    # Remove customer from original route\n                    new_route1 = np.concatenate([route1[:cust_pos], route1[cust_pos+1:]])\n                    new_solution[route1_idx] = new_route1\n\n    # Route-based 2-opt\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            i, j = random.sample(range(1, len(route)-1), 2)\n            if i > j:\n                i, j = j, i\n\n            # Try reversing segment between i and j\n            new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n\n            # Check capacity constraint\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                # Calculate distance change\n                old_dist = (distance_matrix[route[i-1], route[i]] +\n                           distance_matrix[route[j], route[j+1]])\n\n                new_dist = (distance_matrix[new_route[i-1], new_route[i]] +\n                           distance_matrix[new_route[j], new_route[j+1]])\n\n                if new_dist < old_dist:\n                    new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.9914166041886547,
            3.0811938643455505
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a crowding-distance-based selection, then applies a hybrid local search combining route merging, customer insertion, and route reversal to generate a neighbor solution while maintaining feasibility and balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        # Calculate crowding distances\n        distances = np.zeros(len(archive))\n        sorted_obj1 = sorted(range(len(archive)), key=lambda x: archive[x][1][0])\n        sorted_obj2 = sorted(range(len(archive)), key=lambda x: archive[x][1][1])\n\n        for i in range(1, len(archive)-1):\n            distances[sorted_obj1[i]] += (archive[sorted_obj1[i+1]][1][0] - archive[sorted_obj1[i-1]][1][0]) / (archive[sorted_obj1[-1]][1][0] - archive[sorted_obj1[0]][1][0])\n            distances[sorted_obj2[i]] += (archive[sorted_obj2[i+1]][1][1] - archive[sorted_obj2[i-1]][1][1]) / (archive[sorted_obj2[-1]][1][1] - archive[sorted_obj2[0]][1][1])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(distances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Route merging with capacity check\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 3 <= 20:  # Limit maximum route length\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            if sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n    # Customer insertion between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select random customer from first route\n            cust_pos = random.randint(1, len(route1)-2)\n            customer = route1[cust_pos]\n\n            # Find best insertion position in second route\n            best_pos = 1\n            best_cost = float('inf')\n\n            for i in range(1, len(route2)-1):\n                cost = (distance_matrix[route2[i-1], customer] +\n                       distance_matrix[customer, route2[i]] -\n                       distance_matrix[route2[i-1], route2[i]])\n\n                if cost < best_cost and sum(demand[route2[1:i]]) + demand[customer] <= capacity:\n                    best_cost = cost\n                    best_pos = i\n\n            if best_cost < float('inf'):\n                new_route1 = np.concatenate([route1[:cust_pos], route1[cust_pos+1:]])\n                new_route2 = np.insert(route2, best_pos, customer)\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Route reversal with distance improvement check\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            # Try reversing a segment\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n\n            reversed_segment = route[start:end][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end:]])\n\n            # Calculate distance change\n            old_dist = (distance_matrix[route[start-1], route[start]] +\n                       distance_matrix[route[end-1], route[end]])\n\n            new_dist = (distance_matrix[new_route[start-1], new_route[start]] +\n                       distance_matrix[new_route[end-1], new_route[end]])\n\n            if new_dist < old_dist:\n                new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.9547955994121897,
            0.15091398358345032
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with the best balance between total distance and makespan from the archive, then applies a novel \"route fusion-rebalancing\" operator that merges the shortest and longest routes, redistributes customers to balance the load, and optimizes the new fused route structure to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Find shortest and longest routes\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n    longest_route = new_solution[longest_route_idx]\n\n    if len(shortest_route) <= 2 or len(longest_route) <= 2:\n        return new_solution\n\n    # Merge the shortest and longest routes\n    merged_route = [0] + shortest_route[1:-1].tolist() + longest_route[1:-1].tolist() + [0]\n\n    # Check if merged route is feasible\n    if sum(demand[merged_route[1:-1]]) > capacity:\n        # If not feasible, try to redistribute customers\n        remaining_nodes = shortest_route[1:-1].tolist() + longest_route[1:-1].tolist()\n        new_routes = []\n\n        while remaining_nodes:\n            current_route = [0]\n            current_load = 0\n\n            for node in remaining_nodes[:]:\n                if current_load + demand[node] <= capacity:\n                    current_route.append(node)\n                    current_load += demand[node]\n                    remaining_nodes.remove(node)\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                new_routes.append(np.array(current_route))\n\n        new_solution = new_routes\n    else:\n        # Optimize the merged route\n        optimized_route = merged_route.copy()\n        improved = True\n\n        while improved:\n            improved = False\n            # Try 2-opt improvement\n            for i in range(1, len(optimized_route)-2):\n                for j in range(i+1, len(optimized_route)-1):\n                    if j == i+1:\n                        continue\n                    # Create new route by reversing segment\n                    new_route = optimized_route[:i] + optimized_route[i:j][::-1] + optimized_route[j:]\n                    # Check capacity constraint\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        old_dist = (distance_matrix[optimized_route[i-1], optimized_route[i]] +\n                                   distance_matrix[optimized_route[j-1], optimized_route[j]] +\n                                   distance_matrix[optimized_route[i], optimized_route[i+1]] +\n                                   distance_matrix[optimized_route[j-1], optimized_route[j]])\n                        new_dist = (distance_matrix[new_route[i-1], new_route[i]] +\n                                   distance_matrix[new_route[j-1], new_route[j]] +\n                                   distance_matrix[new_route[i], new_route[i+1]] +\n                                   distance_matrix[new_route[j-1], new_route[j]])\n                        if new_dist < old_dist:\n                            optimized_route = new_route.copy()\n                            improved = True\n                            break\n                if improved:\n                    break\n\n        # Check if optimization improved the solution\n        original_dist = sum(distance_matrix[shortest_route[i-1], shortest_route[i]] for i in range(1, len(shortest_route))) + \\\n                       sum(distance_matrix[longest_route[i-1], longest_route[i]] for i in range(1, len(longest_route)))\n        new_dist = sum(distance_matrix[optimized_route[i-1], optimized_route[i]] for i in range(1, len(optimized_route)))\n\n        if new_dist < original_dist:\n            new_solution = [route for idx, route in enumerate(new_solution) if idx not in [shortest_route_idx, longest_route_idx]]\n            new_solution.append(np.array(optimized_route))\n        else:\n            # If optimization didn't help, try redistributing customers\n            remaining_nodes = shortest_route[1:-1].tolist() + longest_route[1:-1].tolist()\n            new_routes = []\n\n            while remaining_nodes:\n                current_route = [0]\n                current_load = 0\n\n                for node in remaining_nodes[:]:\n                    if current_load + demand[node] <= capacity:\n                        current_route.append(node)\n                        current_load += demand[node]\n                        remaining_nodes.remove(node)\n\n                if len(current_route) > 1:\n                    current_route.append(0)\n                    new_routes.append(np.array(current_route))\n\n            new_solution = new_routes\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7377990410612207,
            0.0354846715927124
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with the lowest makespan from the archive, then applies a novel \"route contraction-expansion\" operator that temporarily contracts the longest route by merging adjacent customers into supernodes, performs a demand-aware customer redistribution to balance loads, and finally expands the supernodes back into individual customers while optimizing the route structure to improve both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 1:\n        return new_solution\n\n    # Find the longest route\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 4:  # Skip if route is too short\n        return new_solution\n\n    # Contract the longest route by merging adjacent customers into supernodes\n    contracted_route = []\n    current_supernode = [longest_route[0]]  # Start with depot\n    current_demand = 0\n\n    for node in longest_route[1:-1]:  # Exclude depots\n        if current_demand + demand[node] <= capacity:\n            current_supernode.append(node)\n            current_demand += demand[node]\n        else:\n            # End current supernode and start a new one\n            contracted_route.append(tuple(current_supernode))\n            current_supernode = [longest_route[0], node]\n            current_demand = demand[node]\n\n    if len(current_supernode) > 1:\n        contracted_route.append(tuple(current_supernode))\n\n    # Add the final depot\n    contracted_route.append((longest_route[-1],))\n\n    # Redistribute customers between the contracted route and a new route\n    new_route = [0]\n    remaining_nodes = []\n\n    for supernode in contracted_route[1:-1]:\n        # Try to move some customers to the new route\n        for node in supernode[1:]:\n            if (sum(demand[new_route[1:]]) + demand[node] <= capacity and\n                len(new_route) + 1 < len(longest_route)):\n\n                new_route.append(node)\n            else:\n                remaining_nodes.append(node)\n\n    if len(new_route) > 1:\n        new_route.append(0)\n        new_solution.append(np.array(new_route))\n\n    # Reconstruct the contracted route with remaining nodes\n    reconstructed_route = [0]\n    for supernode in contracted_route[1:-1]:\n        for node in supernode[1:]:\n            if node not in remaining_nodes:\n                reconstructed_route.append(node)\n            else:\n                # Try to find a better position for the remaining nodes\n                best_pos = len(reconstructed_route)\n                best_cost = float('inf')\n\n                for pos in range(1, len(reconstructed_route)):\n                    temp_route = np.insert(reconstructed_route, pos, node)\n                    new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n\n                reconstructed_route.insert(best_pos, node)\n\n    reconstructed_route.append(0)\n    new_solution[longest_route_idx] = np.array(reconstructed_route)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8581771949837946,
            0.04623320698738098
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive using a diversity-aware selection that prioritizes solutions with unique route structures, then applies a novel route fusion and decomposition operator that intelligently merges and splits routes based on spatial proximity and demand balance to generate a neighbor solution while maintaining feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        # Calculate route structure diversity\n        diversity_scores = []\n        for sol in archive:\n            routes = sol[0]\n            route_lengths = [len(r) for r in routes]\n            diversity = len(set(route_lengths)) / len(route_lengths)\n            diversity_scores.append(diversity)\n\n        # Select solution with highest diversity\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route fusion and decomposition operator\n    if len(new_solution) > 1:\n        # Select two routes with different lengths\n        route_pairs = []\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                if len(new_solution[i]) != len(new_solution[j]):\n                    route_pairs.append((i, j))\n\n        if route_pairs:\n            route1_idx, route2_idx = random.choice(route_pairs)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Calculate centroids of routes\n            def calculate_centroid(route):\n                points = coords[route[1:-1]]\n                return np.mean(points, axis=0)\n\n            centroid1 = calculate_centroid(route1)\n            centroid2 = calculate_centroid(route2)\n\n            # Calculate distance between centroids\n            centroid_dist = np.linalg.norm(centroid1 - centroid2)\n\n            # Calculate demand balance\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            # Decide whether to merge or split based on distance and demand\n            if centroid_dist < np.mean(distance_matrix) and abs(demand1 - demand2) < capacity * 0.3:\n                # Try to merge routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                if sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution[route1_idx] = merged_route\n                    new_solution.pop(route2_idx)\n            else:\n                # Try to split routes\n                if len(route1) > 5:\n                    split_pos = random.randint(2, len(route1)-3)\n                    first_part = route1[:split_pos+1]\n                    second_part = np.concatenate([[0], route1[split_pos+1:]])\n\n                    if (sum(demand[first_part[1:-1]]) <= capacity and\n                        sum(demand[second_part[1:-1]]) <= capacity):\n\n                        new_solution[route1_idx] = first_part\n                        new_solution.append(second_part)\n\n    # Spatial proximity insertion\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_score = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if sum(demand[route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Find last customer in route\n                last_customer = route[-2]\n\n                # Calculate spatial proximity score\n                spatial_score = distance_matrix[last_customer, customer]\n\n                # Calculate demand balance score\n                current_demand = sum(demand[route[1:-1]])\n                demand_score = abs((current_demand + demand[customer]) - capacity/2)\n\n                # Combined score\n                total_score = spatial_score + demand_score\n\n                if total_score < best_score:\n                    best_score = total_score\n                    best_route = i\n                    best_pos = len(route) - 1\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos, customer)\n                new_solution[best_route] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.9862617774843405,
            1.0121996998786926
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with the best trade-off between total distance and makespan using a weighted sum with a different parameter setting, then applies a novel \"route splitting-migration\" operator that splits the longest route and migrates customers to other routes to balance the load and improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Find the longest route\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    # Split the longest route into two parts\n    split_pos = len(longest_route) // 2\n    first_part = longest_route[:split_pos + 1]\n    second_part = [0] + longest_route[split_pos:-1].tolist() + [0]\n\n    # Check feasibility of both parts\n    first_load = sum(demand[first_part[1:-1]])\n    second_load = sum(demand[second_part[1:-1]])\n\n    if first_load <= capacity and second_load <= capacity:\n        # Replace the longest route with the two new routes\n        new_solution[longest_route_idx] = np.array(first_part)\n        new_solution.insert(longest_route_idx + 1, np.array(second_part))\n    else:\n        # If splitting is not feasible, try to migrate customers to other routes\n        remaining_nodes = longest_route[1:-1].tolist()\n        new_routes = [route.copy() for route in new_solution if route is not longest_route]\n\n        while remaining_nodes:\n            best_route = None\n            best_improvement = 0\n            best_node = None\n\n            for route in new_routes:\n                for node in remaining_nodes:\n                    if sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                        # Calculate potential improvement\n                        old_dist = sum(distance_matrix[route[i-1], route[i]] for i in range(1, len(route)))\n                        new_route = np.concatenate([route[:-1], [node], [0]])\n                        new_dist = sum(distance_matrix[new_route[i-1], new_route[i]] for i in range(1, len(new_route)))\n                        improvement = old_dist - new_dist\n\n                        if improvement > best_improvement:\n                            best_improvement = improvement\n                            best_route = route\n                            best_node = node\n\n            if best_node is not None:\n                best_route = np.concatenate([best_route[:-1], [best_node], [0]])\n                remaining_nodes.remove(best_node)\n            else:\n                break\n\n        # Add the remaining nodes back to a new route if needed\n        if remaining_nodes:\n            new_route = [0] + remaining_nodes + [0]\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_routes.append(np.array(new_route))\n\n        new_solution = new_routes\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7030856688867874,
            0.028883010149002075
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with a different balance between total distance and makespan (0.5 for distance and 0.5 for makespan) before applying a hybrid \"route merging-splitting\" operator that merges short routes, splits long routes, and performs customer migration to better balance the load and improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n    longest_route = new_solution[longest_route_idx]\n\n    if len(shortest_route) <= 3 or len(longest_route) <= 3:\n        return new_solution\n\n    merged = False\n    for route in new_solution:\n        if route is not shortest_route and route is not longest_route:\n            combined_route = np.concatenate([route[:-1], shortest_route[1:]])\n            if sum(demand[combined_route[1:-1]]) <= capacity:\n                route = combined_route\n                new_solution.remove(shortest_route)\n                merged = True\n                break\n\n    if not merged:\n        split_pos = len(longest_route) // 2\n        first_part = longest_route[:split_pos + 1]\n        second_part = [0] + longest_route[split_pos:-1].tolist() + [0]\n\n        first_load = sum(demand[first_part[1:-1]])\n        second_load = sum(demand[second_part[1:-1]])\n\n        if first_load <= capacity and second_load <= capacity:\n            new_solution[longest_route_idx] = np.array(first_part)\n            new_solution.insert(longest_route_idx + 1, np.array(second_part))\n        else:\n            remaining_nodes = longest_route[1:-1].tolist()\n            new_routes = [route.copy() for route in new_solution if route is not longest_route]\n\n            while remaining_nodes:\n                best_route = None\n                best_improvement = 0\n                best_node = None\n\n                for route in new_routes:\n                    for node in remaining_nodes:\n                        if sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                            old_dist = sum(distance_matrix[route[i-1], route[i]] for i in range(1, len(route)))\n                            new_route = np.concatenate([route[:-1], [node], [0]])\n                            new_dist = sum(distance_matrix[new_route[i-1], new_route[i]] for i in range(1, len(new_route)))\n                            improvement = old_dist - new_dist\n\n                            if improvement > best_improvement:\n                                best_improvement = improvement\n                                best_route = route\n                                best_node = node\n\n                if best_node is not None:\n                    best_route = np.concatenate([best_route[:-1], [best_node], [0]])\n                    remaining_nodes.remove(best_node)\n                else:\n                    break\n\n            if remaining_nodes:\n                new_route = [0] + remaining_nodes + [0]\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_routes.append(np.array(new_route))\n\n            new_solution = new_routes\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7542734014636598,
            0.06706279516220093
        ]
    }
]