[
    {
        "algorithm": "{This algorithm selects a solution with the lowest makespan from the archive, then applies a novel \"route contraction-expansion\" operator that temporarily contracts the longest route by merging adjacent customers into supernodes, performs a demand-aware customer redistribution to balance loads, and finally expands the supernodes back into individual customers while optimizing the route structure to improve both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 1:\n        return new_solution\n\n    # Find the longest route\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 4:  # Skip if route is too short\n        return new_solution\n\n    # Contract the longest route by merging adjacent customers into supernodes\n    contracted_route = []\n    current_supernode = [longest_route[0]]  # Start with depot\n    current_demand = 0\n\n    for node in longest_route[1:-1]:  # Exclude depots\n        if current_demand + demand[node] <= capacity:\n            current_supernode.append(node)\n            current_demand += demand[node]\n        else:\n            # End current supernode and start a new one\n            contracted_route.append(tuple(current_supernode))\n            current_supernode = [longest_route[0], node]\n            current_demand = demand[node]\n\n    if len(current_supernode) > 1:\n        contracted_route.append(tuple(current_supernode))\n\n    # Add the final depot\n    contracted_route.append((longest_route[-1],))\n\n    # Redistribute customers between the contracted route and a new route\n    new_route = [0]\n    remaining_nodes = []\n\n    for supernode in contracted_route[1:-1]:\n        # Try to move some customers to the new route\n        for node in supernode[1:]:\n            if (sum(demand[new_route[1:]]) + demand[node] <= capacity and\n                len(new_route) + 1 < len(longest_route)):\n\n                new_route.append(node)\n            else:\n                remaining_nodes.append(node)\n\n    if len(new_route) > 1:\n        new_route.append(0)\n        new_solution.append(np.array(new_route))\n\n    # Reconstruct the contracted route with remaining nodes\n    reconstructed_route = [0]\n    for supernode in contracted_route[1:-1]:\n        for node in supernode[1:]:\n            if node not in remaining_nodes:\n                reconstructed_route.append(node)\n            else:\n                # Try to find a better position for the remaining nodes\n                best_pos = len(reconstructed_route)\n                best_cost = float('inf')\n\n                for pos in range(1, len(reconstructed_route)):\n                    temp_route = np.insert(reconstructed_route, pos, node)\n                    new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n\n                reconstructed_route.insert(best_pos, node)\n\n    reconstructed_route.append(0)\n    new_solution[longest_route_idx] = np.array(reconstructed_route)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8581771949837946,
            0.04623320698738098
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of crowding distance and objective normalization, then applies a novel route transformation operator that combines partial route reversal, segment migration, and demand-balanced insertion to generate a neighbor solution while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        # Normalize objectives\n        min_dist = min(s[1][0] for s in archive)\n        max_dist = max(s[1][0] for s in archive)\n        min_make = min(s[1][1] for s in archive)\n        max_make = max(s[1][1] for s in archive)\n\n        normalized = []\n        for sol in archive:\n            norm_dist = (sol[1][0] - min_dist) / (max_dist - min_dist + 1e-8)\n            norm_make = (sol[1][1] - min_make) / (max_make - min_make + 1e-8)\n            normalized.append((sol, norm_dist, norm_make))\n\n        # Sort by crowding distance\n        normalized.sort(key=lambda x: (x[1] + x[2]) / 2, reverse=True)\n        selected = normalized[0][0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel route transformation operator\n    if len(new_solution) > 1:\n        # Select two distinct routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Partial route reversal with demand check\n        if len(route1) > 4:\n            start_pos = random.randint(1, len(route1)-3)\n            end_pos = random.randint(start_pos+1, len(route1)-2)\n            reversed_segment = route1[start_pos:end_pos][::-1]\n\n            # Check capacity after reversal\n            if (sum(demand[np.concatenate([route1[1:start_pos], reversed_segment, route1[end_pos:-1]])]) <= capacity):\n                new_route1 = np.concatenate([route1[:start_pos], reversed_segment, route1[end_pos:]])\n                new_solution[route1_idx] = new_route1\n\n        # Segment migration with demand balance\n        if len(route1) > 3 and len(route2) > 3:\n            # Select segment from route1\n            start_pos = random.randint(1, len(route1)-3)\n            end_pos = random.randint(start_pos+1, len(route1)-2)\n            segment = route1[start_pos:end_pos]\n\n            # Check capacity after removal\n            if (sum(demand[route1[1:start_pos]]) + sum(demand[route1[end_pos:-1]]) <= capacity and\n                sum(demand[route2[1:-1]]) + sum(demand[segment]) <= capacity):\n\n                # Calculate potential demand balance\n                route1_new_demand = sum(demand[route1[1:start_pos]]) + sum(demand[route1[end_pos:-1]])\n                route2_new_demand = sum(demand[route2[1:-1]]) + sum(demand[segment])\n\n                # Only proceed if both routes remain balanced\n                if (abs(route1_new_demand - capacity/2) < abs(sum(demand[route1[1:-1]]) - capacity/2) and\n                    abs(route2_new_demand - capacity/2) < abs(sum(demand[route2[1:-1]]) - capacity/2)):\n\n                    # Create new routes\n                    new_route1 = np.concatenate([route1[:start_pos], route1[end_pos:]])\n                    new_route2 = np.concatenate([route2[:-1], segment, [0]])\n\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Demand-balanced insertion\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Sort customers by demand (descending) to prioritize larger customers\n        missing_customers = sorted(missing_customers, key=lambda x: -demand[x])\n\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_balance = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion position considering demand balance\n                for j in range(len(route)-1):\n                    new_demand = current_demand + demand[customer]\n                    balance_score = abs(new_demand - capacity/2)\n\n                    if balance_score < best_balance:\n                        best_balance = balance_score\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.9264798990634219,
            0.15741705894470215
        ]
    },
    {
        "algorithm": "{This new algorithm combines route merging with demand-aware customer redistribution by first merging two short routes into one, then intelligently redistributing customers between the merged route and a new route to balance loads and improve both total distance and makespan while ensuring capacity constraints are satisfied.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Find two shortest routes that can be merged\n    route_lengths = [(i, len(route)) for i, route in enumerate(new_solution)]\n    route_lengths.sort(key=lambda x: x[1])\n    route1_idx, route2_idx = route_lengths[0][0], route_lengths[1][0]\n\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Calculate total demand of both routes\n    total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n    # Check if merging is feasible\n    if total_demand > capacity:\n        return new_solution\n\n    # Create merged route (combining both routes)\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n    # Remove the two original routes\n    del new_solution[max(route1_idx, route2_idx)]\n    del new_solution[min(route1_idx, route2_idx)]\n\n    # Add the merged route\n    new_solution.append(merged_route)\n\n    # Try to split the merged route back into two routes to balance loads\n    if len(merged_route) > 4:\n        # Calculate average demand per segment\n        avg_demand = total_demand / 2\n\n        # Find best split position to balance demands\n        best_split = 1\n        best_balance = float('inf')\n\n        for i in range(2, len(merged_route)-2):\n            part1_demand = sum(demand[merged_route[1:i]])\n            part2_demand = sum(demand[merged_route[i:-1]])\n\n            balance = abs(part1_demand - avg_demand) + abs(part2_demand - avg_demand)\n            if balance < best_balance:\n                best_balance = balance\n                best_split = i\n\n        # Split the route\n        part1 = merged_route[:best_split+1]\n        part2 = np.concatenate([[0], merged_route[best_split:-1], [0]])\n\n        # Check capacity constraints\n        if (sum(demand[part1[1:-1]]) <= capacity and\n            sum(demand[part2[1:-1]]) <= capacity):\n\n            # Remove the merged route and add the two new routes\n            new_solution.pop()\n            new_solution.append(part1)\n            new_solution.append(part2)\n\n            # Try to optimize the split by moving customers between routes\n            for i in range(len(part1)-2, 0, -1):\n                node = part1[i]\n                if demand[node] <= (capacity - sum(demand[part2[1:-1]])):\n                    # Calculate insertion cost in part2\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(part2)):\n                        temp_route = np.insert(part2, pos, node)\n                        new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                        if new_cost < best_cost:\n                            best_cost = new_cost\n                            best_pos = pos\n\n                    # Perform the move\n                    part2 = np.insert(part2, best_pos, node)\n                    part1 = np.delete(part1, i)\n\n    return new_solution\n\n",
        "score": [
            -0.8824120857415693,
            0.19146299362182617
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a non-dominated sorting approach, then applies a hybrid local search combining route splitting, customer swapping, and inter-route optimization to generate a neighbor solution while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    fronts = []\n    dominated_counts = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] <= archive[j][1][1] and\n                    (archive[i][1][0] < archive[j][1][0] or archive[i][1][1] < archive[j][1][1])):\n                    dominating_sets[i].append(j)\n                elif (archive[j][1][0] <= archive[i][1][0] and archive[j][1][1] <= archive[i][1][1] and\n                      (archive[j][1][0] < archive[i][1][0] or archive[j][1][1] < archive[i][1][1])):\n                    dominated_counts[i] += 1\n\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating_sets[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    # Select from the first non-dominated front\n    if fronts[0]:\n        selected_idx = random.choice(fronts[0])\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Route splitting with capacity check\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Only split long routes\n            split_pos = random.randint(2, len(route)-3)\n            first_part = route[:split_pos+1]\n            second_part = np.array([0] + route[split_pos:-1].tolist() + [0])\n\n            # Check capacity constraints\n            if (sum(demand[first_part[1:-1]]) <= capacity and\n                sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.append(second_part)\n\n    # Customer swapping between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select random customers from each route (excluding depots)\n            cust1_pos = random.randint(1, len(route1)-2)\n            cust2_pos = random.randint(1, len(route2)-2)\n\n            # Check capacity constraints after swap\n            if (sum(demand[route1[1:-1]]) - demand[route1[cust1_pos]] + demand[route2[cust2_pos]] <= capacity and\n                sum(demand[route2[1:-1]]) - demand[route2[cust2_pos]] + demand[route1[cust1_pos]] <= capacity):\n\n                # Perform swap\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[cust1_pos], new_route2[cust2_pos] = new_route2[cust2_pos], new_route1[cust1_pos]\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Inter-route optimization (cross-route 2-opt)\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select two random positions from each route (excluding depots)\n            pos1 = random.randint(1, len(route1)-2)\n            pos2 = random.randint(1, len(route2)-2)\n\n            # Try swapping segments\n            new_route1 = np.concatenate([route1[:pos1], route2[pos2:]])\n            new_route2 = np.concatenate([route2[:pos2], route1[pos1:]])\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n\n                # Calculate distance change\n                old_dist = (distance_matrix[route1[pos1-1], route1[pos1]] +\n                           distance_matrix[route1[-2], route1[-1]] +\n                           distance_matrix[route2[pos2-1], route2[pos2]] +\n                           distance_matrix[route2[-2], route2[-1]])\n\n                new_dist = (distance_matrix[new_route1[pos1-1], new_route1[pos1]] +\n                           distance_matrix[new_route1[-2], new_route1[-1]] +\n                           distance_matrix[new_route2[pos2-1], new_route2[pos2]] +\n                           distance_matrix[new_route2[-2], new_route2[-1]])\n\n                # Accept if distance decreases\n                if new_dist < old_dist:\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8252884346623004,
            0.08127644658088684
        ]
    },
    {
        "algorithm": "{This new algorithm combines route merging with demand-aware rebalancing by first merging two short routes into one while ensuring capacity constraints, then redistributing customers between the merged route and other routes to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][0])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Randomly select two routes to merge\n    route_indices = np.random.choice(len(new_solution), size=2, replace=False)\n    route1_idx, route2_idx = route_indices[0], route_indices[1]\n    route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n    # Check if merging is possible without violating capacity\n    total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n    if total_demand > capacity:\n        return new_solution\n\n    # Calculate the best merging point (minimizing the new route's distance)\n    best_merge_cost = float('inf')\n    best_merge_point = (0, 0)\n\n    for i in range(1, len(route1)):\n        for j in range(1, len(route2)):\n            # Create potential merged route\n            merged = np.concatenate([\n                route1[:i],\n                route2[j:][::-1],\n                route1[i:]\n            ])\n\n            # Calculate the cost of the merged route\n            cost = sum(distance_matrix[merged[k-1], merged[k]] for k in range(1, len(merged)))\n            if cost < best_merge_cost:\n                best_merge_cost = cost\n                best_merge_point = (i, j)\n\n    # Perform the merge\n    i, j = best_merge_point\n    merged_route = np.concatenate([\n        route1[:i],\n        route2[j:][::-1],\n        route1[i:]\n    ])\n\n    # Remove the old routes and add the merged route\n    new_solution.pop(max(route1_idx, route2_idx))\n    new_solution.pop(min(route1_idx, route2_idx))\n    new_solution.append(merged_route)\n\n    # Try to redistribute customers between the merged route and other routes\n    if len(new_solution) > 1:\n        # Randomly select another route to consider for redistribution\n        other_route_idx = np.random.choice(len(new_solution))\n        other_route = new_solution[other_route_idx]\n\n        # Calculate remaining capacities\n        merged_load = sum(demand[node] for node in merged_route[1:-1])\n        other_load = sum(demand[node] for node in other_route[1:-1])\n\n        # Try moving customers from merged_route to other_route if possible\n        for i in range(len(merged_route)-2, 0, -1):\n            node = merged_route[i]\n            if demand[node] <= (capacity - other_load):\n                # Find best insertion position in other route\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    temp_route = np.insert(other_route, pos, node)\n                    new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n\n                # Perform the move if it improves the solution\n                other_route = np.insert(other_route, best_pos, node)\n                merged_route = np.delete(merged_route, i)\n                other_load += demand[node]\n                merged_load -= demand[node]\n\n        # Update the solution\n        new_solution[other_route_idx] = other_route\n        new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "score": [
            -0.8299994402912617,
            0.12122252583503723
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution with high makespan and applies a demand-aware route splitting and customer redistribution strategy, where it identifies a long route, splits it into two balanced routes while considering demand, and redistributes customers to minimize the makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 1:\n        return new_solution\n\n    # Select the longest route\n    longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n    longest_route = new_solution[longest_route_idx].copy()\n\n    # Calculate total demand and route length\n    total_demand = sum(demand[node] for node in longest_route[1:-1])\n    route_length = sum(distance_matrix[longest_route[i], longest_route[i+1]] for i in range(len(longest_route)-1))\n\n    # Split the route into two balanced parts\n    split_pos = len(longest_route) // 2\n    part1 = longest_route[:split_pos+1]\n    part2 = longest_route[split_pos:]\n\n    # Adjust parts to ensure depot closure\n    part1[-1] = 0\n    part2[0] = 0\n\n    # Calculate demands for both parts\n    demand1 = sum(demand[node] for node in part1[1:-1])\n    demand2 = sum(demand[node] for node in part2[1:-1])\n\n    # Redistribute customers to balance demands\n    if demand1 > capacity or demand2 > capacity:\n        # If splitting violates capacity, try to move customers between parts\n        for i in range(1, len(part1)-1):\n            node = part1[i]\n            if demand[node] <= (capacity - demand2):\n                # Move node from part1 to part2\n                part1 = np.delete(part1, i)\n                part2 = np.insert(part2, 1, node)\n                demand1 -= demand[node]\n                demand2 += demand[node]\n                i -= 1\n                if demand1 <= capacity and demand2 <= capacity:\n                    break\n\n    # Remove the original long route and add the two new routes\n    new_solution.pop(longest_route_idx)\n    new_solution.extend([part1, part2])\n\n    return new_solution\n\n",
        "score": [
            -0.8093676159681487,
            0.1202014684677124
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with demand-aware customer redistribution by first selecting two short routes with complementary demands, then merging them into one route while strategically redistributing customers to balance the load and minimize the makespan while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Select two routes to merge\n    route_indices = np.random.choice(len(new_solution), size=2, replace=False)\n    route1_idx, route2_idx = min(route_indices), max(route_indices)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Calculate demands and distances\n    demand1 = sum(demand[node] for node in route1[1:-1])\n    demand2 = sum(demand[node] for node in route2[1:-1])\n    total_demand = demand1 + demand2\n\n    if total_demand > capacity:\n        return new_solution\n\n    # Merge the two routes\n    merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n    # Remove the two routes and add the merged one\n    new_solution.pop(route2_idx)\n    new_solution.pop(route1_idx)\n    new_solution.append(merged_route)\n\n    # Try to rebalance customers in the merged route\n    for i in range(1, len(merged_route) - 1):\n        node = merged_route[i]\n        if demand[node] <= (capacity - total_demand):\n            # Calculate removal cost\n            original_cost = distance_matrix[merged_route[i-1], merged_route[i]] + distance_matrix[merged_route[i], merged_route[i+1]]\n            new_cost = distance_matrix[merged_route[i-1], merged_route[i+1]]\n\n            if new_cost < original_cost:\n                # Remove the node from the route\n                merged_route = np.delete(merged_route, i)\n                total_demand -= demand[node]\n                i -= 1  # Adjust index after deletion\n\n    # Update the solution\n    new_solution[-1] = merged_route\n\n    return new_solution\n\n",
        "score": [
            -0.7652536488197371,
            0.11572450399398804
        ]
    },
    {
        "algorithm": "{This new algorithm implements a demand-aware route splitting and reinsertion strategy that first identifies the longest route in the solution, splits it into smaller segments based on capacity constraints, and then intelligently reinserts the segments into the solution while optimizing both total distance and makespan by considering spatial proximity and demand balance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Select the longest route for splitting\n    longest_route_idx = np.argmax([len(route) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:  # Route has only depot and one customer\n        return new_solution\n\n    # Calculate cumulative demand along the route\n    cumulative_demand = np.cumsum([demand[node] for node in longest_route[1:-1]])\n\n    # Find split points where cumulative demand exceeds capacity\n    split_points = [0] + [i+1 for i in range(len(cumulative_demand)-1) if cumulative_demand[i] <= capacity and cumulative_demand[i+1] > capacity]\n\n    if len(split_points) <= 1:\n        return new_solution\n\n    # Split the route into segments\n    segments = []\n    for i in range(len(split_points)-1):\n        start = split_points[i]\n        end = split_points[i+1]\n        segment = longest_route[start+1:end+1]\n        segments.append(segment)\n\n    # Remove the original long route\n    del new_solution[longest_route_idx]\n\n    # Reinsert segments into the solution\n    for segment in segments:\n        best_route_idx = -1\n        best_insertion_cost = float('inf')\n        best_position = -1\n\n        # Find the best route and position to insert the segment\n        for route_idx, route in enumerate(new_solution):\n            for pos in range(1, len(route)):\n                # Check capacity constraint\n                segment_demand = sum(demand[node] for node in segment)\n                route_demand = sum(demand[node] for node in route[1:-1])\n                if route_demand + segment_demand > capacity:\n                    continue\n\n                # Calculate insertion cost\n                temp_route = np.insert(route, pos, segment)\n                insertion_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n\n                if insertion_cost < best_insertion_cost:\n                    best_insertion_cost = insertion_cost\n                    best_route_idx = route_idx\n                    best_position = pos\n\n        # Insert the segment into the best position\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_position, segment)\n        else:\n            # If no suitable position found, create a new route\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7390465425489432,
            0.11352488398551941
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a crowding-distance-based approach, then applies a novel local search operator combining route reversal with demand-aware customer insertion to generate a neighbor solution while maintaining feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances\n        objectives = np.array([s[1] for s in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(2):  # For each objective\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                if objectives[sorted_indices[-1], m] != objectives[sorted_indices[0], m]:\n                    crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Novel local search operator: Route reversal with demand-aware insertion\n    if len(new_solution) > 0:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Only consider non-trivial routes\n            # Reverse the route between two random points\n            start_pos = random.randint(1, len(route)-3)\n            end_pos = random.randint(start_pos+1, len(route)-2)\n\n            reversed_segment = route[start_pos:end_pos+1][::-1]\n            new_route = np.concatenate([route[:start_pos], reversed_segment, route[end_pos+1:]])\n\n            # Try to insert customers from other routes into the reversed segment\n            for other_route_idx in range(len(new_solution)):\n                if other_route_idx != route_idx:\n                    other_route = new_solution[other_route_idx]\n                    if len(other_route) > 3:\n                        # Select a random customer to potentially move\n                        cust_pos = random.randint(1, len(other_route)-2)\n                        cust = other_route[cust_pos]\n\n                        # Check if insertion is feasible\n                        if sum(demand[new_route[1:-1]]) + demand[cust] <= capacity:\n                            # Find best insertion position in new_route\n                            best_pos = 1\n                            best_cost = float('inf')\n\n                            for i in range(1, len(new_route)):\n                                # Calculate insertion cost\n                                cost = (distance_matrix[new_route[i-1], cust] +\n                                       distance_matrix[cust, new_route[i]] -\n                                       distance_matrix[new_route[i-1], new_route[i]])\n\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = i\n\n                            # Perform insertion\n                            new_route = np.insert(new_route, best_pos, cust)\n                            # Remove customer from original route\n                            other_route = np.delete(other_route, cust_pos)\n                            new_solution[other_route_idx] = other_route\n\n            new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8690398385625988,
            0.21984520554542542
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining route merging, customer reinsertion, and intra-route optimization to generate a neighbor solution while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))\n    selected = random.choice(archive[:max(1, len(archive)//2)])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n    routes = [route for route in base_solution if len(route) > 2]\n\n    # Try route merging\n    if len(routes) > 1:\n        route1_idx = random.randint(0, len(routes)-1)\n        route2_idx = random.randint(0, len(routes)-1)\n        if route1_idx != route2_idx:\n            route1 = routes[route1_idx]\n            route2 = routes[route2_idx]\n\n            # Check if merging is possible\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Merge routes by connecting them at closest points\n                min_dist = float('inf')\n                best_pos1, best_pos2 = 0, 0\n\n                for i in range(1, len(route1)-1):\n                    for j in range(1, len(route2)-1):\n                        dist = distance_matrix[route1[i], route2[j]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pos1, best_pos2 = i, j\n\n                # Create merged route\n                merged_route = np.concatenate([\n                    route1[:best_pos1+1],\n                    route2[best_pos2:],\n                    route1[best_pos1+1:]\n                ])\n                new_solution.append(merged_route)\n\n                # Remove merged routes\n                routes = [r for idx, r in enumerate(routes) if idx not in [route1_idx, route2_idx]]\n                routes.extend(new_solution)\n            else:\n                new_solution.extend(routes)\n        else:\n            new_solution.extend(routes)\n    else:\n        new_solution.extend(routes)\n\n    # Customer reinsertion with optimization\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Sort customers by demand (descending) to prioritize larger customers\n        missing_customers = sorted(missing_customers, key=lambda x: -demand[x])\n\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_score = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion position considering both distance and balance\n                for j in range(len(route)-1):\n                    dist_increase = (distance_matrix[route[j], customer] +\n                                   distance_matrix[customer, route[j+1]] -\n                                   distance_matrix[route[j], route[j+1]])\n\n                    # Score combines distance increase and demand balance\n                    new_demand = current_demand + demand[customer]\n                    balance_score = abs(new_demand - capacity/2)\n                    score = dist_increase + 0.5 * balance_score\n\n                    if score < best_score:\n                        best_score = score\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    # Intra-route optimization (2.5-opt for routes with >4 customers)\n    for i, route in enumerate(new_solution):\n        if len(route) > 6:  # Only optimize longer routes\n            for _ in range(2):  # Limited attempts\n                # Select 5 random positions (excluding depot)\n                positions = sorted(random.sample(range(1, len(route)-1), 5))\n\n                # Try different configurations\n                configs = [\n                    [positions[0], positions[1], positions[2], positions[3], positions[4]],\n                    [positions[0], positions[2], positions[1], positions[3], positions[4]],\n                    [positions[0], positions[1], positions[3], positions[2], positions[4]],\n                    [positions[0], positions[2], positions[3], positions[1], positions[4]]\n                ]\n\n                best_config = None\n                min_cost = float('inf')\n\n                for config in configs:\n                    # Reconstruct route with this configuration\n                    temp_route = np.array([0] + [route[pos] for pos in [0] + config + [len(route)-1]] + [0])\n\n                    # Calculate total distance\n                    total_dist = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n\n                    if total_dist < min_cost:\n                        min_cost = total_dist\n                        best_config = config\n\n                if best_config:\n                    # Apply best configuration\n                    new_route = np.array([0] + [route[pos] for pos in [0] + best_config + [len(route)-1]] + [0])\n                    new_solution[i] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8718531319664314,
            0.805967390537262
        ]
    }
]