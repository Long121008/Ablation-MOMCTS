[
    {
        "algorithm": "{This algorithm selects a solution from the archive using a non-dominated sorting approach, then applies a hybrid local search combining route splitting, customer swapping, and inter-route optimization to generate a neighbor solution while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    fronts = []\n    dominated_counts = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] <= archive[j][1][1] and\n                    (archive[i][1][0] < archive[j][1][0] or archive[i][1][1] < archive[j][1][1])):\n                    dominating_sets[i].append(j)\n                elif (archive[j][1][0] <= archive[i][1][0] and archive[j][1][1] <= archive[i][1][1] and\n                      (archive[j][1][0] < archive[i][1][0] or archive[j][1][1] < archive[i][1][1])):\n                    dominated_counts[i] += 1\n\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating_sets[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    # Select from the first non-dominated front\n    if fronts[0]:\n        selected_idx = random.choice(fronts[0])\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Route splitting with capacity check\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Only split long routes\n            split_pos = random.randint(2, len(route)-3)\n            first_part = route[:split_pos+1]\n            second_part = np.array([0] + route[split_pos:-1].tolist() + [0])\n\n            # Check capacity constraints\n            if (sum(demand[first_part[1:-1]]) <= capacity and\n                sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.append(second_part)\n\n    # Customer swapping between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select random customers from each route (excluding depots)\n            cust1_pos = random.randint(1, len(route1)-2)\n            cust2_pos = random.randint(1, len(route2)-2)\n\n            # Check capacity constraints after swap\n            if (sum(demand[route1[1:-1]]) - demand[route1[cust1_pos]] + demand[route2[cust2_pos]] <= capacity and\n                sum(demand[route2[1:-1]]) - demand[route2[cust2_pos]] + demand[route1[cust1_pos]] <= capacity):\n\n                # Perform swap\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[cust1_pos], new_route2[cust2_pos] = new_route2[cust2_pos], new_route1[cust1_pos]\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Inter-route optimization (cross-route 2-opt)\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select two random positions from each route (excluding depots)\n            pos1 = random.randint(1, len(route1)-2)\n            pos2 = random.randint(1, len(route2)-2)\n\n            # Try swapping segments\n            new_route1 = np.concatenate([route1[:pos1], route2[pos2:]])\n            new_route2 = np.concatenate([route2[:pos2], route1[pos1:]])\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n\n                # Calculate distance change\n                old_dist = (distance_matrix[route1[pos1-1], route1[pos1]] +\n                           distance_matrix[route1[-2], route1[-1]] +\n                           distance_matrix[route2[pos2-1], route2[pos2]] +\n                           distance_matrix[route2[-2], route2[-1]])\n\n                new_dist = (distance_matrix[new_route1[pos1-1], new_route1[pos1]] +\n                           distance_matrix[new_route1[-2], new_route1[-1]] +\n                           distance_matrix[new_route2[pos2-1], new_route2[pos2]] +\n                           distance_matrix[new_route2[-2], new_route2[-1]])\n\n                # Accept if distance decreases\n                if new_dist < old_dist:\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8252884346623004,
            0.08127644658088684
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining route merging, customer reinsertion, and intra-route optimization to generate a neighbor solution while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))\n    selected = random.choice(archive[:max(1, len(archive)//2)])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n    routes = [route for route in base_solution if len(route) > 2]\n\n    # Try route merging\n    if len(routes) > 1:\n        route1_idx = random.randint(0, len(routes)-1)\n        route2_idx = random.randint(0, len(routes)-1)\n        if route1_idx != route2_idx:\n            route1 = routes[route1_idx]\n            route2 = routes[route2_idx]\n\n            # Check if merging is possible\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Merge routes by connecting them at closest points\n                min_dist = float('inf')\n                best_pos1, best_pos2 = 0, 0\n\n                for i in range(1, len(route1)-1):\n                    for j in range(1, len(route2)-1):\n                        dist = distance_matrix[route1[i], route2[j]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pos1, best_pos2 = i, j\n\n                # Create merged route\n                merged_route = np.concatenate([\n                    route1[:best_pos1+1],\n                    route2[best_pos2:],\n                    route1[best_pos1+1:]\n                ])\n                new_solution.append(merged_route)\n\n                # Remove merged routes\n                routes = [r for idx, r in enumerate(routes) if idx not in [route1_idx, route2_idx]]\n                routes.extend(new_solution)\n            else:\n                new_solution.extend(routes)\n        else:\n            new_solution.extend(routes)\n    else:\n        new_solution.extend(routes)\n\n    # Customer reinsertion with optimization\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Sort customers by demand (descending) to prioritize larger customers\n        missing_customers = sorted(missing_customers, key=lambda x: -demand[x])\n\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_score = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion position considering both distance and balance\n                for j in range(len(route)-1):\n                    dist_increase = (distance_matrix[route[j], customer] +\n                                   distance_matrix[customer, route[j+1]] -\n                                   distance_matrix[route[j], route[j+1]])\n\n                    # Score combines distance increase and demand balance\n                    new_demand = current_demand + demand[customer]\n                    balance_score = abs(new_demand - capacity/2)\n                    score = dist_increase + 0.5 * balance_score\n\n                    if score < best_score:\n                        best_score = score\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    # Intra-route optimization (2.5-opt for routes with >4 customers)\n    for i, route in enumerate(new_solution):\n        if len(route) > 6:  # Only optimize longer routes\n            for _ in range(2):  # Limited attempts\n                # Select 5 random positions (excluding depot)\n                positions = sorted(random.sample(range(1, len(route)-1), 5))\n\n                # Try different configurations\n                configs = [\n                    [positions[0], positions[1], positions[2], positions[3], positions[4]],\n                    [positions[0], positions[2], positions[1], positions[3], positions[4]],\n                    [positions[0], positions[1], positions[3], positions[2], positions[4]],\n                    [positions[0], positions[2], positions[3], positions[1], positions[4]]\n                ]\n\n                best_config = None\n                min_cost = float('inf')\n\n                for config in configs:\n                    # Reconstruct route with this configuration\n                    temp_route = np.array([0] + [route[pos] for pos in [0] + config + [len(route)-1]] + [0])\n\n                    # Calculate total distance\n                    total_dist = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n\n                    if total_dist < min_cost:\n                        min_cost = total_dist\n                        best_config = config\n\n                if best_config:\n                    # Apply best configuration\n                    new_route = np.array([0] + [route[pos] for pos in [0] + best_config + [len(route)-1]] + [0])\n                    new_solution[i] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8718531319664314,
            0.805967390537262
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with capacity-aware demand rebalancing by first splitting a long route into two shorter routes, then redistributing customers between the new routes to balance loads and reduce makespan while ensuring all capacity constraints are satisfied.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Randomly select a route to split\n    route_idx = np.random.choice(len(new_solution))\n    route = new_solution[route_idx]\n\n    # Calculate route demand and total distance\n    route_demand = sum(demand[node] for node in route[1:-1])\n    route_distance = sum(distance_matrix[route[i-1], route[i]] for i in range(1, len(route)))\n\n    # Calculate average demand per customer in the route\n    avg_demand = route_demand / (len(route) - 2) if len(route) > 2 else 0\n\n    # Split the route into two parts at a random position\n    split_pos = np.random.randint(1, len(route) - 1)\n    part1 = route[:split_pos + 1]\n    part2 = route[split_pos:]\n    part2[0] = 0  # Ensure part2 starts at depot\n\n    # Calculate demands for both parts\n    part1_demand = sum(demand[node] for node in part1[1:-1])\n    part2_demand = sum(demand[node] for node in part2[1:-1])\n\n    # Check if splitting is feasible (both parts must have demand <= capacity)\n    if part1_demand > capacity or part2_demand > capacity:\n        return new_solution\n\n    # Replace the original route with the two new routes\n    new_solution[route_idx] = part1\n    new_solution.insert(route_idx + 1, part2)\n\n    # Try to rebalance customers between the two new routes\n    for i in range(len(part1) - 2, 0, -1):\n        node = part1[i]\n        if demand[node] <= (capacity - part2_demand):\n            # Calculate insertion cost in part2\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(part2)):\n                temp_route = np.insert(part2, pos, node)\n                new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                if new_cost < best_cost:\n                    best_cost = new_cost\n                    best_pos = pos\n\n            # Perform the move\n            part2 = np.insert(part2, best_pos, node)\n            part1 = np.delete(part1, i)\n            part2_demand += demand[node]\n\n    # Update the solution\n    new_solution[route_idx] = part1\n    new_solution[route_idx + 1] = part2\n\n    return new_solution\n\n",
        "score": [
            -0.8519818579398478,
            0.4886901080608368
        ]
    },
    {
        "algorithm": "{This new algorithm implements a demand-aware route splitting and reinsertion strategy that first identifies the longest route in the solution, splits it into smaller segments based on capacity constraints, and then intelligently reinserts the segments into the solution while optimizing both total distance and makespan by considering spatial proximity and demand balance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Select the longest route for splitting\n    longest_route_idx = np.argmax([len(route) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:  # Route has only depot and one customer\n        return new_solution\n\n    # Calculate cumulative demand along the route\n    cumulative_demand = np.cumsum([demand[node] for node in longest_route[1:-1]])\n\n    # Find split points where cumulative demand exceeds capacity\n    split_points = [0] + [i+1 for i in range(len(cumulative_demand)-1) if cumulative_demand[i] <= capacity and cumulative_demand[i+1] > capacity]\n\n    if len(split_points) <= 1:\n        return new_solution\n\n    # Split the route into segments\n    segments = []\n    for i in range(len(split_points)-1):\n        start = split_points[i]\n        end = split_points[i+1]\n        segment = longest_route[start+1:end+1]\n        segments.append(segment)\n\n    # Remove the original long route\n    del new_solution[longest_route_idx]\n\n    # Reinsert segments into the solution\n    for segment in segments:\n        best_route_idx = -1\n        best_insertion_cost = float('inf')\n        best_position = -1\n\n        # Find the best route and position to insert the segment\n        for route_idx, route in enumerate(new_solution):\n            for pos in range(1, len(route)):\n                # Check capacity constraint\n                segment_demand = sum(demand[node] for node in segment)\n                route_demand = sum(demand[node] for node in route[1:-1])\n                if route_demand + segment_demand > capacity:\n                    continue\n\n                # Calculate insertion cost\n                temp_route = np.insert(route, pos, segment)\n                insertion_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n\n                if insertion_cost < best_insertion_cost:\n                    best_insertion_cost = insertion_cost\n                    best_route_idx = route_idx\n                    best_position = pos\n\n        # Insert the segment into the best position\n        if best_route_idx != -1:\n            new_solution[best_route_idx] = np.insert(new_solution[best_route_idx], best_position, segment)\n        else:\n            # If no suitable position found, create a new route\n            new_route = np.concatenate([[0], segment, [0]])\n            new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7390465425489432,
            0.11352488398551941
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with demand-aware rebalancing by first merging two routes into one if their combined demand fits within capacity, then redistributing customers between the new route and a third route to balance loads and reduce makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Randomly select two routes to potentially merge\n    route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Check if merging these routes is feasible\n    total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n    if total_demand > capacity:\n        return new_solution\n\n    # Merge the two routes by combining their customers\n    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n    np.random.shuffle(merged_route)  # Randomize order for rebalancing\n    merged_route = np.insert(merged_route, 0, 0)\n    merged_route = np.append(merged_route, 0)\n\n    # Try to rebalance by redistributing customers to another route\n    if len(new_solution) > 2:\n        other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i not in (route1_idx, route2_idx)])\n        other_route = new_solution[other_route_idx]\n\n        # Calculate remaining capacity of the other route\n        other_load = sum(demand[node] for node in other_route[1:-1])\n        available_capacity = capacity - other_load\n\n        # Move customers from merged route to other route if possible\n        for i in range(len(merged_route) - 2, 0, -1):\n            node = merged_route[i]\n            if demand[node] <= available_capacity:\n                # Insert node into other route at the best position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    temp_route = np.insert(other_route, pos, node)\n                    new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n\n                # Perform the move\n                other_route = np.insert(other_route, best_pos, node)\n                merged_route = np.delete(merged_route, i)\n                available_capacity -= demand[node]\n\n        # Update the solution\n        new_solution[other_route_idx] = other_route\n        new_solution[route1_idx] = merged_route\n        del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7710716440369542,
            0.1315108835697174
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with demand-aware rebalancing by first splitting a long route into two shorter routes if their demands fit within capacity, then redistributing customers between the new routes and an existing route to balance loads and reduce makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Randomly select a route to potentially split\n    route_idx = np.random.choice(len(new_solution))\n    route = new_solution[route_idx]\n    customers = route[1:-1]\n\n    if len(customers) < 2:\n        return new_solution\n\n    # Split the route into two parts\n    split_pos = np.random.randint(1, len(customers))\n    part1 = customers[:split_pos]\n    part2 = customers[split_pos:]\n\n    # Check if both parts fit within capacity\n    demand_part1 = sum(demand[node] for node in part1)\n    demand_part2 = sum(demand[node] for node in part2)\n\n    if demand_part1 > capacity or demand_part2 > capacity:\n        return new_solution\n\n    # Create two new routes\n    new_route1 = np.insert(part1, 0, 0)\n    new_route1 = np.append(new_route1, 0)\n    new_route2 = np.insert(part2, 0, 0)\n    new_route2 = np.append(new_route2, 0)\n\n    # Replace the original route with the two new routes\n    new_solution[route_idx] = new_route1\n    new_solution.insert(route_idx + 1, new_route2)\n\n    # Try to rebalance by redistributing customers to another route\n    if len(new_solution) > 2:\n        other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n        other_route = new_solution[other_route_idx]\n\n        # Calculate remaining capacity of the other route\n        other_load = sum(demand[node] for node in other_route[1:-1])\n        available_capacity = capacity - other_load\n\n        # Move customers from new routes to other route if possible\n        for new_route in [new_route1, new_route2]:\n            for i in range(len(new_route) - 2, 0, -1):\n                node = new_route[i]\n                if demand[node] <= available_capacity:\n                    # Insert node into other route at the best position\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(other_route)):\n                        temp_route = np.insert(other_route, pos, node)\n                        new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                        if new_cost < best_cost:\n                            best_cost = new_cost\n                            best_pos = pos\n\n                    # Perform the move\n                    other_route = np.insert(other_route, best_pos, node)\n                    new_route = np.delete(new_route, i)\n                    available_capacity -= demand[node]\n\n        # Update the solution\n        new_solution[other_route_idx] = other_route\n\n    return new_solution\n\n",
        "score": [
            -0.8015843910753389,
            0.424274742603302
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route merging, customer reinsertion with demand-aware positioning, and inter-route segment swaps to generate a neighbor solution while ensuring feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    selected = random.choice(archive[:max(1, len(archive)//3)])\n    base_solution = selected[0].copy()\n\n    new_solution = []\n    routes = [route for route in base_solution if len(route) > 2]\n\n    if len(routes) > 1:\n        route1_idx = random.randint(0, len(routes)-1)\n        route2_idx = random.randint(0, len(routes)-1)\n        if route1_idx != route2_idx:\n            route1 = routes[route1_idx]\n            route2 = routes[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if demand1 + demand2 <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution = [r for i, r in enumerate(routes) if i not in {route1_idx, route2_idx}]\n                new_solution.append(merged_route)\n            else:\n                new_solution = routes.copy()\n\n            if random.random() < 0.5 and len(new_solution) > 1:\n                route_idx = random.randint(0, len(new_solution)-1)\n                route = new_solution[route_idx]\n                if len(route) > 4:\n                    split_pos = random.randint(1, len(route)-2)\n                    part1 = route[:split_pos+1]\n                    part2 = route[split_pos:]\n\n                    demand_part1 = sum(demand[part1[1:-1]])\n                    demand_part2 = sum(demand[part2[1:-1]])\n\n                    if demand_part1 <= capacity and demand_part2 <= capacity:\n                        new_solution[route_idx] = part1\n                        new_solution.append(part2)\n    else:\n        new_solution = routes.copy()\n\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 3:\n                pos1 = random.randint(1, len(route1)-3)\n                pos2 = random.randint(1, len(route2)-3)\n\n                segment1 = route1[pos1:pos1+2]\n                segment2 = route2[pos2:pos2+2]\n\n                demand_route1 = sum(demand[route1[1:-1]]) - sum(demand[segment1[1:-1]]) + sum(demand[segment2[1:-1]])\n                demand_route2 = sum(demand[route2[1:-1]]) - sum(demand[segment2[1:-1]]) + sum(demand[segment1[1:-1]])\n\n                if demand_route1 <= capacity and demand_route2 <= capacity:\n                    new_route1 = np.concatenate([route1[:pos1], segment2, route1[pos1+2:]])\n                    new_route2 = np.concatenate([route2[:pos2], segment1, route2[pos2+2:]])\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_improvement = -float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                for j in range(len(route)-1):\n                    dist_before = distance_matrix[route[j], route[j+1]]\n                    dist_after = distance_matrix[route[j], customer] + distance_matrix[customer, route[j+1]]\n                    improvement = dist_before - dist_after\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5525269048812648,
            0.12736353278160095
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with balanced objectives, then applies a hybrid local search combining route merging, customer reinsertion, and intra-route segment reversals to generate a neighbor solution while ensuring feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))  # Weighted by importance\n    selected = random.choice(archive[:max(1, len(archive)//2)])  # Pick from top half\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # 1. Route merging: Try to merge two routes if their combined demand is within capacity\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes by connecting them\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    # 2. Customer reinsertion: Remove a random customer and reinsert it optimally\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Need at least 3 nodes (depot + 1 customer + depot)\n            pos = random.randint(1, len(route)-2)\n            customer = route[pos]\n            # Remove customer\n            new_route = np.concatenate([route[:pos], route[pos+1:]])\n            new_solution[route_idx] = new_route\n\n            # Find best reinsertion position\n            best_route = None\n            best_pos = None\n            best_distance_increase = float('inf')\n\n            for i, candidate_route in enumerate(new_solution):\n                current_demand = sum(demand[candidate_route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                for j in range(len(candidate_route)-1):\n                    dist_increase = (distance_matrix[candidate_route[j], customer] +\n                                   distance_matrix[customer, candidate_route[j+1]] -\n                                   distance_matrix[candidate_route[j], candidate_route[j+1]])\n\n                    if dist_increase < best_distance_increase:\n                        best_distance_increase = dist_increase\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    # 3. Intra-route segment reversal: Reverse a random segment of a route\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Need at least 5 nodes for a meaningful reversal\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            reversed_segment = route[start:end][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end:]])\n            new_solution[i] = new_route\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Assign missing customers to routes with available capacity\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_distance_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion position\n                for j in range(len(route)-1):\n                    dist_increase = (distance_matrix[route[j], customer] +\n                                   distance_matrix[customer, route[j+1]] -\n                                   distance_matrix[route[j], route[j+1]])\n\n                    if dist_increase < best_distance_increase:\n                        best_distance_increase = dist_increase\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7183359669900888,
            0.24442437291145325
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a novel combination of Pareto dominance and objective correlation, then applies a hybrid local search that combines route reversal, customer migration, and adaptive route merging to generate a neighbor solution while maintaining feasibility and improving both objectives through a dynamic balance of distance and makespan optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + 0.5*x[1][1]))  # Weighted sum prioritizing distance but considering makespan\n    selected = random.choice(archive[:max(1, len(archive)//2)])  # Wider selection range\n    base_solution = selected[0].copy()\n\n    new_solution = []\n    for route in base_solution:\n        if len(route) > 3:\n            # Adaptive route reversal with capacity check\n            reversed_route = route[::-1]\n            reversed_demand = sum(demand[reversed_route[1:-1]])\n            if reversed_demand <= capacity:\n                new_solution.append(reversed_route)\n            else:\n                # If reversal exceeds capacity, try partial reversal\n                for i in range(1, len(route)-1):\n                    partial_reversed = np.concatenate([route[:i], route[i:][::-1]])\n                    partial_demand = sum(demand[partial_reversed[1:-1]])\n                    if partial_demand <= capacity:\n                        new_solution.append(partial_reversed)\n                        break\n                else:\n                    new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Customer migration between routes\n    if len(new_solution) > 1:\n        for _ in range(2):  # Perform multiple migrations\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 2:\n                    # Select random customer to migrate\n                    customer_pos = random.randint(1, len(route1)-2)\n                    customer = route1[customer_pos]\n\n                    # Check capacity constraints\n                    demand_route1 = sum(demand[route1[1:-1]]) - demand[customer]\n                    demand_route2 = sum(demand[route2[1:-1]]) + demand[customer]\n\n                    if demand_route1 <= capacity and demand_route2 <= capacity:\n                        # Find best insertion point in route2\n                        best_pos = None\n                        best_gain = -float('inf')\n\n                        for i in range(len(route2)-1):\n                            gain = (distance_matrix[route2[i], customer] +\n                                   distance_matrix[customer, route2[i+1]] -\n                                   distance_matrix[route2[i], route2[i+1]])\n\n                            if gain > best_gain:\n                                best_gain = gain\n                                best_pos = i\n\n                        if best_pos is not None:\n                            # Perform migration\n                            new_route1 = np.delete(route1, customer_pos)\n                            new_route2 = np.insert(route2, best_pos+1, customer)\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n\n    # Adaptive route merging\n    if len(new_solution) > 2:\n        for _ in range(2):  # Try multiple merges\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                # Check capacity constraint\n                total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Calculate potential distance improvement\n                    dist_before = (distance_matrix[route1[-2], 0] +\n                                 distance_matrix[route2[-2], 0] +\n                                 distance_matrix[0, route1[1]] +\n                                 distance_matrix[0, route2[1]])\n\n                    dist_after = (distance_matrix[route1[-2], route2[1]] +\n                                 distance_matrix[route2[-2], route1[1]])\n\n                    if dist_after < dist_before * 0.95:  # Only merge if significant improvement\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution[route1_idx] = merged_route\n                        new_solution.pop(route2_idx)\n                        break\n\n    # Remove empty routes and ensure all customers are served\n    new_solution = [route for route in new_solution if len(route) > 2]\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Assign missing customers to shortest possible route\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_distance = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                # Find insertion that minimizes route length\n                for j in range(len(route)-1):\n                    dist = (distance_matrix[route[j], customer] +\n                           distance_matrix[customer, route[j+1]] -\n                           distance_matrix[route[j], route[j+1]])\n\n                    if dist < best_distance:\n                        best_distance = dist\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n            else:\n                # If no feasible route found, create a new route\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.6448471339544957,
            0.2122381031513214
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with load-aware rebalancing by first splitting a long route into two shorter routes if their demands fit within capacity, then redistributing customers between the new routes and other routes to balance loads and reduce the maximum route length.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Select the longest route to split\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    # Try to split the longest route into two\n    for split_pos in range(2, len(longest_route)-2):\n        first_part = longest_route[:split_pos+1]\n        second_part = longest_route[split_pos:]\n\n        first_demand = sum(demand[node] for node in first_part[1:-1])\n        second_demand = sum(demand[node] for node in second_part[1:-1])\n\n        if first_demand <= capacity and second_demand <= capacity:\n            # Valid split found\n            new_solution[longest_route_idx] = first_part\n            new_solution.insert(longest_route_idx+1, second_part)\n\n            # Try to rebalance by redistributing customers\n            if len(new_solution) > 2:\n                other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != longest_route_idx])\n                other_route = new_solution[other_route_idx]\n\n                other_load = sum(demand[node] for node in other_route[1:-1])\n                available_capacity = capacity - other_load\n\n                # Move customers from the new routes to the other route if possible\n                for route_idx in [longest_route_idx, longest_route_idx+1]:\n                    current_route = new_solution[route_idx]\n                    for i in range(len(current_route)-2, 0, -1):\n                        node = current_route[i]\n                        if demand[node] <= available_capacity:\n                            # Insert node into other route at the best position\n                            best_pos = 1\n                            best_cost = float('inf')\n                            for pos in range(1, len(other_route)):\n                                temp_route = np.insert(other_route, pos, node)\n                                new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                                if new_cost < best_cost:\n                                    best_cost = new_cost\n                                    best_pos = pos\n\n                            # Perform the move\n                            other_route = np.insert(other_route, best_pos, node)\n                            current_route = np.delete(current_route, i)\n                            available_capacity -= demand[node]\n\n                    new_solution[route_idx] = current_route\n                new_solution[other_route_idx] = other_route\n\n            return new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7685826093627509,
            0.4430483877658844
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining route merging, customer reinsertion, and intra-route optimization to generate a neighbor solution while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))\n    selected = random.choice(archive[:max(1, len(archive)//2)])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n    routes = [route for route in base_solution if len(route) > 2]\n\n    # Try route merging\n    if len(routes) > 1:\n        route1_idx = random.randint(0, len(routes)-1)\n        route2_idx = random.randint(0, len(routes)-1)\n        if route1_idx != route2_idx:\n            route1 = routes[route1_idx]\n            route2 = routes[route2_idx]\n\n            # Check if merging is possible\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Merge routes by connecting them at closest points\n                min_dist = float('inf')\n                best_pos1, best_pos2 = 0, 0\n\n                for i in range(1, len(route1)-1):\n                    for j in range(1, len(route2)-1):\n                        dist = distance_matrix[route1[i], route2[j]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pos1, best_pos2 = i, j\n\n                # Create merged route\n                merged_route = np.concatenate([\n                    route1[:best_pos1+1],\n                    route2[best_pos2:],\n                    route1[best_pos1+1:]\n                ])\n                new_solution.append(merged_route)\n\n                # Remove merged routes\n                routes = [r for idx, r in enumerate(routes) if idx not in [route1_idx, route2_idx]]\n                routes.extend(new_solution)\n            else:\n                new_solution.extend(routes)\n        else:\n            new_solution.extend(routes)\n    else:\n        new_solution.extend(routes)\n\n    # Customer reinsertion with optimization\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Sort customers by demand (descending) to prioritize larger customers\n        missing_customers = sorted(missing_customers, key=lambda x: -demand[x])\n\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_score = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion position considering both distance and balance\n                for j in range(len(route)-1):\n                    dist_increase = (distance_matrix[route[j], customer] +\n                                   distance_matrix[customer, route[j+1]] -\n                                   distance_matrix[route[j], route[j+1]])\n\n                    # Score combines distance increase and demand balance\n                    new_demand = current_demand + demand[customer]\n                    balance_score = abs(new_demand - capacity/2)\n                    score = dist_increase + 0.5 * balance_score\n\n                    if score < best_score:\n                        best_score = score\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    # Intra-route optimization (2.5-opt for routes with >4 customers)\n    for i, route in enumerate(new_solution):\n        if len(route) > 6:  # Only optimize longer routes\n            for _ in range(2):  # Limited attempts\n                # Select 5 random positions (excluding depot)\n                positions = sorted(random.sample(range(1, len(route)-1), 5))\n\n                # Try different configurations\n                configs = [\n                    [positions[0], positions[1], positions[2], positions[3], positions[4]],\n                    [positions[0], positions[2], positions[1], positions[3], positions[4]],\n                    [positions[0], positions[1], positions[3], positions[2], positions[4]],\n                    [positions[0], positions[2], positions[3], positions[1], positions[4]]\n                ]\n\n                best_config = None\n                min_cost = float('inf')\n\n                for config in configs:\n                    # Reconstruct route with this configuration\n                    temp_route = np.array([0] + [route[pos] for pos in [0] + config + [len(route)-1]] + [0])\n\n                    # Calculate total distance\n                    total_dist = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n\n                    if total_dist < min_cost:\n                        min_cost = total_dist\n                        best_config = config\n\n                if best_config:\n                    # Apply best configuration\n                    new_route = np.array([0] + [route[pos] for pos in [0] + best_config + [len(route)-1]] + [0])\n                    new_solution[i] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8718531319664314,
            0.805967390537262
        ]
    },
    {
        "algorithm": "{The new algorithm combines route splitting with capacity-aware demand rebalancing by first splitting a long route into two shorter routes, then redistributing customers between the new routes to balance loads and reduce makespan while ensuring all capacity constraints are satisfied.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Randomly select a route to split\n    route_idx = np.random.choice(len(new_solution))\n    route = new_solution[route_idx]\n\n    # Calculate route demand and total distance\n    route_demand = sum(demand[node] for node in route[1:-1])\n    route_distance = sum(distance_matrix[route[i-1], route[i]] for i in range(1, len(route)))\n\n    # Calculate average demand per customer in the route\n    avg_demand = route_demand / (len(route) - 2) if len(route) > 2 else 0\n\n    # Split the route into two parts at a random position\n    split_pos = np.random.randint(1, len(route) - 1)\n    part1 = route[:split_pos + 1]\n    part2 = route[split_pos:]\n    part2[0] = 0  # Ensure part2 starts at depot\n\n    # Calculate demands for both parts\n    part1_demand = sum(demand[node] for node in part1[1:-1])\n    part2_demand = sum(demand[node] for node in part2[1:-1])\n\n    # Check if splitting is feasible (both parts must have demand <= capacity)\n    if part1_demand > capacity or part2_demand > capacity:\n        return new_solution\n\n    # Replace the original route with the two new routes\n    new_solution[route_idx] = part1\n    new_solution.insert(route_idx + 1, part2)\n\n    # Try to rebalance customers between the two new routes\n    for i in range(len(part1) - 2, 0, -1):\n        node = part1[i]\n        if demand[node] <= (capacity - part2_demand):\n            # Calculate insertion cost in part2\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(part2)):\n                temp_route = np.insert(part2, pos, node)\n                new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                if new_cost < best_cost:\n                    best_cost = new_cost\n                    best_pos = pos\n\n            # Perform the move\n            part2 = np.insert(part2, best_pos, node)\n            part1 = np.delete(part1, i)\n            part2_demand += demand[node]\n\n    # Update the solution\n    new_solution[route_idx] = part1\n    new_solution[route_idx + 1] = part2\n\n    return new_solution\n\n",
        "score": [
            -0.8519818579398478,
            0.4886901080608368
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a non-dominated sorting approach, then applies a hybrid local search combining route splitting, customer swapping, and inter-route optimization to generate a neighbor solution while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    fronts = []\n    dominated_counts = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] <= archive[j][1][1] and\n                    (archive[i][1][0] < archive[j][1][0] or archive[i][1][1] < archive[j][1][1])):\n                    dominating_sets[i].append(j)\n                elif (archive[j][1][0] <= archive[i][1][0] and archive[j][1][1] <= archive[i][1][1] and\n                      (archive[j][1][0] < archive[i][1][0] or archive[j][1][1] < archive[i][1][1])):\n                    dominated_counts[i] += 1\n\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating_sets[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    # Select from the first non-dominated front\n    if fronts[0]:\n        selected_idx = random.choice(fronts[0])\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Route splitting with capacity check\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Only split long routes\n            split_pos = random.randint(2, len(route)-3)\n            first_part = route[:split_pos+1]\n            second_part = np.array([0] + route[split_pos:-1].tolist() + [0])\n\n            # Check capacity constraints\n            if (sum(demand[first_part[1:-1]]) <= capacity and\n                sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.append(second_part)\n\n    # Customer swapping between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select random customers from each route (excluding depots)\n            cust1_pos = random.randint(1, len(route1)-2)\n            cust2_pos = random.randint(1, len(route2)-2)\n\n            # Check capacity constraints after swap\n            if (sum(demand[route1[1:-1]]) - demand[route1[cust1_pos]] + demand[route2[cust2_pos]] <= capacity and\n                sum(demand[route2[1:-1]]) - demand[route2[cust2_pos]] + demand[route1[cust1_pos]] <= capacity):\n\n                # Perform swap\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[cust1_pos], new_route2[cust2_pos] = new_route2[cust2_pos], new_route1[cust1_pos]\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Inter-route optimization (cross-route 2-opt)\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select two random positions from each route (excluding depots)\n            pos1 = random.randint(1, len(route1)-2)\n            pos2 = random.randint(1, len(route2)-2)\n\n            # Try swapping segments\n            new_route1 = np.concatenate([route1[:pos1], route2[pos2:]])\n            new_route2 = np.concatenate([route2[:pos2], route1[pos1:]])\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n\n                # Calculate distance change\n                old_dist = (distance_matrix[route1[pos1-1], route1[pos1]] +\n                           distance_matrix[route1[-2], route1[-1]] +\n                           distance_matrix[route2[pos2-1], route2[pos2]] +\n                           distance_matrix[route2[-2], route2[-1]])\n\n                new_dist = (distance_matrix[new_route1[pos1-1], new_route1[pos1]] +\n                           distance_matrix[new_route1[-2], new_route1[-1]] +\n                           distance_matrix[new_route2[pos2-1], new_route2[pos2]] +\n                           distance_matrix[new_route2[-2], new_route2[-1]])\n\n                # Accept if distance decreases\n                if new_dist < old_dist:\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8252884346623004,
            0.08127644658088684
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining route merging, customer reinsertion, and intra-route optimization to generate a neighbor solution while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))\n    selected = random.choice(archive[:max(1, len(archive)//2)])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n    routes = [route for route in base_solution if len(route) > 2]\n\n    # Try route merging\n    if len(routes) > 1:\n        route1_idx = random.randint(0, len(routes)-1)\n        route2_idx = random.randint(0, len(routes)-1)\n        if route1_idx != route2_idx:\n            route1 = routes[route1_idx]\n            route2 = routes[route2_idx]\n\n            # Check if merging is possible\n            if sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n                # Merge routes by connecting them at closest points\n                min_dist = float('inf')\n                best_pos1, best_pos2 = 0, 0\n\n                for i in range(1, len(route1)-1):\n                    for j in range(1, len(route2)-1):\n                        dist = distance_matrix[route1[i], route2[j]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pos1, best_pos2 = i, j\n\n                # Create merged route\n                merged_route = np.concatenate([\n                    route1[:best_pos1+1],\n                    route2[best_pos2:],\n                    route1[best_pos1+1:]\n                ])\n                new_solution.append(merged_route)\n\n                # Remove merged routes\n                routes = [r for idx, r in enumerate(routes) if idx not in [route1_idx, route2_idx]]\n                routes.extend(new_solution)\n            else:\n                new_solution.extend(routes)\n        else:\n            new_solution.extend(routes)\n    else:\n        new_solution.extend(routes)\n\n    # Customer reinsertion with optimization\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Sort customers by demand (descending) to prioritize larger customers\n        missing_customers = sorted(missing_customers, key=lambda x: -demand[x])\n\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_score = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion position considering both distance and balance\n                for j in range(len(route)-1):\n                    dist_increase = (distance_matrix[route[j], customer] +\n                                   distance_matrix[customer, route[j+1]] -\n                                   distance_matrix[route[j], route[j+1]])\n\n                    # Score combines distance increase and demand balance\n                    new_demand = current_demand + demand[customer]\n                    balance_score = abs(new_demand - capacity/2)\n                    score = dist_increase + 0.5 * balance_score\n\n                    if score < best_score:\n                        best_score = score\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    # Intra-route optimization (2.5-opt for routes with >4 customers)\n    for i, route in enumerate(new_solution):\n        if len(route) > 6:  # Only optimize longer routes\n            for _ in range(2):  # Limited attempts\n                # Select 5 random positions (excluding depot)\n                positions = sorted(random.sample(range(1, len(route)-1), 5))\n\n                # Try different configurations\n                configs = [\n                    [positions[0], positions[1], positions[2], positions[3], positions[4]],\n                    [positions[0], positions[2], positions[1], positions[3], positions[4]],\n                    [positions[0], positions[1], positions[3], positions[2], positions[4]],\n                    [positions[0], positions[2], positions[3], positions[1], positions[4]]\n                ]\n\n                best_config = None\n                min_cost = float('inf')\n\n                for config in configs:\n                    # Reconstruct route with this configuration\n                    temp_route = np.array([0] + [route[pos] for pos in [0] + config + [len(route)-1]] + [0])\n\n                    # Calculate total distance\n                    total_dist = sum(distance_matrix[temp_route[i], temp_route[i+1]] for i in range(len(temp_route)-1))\n\n                    if total_dist < min_cost:\n                        min_cost = total_dist\n                        best_config = config\n\n                if best_config:\n                    # Apply best configuration\n                    new_route = np.array([0] + [route[pos] for pos in [0] + best_config + [len(route)-1]] + [0])\n                    new_solution[i] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8718531319664314,
            0.805967390537262
        ]
    }
]