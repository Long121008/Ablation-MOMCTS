[
    {
        "algorithm": "{The new algorithm combines route merging with demand-aware rebalancing by first merging two routes into one if their combined demand fits within capacity, then redistributing customers between the new route and a third route to balance loads and reduce makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Randomly select two routes to potentially merge\n    route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Check if merging these routes is feasible\n    total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n    if total_demand > capacity:\n        return new_solution\n\n    # Merge the two routes by combining their customers\n    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n    np.random.shuffle(merged_route)  # Randomize order for rebalancing\n    merged_route = np.insert(merged_route, 0, 0)\n    merged_route = np.append(merged_route, 0)\n\n    # Try to rebalance by redistributing customers to another route\n    if len(new_solution) > 2:\n        other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i not in (route1_idx, route2_idx)])\n        other_route = new_solution[other_route_idx]\n\n        # Calculate remaining capacity of the other route\n        other_load = sum(demand[node] for node in other_route[1:-1])\n        available_capacity = capacity - other_load\n\n        # Move customers from merged route to other route if possible\n        for i in range(len(merged_route) - 2, 0, -1):\n            node = merged_route[i]\n            if demand[node] <= available_capacity:\n                # Insert node into other route at the best position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    temp_route = np.insert(other_route, pos, node)\n                    new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n\n                # Perform the move\n                other_route = np.insert(other_route, best_pos, node)\n                merged_route = np.delete(merged_route, i)\n                available_capacity -= demand[node]\n\n        # Update the solution\n        new_solution[other_route_idx] = other_route\n        new_solution[route1_idx] = merged_route\n        del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7710716440369542,
            0.1315108835697174
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with balanced objectives, then applies a hybrid local search combining route merging, customer reinsertion, and intra-route segment reversals to generate a neighbor solution while ensuring feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))  # Weighted by importance\n    selected = random.choice(archive[:max(1, len(archive)//2)])  # Pick from top half\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # 1. Route merging: Try to merge two routes if their combined demand is within capacity\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes by connecting them\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                new_solution.pop(route2_idx)\n\n    # 2. Customer reinsertion: Remove a random customer and reinsert it optimally\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 3:  # Need at least 3 nodes (depot + 1 customer + depot)\n            pos = random.randint(1, len(route)-2)\n            customer = route[pos]\n            # Remove customer\n            new_route = np.concatenate([route[:pos], route[pos+1:]])\n            new_solution[route_idx] = new_route\n\n            # Find best reinsertion position\n            best_route = None\n            best_pos = None\n            best_distance_increase = float('inf')\n\n            for i, candidate_route in enumerate(new_solution):\n                current_demand = sum(demand[candidate_route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                for j in range(len(candidate_route)-1):\n                    dist_increase = (distance_matrix[candidate_route[j], customer] +\n                                   distance_matrix[customer, candidate_route[j+1]] -\n                                   distance_matrix[candidate_route[j], candidate_route[j+1]])\n\n                    if dist_increase < best_distance_increase:\n                        best_distance_increase = dist_increase\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    # 3. Intra-route segment reversal: Reverse a random segment of a route\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) > 4:  # Need at least 5 nodes for a meaningful reversal\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n            reversed_segment = route[start:end][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end:]])\n            new_solution[i] = new_route\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Assign missing customers to routes with available capacity\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_distance_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion position\n                for j in range(len(route)-1):\n                    dist_increase = (distance_matrix[route[j], customer] +\n                                   distance_matrix[customer, route[j+1]] -\n                                   distance_matrix[route[j], route[j+1]])\n\n                    if dist_increase < best_distance_increase:\n                        best_distance_increase = dist_increase\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7183359669900888,
            0.24442437291145325
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a novel combination of Pareto dominance and objective correlation, then applies a hybrid local search that combines route reversal, customer migration, and adaptive route merging to generate a neighbor solution while maintaining feasibility and improving both objectives through a dynamic balance of distance and makespan optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + 0.5*x[1][1]))  # Weighted sum prioritizing distance but considering makespan\n    selected = random.choice(archive[:max(1, len(archive)//2)])  # Wider selection range\n    base_solution = selected[0].copy()\n\n    new_solution = []\n    for route in base_solution:\n        if len(route) > 3:\n            # Adaptive route reversal with capacity check\n            reversed_route = route[::-1]\n            reversed_demand = sum(demand[reversed_route[1:-1]])\n            if reversed_demand <= capacity:\n                new_solution.append(reversed_route)\n            else:\n                # If reversal exceeds capacity, try partial reversal\n                for i in range(1, len(route)-1):\n                    partial_reversed = np.concatenate([route[:i], route[i:][::-1]])\n                    partial_demand = sum(demand[partial_reversed[1:-1]])\n                    if partial_demand <= capacity:\n                        new_solution.append(partial_reversed)\n                        break\n                else:\n                    new_solution.append(route)\n        else:\n            new_solution.append(route)\n\n    # Customer migration between routes\n    if len(new_solution) > 1:\n        for _ in range(2):  # Perform multiple migrations\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 2:\n                    # Select random customer to migrate\n                    customer_pos = random.randint(1, len(route1)-2)\n                    customer = route1[customer_pos]\n\n                    # Check capacity constraints\n                    demand_route1 = sum(demand[route1[1:-1]]) - demand[customer]\n                    demand_route2 = sum(demand[route2[1:-1]]) + demand[customer]\n\n                    if demand_route1 <= capacity and demand_route2 <= capacity:\n                        # Find best insertion point in route2\n                        best_pos = None\n                        best_gain = -float('inf')\n\n                        for i in range(len(route2)-1):\n                            gain = (distance_matrix[route2[i], customer] +\n                                   distance_matrix[customer, route2[i+1]] -\n                                   distance_matrix[route2[i], route2[i+1]])\n\n                            if gain > best_gain:\n                                best_gain = gain\n                                best_pos = i\n\n                        if best_pos is not None:\n                            # Perform migration\n                            new_route1 = np.delete(route1, customer_pos)\n                            new_route2 = np.insert(route2, best_pos+1, customer)\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n\n    # Adaptive route merging\n    if len(new_solution) > 2:\n        for _ in range(2):  # Try multiple merges\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                # Check capacity constraint\n                total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                if total_demand <= capacity:\n                    # Calculate potential distance improvement\n                    dist_before = (distance_matrix[route1[-2], 0] +\n                                 distance_matrix[route2[-2], 0] +\n                                 distance_matrix[0, route1[1]] +\n                                 distance_matrix[0, route2[1]])\n\n                    dist_after = (distance_matrix[route1[-2], route2[1]] +\n                                 distance_matrix[route2[-2], route1[1]])\n\n                    if dist_after < dist_before * 0.95:  # Only merge if significant improvement\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution[route1_idx] = merged_route\n                        new_solution.pop(route2_idx)\n                        break\n\n    # Remove empty routes and ensure all customers are served\n    new_solution = [route for route in new_solution if len(route) > 2]\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Assign missing customers to shortest possible route\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_distance = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                # Find insertion that minimizes route length\n                for j in range(len(route)-1):\n                    dist = (distance_matrix[route[j], customer] +\n                           distance_matrix[customer, route[j+1]] -\n                           distance_matrix[route[j], route[j+1]])\n\n                    if dist < best_distance:\n                        best_distance = dist\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n            else:\n                # If no feasible route found, create a new route\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.6448471339544957,
            0.2122381031513214
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] - x[1][1])[0]\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Apply a novel local search operator: Route Merging and Splitting with Demand Balancing\n    if len(new_solution) > 1:\n        # Step 1: Identify the two routes with the highest and lowest makespans\n        route_lengths = [sum(distance_matrix[route[i-1], route[i]] for i in range(1, len(route))) for route in new_solution]\n        longest_route_idx = np.argmax(route_lengths)\n        shortest_route_idx = np.argmin(route_lengths)\n\n        longest_route = new_solution[longest_route_idx]\n        shortest_route = new_solution[shortest_route_idx]\n\n        # Step 2: Transfer nodes from the longest route to the shortest route if capacity allows\n        if len(longest_route) > 3 and len(shortest_route) > 2:\n            # Calculate current loads\n            longest_load = sum(demand[node] for node in longest_route[1:-1])\n            shortest_load = sum(demand[node] for node in shortest_route[1:-1])\n\n            # Attempt to transfer nodes\n            for node in longest_route[1:-1]:\n                if shortest_load + demand[node] <= capacity:\n                    # Find the best insertion position in the shortest route\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(shortest_route)):\n                        # Insert node at position pos\n                        temp_route = np.insert(shortest_route, pos, node)\n                        # Calculate new cost of the modified route\n                        new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                        if new_cost < best_cost:\n                            best_cost = new_cost\n                            best_pos = pos\n\n                    # Perform the insertion\n                    shortest_route = np.insert(shortest_route, best_pos, node)\n                    # Remove the node from the longest route\n                    longest_route = np.delete(longest_route, np.where(longest_route == node)[0][0])\n                    # Update loads\n                    shortest_load += demand[node]\n                    longest_load -= demand[node]\n\n            # Update the solution if changes were made\n            if len(longest_route) > 2:\n                new_solution[longest_route_idx] = longest_route\n                new_solution[shortest_route_idx] = shortest_route\n            else:\n                # If the longest route becomes empty, remove it\n                new_solution.pop(longest_route_idx)\n\n    return new_solution\n\n",
        "score": [
            -0.7490652814300991,
            1.202131062746048
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0]\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    route = new_solution[route_idx]\n\n    # Apply a hybrid local search operator: Route Shuffling with Capacity-Aware Insertion\n    if len(route) > 3:  # Ensure route has at least one customer\n        # Step 1: Shuffle the internal nodes of the route (excluding depots)\n        internal_nodes = route[1:-1]\n        np.random.shuffle(internal_nodes)\n        route[1:-1] = internal_nodes\n\n        # Step 2: Attempt to insert a node from another route if capacity allows\n        if len(new_solution) > 1:\n            other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(other_route) > 3:  # If other route has customers\n                node_to_move = other_route[np.random.randint(1, len(other_route)-1)]\n\n                # Calculate remaining capacity of the current route\n                current_load = sum(demand[node] for node in route[1:-1])\n                if current_load + demand[node_to_move] <= capacity:\n                    # Find the best insertion position in the current route\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route)):\n                        # Insert node_to_move at position pos\n                        temp_route = np.insert(route, pos, node_to_move)\n                        # Calculate new cost (distance) of the modified route\n                        new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                        if new_cost < best_cost:\n                            best_cost = new_cost\n                            best_pos = pos\n\n                    # Perform the insertion\n                    route = np.insert(route, best_pos, node_to_move)\n                    # Remove the node from the other route\n                    other_route = np.delete(other_route, np.where(other_route == node_to_move)[0][0])\n                    # Update the solution\n                    new_solution[route_idx] = route\n                    new_solution[other_route_idx] = other_route\n\n    return new_solution\n\n",
        "score": [
            -0.49311093101338577,
            0.1904425323009491
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the highest makespan, then applies a novel local search combining route merging, customer reinsertion with spatial clustering, and adaptive inter-route swaps to generate a neighbor solution while balancing both objectives and ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: -x[1][1])\n    selected = archive[0]\n    base_solution = selected[0].copy()\n\n    # Route merging operator\n    new_solution = []\n    for i in range(len(base_solution)):\n        for j in range(i+1, len(base_solution)):\n            route1 = base_solution[i]\n            route2 = base_solution[j]\n\n            # Check if merging is feasible\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand > capacity:\n                continue\n\n            # Calculate merged route distance\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            route_distance = sum(distance_matrix[merged_route[k], merged_route[k+1]] for k in range(len(merged_route)-1))\n\n            # Calculate original routes distance\n            original_distance = (sum(distance_matrix[route1[k], route1[k+1]] for k in range(len(route1)-1)) +\n                                sum(distance_matrix[route2[k], route2[k+1]] for k in range(len(route2)-1)))\n\n            # Accept merge if it reduces total distance\n            if route_distance < original_distance:\n                new_solution.append(merged_route)\n                break\n        else:\n            new_solution.append(base_solution[i])\n\n    # Customer reinsertion with spatial clustering\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Cluster customers by spatial proximity\n        customer_coords = coords[list(missing_customers)]\n        from sklearn.cluster import KMeans\n        n_clusters = min(len(missing_customers), len(new_solution))\n        kmeans = KMeans(n_clusters=n_clusters, random_state=42).fit(customer_coords)\n        clusters = [[] for _ in range(n_clusters)]\n        for customer in missing_customers:\n            cluster = kmeans.predict([coords[customer]])[0]\n            clusters[cluster].append(customer)\n\n        # Reinsert customers to nearest route\n        for cluster in clusters:\n            for customer in cluster:\n                best_route = None\n                best_pos = None\n                best_distance = float('inf')\n\n                for i, route in enumerate(new_solution):\n                    current_demand = sum(demand[route[1:-1]])\n                    if current_demand + demand[customer] > capacity:\n                        continue\n\n                    # Find insertion position minimizing distance increase\n                    for j in range(len(route)-1):\n                        dist_increase = (distance_matrix[route[j], customer] +\n                                       distance_matrix[customer, route[j+1]] -\n                                       distance_matrix[route[j], route[j+1]])\n\n                        if dist_increase < best_distance:\n                            best_distance = dist_increase\n                            best_route = i\n                            best_pos = j\n\n                if best_route is not None:\n                    new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                    new_solution[best_route] = new_route\n\n    # Adaptive inter-route swaps\n    if len(new_solution) > 1:\n        for _ in range(min(3, len(new_solution))):\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx != route2_idx:\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                if len(route1) > 2 and len(route2) > 2:\n                    # Select segments to swap\n                    seg1_start = random.randint(1, len(route1)-2)\n                    seg1_end = random.randint(seg1_start, len(route1)-2)\n                    seg2_start = random.randint(1, len(route2)-2)\n                    seg2_end = random.randint(seg2_start, len(route2)-2)\n\n                    # Check capacity constraints\n                    demand_route1 = (sum(demand[route1[1:-1]]) -\n                                   sum(demand[route1[seg1_start:seg1_end]]) +\n                                   sum(demand[route2[seg2_start:seg2_end]]))\n\n                    demand_route2 = (sum(demand[route2[1:-1]]) -\n                                   sum(demand[route2[seg2_start:seg2_end]]) +\n                                   sum(demand[route1[seg1_start:seg1_end]]))\n\n                    if demand_route1 <= capacity and demand_route2 <= capacity:\n                        # Perform the swap\n                        new_route1 = np.concatenate([\n                            route1[:seg1_start],\n                            route2[seg2_start:seg2_end],\n                            route1[seg1_end:]\n                        ])\n                        new_route2 = np.concatenate([\n                            route2[:seg2_start],\n                            route1[seg1_start:seg1_end],\n                            route2[seg2_end:]\n                        ])\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Create new routes for missing customers\n        for customer in missing_customers:\n            new_route = np.array([0, customer, 0])\n            new_solution.append(new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.6698456531446157,
            0.4068756699562073
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search that combines route fragmentation and reinsertion with capacity-aware swaps to balance the two objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route fragmentation and reinsertion with capacity-aware swaps\n    for _ in range(5):  # Number of iterations\n        # Randomly select a route to modify\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Fragment the route into segments\n        segments = []\n        current_segment = [route[0]]\n        current_load = 0\n        for node in route[1:-1]:\n            current_load += demand[node]\n            current_segment.append(node)\n            if current_load >= capacity * 0.7 or random.random() < 0.2:  # Fragmentation condition\n                current_segment.append(route[0])\n                segments.append(current_segment)\n                current_segment = [route[0]]\n                current_load = 0\n        if len(current_segment) > 2:\n            current_segment.append(route[0])\n            segments.append(current_segment)\n\n        # Reinsert segments into the solution\n        for seg in segments:\n            if len(seg) <= 2:\n                continue\n            # Remove the segment from the route\n            route = np.setdiff1d(route, seg[1:-1])\n            # Find the best insertion position for the segment\n            best_pos = -1\n            best_cost = float('inf')\n            for i in range(len(route) - 1):\n                for j in range(len(seg) - 1):\n                    # Check capacity constraint\n                    if sum(demand[seg[j+1:j+2]]) + sum(demand[route[i+1:i+len(seg)-j]]) > capacity:\n                        continue\n                    # Calculate insertion cost\n                    cost = (distance_matrix[route[i], seg[1]] +\n                            distance_matrix[seg[-2], route[i+1]] -\n                            distance_matrix[route[i], route[i+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = (i, j)\n            if best_pos != -1:\n                i, j = best_pos\n                route = np.insert(route, i + 1, seg[j+1:-1])\n        new_solution[route_idx] = route\n\n        # Capacity-aware swap between routes\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            for _ in range(3):  # Try a few swaps\n                # Randomly select nodes from each route\n                if len(route1) <= 2 or len(route2) <= 2:\n                    continue\n                node1_idx = random.randint(1, len(route1) - 2)\n                node2_idx = random.randint(1, len(route2) - 2)\n                node1, node2 = route1[node1_idx], route2[node2_idx]\n\n                # Check capacity constraints\n                load1 = sum(demand[route1[1:-1]]) - demand[node1] + demand[node2]\n                load2 = sum(demand[route2[1:-1]]) - demand[node2] + demand[node1]\n                if load1 <= capacity and load2 <= capacity:\n                    # Perform the swap\n                    route1[node1_idx], route2[node2_idx] = route2[node2_idx], route1[node1_idx]\n                    new_solution[route1_idx] = route1\n                    new_solution[route2_idx] = route2\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7176569104090649,
            2.4692458510398865
        ]
    },
    {
        "algorithm": "{This algorithm selects a promising solution from the archive, identifies critical routes (longest and shortest), and applies a hybrid local search combining route merging and segment swapping to balance distance and makespan while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify the longest and shortest routes\n    route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n    longest_route_idx = np.argmax(route_lengths)\n    shortest_route_idx = np.argmin(route_lengths)\n\n    # Hybrid local search: merge segments between longest and shortest routes, then swap segments\n    longest_route = new_solution[longest_route_idx]\n    shortest_route = new_solution[shortest_route_idx]\n\n    # Find a segment in the longest route to merge into the shortest route\n    for i in range(1, len(longest_route)-2):\n        segment = longest_route[i:i+2]\n        segment_demand = demand[segment].sum()\n\n        # Find feasible insertion points in the shortest route\n        for j in range(1, len(shortest_route)):\n            if demand[shortest_route].sum() + segment_demand <= capacity:\n                # Insert the segment and update routes\n                new_shortest = np.concatenate([shortest_route[:j], segment, shortest_route[j:]])\n                new_longest = np.concatenate([longest_route[:i], longest_route[i+2:]])\n\n                # Ensure depot is maintained\n                if new_longest[0] == 0 and new_longest[-1] == 0 and new_shortest[0] == 0 and new_shortest[-1] == 0:\n                    new_solution[shortest_route_idx] = new_shortest\n                    new_solution[longest_route_idx] = new_longest\n                    break\n\n    # Swap segments between other routes to further improve\n    if len(new_solution) > 1:\n        for _ in range(2):  # Limit iterations for efficiency\n            route1_idx = random.randint(0, len(new_solution)-1)\n            route2_idx = random.randint(0, len(new_solution)-1)\n            if route1_idx == route2_idx:\n                continue\n\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Find feasible swap segments\n            for i in range(1, len(route1)-1):\n                for j in range(1, len(route2)-1):\n                    segment1 = route1[i:i+1]\n                    segment2 = route2[j:j+1]\n                    if (demand[route1].sum() - demand[segment1].sum() + demand[segment2].sum() <= capacity and\n                        demand[route2].sum() - demand[segment2].sum() + demand[segment1].sum() <= capacity):\n\n                        # Perform swap\n                        new_route1 = np.concatenate([route1[:i], segment2, route1[i+1:]])\n                        new_route2 = np.concatenate([route2[:j], segment1, route2[j+1:]])\n\n                        # Ensure depot is maintained\n                        if new_route1[0] == 0 and new_route1[-1] == 0 and new_route2[0] == 0 and new_route2[-1] == 0:\n                            new_solution[route1_idx] = new_route1\n                            new_solution[route2_idx] = new_route2\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.5172601335270837,
            0.7428402304649353
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and inter-route edge swaps to generate a neighbor solution while ensuring feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected = random.choice(archive[:max(1, len(archive)//3)])  # Pick from top 1/3 solutions\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n    for route in base_solution:\n        if len(route) > 4:  # Only consider routes with potential for improvement\n            # Split route into two parts\n            split_point = random.randint(1, len(route)-2)\n            part1 = route[:split_point+1]\n            part2 = route[split_point:]\n\n            # Reallocate customers between parts while respecting capacity\n            temp_demand1 = sum(demand[part1[1:-1]])\n            temp_demand2 = sum(demand[part2[1:-1]])\n\n            # Try to balance demands\n            if temp_demand1 > capacity or temp_demand2 > capacity:\n                # If capacity is exceeded, try to move customers between parts\n                for i in range(1, len(part1)-1):\n                    if temp_demand1 - demand[part1[i]] <= capacity and temp_demand2 + demand[part1[i]] <= capacity:\n                        # Move customer from part1 to part2\n                        part2 = np.insert(part2, 1, part1[i])\n                        part1 = np.delete(part1, i)\n                        temp_demand1 -= demand[part1[i]]\n                        temp_demand2 += demand[part1[i]]\n                        break\n\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            new_solution.append(route)\n\n    # Perform inter-route edge swaps\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Select random edges to swap\n                pos1 = random.randint(1, len(route1)-2)\n                pos2 = random.randint(1, len(route2)-2)\n\n                # Check capacity constraints\n                demand_route1 = sum(demand[route1[1:-1]]) - demand[route1[pos1]] + demand[route2[pos2]]\n                demand_route2 = sum(demand[route2[1:-1]]) - demand[route2[pos2]] + demand[route1[pos1]]\n\n                if demand_route1 <= capacity and demand_route2 <= capacity:\n                    # Perform the swap\n                    new_route1 = np.concatenate([route1[:pos1], [route2[pos2]], route1[pos1+1:]])\n                    new_route2 = np.concatenate([route2[:pos2], [route1[pos1]], route2[pos2+1:]])\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Assign missing customers to routes with available capacity\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_distance_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion position\n                for j in range(len(route)-1):\n                    dist_increase = (distance_matrix[route[j], customer] +\n                                   distance_matrix[customer, route[j+1]] -\n                                   distance_matrix[route[j], route[j+1]])\n\n                    if dist_increase < best_distance_increase:\n                        best_distance_increase = dist_increase\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7113970282910601,
            1.8228459060192108
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route-splitting and demand-based relocation to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: route-splitting and demand-based relocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Split the route into two if possible\n        split_pos = len(route) // 2\n        route1 = np.concatenate(([0], route[1:split_pos+1], [0]))\n        route2 = np.concatenate(([0], route[split_pos+1:-1], [0]))\n\n        # Check capacity feasibility\n        if np.sum(demand[route1[1:-1]]) <= capacity and np.sum(demand[route2[1:-1]]) <= capacity:\n            new_solution.extend([route1, route2])\n        else:\n            # If split is infeasible, try demand-based relocation\n            total_demand = np.sum(demand[route[1:-1]])\n            if total_demand > capacity:\n                # Relocate customers with lowest demand first\n                sorted_indices = np.argsort(demand[route[1:-1]])\n                remaining_route = [0]\n                current_load = 0\n                for idx in sorted_indices:\n                    if current_load + demand[route[1:-1][idx]] <= capacity:\n                        remaining_route.append(route[1:-1][idx])\n                        current_load += demand[route[1:-1][idx]]\n                    else:\n                        break\n                remaining_route.append(0)\n                if len(remaining_route) > 2:\n                    new_solution.append(np.array(remaining_route))\n    return new_solution\n\n",
        "score": [
            -0.6535573860457609,
            3.4505419731140137
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with demand-aware rebalancing by first merging two routes into one if their combined demand fits within capacity, then redistributing customers between the new route and a third route to balance loads and reduce makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Randomly select two routes to potentially merge\n    route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Check if merging these routes is feasible\n    total_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n    if total_demand > capacity:\n        return new_solution\n\n    # Merge the two routes by combining their customers\n    merged_route = np.concatenate([route1[1:-1], route2[1:-1]])\n    np.random.shuffle(merged_route)  # Randomize order for rebalancing\n    merged_route = np.insert(merged_route, 0, 0)\n    merged_route = np.append(merged_route, 0)\n\n    # Try to rebalance by redistributing customers to another route\n    if len(new_solution) > 2:\n        other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i not in (route1_idx, route2_idx)])\n        other_route = new_solution[other_route_idx]\n\n        # Calculate remaining capacity of the other route\n        other_load = sum(demand[node] for node in other_route[1:-1])\n        available_capacity = capacity - other_load\n\n        # Move customers from merged route to other route if possible\n        for i in range(len(merged_route) - 2, 0, -1):\n            node = merged_route[i]\n            if demand[node] <= available_capacity:\n                # Insert node into other route at the best position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(other_route)):\n                    temp_route = np.insert(other_route, pos, node)\n                    new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n\n                # Perform the move\n                other_route = np.insert(other_route, best_pos, node)\n                merged_route = np.delete(merged_route, i)\n                available_capacity -= demand[node]\n\n        # Update the solution\n        new_solution[other_route_idx] = other_route\n        new_solution[route1_idx] = merged_route\n        del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7710716440369542,
            0.1315108835697174
        ]
    }
]