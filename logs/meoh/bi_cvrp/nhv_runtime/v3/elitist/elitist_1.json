[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0]\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    route = new_solution[route_idx]\n\n    # Apply a hybrid local search operator: Route Shuffling with Capacity-Aware Insertion\n    if len(route) > 3:  # Ensure route has at least one customer\n        # Step 1: Shuffle the internal nodes of the route (excluding depots)\n        internal_nodes = route[1:-1]\n        np.random.shuffle(internal_nodes)\n        route[1:-1] = internal_nodes\n\n        # Step 2: Attempt to insert a node from another route if capacity allows\n        if len(new_solution) > 1:\n            other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(other_route) > 3:  # If other route has customers\n                node_to_move = other_route[np.random.randint(1, len(other_route)-1)]\n\n                # Calculate remaining capacity of the current route\n                current_load = sum(demand[node] for node in route[1:-1])\n                if current_load + demand[node_to_move] <= capacity:\n                    # Find the best insertion position in the current route\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route)):\n                        # Insert node_to_move at position pos\n                        temp_route = np.insert(route, pos, node_to_move)\n                        # Calculate new cost (distance) of the modified route\n                        new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                        if new_cost < best_cost:\n                            best_cost = new_cost\n                            best_pos = pos\n\n                    # Perform the insertion\n                    route = np.insert(route, best_pos, node_to_move)\n                    # Remove the node from the other route\n                    other_route = np.delete(other_route, np.where(other_route == node_to_move)[0][0])\n                    # Update the solution\n                    new_solution[route_idx] = route\n                    new_solution[other_route_idx] = other_route\n\n    return new_solution\n\n",
        "score": [
            -0.49311093101338577,
            0.1904425323009491
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and inter-route edge swaps to generate a neighbor solution while ensuring feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected = random.choice(archive[:max(1, len(archive)//3)])  # Pick from top 1/3 solutions\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n    for route in base_solution:\n        if len(route) > 4:  # Only consider routes with potential for improvement\n            # Split route into two parts\n            split_point = random.randint(1, len(route)-2)\n            part1 = route[:split_point+1]\n            part2 = route[split_point:]\n\n            # Reallocate customers between parts while respecting capacity\n            temp_demand1 = sum(demand[part1[1:-1]])\n            temp_demand2 = sum(demand[part2[1:-1]])\n\n            # Try to balance demands\n            if temp_demand1 > capacity or temp_demand2 > capacity:\n                # If capacity is exceeded, try to move customers between parts\n                for i in range(1, len(part1)-1):\n                    if temp_demand1 - demand[part1[i]] <= capacity and temp_demand2 + demand[part1[i]] <= capacity:\n                        # Move customer from part1 to part2\n                        part2 = np.insert(part2, 1, part1[i])\n                        part1 = np.delete(part1, i)\n                        temp_demand1 -= demand[part1[i]]\n                        temp_demand2 += demand[part1[i]]\n                        break\n\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            new_solution.append(route)\n\n    # Perform inter-route edge swaps\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Select random edges to swap\n                pos1 = random.randint(1, len(route1)-2)\n                pos2 = random.randint(1, len(route2)-2)\n\n                # Check capacity constraints\n                demand_route1 = sum(demand[route1[1:-1]]) - demand[route1[pos1]] + demand[route2[pos2]]\n                demand_route2 = sum(demand[route2[1:-1]]) - demand[route2[pos2]] + demand[route1[pos1]]\n\n                if demand_route1 <= capacity and demand_route2 <= capacity:\n                    # Perform the swap\n                    new_route1 = np.concatenate([route1[:pos1], [route2[pos2]], route1[pos1+1:]])\n                    new_route2 = np.concatenate([route2[:pos2], [route1[pos1]], route2[pos2+1:]])\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Assign missing customers to routes with available capacity\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_distance_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion position\n                for j in range(len(route)-1):\n                    dist_increase = (distance_matrix[route[j], customer] +\n                                   distance_matrix[customer, route[j+1]] -\n                                   distance_matrix[route[j], route[j+1]])\n\n                    if dist_increase < best_distance_increase:\n                        best_distance_increase = dist_increase\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7113970282910601,
            1.8228459060192108
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and inter-route edge swaps to generate a neighbor solution while ensuring feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected = random.choice(archive[:max(1, len(archive)//3)])  # Pick from top 1/3 solutions\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator\n    new_solution = []\n    for route in base_solution:\n        if len(route) > 4:  # Only consider routes with potential for improvement\n            # Split route into two parts\n            split_point = random.randint(1, len(route)-2)\n            part1 = route[:split_point+1]\n            part2 = route[split_point:]\n\n            # Reallocate customers between parts while respecting capacity\n            temp_demand1 = sum(demand[part1[1:-1]])\n            temp_demand2 = sum(demand[part2[1:-1]])\n\n            # Try to balance demands\n            if temp_demand1 > capacity or temp_demand2 > capacity:\n                # If capacity is exceeded, try to move customers between parts\n                for i in range(1, len(part1)-1):\n                    if temp_demand1 - demand[part1[i]] <= capacity and temp_demand2 + demand[part1[i]] <= capacity:\n                        # Move customer from part1 to part2\n                        part2 = np.insert(part2, 1, part1[i])\n                        part1 = np.delete(part1, i)\n                        temp_demand1 -= demand[part1[i]]\n                        temp_demand2 += demand[part1[i]]\n                        break\n\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            new_solution.append(route)\n\n    # Perform inter-route edge swaps\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        if route1_idx != route2_idx:\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            if len(route1) > 2 and len(route2) > 2:\n                # Select random edges to swap\n                pos1 = random.randint(1, len(route1)-2)\n                pos2 = random.randint(1, len(route2)-2)\n\n                # Check capacity constraints\n                demand_route1 = sum(demand[route1[1:-1]]) - demand[route1[pos1]] + demand[route2[pos2]]\n                demand_route2 = sum(demand[route2[1:-1]]) - demand[route2[pos2]] + demand[route1[pos1]]\n\n                if demand_route1 <= capacity and demand_route2 <= capacity:\n                    # Perform the swap\n                    new_route1 = np.concatenate([route1[:pos1], [route2[pos2]], route1[pos1+1:]])\n                    new_route2 = np.concatenate([route2[:pos2], [route1[pos1]], route2[pos2+1:]])\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n\n    missing_customers = all_customers - served_customers\n    if missing_customers:\n        # Assign missing customers to routes with available capacity\n        for customer in missing_customers:\n            best_route = None\n            best_pos = None\n            best_distance_increase = float('inf')\n\n            for i, route in enumerate(new_solution):\n                current_demand = sum(demand[route[1:-1]])\n                if current_demand + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion position\n                for j in range(len(route)-1):\n                    dist_increase = (distance_matrix[route[j], customer] +\n                                   distance_matrix[customer, route[j+1]] -\n                                   distance_matrix[route[j], route[j+1]])\n\n                    if dist_increase < best_distance_increase:\n                        best_distance_increase = dist_increase\n                        best_route = i\n                        best_pos = j\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos+1, customer)\n                new_solution[best_route] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7113970282910601,
            1.8228459060192108
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0]\n\n    # Create a copy of the selected solution to modify\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Randomly select a route to modify\n    route_idx = np.random.randint(0, len(new_solution))\n    route = new_solution[route_idx]\n\n    # Apply a hybrid local search operator: Route Shuffling with Capacity-Aware Insertion\n    if len(route) > 3:  # Ensure route has at least one customer\n        # Step 1: Shuffle the internal nodes of the route (excluding depots)\n        internal_nodes = route[1:-1]\n        np.random.shuffle(internal_nodes)\n        route[1:-1] = internal_nodes\n\n        # Step 2: Attempt to insert a node from another route if capacity allows\n        if len(new_solution) > 1:\n            other_route_idx = np.random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(other_route) > 3:  # If other route has customers\n                node_to_move = other_route[np.random.randint(1, len(other_route)-1)]\n\n                # Calculate remaining capacity of the current route\n                current_load = sum(demand[node] for node in route[1:-1])\n                if current_load + demand[node_to_move] <= capacity:\n                    # Find the best insertion position in the current route\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(route)):\n                        # Insert node_to_move at position pos\n                        temp_route = np.insert(route, pos, node_to_move)\n                        # Calculate new cost (distance) of the modified route\n                        new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                        if new_cost < best_cost:\n                            best_cost = new_cost\n                            best_pos = pos\n\n                    # Perform the insertion\n                    route = np.insert(route, best_pos, node_to_move)\n                    # Remove the node from the other route\n                    other_route = np.delete(other_route, np.where(other_route == node_to_move)[0][0])\n                    # Update the solution\n                    new_solution[route_idx] = route\n                    new_solution[other_route_idx] = other_route\n\n    return new_solution\n\n",
        "score": [
            -0.49311093101338577,
            0.1904425323009491
        ]
    }
]