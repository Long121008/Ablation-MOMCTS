[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a non-dominated sorting approach, then applies a hybrid local search combining route splitting, customer swapping, and inter-route optimization to generate a neighbor solution while maintaining feasibility and diversity.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    fronts = []\n    dominated_counts = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] <= archive[j][1][1] and\n                    (archive[i][1][0] < archive[j][1][0] or archive[i][1][1] < archive[j][1][1])):\n                    dominating_sets[i].append(j)\n                elif (archive[j][1][0] <= archive[i][1][0] and archive[j][1][1] <= archive[i][1][1] and\n                      (archive[j][1][0] < archive[i][1][0] or archive[j][1][1] < archive[i][1][1])):\n                    dominated_counts[i] += 1\n\n        if dominated_counts[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while fronts[current_front]:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating_sets[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    # Select from the first non-dominated front\n    if fronts[0]:\n        selected_idx = random.choice(fronts[0])\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Route splitting with capacity check\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n        if len(route) > 4:  # Only split long routes\n            split_pos = random.randint(2, len(route)-3)\n            first_part = route[:split_pos+1]\n            second_part = np.array([0] + route[split_pos:-1].tolist() + [0])\n\n            # Check capacity constraints\n            if (sum(demand[first_part[1:-1]]) <= capacity and\n                sum(demand[second_part[1:-1]]) <= capacity):\n                new_solution[route_idx] = first_part\n                new_solution.append(second_part)\n\n    # Customer swapping between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select random customers from each route (excluding depots)\n            cust1_pos = random.randint(1, len(route1)-2)\n            cust2_pos = random.randint(1, len(route2)-2)\n\n            # Check capacity constraints after swap\n            if (sum(demand[route1[1:-1]]) - demand[route1[cust1_pos]] + demand[route2[cust2_pos]] <= capacity and\n                sum(demand[route2[1:-1]]) - demand[route2[cust2_pos]] + demand[route1[cust1_pos]] <= capacity):\n\n                # Perform swap\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[cust1_pos], new_route2[cust2_pos] = new_route2[cust2_pos], new_route1[cust1_pos]\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Inter-route optimization (cross-route 2-opt)\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select two random positions from each route (excluding depots)\n            pos1 = random.randint(1, len(route1)-2)\n            pos2 = random.randint(1, len(route2)-2)\n\n            # Try swapping segments\n            new_route1 = np.concatenate([route1[:pos1], route2[pos2:]])\n            new_route2 = np.concatenate([route2[:pos2], route1[pos1:]])\n\n            # Check capacity constraints\n            if (sum(demand[new_route1[1:-1]]) <= capacity and\n                sum(demand[new_route2[1:-1]]) <= capacity):\n\n                # Calculate distance change\n                old_dist = (distance_matrix[route1[pos1-1], route1[pos1]] +\n                           distance_matrix[route1[-2], route1[-1]] +\n                           distance_matrix[route2[pos2-1], route2[pos2]] +\n                           distance_matrix[route2[-2], route2[-1]])\n\n                new_dist = (distance_matrix[new_route1[pos1-1], new_route1[pos1]] +\n                           distance_matrix[new_route1[-2], new_route1[-1]] +\n                           distance_matrix[new_route2[pos2-1], new_route2[pos2]] +\n                           distance_matrix[new_route2[-2], new_route2[-1]])\n\n                # Accept if distance decreases\n                if new_dist < old_dist:\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the lowest makespan from the archive, then applies a novel \"route contraction-expansion\" operator that temporarily contracts the longest route by merging adjacent customers into supernodes, performs a demand-aware customer redistribution to balance loads, and finally expands the supernodes back into individual customers while optimizing the route structure to improve both total distance and makespan.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 1:\n        return new_solution\n\n    # Find the longest route\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 4:  # Skip if route is too short\n        return new_solution\n\n    # Contract the longest route by merging adjacent customers into supernodes\n    contracted_route = []\n    current_supernode = [longest_route[0]]  # Start with depot\n    current_demand = 0\n\n    for node in longest_route[1:-1]:  # Exclude depots\n        if current_demand + demand[node] <= capacity:\n            current_supernode.append(node)\n            current_demand += demand[node]\n        else:\n            # End current supernode and start a new one\n            contracted_route.append(tuple(current_supernode))\n            current_supernode = [longest_route[0], node]\n            current_demand = demand[node]\n\n    if len(current_supernode) > 1:\n        contracted_route.append(tuple(current_supernode))\n\n    # Add the final depot\n    contracted_route.append((longest_route[-1],))\n\n    # Redistribute customers between the contracted route and a new route\n    new_route = [0]\n    remaining_nodes = []\n\n    for supernode in contracted_route[1:-1]:\n        # Try to move some customers to the new route\n        for node in supernode[1:]:\n            if (sum(demand[new_route[1:]]) + demand[node] <= capacity and\n                len(new_route) + 1 < len(longest_route)):\n\n                new_route.append(node)\n            else:\n                remaining_nodes.append(node)\n\n    if len(new_route) > 1:\n        new_route.append(0)\n        new_solution.append(np.array(new_route))\n\n    # Reconstruct the contracted route with remaining nodes\n    reconstructed_route = [0]\n    for supernode in contracted_route[1:-1]:\n        for node in supernode[1:]:\n            if node not in remaining_nodes:\n                reconstructed_route.append(node)\n            else:\n                # Try to find a better position for the remaining nodes\n                best_pos = len(reconstructed_route)\n                best_cost = float('inf')\n\n                for pos in range(1, len(reconstructed_route)):\n                    temp_route = np.insert(reconstructed_route, pos, node)\n                    new_cost = sum(distance_matrix[temp_route[i-1], temp_route[i]] for i in range(1, len(temp_route)))\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_pos = pos\n\n                reconstructed_route.insert(best_pos, node)\n\n    reconstructed_route.append(0)\n    new_solution[longest_route_idx] = np.array(reconstructed_route)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm selects a solution from the archive using a crowding distance-based approach to prioritize solutions in less crowded regions of the Pareto front, then applies a novel \"route fusion and segmentation\" operator that intelligently merges routes with similar directions and segments them to balance load and reduce makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        return []\n\n    # Calculate crowding distances for solutions in the archive\n    objectives = [obj for (_, obj) in archive]\n    if len(objectives) < 2:\n        selected_idx = 0\n    else:\n        # Normalize objectives\n        min_dist = min(obj[0] for obj in objectives)\n        max_dist = max(obj[0] for obj in objectives)\n        min_make = min(obj[1] for obj in objectives)\n        max_make = max(obj[1] for obj in objectives)\n\n        normalized = []\n        for obj in objectives:\n            norm_dist = (obj[0] - min_dist) / (max_dist - min_dist) if max_dist != min_dist else 0.5\n            norm_make = (obj[1] - min_make) / (max_make - min_make) if max_make != min_make else 0.5\n            normalized.append((norm_dist, norm_make))\n\n        # Sort by distance and makespan\n        sorted_by_dist = sorted(range(len(normalized)), key=lambda i: normalized[i][0])\n        sorted_by_make = sorted(range(len(normalized)), key=lambda i: normalized[i][1])\n\n        # Calculate crowding distances\n        crowding = [0.0] * len(archive)\n        for i in range(len(archive)):\n            if i == 0 or i == len(archive)-1:\n                crowding[i] = float('inf')\n            else:\n                crowding[i] = (normalized[sorted_by_dist[i+1]][0] - normalized[sorted_by_dist[i-1]][0]) + \\\n                              (normalized[sorted_by_make[i+1]][1] - normalized[sorted_by_make[i-1]][1])\n\n        # Select solution with minimum crowding distance\n        selected_idx = min(range(len(crowding)), key=lambda i: crowding[i])\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Route fusion and segmentation operator\n    # Select two routes with similar directions\n    route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Calculate direction vectors\n    def get_direction(route):\n        if len(route) < 3:\n            return (0, 0)\n        start = coords[route[1]]\n        end = coords[route[-2]]\n        return (end[0] - start[0], end[1] - start[1])\n\n    dir1 = get_direction(route1)\n    dir2 = get_direction(route2)\n\n    # Dot product to check similarity\n    dot_product = dir1[0]*dir2[0] + dir1[1]*dir2[1]\n    if dot_product > 0:  # Similar directions\n        # Merge the two routes\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        if sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution.append(merged_route)\n            new_solution.pop(route1_idx)\n            if route2_idx > route1_idx:\n                new_solution.pop(route2_idx-1)\n            else:\n                new_solution.pop(route2_idx)\n\n            # Segment the merged route to balance load\n            current_load = 0\n            last_split = 0\n            segments = []\n\n            for i in range(1, len(merged_route)-1):\n                if current_load + demand[merged_route[i]] > capacity:\n                    segments.append(merged_route[last_split:i])\n                    last_split = i\n                    current_load = demand[merged_route[i]]\n                else:\n                    current_load += demand[merged_route[i]]\n\n            if last_split < len(merged_route)-1:\n                segments.append(merged_route[last_split:])\n\n            # Create new routes from segments\n            new_routes = []\n            for seg in segments:\n                new_route = np.concatenate([[0], seg, [0]])\n                new_routes.append(new_route)\n\n            new_solution.extend(new_routes)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7658134839155558,
            1.2688023149967194
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if not archive:\n        return []\n\n    # Calculate crowding distances for solutions in the archive\n    objectives = [obj for (_, obj) in archive]\n    if len(objectives) < 2:\n        selected_idx = 0\n    else:\n        # Normalize objectives\n        min_dist = min(obj[0] for obj in objectives)\n        max_dist = max(obj[0] for obj in objectives)\n        min_make = min(obj[1] for obj in objectives)\n        max_make = max(obj[1] for obj in objectives)\n\n        normalized = []\n        for obj in objectives:\n            norm_dist = (obj[0] - min_dist) / (max_dist - min_dist) if max_dist != min_dist else 0.5\n            norm_make = (obj[1] - min_make) / (max_make - min_make) if max_make != min_make else 0.5\n            normalized.append((norm_dist, norm_make))\n\n        # Sort by distance and makespan\n        sorted_by_dist = sorted(range(len(normalized)), key=lambda i: normalized[i][0])\n        sorted_by_make = sorted(range(len(normalized)), key=lambda i: normalized[i][1])\n\n        # Calculate crowding distances\n        crowding = [0.0] * len(archive)\n        for i in range(len(archive)):\n            if i == 0 or i == len(archive)-1:\n                crowding[i] = float('inf')\n            else:\n                crowding[i] = (normalized[sorted_by_dist[i+1]][0] - normalized[sorted_by_dist[i-1]][0]) + \\\n                              (normalized[sorted_by_make[i+1]][1] - normalized[sorted_by_make[i-1]][1])\n\n        # Select solution with minimum crowding distance\n        selected_idx = min(range(len(crowding)), key=lambda i: crowding[i])\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Route fusion and segmentation operator\n    # Select two routes with similar directions\n    route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Calculate direction vectors\n    def get_direction(route):\n        if len(route) < 3:\n            return (0, 0)\n        start = coords[route[1]]\n        end = coords[route[-2]]\n        return (end[0] - start[0], end[1] - start[1])\n\n    dir1 = get_direction(route1)\n    dir2 = get_direction(route2)\n\n    # Dot product to check similarity\n    dot_product = dir1[0]*dir2[0] + dir1[1]*dir2[1]\n    if dot_product > 0:  # Similar directions\n        # Merge the two routes\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        if sum(demand[merged_route[1:-1]]) <= capacity:\n            new_solution.append(merged_route)\n            new_solution.pop(route1_idx)\n            if route2_idx > route1_idx:\n                new_solution.pop(route2_idx-1)\n            else:\n                new_solution.pop(route2_idx)\n\n            # Segment the merged route to balance load\n            current_load = 0\n            last_split = 0\n            segments = []\n\n            for i in range(1, len(merged_route)-1):\n                if current_load + demand[merged_route[i]] > capacity:\n                    segments.append(merged_route[last_split:i])\n                    last_split = i\n                    current_load = demand[merged_route[i]]\n                else:\n                    current_load += demand[merged_route[i]]\n\n            if last_split < len(merged_route)-1:\n                segments.append(merged_route[last_split:])\n\n            # Create new routes from segments\n            new_routes = []\n            for seg in segments:\n                new_route = np.concatenate([[0], seg, [0]])\n                new_routes.append(new_route)\n\n            new_solution.extend(new_routes)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest makespan from the archive, then applies a \"route consolidation and relocation\" operator that combines short routes into a single route and strategically relocates customers to balance the load and minimize both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Find the shortest route\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n\n    # Find the longest route\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    # Combine shortest route with longest route\n    combined_route = np.concatenate([longest_route[:-1], shortest_route[1:-1], [0]])\n\n    # Check feasibility\n    if sum(demand[combined_route[1:-1]]) <= capacity:\n        # Replace both routes with the combined route\n        new_solution[longest_route_idx] = combined_route\n        new_solution.pop(shortest_route_idx)\n    else:\n        # If not feasible, try to relocate customers from shortest to longest route\n        remaining_nodes = shortest_route[1:-1].tolist()\n        while remaining_nodes:\n            best_node = None\n            best_improvement = 0\n\n            for node in remaining_nodes:\n                if sum(demand[longest_route[1:-1]]) + demand[node] <= capacity:\n                    # Calculate potential improvement\n                    old_dist = sum(distance_matrix[longest_route[i-1], longest_route[i]] for i in range(1, len(longest_route)))\n                    new_route = np.concatenate([longest_route[:-1], [node], [0]])\n                    new_dist = sum(distance_matrix[new_route[i-1], new_route[i]] for i in range(1, len(new_route)))\n                    improvement = old_dist - new_dist\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n\n            if best_node is not None:\n                longest_route = np.concatenate([longest_route[:-1], [best_node], [0]])\n                remaining_nodes.remove(best_node)\n            else:\n                break\n\n        # Add remaining nodes to a new route if needed\n        if remaining_nodes:\n            new_route = [0] + remaining_nodes + [0]\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution.append(np.array(new_route))\n\n        new_solution[longest_route_idx] = longest_route\n        new_solution.pop(shortest_route_idx)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a crowding-distance-based selection, then applies a hybrid local search combining route merging, customer insertion, and route reversal to generate a neighbor solution while maintaining feasibility and balancing both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        # Calculate crowding distances\n        distances = np.zeros(len(archive))\n        sorted_obj1 = sorted(range(len(archive)), key=lambda x: archive[x][1][0])\n        sorted_obj2 = sorted(range(len(archive)), key=lambda x: archive[x][1][1])\n\n        for i in range(1, len(archive)-1):\n            distances[sorted_obj1[i]] += (archive[sorted_obj1[i+1]][1][0] - archive[sorted_obj1[i-1]][1][0]) / (archive[sorted_obj1[-1]][1][0] - archive[sorted_obj1[0]][1][0])\n            distances[sorted_obj2[i]] += (archive[sorted_obj2[i+1]][1][1] - archive[sorted_obj2[i-1]][1][1]) / (archive[sorted_obj2[-1]][1][1] - archive[sorted_obj2[0]][1][1])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(distances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Route merging with capacity check\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 3 <= 20:  # Limit maximum route length\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            if sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n    # Customer insertion between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select random customer from first route\n            cust_pos = random.randint(1, len(route1)-2)\n            customer = route1[cust_pos]\n\n            # Find best insertion position in second route\n            best_pos = 1\n            best_cost = float('inf')\n\n            for i in range(1, len(route2)-1):\n                cost = (distance_matrix[route2[i-1], customer] +\n                       distance_matrix[customer, route2[i]] -\n                       distance_matrix[route2[i-1], route2[i]])\n\n                if cost < best_cost and sum(demand[route2[1:i]]) + demand[customer] <= capacity:\n                    best_cost = cost\n                    best_pos = i\n\n            if best_cost < float('inf'):\n                new_route1 = np.concatenate([route1[:cust_pos], route1[cust_pos+1:]])\n                new_route2 = np.insert(route2, best_pos, customer)\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Route reversal with distance improvement check\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            # Try reversing a segment\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n\n            reversed_segment = route[start:end][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end:]])\n\n            # Calculate distance change\n            old_dist = (distance_matrix[route[start-1], route[start]] +\n                       distance_matrix[route[end-1], route[end]])\n\n            new_dist = (distance_matrix[new_route[start-1], new_route[start]] +\n                       distance_matrix[new_route[end-1], new_route[end]])\n\n            if new_dist < old_dist:\n                new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This algorithm selects a solution with the highest total distance from the archive, then applies a \"route fragmentation and strategic customer redistribution\" operator that splits long routes into smaller segments and redistributes customers to create more balanced routes while minimizing both objectives and maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Find the longest route\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    # Split the longest route into two segments\n    split_pos = len(longest_route) // 2\n    segment1 = longest_route[:split_pos+1]\n    segment2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n    # Check feasibility of segments\n    if sum(demand[segment1[1:-1]]) <= capacity and sum(demand[segment2[1:-1]]) <= capacity:\n        new_solution[longest_route_idx] = segment1\n        new_solution.append(segment2)\n    else:\n        # If not feasible, try to redistribute customers to existing routes\n        customers = longest_route[1:-1].tolist()\n        while customers:\n            best_route = None\n            best_pos = None\n            best_improvement = 0\n\n            for route_idx in range(len(new_solution)):\n                if route_idx == longest_route_idx:\n                    continue\n                route = new_solution[route_idx]\n\n                for cust in customers:\n                    if sum(demand[route[1:-1]]) + demand[cust] > capacity:\n                        continue\n\n                    # Find best insertion position\n                    best_insert_pos = 1\n                    best_insert_cost = float('inf')\n\n                    for i in range(1, len(route)-1):\n                        cost = (distance_matrix[route[i-1], cust] +\n                              distance_matrix[cust, route[i]] -\n                              distance_matrix[route[i-1], route[i]])\n\n                        if cost < best_insert_cost:\n                            best_insert_cost = cost\n                            best_insert_pos = i\n\n                    if best_insert_cost < best_improvement:\n                        best_improvement = best_insert_cost\n                        best_route = route_idx\n                        best_pos = best_insert_pos\n                        best_cust = cust\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos, best_cust)\n                new_solution[best_route] = new_route\n                customers.remove(best_cust)\n            else:\n                break\n\n        # Add remaining customers to new routes if needed\n        while customers:\n            new_route = [0]\n            current_load = 0\n\n            for cust in customers[:]:\n                if current_load + demand[cust] <= capacity:\n                    new_route.append(cust)\n                    current_load += demand[cust]\n                    customers.remove(cust)\n\n            new_route.append(0)\n            if len(new_route) > 2:\n                new_solution.append(np.array(new_route))\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6958243394647611,
            0.027441442012786865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Find the longest route\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    # Split the longest route into two segments\n    split_pos = len(longest_route) // 2\n    segment1 = longest_route[:split_pos+1]\n    segment2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n    # Check feasibility of segments\n    if sum(demand[segment1[1:-1]]) <= capacity and sum(demand[segment2[1:-1]]) <= capacity:\n        new_solution[longest_route_idx] = segment1\n        new_solution.append(segment2)\n    else:\n        # If not feasible, try to redistribute customers to existing routes\n        customers = longest_route[1:-1].tolist()\n        while customers:\n            best_route = None\n            best_pos = None\n            best_improvement = 0\n\n            for route_idx in range(len(new_solution)):\n                if route_idx == longest_route_idx:\n                    continue\n                route = new_solution[route_idx]\n\n                for cust in customers:\n                    if sum(demand[route[1:-1]]) + demand[cust] > capacity:\n                        continue\n\n                    # Find best insertion position\n                    best_insert_pos = 1\n                    best_insert_cost = float('inf')\n\n                    for i in range(1, len(route)-1):\n                        cost = (distance_matrix[route[i-1], cust] +\n                              distance_matrix[cust, route[i]] -\n                              distance_matrix[route[i-1], route[i]])\n\n                        if cost < best_insert_cost:\n                            best_insert_cost = cost\n                            best_insert_pos = i\n\n                    if best_insert_cost < best_improvement:\n                        best_improvement = best_insert_cost\n                        best_route = route_idx\n                        best_pos = best_insert_pos\n                        best_cust = cust\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos, best_cust)\n                new_solution[best_route] = new_route\n                customers.remove(best_cust)\n            else:\n                break\n\n        # Add remaining customers to new routes if needed\n        while customers:\n            new_route = [0]\n            current_load = 0\n\n            for cust in customers[:]:\n                if current_load + demand[cust] <= capacity:\n                    new_route.append(cust)\n                    current_load += demand[cust]\n                    customers.remove(cust)\n\n            new_route.append(0)\n            if len(new_route) > 2:\n                new_solution.append(np.array(new_route))\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest makespan from the archive, then applies a \"route consolidation and relocation\" operator that combines short routes into a single route and strategically relocates customers to balance the load and minimize both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Find the shortest route\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n\n    # Find the longest route\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    # Combine shortest route with longest route\n    combined_route = np.concatenate([longest_route[:-1], shortest_route[1:-1], [0]])\n\n    # Check feasibility\n    if sum(demand[combined_route[1:-1]]) <= capacity:\n        # Replace both routes with the combined route\n        new_solution[longest_route_idx] = combined_route\n        new_solution.pop(shortest_route_idx)\n    else:\n        # If not feasible, try to relocate customers from shortest to longest route\n        remaining_nodes = shortest_route[1:-1].tolist()\n        while remaining_nodes:\n            best_node = None\n            best_improvement = 0\n\n            for node in remaining_nodes:\n                if sum(demand[longest_route[1:-1]]) + demand[node] <= capacity:\n                    # Calculate potential improvement\n                    old_dist = sum(distance_matrix[longest_route[i-1], longest_route[i]] for i in range(1, len(longest_route)))\n                    new_route = np.concatenate([longest_route[:-1], [node], [0]])\n                    new_dist = sum(distance_matrix[new_route[i-1], new_route[i]] for i in range(1, len(new_route)))\n                    improvement = old_dist - new_dist\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n\n            if best_node is not None:\n                longest_route = np.concatenate([longest_route[:-1], [best_node], [0]])\n                remaining_nodes.remove(best_node)\n            else:\n                break\n\n        # Add remaining nodes to a new route if needed\n        if remaining_nodes:\n            new_route = [0] + remaining_nodes + [0]\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution.append(np.array(new_route))\n\n        new_solution[longest_route_idx] = longest_route\n        new_solution.pop(shortest_route_idx)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a crowding-distance-based selection, then applies a hybrid local search combining route merging, customer insertion, and route reversal to generate a neighbor solution while maintaining feasibility and balancing both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    if len(archive) > 1:\n        # Calculate crowding distances\n        distances = np.zeros(len(archive))\n        sorted_obj1 = sorted(range(len(archive)), key=lambda x: archive[x][1][0])\n        sorted_obj2 = sorted(range(len(archive)), key=lambda x: archive[x][1][1])\n\n        for i in range(1, len(archive)-1):\n            distances[sorted_obj1[i]] += (archive[sorted_obj1[i+1]][1][0] - archive[sorted_obj1[i-1]][1][0]) / (archive[sorted_obj1[-1]][1][0] - archive[sorted_obj1[0]][1][0])\n            distances[sorted_obj2[i]] += (archive[sorted_obj2[i+1]][1][1] - archive[sorted_obj2[i-1]][1][1]) / (archive[sorted_obj2[-1]][1][1] - archive[sorted_obj2[0]][1][1])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(distances)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Route merging with capacity check\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 3 <= 20:  # Limit maximum route length\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            if sum(demand[merged_route[1:-1]]) <= capacity:\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n    # Customer insertion between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3 and len(route2) > 3:\n            # Select random customer from first route\n            cust_pos = random.randint(1, len(route1)-2)\n            customer = route1[cust_pos]\n\n            # Find best insertion position in second route\n            best_pos = 1\n            best_cost = float('inf')\n\n            for i in range(1, len(route2)-1):\n                cost = (distance_matrix[route2[i-1], customer] +\n                       distance_matrix[customer, route2[i]] -\n                       distance_matrix[route2[i-1], route2[i]])\n\n                if cost < best_cost and sum(demand[route2[1:i]]) + demand[customer] <= capacity:\n                    best_cost = cost\n                    best_pos = i\n\n            if best_cost < float('inf'):\n                new_route1 = np.concatenate([route1[:cust_pos], route1[cust_pos+1:]])\n                new_route2 = np.insert(route2, best_pos, customer)\n\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n    # Route reversal with distance improvement check\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            # Try reversing a segment\n            start = random.randint(1, len(route)-3)\n            end = random.randint(start+1, len(route)-2)\n\n            reversed_segment = route[start:end][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end:]])\n\n            # Calculate distance change\n            old_dist = (distance_matrix[route[start-1], route[start]] +\n                       distance_matrix[route[end-1], route[end]])\n\n            new_dist = (distance_matrix[new_route[start-1], new_route[start]] +\n                       distance_matrix[new_route[end-1], new_route[end]])\n\n            if new_dist < old_dist:\n                new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This algorithm selects a solution with the highest total distance from the archive, then applies a \"route fragmentation and strategic customer redistribution\" operator that splits long routes into smaller segments and redistributes customers to create more balanced routes while minimizing both objectives and maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Find the longest route\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    # Split the longest route into two segments\n    split_pos = len(longest_route) // 2\n    segment1 = longest_route[:split_pos+1]\n    segment2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n    # Check feasibility of segments\n    if sum(demand[segment1[1:-1]]) <= capacity and sum(demand[segment2[1:-1]]) <= capacity:\n        new_solution[longest_route_idx] = segment1\n        new_solution.append(segment2)\n    else:\n        # If not feasible, try to redistribute customers to existing routes\n        customers = longest_route[1:-1].tolist()\n        while customers:\n            best_route = None\n            best_pos = None\n            best_improvement = 0\n\n            for route_idx in range(len(new_solution)):\n                if route_idx == longest_route_idx:\n                    continue\n                route = new_solution[route_idx]\n\n                for cust in customers:\n                    if sum(demand[route[1:-1]]) + demand[cust] > capacity:\n                        continue\n\n                    # Find best insertion position\n                    best_insert_pos = 1\n                    best_insert_cost = float('inf')\n\n                    for i in range(1, len(route)-1):\n                        cost = (distance_matrix[route[i-1], cust] +\n                              distance_matrix[cust, route[i]] -\n                              distance_matrix[route[i-1], route[i]])\n\n                        if cost < best_insert_cost:\n                            best_insert_cost = cost\n                            best_insert_pos = i\n\n                    if best_insert_cost < best_improvement:\n                        best_improvement = best_insert_cost\n                        best_route = route_idx\n                        best_pos = best_insert_pos\n                        best_cust = cust\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos, best_cust)\n                new_solution[best_route] = new_route\n                customers.remove(best_cust)\n            else:\n                break\n\n        # Add remaining customers to new routes if needed\n        while customers:\n            new_route = [0]\n            current_load = 0\n\n            for cust in customers[:]:\n                if current_load + demand[cust] <= capacity:\n                    new_route.append(cust)\n                    current_load += demand[cust]\n                    customers.remove(cust)\n\n            new_route.append(0)\n            if len(new_route) > 2:\n                new_solution.append(np.array(new_route))\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.6958243394647611,
            0.027441442012786865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Find the longest route\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    # Split the longest route into two segments\n    split_pos = len(longest_route) // 2\n    segment1 = longest_route[:split_pos+1]\n    segment2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n    # Check feasibility of segments\n    if sum(demand[segment1[1:-1]]) <= capacity and sum(demand[segment2[1:-1]]) <= capacity:\n        new_solution[longest_route_idx] = segment1\n        new_solution.append(segment2)\n    else:\n        # If not feasible, try to redistribute customers to existing routes\n        customers = longest_route[1:-1].tolist()\n        while customers:\n            best_route = None\n            best_pos = None\n            best_improvement = 0\n\n            for route_idx in range(len(new_solution)):\n                if route_idx == longest_route_idx:\n                    continue\n                route = new_solution[route_idx]\n\n                for cust in customers:\n                    if sum(demand[route[1:-1]]) + demand[cust] > capacity:\n                        continue\n\n                    # Find best insertion position\n                    best_insert_pos = 1\n                    best_insert_cost = float('inf')\n\n                    for i in range(1, len(route)-1):\n                        cost = (distance_matrix[route[i-1], cust] +\n                              distance_matrix[cust, route[i]] -\n                              distance_matrix[route[i-1], route[i]])\n\n                        if cost < best_insert_cost:\n                            best_insert_cost = cost\n                            best_insert_pos = i\n\n                    if best_insert_cost < best_improvement:\n                        best_improvement = best_insert_cost\n                        best_route = route_idx\n                        best_pos = best_insert_pos\n                        best_cust = cust\n\n            if best_route is not None:\n                new_route = np.insert(new_solution[best_route], best_pos, best_cust)\n                new_solution[best_route] = new_route\n                customers.remove(best_cust)\n            else:\n                break\n\n        # Add remaining customers to new routes if needed\n        while customers:\n            new_route = [0]\n            current_load = 0\n\n            for cust in customers[:]:\n                if current_load + demand[cust] <= capacity:\n                    new_route.append(cust)\n                    current_load += demand[cust]\n                    customers.remove(cust)\n\n            new_route.append(0)\n            if len(new_route) > 2:\n                new_solution.append(np.array(new_route))\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution with a better balance between total distance and makespan using a different weighted sum (0.3 for distance and 0.7 for makespan) before applying a novel \"route merging-splitting\" operator that merges short routes and splits long routes to better balance the load and improve both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Find the shortest and longest routes\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n    longest_route = new_solution[longest_route_idx]\n\n    if len(shortest_route) <= 3 or len(longest_route) <= 3:\n        return new_solution\n\n    # Try to merge the shortest route into another route\n    merged = False\n    for route in new_solution:\n        if route is not shortest_route and route is not longest_route:\n            combined_route = np.concatenate([route[:-1], shortest_route[1:]])\n            if sum(demand[combined_route[1:-1]]) <= capacity:\n                route = combined_route\n                new_solution.remove(shortest_route)\n                merged = True\n                break\n\n    if not merged:\n        # If merging fails, split the longest route\n        split_pos = len(longest_route) // 2\n        first_part = longest_route[:split_pos + 1]\n        second_part = [0] + longest_route[split_pos:-1].tolist() + [0]\n\n        first_load = sum(demand[first_part[1:-1]])\n        second_load = sum(demand[second_part[1:-1]])\n\n        if first_load <= capacity and second_load <= capacity:\n            new_solution[longest_route_idx] = np.array(first_part)\n            new_solution.insert(longest_route_idx + 1, np.array(second_part))\n        else:\n            # If splitting is not feasible, try to migrate customers to other routes\n            remaining_nodes = longest_route[1:-1].tolist()\n            new_routes = [route.copy() for route in new_solution if route is not longest_route]\n\n            while remaining_nodes:\n                best_route = None\n                best_improvement = 0\n                best_node = None\n\n                for route in new_routes:\n                    for node in remaining_nodes:\n                        if sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                            old_dist = sum(distance_matrix[route[i-1], route[i]] for i in range(1, len(route)))\n                            new_route = np.concatenate([route[:-1], [node], [0]])\n                            new_dist = sum(distance_matrix[new_route[i-1], new_route[i]] for i in range(1, len(new_route)))\n                            improvement = old_dist - new_dist\n\n                            if improvement > best_improvement:\n                                best_improvement = improvement\n                                best_route = route\n                                best_node = node\n\n                if best_node is not None:\n                    best_route = np.concatenate([best_route[:-1], [best_node], [0]])\n                    remaining_nodes.remove(best_node)\n                else:\n                    break\n\n            if remaining_nodes:\n                new_route = [0] + remaining_nodes + [0]\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_routes.append(np.array(new_route))\n\n            new_solution = new_routes\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with the highest makespan from the archive, then applies a \"route consolidation and relocation\" operator that combines short routes into a single route and strategically relocates customers to balance the load and minimize both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Find the shortest route\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n\n    # Find the longest route\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    # Combine shortest route with longest route\n    combined_route = np.concatenate([longest_route[:-1], shortest_route[1:-1], [0]])\n\n    # Check feasibility\n    if sum(demand[combined_route[1:-1]]) <= capacity:\n        # Replace both routes with the combined route\n        new_solution[longest_route_idx] = combined_route\n        new_solution.pop(shortest_route_idx)\n    else:\n        # If not feasible, try to relocate customers from shortest to longest route\n        remaining_nodes = shortest_route[1:-1].tolist()\n        while remaining_nodes:\n            best_node = None\n            best_improvement = 0\n\n            for node in remaining_nodes:\n                if sum(demand[longest_route[1:-1]]) + demand[node] <= capacity:\n                    # Calculate potential improvement\n                    old_dist = sum(distance_matrix[longest_route[i-1], longest_route[i]] for i in range(1, len(longest_route)))\n                    new_route = np.concatenate([longest_route[:-1], [node], [0]])\n                    new_dist = sum(distance_matrix[new_route[i-1], new_route[i]] for i in range(1, len(new_route)))\n                    improvement = old_dist - new_dist\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = node\n\n            if best_node is not None:\n                longest_route = np.concatenate([longest_route[:-1], [best_node], [0]])\n                remaining_nodes.remove(best_node)\n            else:\n                break\n\n        # Add remaining nodes to a new route if needed\n        if remaining_nodes:\n            new_route = [0] + remaining_nodes + [0]\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                new_solution.append(np.array(new_route))\n\n        new_solution[longest_route_idx] = longest_route\n        new_solution.pop(shortest_route_idx)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This algorithm selects a solution with the best trade-off between total distance and makespan using a novel \"route inversion and customer transfer\" operator that inverts the order of customers in the longest route and strategically transfers customers to other routes to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] * x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 1:\n        return new_solution\n\n    # Find the longest route\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    # Invert the order of customers in the longest route\n    inverted_route = np.concatenate([[0], longest_route[-2:0:-1], [0]])\n\n    # Check if the inverted route is feasible\n    if sum(demand[inverted_route[1:-1]]) <= capacity:\n        new_solution[longest_route_idx] = inverted_route\n\n        # Try to transfer customers from the inverted route to other routes\n        remaining_nodes = []\n        for i in range(1, len(inverted_route) - 1):\n            node = inverted_route[i]\n            for route in new_solution:\n                if route is not inverted_route and sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                    # Calculate potential improvement\n                    old_dist = sum(distance_matrix[route[j-1], route[j]] for j in range(1, len(route)))\n                    new_route = np.concatenate([route[:-1], [node], [0]])\n                    new_dist = sum(distance_matrix[new_route[j-1], new_route[j]] for j in range(1, len(new_route)))\n                    improvement = old_dist - new_dist\n\n                    if improvement > 0:\n                        # Transfer the node\n                        route[:] = new_route\n                        inverted_route = np.delete(inverted_route, i)\n                        break\n            else:\n                remaining_nodes.append(node)\n\n        # Update the inverted route with remaining nodes\n        if len(remaining_nodes) > 0:\n            new_solution[longest_route_idx] = np.concatenate([[0], remaining_nodes, [0]])\n        else:\n            new_solution.pop(longest_route_idx)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7306957691342089,
            3.3694176375865936
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] * x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 1:\n        return new_solution\n\n    # Find the longest route\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    # Invert the order of customers in the longest route\n    inverted_route = np.concatenate([[0], longest_route[-2:0:-1], [0]])\n\n    # Check if the inverted route is feasible\n    if sum(demand[inverted_route[1:-1]]) <= capacity:\n        new_solution[longest_route_idx] = inverted_route\n\n        # Try to transfer customers from the inverted route to other routes\n        remaining_nodes = []\n        for i in range(1, len(inverted_route) - 1):\n            node = inverted_route[i]\n            for route in new_solution:\n                if route is not inverted_route and sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                    # Calculate potential improvement\n                    old_dist = sum(distance_matrix[route[j-1], route[j]] for j in range(1, len(route)))\n                    new_route = np.concatenate([route[:-1], [node], [0]])\n                    new_dist = sum(distance_matrix[new_route[j-1], new_route[j]] for j in range(1, len(new_route)))\n                    improvement = old_dist - new_dist\n\n                    if improvement > 0:\n                        # Transfer the node\n                        route[:] = new_route\n                        inverted_route = np.delete(inverted_route, i)\n                        break\n            else:\n                remaining_nodes.append(node)\n\n        # Update the inverted route with remaining nodes\n        if len(remaining_nodes) > 0:\n            new_solution[longest_route_idx] = np.concatenate([[0], remaining_nodes, [0]])\n        else:\n            new_solution.pop(longest_route_idx)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with a better balance between total distance and makespan using a different weighted sum (0.3 for distance and 0.7 for makespan) before applying a novel \"route merging-splitting\" operator that merges short routes and splits long routes to better balance the load and improve both objectives while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Find the shortest and longest routes\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n    longest_route = new_solution[longest_route_idx]\n\n    if len(shortest_route) <= 3 or len(longest_route) <= 3:\n        return new_solution\n\n    # Try to merge the shortest route into another route\n    merged = False\n    for route in new_solution:\n        if route is not shortest_route and route is not longest_route:\n            combined_route = np.concatenate([route[:-1], shortest_route[1:]])\n            if sum(demand[combined_route[1:-1]]) <= capacity:\n                route = combined_route\n                new_solution.remove(shortest_route)\n                merged = True\n                break\n\n    if not merged:\n        # If merging fails, split the longest route\n        split_pos = len(longest_route) // 2\n        first_part = longest_route[:split_pos + 1]\n        second_part = [0] + longest_route[split_pos:-1].tolist() + [0]\n\n        first_load = sum(demand[first_part[1:-1]])\n        second_load = sum(demand[second_part[1:-1]])\n\n        if first_load <= capacity and second_load <= capacity:\n            new_solution[longest_route_idx] = np.array(first_part)\n            new_solution.insert(longest_route_idx + 1, np.array(second_part))\n        else:\n            # If splitting is not feasible, try to migrate customers to other routes\n            remaining_nodes = longest_route[1:-1].tolist()\n            new_routes = [route.copy() for route in new_solution if route is not longest_route]\n\n            while remaining_nodes:\n                best_route = None\n                best_improvement = 0\n                best_node = None\n\n                for route in new_routes:\n                    for node in remaining_nodes:\n                        if sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                            old_dist = sum(distance_matrix[route[i-1], route[i]] for i in range(1, len(route)))\n                            new_route = np.concatenate([route[:-1], [node], [0]])\n                            new_dist = sum(distance_matrix[new_route[i-1], new_route[i]] for i in range(1, len(new_route)))\n                            improvement = old_dist - new_dist\n\n                            if improvement > best_improvement:\n                                best_improvement = improvement\n                                best_route = route\n                                best_node = node\n\n                if best_node is not None:\n                    best_route = np.concatenate([best_route[:-1], [best_node], [0]])\n                    remaining_nodes.remove(best_node)\n                else:\n                    break\n\n            if remaining_nodes:\n                new_route = [0] + remaining_nodes + [0]\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_routes.append(np.array(new_route))\n\n            new_solution = new_routes\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This algorithm selects a solution with a better balance between total distance and makespan using a different weighted sum (0.5 for distance and 0.5 for makespan) before applying a hybrid \"route swapping and insertion\" operator that swaps customers between routes and inserts them into other routes to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Find the two routes with the largest difference in makespan\n    routes_with_lengths = [(i, len(route)) for i, route in enumerate(new_solution)]\n    routes_with_lengths.sort(key=lambda x: x[1])\n    shortest_route_idx = routes_with_lengths[0][0]\n    longest_route_idx = routes_with_lengths[-1][0]\n    shortest_route = new_solution[shortest_route_idx]\n    longest_route = new_solution[longest_route_idx]\n\n    if len(shortest_route) <= 3 or len(longest_route) <= 3:\n        return new_solution\n\n    # Try to swap customers between the shortest and longest routes\n    swapped = False\n    for i in range(1, len(shortest_route) - 1):\n        for j in range(1, len(longest_route) - 1):\n            # Calculate the difference in total distance if we swap customers\n            old_dist = (distance_matrix[shortest_route[i-1], shortest_route[i]] +\n                        distance_matrix[shortest_route[i], shortest_route[i+1]] +\n                        distance_matrix[longest_route[j-1], longest_route[j]] +\n                        distance_matrix[longest_route[j], longest_route[j+1]])\n\n            new_dist = (distance_matrix[shortest_route[i-1], longest_route[j]] +\n                        distance_matrix[longest_route[j], shortest_route[i+1]] +\n                        distance_matrix[longest_route[j-1], shortest_route[i]] +\n                        distance_matrix[shortest_route[i], longest_route[j+1]])\n\n            if new_dist < old_dist:\n                # Check capacity constraints\n                shortest_load = sum(demand[shortest_route[1:-1]] - demand[shortest_route[i]] + demand[longest_route[j]])\n                longest_load = sum(demand[longest_route[1:-1]] - demand[longest_route[j]] + demand[shortest_route[i]])\n\n                if shortest_load <= capacity and longest_load <= capacity:\n                    # Perform the swap\n                    shortest_route[i], longest_route[j] = longest_route[j], shortest_route[i]\n                    swapped = True\n                    break\n        if swapped:\n            break\n\n    if not swapped:\n        # If swapping fails, try to insert a customer from the longest route into another route\n        for route in new_solution:\n            if route is not longest_route:\n                for node in longest_route[1:-1]:\n                    if sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                        # Find the best insertion position\n                        best_pos = 1\n                        best_dist = float('inf')\n\n                        for pos in range(1, len(route)):\n                            insert_dist = (distance_matrix[route[pos-1], node] +\n                                          distance_matrix[node, route[pos]] -\n                                          distance_matrix[route[pos-1], route[pos]])\n\n                            if insert_dist < best_dist:\n                                best_dist = insert_dist\n                                best_pos = pos\n\n                        if best_dist < 0:  # Only insert if it improves the distance\n                            route = np.insert(route, best_pos, node)\n                            longest_route = np.delete(longest_route, np.where(longest_route == node)[0][0])\n                            break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.4740558333506076,
            4.464974761009216
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Find the two routes with the largest difference in makespan\n    routes_with_lengths = [(i, len(route)) for i, route in enumerate(new_solution)]\n    routes_with_lengths.sort(key=lambda x: x[1])\n    shortest_route_idx = routes_with_lengths[0][0]\n    longest_route_idx = routes_with_lengths[-1][0]\n    shortest_route = new_solution[shortest_route_idx]\n    longest_route = new_solution[longest_route_idx]\n\n    if len(shortest_route) <= 3 or len(longest_route) <= 3:\n        return new_solution\n\n    # Try to swap customers between the shortest and longest routes\n    swapped = False\n    for i in range(1, len(shortest_route) - 1):\n        for j in range(1, len(longest_route) - 1):\n            # Calculate the difference in total distance if we swap customers\n            old_dist = (distance_matrix[shortest_route[i-1], shortest_route[i]] +\n                        distance_matrix[shortest_route[i], shortest_route[i+1]] +\n                        distance_matrix[longest_route[j-1], longest_route[j]] +\n                        distance_matrix[longest_route[j], longest_route[j+1]])\n\n            new_dist = (distance_matrix[shortest_route[i-1], longest_route[j]] +\n                        distance_matrix[longest_route[j], shortest_route[i+1]] +\n                        distance_matrix[longest_route[j-1], shortest_route[i]] +\n                        distance_matrix[shortest_route[i], longest_route[j+1]])\n\n            if new_dist < old_dist:\n                # Check capacity constraints\n                shortest_load = sum(demand[shortest_route[1:-1]] - demand[shortest_route[i]] + demand[longest_route[j]])\n                longest_load = sum(demand[longest_route[1:-1]] - demand[longest_route[j]] + demand[shortest_route[i]])\n\n                if shortest_load <= capacity and longest_load <= capacity:\n                    # Perform the swap\n                    shortest_route[i], longest_route[j] = longest_route[j], shortest_route[i]\n                    swapped = True\n                    break\n        if swapped:\n            break\n\n    if not swapped:\n        # If swapping fails, try to insert a customer from the longest route into another route\n        for route in new_solution:\n            if route is not longest_route:\n                for node in longest_route[1:-1]:\n                    if sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                        # Find the best insertion position\n                        best_pos = 1\n                        best_dist = float('inf')\n\n                        for pos in range(1, len(route)):\n                            insert_dist = (distance_matrix[route[pos-1], node] +\n                                          distance_matrix[node, route[pos]] -\n                                          distance_matrix[route[pos-1], route[pos]])\n\n                            if insert_dist < best_dist:\n                                best_dist = insert_dist\n                                best_pos = pos\n\n                        if best_dist < 0:  # Only insert if it improves the distance\n                            route = np.insert(route, best_pos, node)\n                            longest_route = np.delete(longest_route, np.where(longest_route == node)[0][0])\n                            break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a crowding-distance-based selection to prioritize solutions with better diversity and then applies a hybrid local search combining route merging, customer relocation, and route-based 2-opt to generate a neighbor solution while maintaining feasibility and improving both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    crowding_distances = np.zeros(len(archive))\n    objectives = np.array([obj for _, obj in archive])\n\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], m] == objectives[sorted_indices[0], m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (\n                objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]\n            ) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search operator\n    # Route merging with capacity check\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if (sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity and\n            len(route1) + len(route2) - 2 < 2 * len(coords)):  # Prevent excessively long routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n\n    # Customer relocation between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 3:\n            cust_pos = random.randint(1, len(route1)-2)\n            customer = route1[cust_pos]\n\n            if (sum(demand[route2[1:-1]]) + demand[customer] <= capacity and\n                len(route2) + 1 < 2 * len(coords)):\n\n                # Try inserting customer into route2\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(route2)):\n                    new_route = np.concatenate([route2[:pos], [customer], route2[pos:]])\n                    cost = (distance_matrix[new_route[pos-1], customer] +\n                           distance_matrix[customer, new_route[pos+1]] -\n                           distance_matrix[new_route[pos-1], new_route[pos+1]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                if best_cost < 0:  # Only accept if it improves the solution\n                    new_route2 = np.concatenate([route2[:best_pos], [customer], route2[best_pos:]])\n                    new_solution[route2_idx] = new_route2\n\n                    # Remove customer from original route\n                    new_route1 = np.concatenate([route1[:cust_pos], route1[cust_pos+1:]])\n                    new_solution[route1_idx] = new_route1\n\n    # Route-based 2-opt\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) > 4:\n            i, j = random.sample(range(1, len(route)-1), 2)\n            if i > j:\n                i, j = j, i\n\n            # Try reversing segment between i and j\n            new_route = np.concatenate([route[:i], route[i:j+1][::-1], route[j+1:]])\n\n            # Check capacity constraint\n            if sum(demand[new_route[1:-1]]) <= capacity:\n                # Calculate distance change\n                old_dist = (distance_matrix[route[i-1], route[i]] +\n                           distance_matrix[route[j], route[j+1]])\n\n                new_dist = (distance_matrix[new_route[i-1], new_route[i]] +\n                           distance_matrix[new_route[j], new_route[j+1]])\n\n                if new_dist < old_dist:\n                    new_solution[route_idx] = new_route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution with a better balance between total distance and makespan using a different weighted sum (0.3 for distance and 0.7 for makespan) before applying a novel \"route merging-splitting\" operator that merges short routes and splits long routes to better balance the load and improve both objectives while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: 0.3 * x[1][0] + 0.7 * x[1][1])[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    if len(new_solution) < 2:\n        return new_solution\n\n    # Find the shortest and longest routes\n    shortest_route_idx = min(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n    shortest_route = new_solution[shortest_route_idx]\n    longest_route = new_solution[longest_route_idx]\n\n    if len(shortest_route) <= 3 or len(longest_route) <= 3:\n        return new_solution\n\n    # Try to merge the shortest route into another route\n    merged = False\n    for route in new_solution:\n        if route is not shortest_route and route is not longest_route:\n            combined_route = np.concatenate([route[:-1], shortest_route[1:]])\n            if sum(demand[combined_route[1:-1]]) <= capacity:\n                route = combined_route\n                new_solution.remove(shortest_route)\n                merged = True\n                break\n\n    if not merged:\n        # If merging fails, split the longest route\n        split_pos = len(longest_route) // 2\n        first_part = longest_route[:split_pos + 1]\n        second_part = [0] + longest_route[split_pos:-1].tolist() + [0]\n\n        first_load = sum(demand[first_part[1:-1]])\n        second_load = sum(demand[second_part[1:-1]])\n\n        if first_load <= capacity and second_load <= capacity:\n            new_solution[longest_route_idx] = np.array(first_part)\n            new_solution.insert(longest_route_idx + 1, np.array(second_part))\n        else:\n            # If splitting is not feasible, try to migrate customers to other routes\n            remaining_nodes = longest_route[1:-1].tolist()\n            new_routes = [route.copy() for route in new_solution if route is not longest_route]\n\n            while remaining_nodes:\n                best_route = None\n                best_improvement = 0\n                best_node = None\n\n                for route in new_routes:\n                    for node in remaining_nodes:\n                        if sum(demand[route[1:-1]]) + demand[node] <= capacity:\n                            old_dist = sum(distance_matrix[route[i-1], route[i]] for i in range(1, len(route)))\n                            new_route = np.concatenate([route[:-1], [node], [0]])\n                            new_dist = sum(distance_matrix[new_route[i-1], new_route[i]] for i in range(1, len(new_route)))\n                            improvement = old_dist - new_dist\n\n                            if improvement > best_improvement:\n                                best_improvement = improvement\n                                best_route = route\n                                best_node = node\n\n                if best_node is not None:\n                    best_route = np.concatenate([best_route[:-1], [best_node], [0]])\n                    remaining_nodes.remove(best_node)\n                else:\n                    break\n\n            if remaining_nodes:\n                new_route = [0] + remaining_nodes + [0]\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_routes.append(np.array(new_route))\n\n            new_solution = new_routes\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{This algorithm selects a solution with high potential for improvement by prioritizing those with high crowding distance and long routes, then applies a novel \"route balancing and customer redistribution\" operator that redistributes customers between routes to create balanced loads and reduce makespan while maintaining feasibility and improving total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    crowding_distances = np.zeros(len(archive))\n    objectives = np.array([obj for _, obj in archive])\n\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], m] == objectives[sorted_indices[0], m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (\n                objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]\n            ) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route balancing and customer redistribution operator\n    if len(new_solution) > 1:\n        # Find the most loaded route\n        route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n        most_loaded_idx = np.argmax(route_loads)\n        most_loaded_route = new_solution[most_loaded_idx]\n\n        # Find the least loaded route\n        least_loaded_idx = np.argmin(route_loads)\n        least_loaded_route = new_solution[least_loaded_idx]\n\n        # Try to redistribute customers from most loaded to least loaded\n        for cust_pos in range(1, len(most_loaded_route)-1):\n            customer = most_loaded_route[cust_pos]\n            if (sum(demand[least_loaded_route[1:-1]]) + demand[customer] <= capacity and\n                len(least_loaded_route) + 1 < 2 * len(coords)):\n\n                # Find best insertion position in least loaded route\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(least_loaded_route)):\n                    new_route = np.concatenate([least_loaded_route[:pos], [customer], least_loaded_route[pos:]])\n                    cost = (distance_matrix[new_route[pos-1], customer] +\n                           distance_matrix[customer, new_route[pos+1]] -\n                           distance_matrix[new_route[pos-1], new_route[pos+1]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                if best_cost < 0:\n                    # Perform the redistribution\n                    new_least_loaded = np.concatenate([least_loaded_route[:best_pos], [customer], least_loaded_route[best_pos:]])\n                    new_most_loaded = np.concatenate([most_loaded_route[:cust_pos], most_loaded_route[cust_pos+1:]])\n\n                    new_solution[least_loaded_idx] = new_least_loaded\n                    new_solution[most_loaded_idx] = new_most_loaded\n\n                    # Update loads and check for further improvements\n                    route_loads[least_loaded_idx] += demand[customer]\n                    route_loads[most_loaded_idx] -= demand[customer]\n\n                    # Break after first successful redistribution to maintain balance\n                    break\n\n    # Additional improvement: try to merge small routes\n    if len(new_solution) > 2:\n        small_routes = [i for i, route in enumerate(new_solution) if len(route) <= 4]\n        if small_routes:\n            target_route_idx = random.choice(small_routes)\n            target_route = new_solution[target_route_idx]\n\n            # Try to merge with another route\n            for other_idx in range(len(new_solution)):\n                if other_idx != target_route_idx:\n                    other_route = new_solution[other_idx]\n                    if sum(demand[target_route[1:-1]]) + sum(demand[other_route[1:-1]]) <= capacity:\n                        merged_route = np.concatenate([other_route[:-1], target_route[1:]])\n                        new_solution[other_idx] = merged_route\n                        del new_solution[target_route_idx]\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7087557479386896,
            3.2206348180770874
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    crowding_distances = np.zeros(len(archive))\n    objectives = np.array([obj for _, obj in archive])\n\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], m] == objectives[sorted_indices[0], m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (\n                objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]\n            ) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route balancing and customer redistribution operator\n    if len(new_solution) > 1:\n        # Find the most loaded route\n        route_loads = [sum(demand[route[1:-1]]) for route in new_solution]\n        most_loaded_idx = np.argmax(route_loads)\n        most_loaded_route = new_solution[most_loaded_idx]\n\n        # Find the least loaded route\n        least_loaded_idx = np.argmin(route_loads)\n        least_loaded_route = new_solution[least_loaded_idx]\n\n        # Try to redistribute customers from most loaded to least loaded\n        for cust_pos in range(1, len(most_loaded_route)-1):\n            customer = most_loaded_route[cust_pos]\n            if (sum(demand[least_loaded_route[1:-1]]) + demand[customer] <= capacity and\n                len(least_loaded_route) + 1 < 2 * len(coords)):\n\n                # Find best insertion position in least loaded route\n                best_pos = 1\n                best_cost = float('inf')\n\n                for pos in range(1, len(least_loaded_route)):\n                    new_route = np.concatenate([least_loaded_route[:pos], [customer], least_loaded_route[pos:]])\n                    cost = (distance_matrix[new_route[pos-1], customer] +\n                           distance_matrix[customer, new_route[pos+1]] -\n                           distance_matrix[new_route[pos-1], new_route[pos+1]])\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n                if best_cost < 0:\n                    # Perform the redistribution\n                    new_least_loaded = np.concatenate([least_loaded_route[:best_pos], [customer], least_loaded_route[best_pos:]])\n                    new_most_loaded = np.concatenate([most_loaded_route[:cust_pos], most_loaded_route[cust_pos+1:]])\n\n                    new_solution[least_loaded_idx] = new_least_loaded\n                    new_solution[most_loaded_idx] = new_most_loaded\n\n                    # Update loads and check for further improvements\n                    route_loads[least_loaded_idx] += demand[customer]\n                    route_loads[most_loaded_idx] -= demand[customer]\n\n                    # Break after first successful redistribution to maintain balance\n                    break\n\n    # Additional improvement: try to merge small routes\n    if len(new_solution) > 2:\n        small_routes = [i for i, route in enumerate(new_solution) if len(route) <= 4]\n        if small_routes:\n            target_route_idx = random.choice(small_routes)\n            target_route = new_solution[target_route_idx]\n\n            # Try to merge with another route\n            for other_idx in range(len(new_solution)):\n                if other_idx != target_route_idx:\n                    other_route = new_solution[other_idx]\n                    if sum(demand[target_route[1:-1]]) + sum(demand[other_route[1:-1]]) <= capacity:\n                        merged_route = np.concatenate([other_route[:-1], target_route[1:]])\n                        new_solution[other_idx] = merged_route\n                        del new_solution[target_route_idx]\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    }
]