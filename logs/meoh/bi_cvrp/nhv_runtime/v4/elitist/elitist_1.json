[
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines adaptive route splitting and demand-aware node relocation to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])  # Sort by makespan\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a deep copy of the solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search: adaptive route splitting and demand-aware relocation\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Adaptive route splitting: split if route is too long or imbalanced\n        if distance_matrix[route[0], route[-2]] > 1.5 * np.mean([distance_matrix[r[0], r[-2]] for r in new_solution]):\n            # Find split point with minimal additional distance\n            min_split_cost = float('inf')\n            best_split = None\n            for j in range(1, len(route)-2):\n                cost = distance_matrix[route[0], route[j]] + distance_matrix[route[j], route[-1]]\n                if cost < min_split_cost:\n                    min_split_cost = cost\n                    best_split = j\n\n            if best_split is not None:\n                new_route1 = np.concatenate([np.array([0]), route[1:best_split+1], np.array([0])])\n                new_route2 = np.concatenate([np.array([0]), route[best_split+1:-1], np.array([0])])\n\n                # Check feasibility\n                if np.sum(demand[new_route1[1:-1]]) <= capacity and np.sum(demand[new_route2[1:-1]]) <= capacity:\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n        # Demand-aware node relocation: move nodes between routes if beneficial\n        for j in range(len(new_solution)):\n            if i == j:\n                continue\n            other_route = new_solution[j]\n\n            # Find best node to move from current route to other route\n            best_node = None\n            best_gain = 0\n            for node in route[1:-1]:\n                # Calculate potential gain in distance\n                original_dist = distance_matrix[route[np.where(route == node)[0][0]-1], node] + \\\n                              distance_matrix[node, route[np.where(route == node)[0][0]+1]]\n\n                # Find best insertion point in other route\n                min_insert_cost = float('inf')\n                best_insert_pos = None\n                for k in range(1, len(other_route)):\n                    insert_cost = distance_matrix[other_route[k-1], node] + \\\n                                 distance_matrix[node, other_route[k]] - \\\n                                 distance_matrix[other_route[k-1], other_route[k]]\n                    if insert_cost < min_insert_cost:\n                        min_insert_cost = insert_cost\n                        best_insert_pos = k\n\n                if best_insert_pos is not None:\n                    total_gain = original_dist - min_insert_cost\n                    if total_gain > best_gain:\n                        # Check capacity constraint\n                        if np.sum(demand[other_route[1:-1]]) + demand[node] <= capacity:\n                            best_gain = total_gain\n                            best_node = (node, best_insert_pos)\n\n            if best_node is not None:\n                node, pos = best_node\n                # Remove node from current route\n                node_pos = np.where(route == node)[0][0]\n                new_route = np.concatenate([route[:node_pos], route[node_pos+1:]])\n\n                # Insert node in other route\n                new_other_route = np.concatenate([other_route[:pos], np.array([node]), other_route[pos:]])\n\n                # Update routes\n                new_solution[i] = new_route\n                new_solution[j] = new_other_route\n                break\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.3347506888498487,
            5.518440991640091
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    }
]