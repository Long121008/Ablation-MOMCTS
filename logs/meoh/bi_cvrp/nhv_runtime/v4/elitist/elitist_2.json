[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objectives and applies a hybrid local search combining route merging, demand-balanced customer reallocation, and adaptive 3-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([(obj[0] * 0.6 + obj[1] * 0.4) for _, obj in archive])\n    weights = np.exp(-objectives / np.max(objectives))  # Prefer better solutions\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, demand-balanced reallocation, and adaptive 3-opt\n    for _ in range(3):  # Number of iterations\n        if len(new_solution) < 2:\n            break\n\n        # Route merging: combine two short routes if capacity allows\n        route1_idx, route2_idx = sorted(random.sample(range(len(new_solution)), 2))\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 <= 15 and sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n            continue\n\n        # Demand-balanced customer reallocation: move customers between routes to balance demands\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 3:\n                continue\n\n            current_demand = sum(demand[route[1:-1]])\n            for other_idx in range(len(new_solution)):\n                if route_idx == other_idx:\n                    continue\n                other_route = new_solution[other_idx]\n                other_demand = sum(demand[other_route[1:-1]])\n\n                if abs(current_demand - capacity/2) > abs(other_demand - capacity/2):\n                    # Try to move a customer to balance demands\n                    for customer_pos in range(1, len(route)-1):\n                        customer = route[customer_pos]\n                        if other_demand + demand[customer] <= capacity:\n                            # Find best insertion point in other route\n                            min_insert_cost = float('inf')\n                            best_pos = None\n                            for pos in range(1, len(other_route)):\n                                insert_cost = distance_matrix[other_route[pos-1], customer] + \\\n                                             distance_matrix[customer, other_route[pos]] - \\\n                                             distance_matrix[other_route[pos-1], other_route[pos]]\n                                if insert_cost < min_insert_cost:\n                                    min_insert_cost = insert_cost\n                                    best_pos = pos\n\n                            if best_pos is not None:\n                                # Perform the move\n                                new_route = np.delete(route, customer_pos)\n                                new_other_route = np.insert(other_route, best_pos, customer)\n\n                                # Update routes\n                                if len(new_route) >= 2:\n                                    new_solution[route_idx] = new_route\n                                else:\n                                    del new_solution[route_idx]\n                                new_solution[other_idx] = new_other_route\n                                break\n\n        # Adaptive 3-opt: perform a limited number of 3-opt swaps\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 4:\n                continue\n\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j, k = sorted(random.sample(range(1, len(route)-1), 3))\n                # Try all possible 3-opt configurations\n                options = [\n                    np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:]]),\n                    np.concatenate([route[:i], route[j:k][::-1], route[i:j], route[k:]]),\n                    np.concatenate([route[:i], route[j:k], route[i:j][::-1], route[k:]])\n                ]\n\n                best_option = None\n                min_cost = float('inf')\n                for option in options:\n                    if sum(demand[option[1:-1]]) <= capacity:\n                        cost = sum(distance_matrix[option[i], option[i+1]] for i in range(len(option)-1))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_option = option\n\n                if best_option is not None:\n                    new_solution[route_idx] = best_option\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.8092992201493914,
            7.086251676082611
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines route splitting and customer reallocation with a biased random walk to explore the solution space while balancing the trade-off between total distance and makespan, ensuring feasibility through capacity-aware transformations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + obj[0] * obj[1]) for _, obj in archive],  # Prefer solutions with better balance between objectives\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search operator: Route splitting and customer reallocation with biased random walk\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Step 1: Randomly select a route to split or modify\n        if len(new_solution) < 2:\n            break  # Need at least two routes to perform meaningful operations\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Step 2: Split the route into two parts at a random position\n        split_pos = random.randint(1, len(route) - 2)\n        new_route1 = route[:split_pos + 1]\n        new_route2 = [0] + route[split_pos:]\n\n        # Step 3: Check capacity feasibility for the new routes\n        def is_feasible(r):\n            return np.sum(demand[r[1:-1]]) <= capacity\n\n        if not is_feasible(new_route1) or not is_feasible(new_route2):\n            continue  # Skip if splitting violates capacity\n\n        # Replace the original route with the two new routes\n        new_solution.pop(route_idx)\n        new_solution.insert(route_idx, new_route2)\n        new_solution.insert(route_idx, new_route1)\n\n        # Step 4: Perform biased random walk to reallocate customers between routes\n        for _ in range(2):  # Limit the number of reallocations\n            # Select a random customer from a random route\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            from_route = new_solution[from_route_idx]\n            if len(from_route) <= 3:  # Skip if route is too short\n                continue\n\n            customer_pos = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_pos]\n\n            # Try to insert the customer into another route\n            to_route_idx = random.randint(0, len(new_solution) - 1)\n            if to_route_idx == from_route_idx:\n                continue  # Skip if same route\n\n            to_route = new_solution[to_route_idx]\n            if np.sum(demand[to_route[1:-1]]) + demand[customer] > capacity:\n                continue  # Skip if capacity is exceeded\n\n            # Insert the customer into the target route at a random position\n            insert_pos = random.randint(1, len(to_route) - 1)\n            new_route = np.insert(to_route, insert_pos, customer)\n\n            # Remove the customer from the original route\n            new_from_route = np.delete(from_route, customer_pos)\n\n            # Update the solution\n            new_solution[to_route_idx] = new_route\n            new_solution[from_route_idx] = new_from_route\n\n    return new_solution\n\n",
        "score": [
            -0.7939521796066197,
            0.13688308000564575
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of distance and makespan, then applies a novel hybrid local search combining route merging, demand-balanced customer insertion, and adaptive route shortening to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [0.7 * obj[0] + 0.3 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, demand-balanced insertion, and adaptive shortening\n    for _ in range(2):  # Limit iterations\n        # Route merging: combine short routes if they fit capacity\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            if len(route1) + len(route2) - 4 <= 20:  # Limit merged route length\n                combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[j]\n                    continue\n\n        # Demand-balanced customer insertion: move customers between routes\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            if len(route1) > 3 and len(route2) > 3:\n                # Find customer with demand closest to average demand\n                avg_demand = (sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])) / (len(route1) + len(route2) - 4)\n                candidates = [c for c in route1[1:-1] if abs(demand[c] - avg_demand) < 0.3 * avg_demand]\n\n                if candidates:\n                    customer = random.choice(candidates)\n                    # Find best insertion in route2\n                    best_pos = 1\n                    min_cost = float('inf')\n                    for pos in range(1, len(route2)):\n                        cost = distance_matrix[route2[pos-1], customer] + distance_matrix[customer, route2[pos]] - distance_matrix[route2[pos-1], route2[pos]]\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Remove from route1\n                        new_route1 = np.delete(route1, np.where(route1 == customer)[0][0])\n                        if len(new_route1) > 2:\n                            new_solution[i] = new_route1\n                        else:\n                            del new_solution[i]\n\n                        # Insert into route2\n                        new_route2 = np.insert(route2, best_pos, customer)\n                        new_solution[j] = new_route2\n\n        # Adaptive route shortening: remove non-critical customers\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:\n                # Find customer with smallest demand\n                customers = route[1:-1]\n                min_demand_idx = np.argmin(demand[customers])\n                customer = customers[min_demand_idx]\n\n                # Check if removal is feasible\n                new_route = np.delete(route, np.where(route == customer)[0][0])\n                if len(new_route) > 2:\n                    new_solution[i] = new_route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.7563857408360191,
            0.3505585789680481
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-frontier dominance score, then applies a hybrid local search combining route merging, customer swapping between routes, and adaptive 3-opt moves to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    pareto_scores = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_scores.append(1.0)\n        else:\n            pareto_scores.append(0.1)\n\n    weights = np.array(pareto_scores) / np.sum(pareto_scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, customer swapping, and adaptive 3-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route merging: combine with a nearby route\n        if len(new_solution) > 1:\n            # Find the closest route\n            min_dist = float('inf')\n            closest_idx = -1\n            for i, other_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n                # Distance between last customer of route and first customer of other_route\n                dist = distance_matrix[route[-2], other_route[1]]\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_idx = i\n\n            if closest_idx != -1:\n                other_route = new_solution[closest_idx]\n                # Check capacity constraint\n                if sum(demand[route[1:-1]]) + sum(demand[other_route[1:-1]]) <= capacity:\n                    # Merge the routes\n                    merged_route = np.concatenate([route[:-1], other_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[closest_idx]\n                    continue\n\n        # Customer swapping between routes\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3 and len(other_route) > 3:\n                # Select a customer from each route\n                customer_pos = random.randint(1, len(route) - 2)\n                other_customer_pos = random.randint(1, len(other_route) - 2)\n                customer = route[customer_pos]\n                other_customer = other_route[other_customer_pos]\n\n                # Check capacity constraints\n                if (sum(demand[route[1:-1]]) - demand[customer] + demand[other_customer] <= capacity and\n                    sum(demand[other_route[1:-1]]) - demand[other_customer] + demand[customer] <= capacity):\n                    # Swap the customers\n                    new_route = route.copy()\n                    new_route[customer_pos] = other_customer\n                    new_other_route = other_route.copy()\n                    new_other_route[other_customer_pos] = customer\n\n                    new_solution[route_idx] = new_route\n                    new_solution[other_route_idx] = new_other_route\n\n        # Adaptive 3-opt: perform a limited number of moves\n        if len(route) > 4:\n            for _ in range(2):  # Limit the number of moves per route\n                # Select three distinct positions\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                # Try all possible 3-opt configurations\n                for config in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n                    a, b, c = config\n                    new_route = np.concatenate([\n                        route[:a], route[b:c][::-1], route[a:b], route[c:]\n                    ])\n                    # Check capacity constraint\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[route_idx] = new_route\n                        break\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.3324894365007257,
            0.19245308637619019
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a normalized combination of normalized objective values, then applies a hybrid local search combining route merging, customer swapping, and adaptive 3-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    min_dist, max_dist = np.min(total_distances), np.max(total_distances)\n    min_span, max_span = np.min(makespans), np.max(makespans)\n\n    normalized_dist = (total_distances - min_dist) / (max_dist - min_dist + 1e-8)\n    normalized_span = (makespans - min_span) / (max_span - min_span + 1e-8)\n    scores = 0.7 * normalized_dist + 0.3 * normalized_span\n    selected_idx = np.argmin(scores)\n\n    base_solution = [route.copy() for route in archive[selected_idx][0]]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, customer swapping, and adaptive 3-opt\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route merging: combine two short routes\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) + len(route2) - 2 <= 20:  # Avoid merging very long routes\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n                if sum(demand[merged_route[1:-1]]) <= capacity:\n                    new_solution.append(merged_route)\n                    del new_solution[max(route1_idx, route2_idx)]\n                    del new_solution[min(route1_idx, route2_idx)]\n                    continue\n\n        # Customer swapping: swap customers between routes\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 3:\n                cust1_pos = random.randint(1, len(route1) - 2)\n                cust2_pos = random.randint(1, len(route2) - 2)\n\n                cust1, cust2 = route1[cust1_pos], route2[cust2_pos]\n\n                # Check capacity constraints\n                new_demand1 = sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n                new_demand2 = sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n\n                if new_demand1 <= capacity and new_demand2 <= capacity:\n                    route1[cust1_pos], route2[cust2_pos] = cust2, cust1\n                    continue\n\n        # Adaptive 3-opt: perform a limited number of swaps\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                for _ in range(2):\n                    i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                    # Try different 3-opt configurations\n                    for new_route in [\n                        np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:j][::-1], route[k:]]),\n                        np.concatenate([route[:i], route[j:k], route[i:j], route[k:]]),\n                        np.concatenate([route[:i], route[j:k][::-1], route[i:j], route[k:]])\n                    ]:\n                        if sum(demand[new_route[1:-1]]) <= capacity:\n                            new_solution[route_idx] = new_route\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.5866150008571532,
            0.6986931264400482
        ]
    },
    {
        "algorithm": "{This novel algorithm selects a solution from the archive based on a combination of objective values and applies a hybrid local search combining route balancing, demand-aware clustering, and adaptive insertion heuristics to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    max_distance = max(obj[0] for _, obj in archive)\n    max_makespan = max(obj[1] for _, obj in archive)\n    weights = np.array([(obj[0]/max_distance + obj[1]/max_makespan) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route balancing, demand clustering, and adaptive insertion\n    for _ in range(3):  # Number of iterations\n        if not new_solution:\n            break\n\n        # Route balancing: identify imbalanced routes\n        route_lengths = [distance_matrix[route[0], route[-2]] for route in new_solution]\n        avg_length = np.mean(route_lengths)\n        imbalanced_routes = [i for i, l in enumerate(route_lengths) if l > 1.2 * avg_length]\n\n        if imbalanced_routes:\n            route_idx = random.choice(imbalanced_routes)\n            route = new_solution[route_idx]\n\n            # Demand-aware clustering: group customers with similar demands\n            customers = route[1:-1]\n            if len(customers) > 1:\n                # Sort customers by demand\n                sorted_customers = sorted(customers, key=lambda x: demand[x])\n\n                # Find split point that balances demand\n                total_demand = np.sum(demand[sorted_customers])\n                half_demand = total_demand / 2\n                cumulative_demand = 0\n                split_pos = 0\n                for i, c in enumerate(sorted_customers):\n                    cumulative_demand += demand[c]\n                    if cumulative_demand >= half_demand:\n                        split_pos = i + 1\n                        break\n\n                if split_pos > 0 and split_pos < len(sorted_customers):\n                    new_route1 = np.concatenate([[0], sorted_customers[:split_pos], [0]])\n                    new_route2 = np.concatenate([[0], sorted_customers[split_pos:], [0]])\n\n                    # Check capacity constraints\n                    if (np.sum(demand[new_route1[1:-1]]) <= capacity and\n                        np.sum(demand[new_route2[1:-1]]) <= capacity):\n                        new_solution[route_idx] = new_route1\n                        new_solution.insert(route_idx + 1, new_route2)\n                        continue\n\n        # Adaptive insertion: move customers to better routes\n        if len(new_solution) > 1:\n            # Select a customer from a random route\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Find the best route to insert the customer\n                best_route_idx = -1\n                best_insert_pos = -1\n                min_distance_increase = float('inf')\n\n                for i, other_route in enumerate(new_solution):\n                    if i == route_idx:\n                        continue\n\n                    # Check capacity constraint\n                    if np.sum(demand[other_route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    # Find best insertion position\n                    for pos in range(1, len(other_route)):\n                        # Calculate distance increase\n                        dist_increase = (distance_matrix[other_route[pos-1], customer] +\n                                       distance_matrix[customer, other_route[pos]] -\n                                       distance_matrix[other_route[pos-1], other_route[pos]])\n\n                        if dist_increase < min_distance_increase:\n                            min_distance_increase = dist_increase\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                if best_route_idx != -1:\n                    # Remove customer from original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n                    # Insert customer into best route\n                    new_other_route = np.insert(new_solution[best_route_idx], best_insert_pos, customer)\n                    new_solution[best_route_idx] = new_other_route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return [np.array(route) for route in new_solution]\n\n",
        "score": [
            -0.6425315352121774,
            0.8249129951000214
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of total distance and makespan, then applies a novel local search combining route merging, customer insertion with distance-based selection, and adaptive 3-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([(obj[0] * 0.6 + obj[1] * 0.4) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route merging: combine two routes if their total demand is within capacity\n    if len(new_solution) > 1:\n        for _ in range(2):\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Check if merging is feasible\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Merge routes by connecting them at the depot\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n\n    # Customer insertion with distance-based selection\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        # Select a customer from a random route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) <= 3:\n            continue\n\n        customer_pos = random.randint(1, len(route) - 2)\n        customer = route[customer_pos]\n\n        # Find the best insertion position in another route\n        best_route_idx = -1\n        best_insert_pos = -1\n        min_increase = float('inf')\n\n        for other_idx in range(len(new_solution)):\n            if other_idx == route_idx:\n                continue\n            other_route = new_solution[other_idx]\n\n            # Check capacity constraint\n            if sum(demand[other_route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Evaluate all possible insertion positions\n            for insert_pos in range(1, len(other_route)):\n                # Calculate the increase in distance\n                prev_node = other_route[insert_pos - 1]\n                next_node = other_route[insert_pos]\n                current_dist = distance_matrix[prev_node, next_node]\n                new_dist = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node]\n\n                if new_dist - current_dist < min_increase:\n                    min_increase = new_dist - current_dist\n                    best_route_idx = other_idx\n                    best_insert_pos = insert_pos\n\n        # Perform the best insertion found\n        if best_route_idx != -1:\n            other_route = new_solution[best_route_idx]\n            new_other_route = np.insert(other_route, best_insert_pos, customer)\n            new_solution[best_route_idx] = new_other_route\n\n            # Remove customer from original route\n            new_route = np.delete(route, customer_pos)\n            if len(new_route) > 2:\n                new_solution[route_idx] = new_route\n            else:\n                del new_solution[route_idx]\n\n    # Adaptive 3-opt: perform limited number of swaps\n    for route_idx in range(len(new_solution)):\n        route = new_solution[route_idx]\n        if len(route) <= 4:\n            continue\n\n        for _ in range(2):\n            # Select 3 distinct customer positions\n            positions = random.sample(range(1, len(route) - 1), 3)\n            positions.sort()\n\n            i, j, k = positions\n            # Try all possible 3-opt configurations\n            for config in [\n                [route[:i], route[i:j], route[j:k], route[k:]],\n                [route[:i], route[j:k], route[i:j], route[k:]],\n                [route[:i], route[j:k][::-1], route[i:j][::-1], route[k:]],\n                [route[:i], route[i:j][::-1], route[j:k][::-1], route[k:]]\n            ]:\n                # Check capacity constraint\n                if sum(demand[np.concatenate([seg[1:-1] for seg in config])]) <= capacity:\n                    new_route = np.concatenate(config)\n                    new_solution[route_idx] = new_route\n                    break\n\n    return [np.array(route) for route in new_solution]\n\n",
        "score": [
            -0.4242702479126037,
            0.6803618371486664
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a novel local search strategy combining route merging, cross-route customer swaps, and adaptive route balancing to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        # Route merging: combine two short routes into one\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 10:  # Avoid merging very short routes\n            continue\n\n        combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if combined_demand > capacity:\n            continue\n\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        new_solution[route1_idx] = merged_route\n        del new_solution[route2_idx]\n        continue\n\n        # Cross-route customer swaps: exchange customers between routes\n        if len(new_solution) > 1:\n            route1_idx = random.randint(0, len(new_solution) - 1)\n            route1 = new_solution[route1_idx]\n\n            if len(route1) > 3:\n                other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route1_idx])\n                other_route = new_solution[other_route_idx]\n\n                customer1_pos = random.randint(1, len(route1) - 2)\n                customer2_pos = random.randint(1, len(other_route) - 2)\n                customer1, customer2 = route1[customer1_pos], other_route[customer2_pos]\n\n                new_demand1 = sum(demand[np.delete(route1[1:-1], customer1_pos - 1)]) + demand[customer2]\n                new_demand2 = sum(demand[np.delete(other_route[1:-1], customer2_pos - 1)]) + demand[customer1]\n\n                if new_demand1 <= capacity and new_demand2 <= capacity:\n                    route1[customer1_pos] = customer2\n                    other_route[customer2_pos] = customer1\n\n        # Adaptive route balancing: redistribute customers between routes\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                for other_route_idx in range(len(new_solution)):\n                    if other_route_idx == route_idx:\n                        continue\n                    other_route = new_solution[other_route_idx]\n\n                    if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(other_route) - 1)\n                        new_other_route = np.insert(other_route, insert_pos, customer)\n                        new_solution[other_route_idx] = new_other_route\n\n                        new_route = np.delete(route, customer_pos)\n                        if len(new_route) > 2:\n                            new_solution[route_idx] = new_route\n                        else:\n                            del new_solution[route_idx]\n                        break\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.6049211535055679,
            3.782785266637802
        ]
    },
    {
        "algorithm": "{The algorithm first selects a solution from the archive based on a weighted random selection biased towards solutions with low makespan and total distance, then applies a hybrid local search combining route splitting, demand-based merging, and demand-aware 2-opt to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    normalized_distances = (total_distances - np.min(total_distances)) / (np.max(total_distances) - np.min(total_distances) + 1e-10)\n    normalized_makespans = (makespans - np.min(makespans)) / (np.max(makespans) - np.min(makespans) + 1e-10)\n    scores = normalized_distances + normalized_makespans\n    probabilities = 1 / (scores + 1e-10)\n    probabilities /= np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Route splitting based on demand\n    for route in new_solution:\n        if len(route) > 3:  # Skip if route is too short\n            total_demand = np.sum(demand[route[1:-1]])\n            if total_demand > capacity:\n                # Find the best split point\n                best_split = None\n                min_split_cost = float('inf')\n                for i in range(1, len(route)-1):\n                    left_demand = np.sum(demand[route[1:i+1]])\n                    right_demand = np.sum(demand[route[i+1:-1]])\n                    if left_demand <= capacity and right_demand <= capacity:\n                        split_cost = distance_matrix[route[i]][0] + distance_matrix[0][route[i+1]]\n                        if split_cost < min_split_cost:\n                            min_split_cost = split_cost\n                            best_split = i\n                if best_split is not None:\n                    # Split the route\n                    new_route1 = np.concatenate(([0], route[1:best_split+1], [0]))\n                    new_route2 = np.concatenate(([0], route[best_split+1:-1], [0]))\n                    new_solution.remove(route)\n                    new_solution.extend([new_route1, new_route2])\n\n    # Step 2: Demand-based merging of routes\n    merged = True\n    while merged:\n        merged = False\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n                if len(route1) + len(route2) - 3 > 2:  # Check if merge is possible\n                    combined_demand = np.sum(demand[np.concatenate((route1[1:-1], route2[1:-1]))])\n                    if combined_demand <= capacity:\n                        # Try to merge routes\n                        # Calculate possible merge cost\n                        cost1 = distance_matrix[route1[-2]][route2[1]] + distance_matrix[route2[-2]][0]\n                        cost2 = distance_matrix[route2[-2]][route1[1]] + distance_matrix[route1[-2]][0]\n                        if cost1 < cost2:\n                            merged_route = np.concatenate((route1[:-1], route2[1:]))\n                        else:\n                            merged_route = np.concatenate((route2[:-1], route1[1:]))\n                        # Check if the merged route is feasible\n                        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                            new_solution.remove(route1)\n                            new_solution.remove(route2)\n                            new_solution.append(merged_route)\n                            merged = True\n                            break\n            if merged:\n                break\n\n    # Step 3: Demand-aware 2-opt for each route\n    for route in new_solution:\n        if len(route) > 4:  # Skip if route is too short\n            improved = True\n            while improved:\n                improved = False\n                for i in range(1, len(route)-2):\n                    for j in range(i+2, len(route)-1):\n                        # Check demand feasibility\n                        segment1 = route[i:j+1]\n                        segment2 = route[j:i-1:-1]\n                        if np.sum(demand[segment1]) <= capacity and np.sum(demand[segment2]) <= capacity:\n                            # Calculate cost change\n                            old_cost = distance_matrix[route[i-1]][route[i]] + distance_matrix[route[j]][route[j+1]]\n                            new_cost = distance_matrix[route[i-1]][route[j]] + distance_matrix[route[i]][route[j+1]]\n                            if new_cost < old_cost:\n                                # Apply 2-opt\n                                route[i:j+1] = route[j:i-1:-1]\n                                improved = True\n                                break\n                    if improved:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.5248856597651215,
            6.911817252635956
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines route splitting and customer reallocation with a biased random walk to explore the solution space while balancing the trade-off between total distance and makespan, ensuring feasibility through capacity-aware transformations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + obj[0] * obj[1]) for _, obj in archive],  # Prefer solutions with better balance between objectives\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search operator: Route splitting and customer reallocation with biased random walk\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Step 1: Randomly select a route to split or modify\n        if len(new_solution) < 2:\n            break  # Need at least two routes to perform meaningful operations\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Step 2: Split the route into two parts at a random position\n        split_pos = random.randint(1, len(route) - 2)\n        new_route1 = route[:split_pos + 1]\n        new_route2 = [0] + route[split_pos:]\n\n        # Step 3: Check capacity feasibility for the new routes\n        def is_feasible(r):\n            return np.sum(demand[r[1:-1]]) <= capacity\n\n        if not is_feasible(new_route1) or not is_feasible(new_route2):\n            continue  # Skip if splitting violates capacity\n\n        # Replace the original route with the two new routes\n        new_solution.pop(route_idx)\n        new_solution.insert(route_idx, new_route2)\n        new_solution.insert(route_idx, new_route1)\n\n        # Step 4: Perform biased random walk to reallocate customers between routes\n        for _ in range(2):  # Limit the number of reallocations\n            # Select a random customer from a random route\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            from_route = new_solution[from_route_idx]\n            if len(from_route) <= 3:  # Skip if route is too short\n                continue\n\n            customer_pos = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_pos]\n\n            # Try to insert the customer into another route\n            to_route_idx = random.randint(0, len(new_solution) - 1)\n            if to_route_idx == from_route_idx:\n                continue  # Skip if same route\n\n            to_route = new_solution[to_route_idx]\n            if np.sum(demand[to_route[1:-1]]) + demand[customer] > capacity:\n                continue  # Skip if capacity is exceeded\n\n            # Insert the customer into the target route at a random position\n            insert_pos = random.randint(1, len(to_route) - 1)\n            new_route = np.insert(to_route, insert_pos, customer)\n\n            # Remove the customer from the original route\n            new_from_route = np.delete(from_route, customer_pos)\n\n            # Update the solution\n            new_solution[to_route_idx] = new_route\n            new_solution[from_route_idx] = new_from_route\n\n    return new_solution\n\n",
        "score": [
            -0.7939521796066197,
            0.13688308000564575
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objectives and applies a hybrid local search combining route merging, demand-balanced customer reallocation, and adaptive 3-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([(obj[0] * 0.6 + obj[1] * 0.4) for _, obj in archive])\n    weights = np.exp(-objectives / np.max(objectives))  # Prefer better solutions\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, demand-balanced reallocation, and adaptive 3-opt\n    for _ in range(3):  # Number of iterations\n        if len(new_solution) < 2:\n            break\n\n        # Route merging: combine two short routes if capacity allows\n        route1_idx, route2_idx = sorted(random.sample(range(len(new_solution)), 2))\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 <= 15 and sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n            continue\n\n        # Demand-balanced customer reallocation: move customers between routes to balance demands\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 3:\n                continue\n\n            current_demand = sum(demand[route[1:-1]])\n            for other_idx in range(len(new_solution)):\n                if route_idx == other_idx:\n                    continue\n                other_route = new_solution[other_idx]\n                other_demand = sum(demand[other_route[1:-1]])\n\n                if abs(current_demand - capacity/2) > abs(other_demand - capacity/2):\n                    # Try to move a customer to balance demands\n                    for customer_pos in range(1, len(route)-1):\n                        customer = route[customer_pos]\n                        if other_demand + demand[customer] <= capacity:\n                            # Find best insertion point in other route\n                            min_insert_cost = float('inf')\n                            best_pos = None\n                            for pos in range(1, len(other_route)):\n                                insert_cost = distance_matrix[other_route[pos-1], customer] + \\\n                                             distance_matrix[customer, other_route[pos]] - \\\n                                             distance_matrix[other_route[pos-1], other_route[pos]]\n                                if insert_cost < min_insert_cost:\n                                    min_insert_cost = insert_cost\n                                    best_pos = pos\n\n                            if best_pos is not None:\n                                # Perform the move\n                                new_route = np.delete(route, customer_pos)\n                                new_other_route = np.insert(other_route, best_pos, customer)\n\n                                # Update routes\n                                if len(new_route) >= 2:\n                                    new_solution[route_idx] = new_route\n                                else:\n                                    del new_solution[route_idx]\n                                new_solution[other_idx] = new_other_route\n                                break\n\n        # Adaptive 3-opt: perform a limited number of 3-opt swaps\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 4:\n                continue\n\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j, k = sorted(random.sample(range(1, len(route)-1), 3))\n                # Try all possible 3-opt configurations\n                options = [\n                    np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:]]),\n                    np.concatenate([route[:i], route[j:k][::-1], route[i:j], route[k:]]),\n                    np.concatenate([route[:i], route[j:k], route[i:j][::-1], route[k:]])\n                ]\n\n                best_option = None\n                min_cost = float('inf')\n                for option in options:\n                    if sum(demand[option[1:-1]]) <= capacity:\n                        cost = sum(distance_matrix[option[i], option[i+1]] for i in range(len(option)-1))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_option = option\n\n                if best_option is not None:\n                    new_solution[route_idx] = best_option\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.8092992201493914,
            7.086251676082611
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    }
]