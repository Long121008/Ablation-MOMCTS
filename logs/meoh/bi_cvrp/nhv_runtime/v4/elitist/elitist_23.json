[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized score combining total distance and makespan with different weights, then applies a hybrid local search combining route decomposition with adaptive demand balancing, spatial-aware customer reinsertion, and dynamic route merging to simultaneously optimize both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.4 + (makespans / np.max(makespans)) * 0.6\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            if total_demand <= 2 * capacity:\n                split_pos = len(route1) // 2 if len(route1) > len(route2) else len(route2) // 2\n                split_route = route1 if len(route1) > len(route2) else route2\n                new_route1 = np.concatenate([[0], split_route[1:split_pos], [0]])\n                new_route2 = np.concatenate([[0], split_route[split_pos:-1], [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    if len(route1) > len(route2):\n                        new_solution[route1_idx] = new_route1\n                        new_solution.insert(route1_idx + 1, new_route2)\n                    else:\n                        new_solution[route2_idx] = new_route1\n                        new_solution.insert(route2_idx + 1, new_route2)\n                    continue\n\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_score = -float('inf')\n\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n\n                    target_route = new_solution[i]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n\n                        spatial_score = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node]) / distance_matrix[prev_node, next_node]\n\n                        demand_score = (capacity - sum(demand[target_route[1:-1]])) / capacity\n\n                        total_score = spatial_score * 0.5 + demand_score * 0.5\n\n                        if total_score > best_score:\n                            best_score = total_score\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                if best_route_idx != -1:\n                    target_route = new_solution[best_route_idx]\n                    new_target_route = np.insert(target_route, best_insert_pos, customer)\n                    new_solution[best_route_idx] = new_target_route\n\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            combined_demand = demand1 + demand2\n\n            if combined_demand <= capacity:\n                route1_last = route1[-2]\n                route2_first = route2[1]\n                route2_last = route2[-2]\n\n                original_dist = (distance_matrix[route1_last, 0] +\n                               distance_matrix[0, route2_first] +\n                               distance_matrix[route2_last, 0])\n\n                merged_dist = (distance_matrix[route1_last, route2_first] +\n                             distance_matrix[route2_last, 0])\n\n                if merged_dist < original_dist:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9849273142234284,
            0.28760358691215515
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of normalized total distance and makespan, then applies a hybrid local search combining route decomposition with adaptive demand balancing, spatial-aware customer reinsertion, and dynamic route merging, while prioritizing solutions with lower makespan to improve the longest route.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.3 + (makespans / np.max(makespans)) * 0.7\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            if total_demand <= 2 * capacity:\n                split_pos = len(route1) // 2 if len(route1) > len(route2) else len(route2) // 2\n                split_route = route1 if len(route1) > len(route2) else route2\n                new_route1 = np.concatenate([[0], split_route[1:split_pos], [0]])\n                new_route2 = np.concatenate([[0], split_route[split_pos:-1], [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    if len(route1) > len(route2):\n                        new_solution[route1_idx] = new_route1\n                        new_solution.insert(route1_idx + 1, new_route2)\n                    else:\n                        new_solution[route2_idx] = new_route1\n                        new_solution.insert(route2_idx + 1, new_route2)\n                    continue\n\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_score = -float('inf')\n\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n\n                    target_route = new_solution[i]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n\n                        spatial_score = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node]) / distance_matrix[prev_node, next_node]\n\n                        demand_score = (capacity - sum(demand[target_route[1:-1]])) / capacity\n\n                        total_score = spatial_score * 0.5 + demand_score * 0.5\n\n                        if total_score > best_score:\n                            best_score = total_score\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                if best_route_idx != -1:\n                    target_route = new_solution[best_route_idx]\n                    new_target_route = np.insert(target_route, best_insert_pos, customer)\n                    new_solution[best_route_idx] = new_target_route\n\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            combined_demand = demand1 + demand2\n\n            if combined_demand <= capacity:\n                route1_last = route1[-2]\n                route2_first = route2[1]\n                route2_last = route2[-2]\n\n                original_dist = (distance_matrix[route1_last, 0] +\n                               distance_matrix[0, route2_first] +\n                               distance_matrix[route2_last, 0])\n\n                merged_dist = (distance_matrix[route1_last, route2_first] +\n                             distance_matrix[route2_last, 0])\n\n                if merged_dist < original_dist:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.934257187156666,
            0.2868064045906067
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-stage perturbation strategy combining adaptive route inversion, strategic customer reinsertion, and dynamic route consolidation to create diverse neighbors while balancing distance and makespan through probabilistic route transformations and capacity-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + 0.4 * obj[0] + 0.6 * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        start_pos = random.randint(1, len(route) - 3)\n        end_pos = random.randint(start_pos + 1, len(route) - 2)\n\n        reversed_segment = route[start_pos:end_pos][::-1]\n        new_route = np.concatenate((route[:start_pos], reversed_segment, route[end_pos:]))\n\n        if np.sum(demand[new_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = new_route\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        customer_pos = random.randint(1, len(route) - 2)\n        customer = route[customer_pos]\n\n        temp_route = np.delete(route, customer_pos)\n\n        if np.sum(demand[temp_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = temp_route\n\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        target_route = new_solution[target_route_idx]\n\n        if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n            continue\n\n        insert_pos = random.randint(1, len(target_route) - 1)\n        new_target_route = np.insert(target_route, insert_pos, customer)\n        new_solution[target_route_idx] = new_target_route\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 9:\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "score": [
            -0.9022976638264517,
            0.12261202931404114
        ]
    },
    {
        "algorithm": "{This algorithm employs a hybrid approach of route decomposition, probabilistic insertion, and adaptive customer redistribution to generate high-quality neighbors by intelligently redistributing customers across routes while maintaining feasibility and exploring the trade-off between distance and makespan through guided perturbations, using a combination of split, merge, and relocation operations with probabilistic selection based on capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        split_pos = random.randint(1, len(route) - 2)\n        first_part = route[:split_pos + 1]\n        second_part = route[split_pos:]\n\n        if np.sum(demand[first_part[1:-1]]) > capacity or np.sum(demand[second_part[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = first_part\n        new_solution.insert(route_idx + 1, second_part)\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 10:\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        customer_pos = random.randint(1, len(route) - 2)\n        customer = route[customer_pos]\n\n        remaining_route = np.concatenate((route[:customer_pos], route[customer_pos + 1:]))\n\n        if np.sum(demand[remaining_route[1:-1]]) > capacity:\n            continue\n\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        if target_route_idx == route_idx:\n            continue\n\n        target_route = new_solution[target_route_idx]\n\n        if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n            continue\n\n        insert_pos = random.randint(1, len(target_route) - 1)\n        new_target_route = np.insert(target_route, insert_pos, customer)\n\n        new_solution[route_idx] = remaining_route\n        new_solution[target_route_idx] = new_target_route\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        pos1 = random.randint(1, len(route) - 3)\n        pos2 = random.randint(pos1 + 1, len(route) - 2)\n\n        new_route = route.copy()\n        new_route[pos1], new_route[pos2] = new_route[pos2], new_route[pos1]\n\n        if np.sum(demand[new_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.8311055738578959,
            0.09319069981575012
        ]
    },
    {
        "algorithm": "{This algorithm uses a hybrid approach combining route splitting, probabilistic customer reallocation, and adaptive route merging to intelligently restructure solutions while balancing distance and makespan objectives through non-uniform perturbation probabilities.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + 0.3 * obj[0] + 0.7 * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        split_pos = random.randint(1, len(route) - 2)\n        first_part = route[:split_pos + 1]\n        second_part = route[split_pos:]\n\n        if np.sum(demand[first_part[1:-1]]) > capacity or np.sum(demand[second_part[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = first_part\n        new_solution.insert(route_idx + 1, second_part)\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        customer_idx = random.randint(1, len(route) - 2)\n        customer = route[customer_idx]\n\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        if target_route_idx == route_idx:\n            continue\n\n        target_route = new_solution[target_route_idx]\n\n        if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n            continue\n\n        insert_pos = random.randint(1, len(target_route) - 1)\n        new_target_route = np.insert(target_route, insert_pos, customer)\n        new_route = np.delete(route, customer_idx)\n\n        new_solution[route_idx] = new_route\n        new_solution[target_route_idx] = new_target_route\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 8:\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7381845939444094,
            0.0779511034488678
        ]
    },
    {
        "algorithm": "{This algorithm combines adaptive route segmentation with probabilistic customer rebalancing and dynamic route merging, using a fitness-based selection mechanism to explore the solution space while maintaining feasibility through capacity-aware perturbations and guided route adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    fitness = [1.0 / (1 + obj[0] * obj[1]) for _, obj in archive]\n    selected_solution, _ = random.choices(archive, weights=fitness, k=1)[0]\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Adaptive route segmentation\n    for _ in range(2):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        # Randomly select a segment to split\n        split_start = random.randint(1, len(route) - 3)\n        split_end = random.randint(split_start + 1, len(route) - 2)\n\n        segment = route[split_start:split_end + 1]\n        remaining_route = np.concatenate((route[:split_start], route[split_end + 1:]))\n\n        # Check capacity constraints\n        if np.sum(demand[remaining_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = remaining_route\n\n        # Probabilistic customer rebalancing\n        for _ in range(2):\n            if len(new_solution) < 2:\n                break\n\n            target_route_idx = random.randint(0, len(new_solution) - 1)\n            if target_route_idx == route_idx:\n                continue\n\n            target_route = new_solution[target_route_idx]\n\n            # Check if we can insert the segment\n            if np.sum(demand[target_route[1:-1]]) + np.sum(demand[segment]) > capacity:\n                continue\n\n            insert_pos = random.randint(1, len(target_route) - 1)\n            new_target_route = np.insert(target_route, insert_pos, segment)\n\n            new_solution[target_route_idx] = new_target_route\n\n    # Dynamic route merging\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Select two routes to merge\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible\n        if len(route1) + len(route2) - 2 > 10:  # Prevent overly long routes\n            continue\n\n        merged_customers = np.concatenate((route1[1:-1], route2[1:-1]))\n        if np.sum(demand[merged_customers]) > capacity:\n            continue\n\n        # Create merged route\n        merged_route = np.concatenate(([0], merged_customers, [0]))\n\n        # Replace the two routes with the merged one\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    # Guided route adjustments\n    for _ in range(3):\n        if len(new_solution) < 1:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        # Randomly select two positions to swap\n        pos1, pos2 = sorted(random.sample(range(1, len(route) - 1), 2))\n\n        # Check capacity after swap\n        if np.sum(demand[route[1:-1]]) != np.sum(demand[route[1:-1]]):  # This check is redundant but ensures feasibility\n            continue\n\n        # Perform the swap\n        route[pos1], route[pos2] = route[pos2], route[pos1]\n        new_solution[route_idx] = route\n\n    return new_solution\n\n",
        "score": [
            -0.847615564107236,
            0.12233731150627136
        ]
    },
    {
        "algorithm": "{This algorithm employs a hybrid approach combining adaptive route segmentation, probabilistic customer relocation, and capacity-aware route splitting to generate diverse neighbors while balancing distance and makespan through dynamic route transformations and demand-constrained perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + 0.5 * obj[0] + 0.5 * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        split_pos = random.randint(2, len(route) - 3)\n        segment1 = route[:split_pos]\n        segment2 = route[split_pos:]\n\n        if np.sum(demand[segment1[1:-1]]) > capacity or np.sum(demand[segment2[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = segment1\n        new_solution.insert(route_idx + 1, segment2)\n\n    for _ in range(4):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 8:\n            continue\n\n        customer_pos = random.randint(1, len(route1) - 2)\n        customer = route1[customer_pos]\n\n        if np.sum(demand[route2[1:-1]]) + demand[customer] > capacity:\n            continue\n\n        new_route1 = np.delete(route1, customer_pos)\n        new_route2 = np.insert(route2, random.randint(1, len(route2) - 1), customer)\n\n        new_solution[route1_idx] = new_route1\n        new_solution[route2_idx] = new_route2\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        start_pos = random.randint(1, len(route) - 3)\n        end_pos = random.randint(start_pos + 1, len(route) - 2)\n\n        segment = route[start_pos:end_pos]\n        reversed_segment = segment[::-1]\n        new_route = np.concatenate((route[:start_pos], reversed_segment, route[end_pos:]))\n\n        if np.sum(demand[new_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.6880218738632191,
            0.06643819808959961
        ]
    },
    {
        "algorithm": "{This algorithm combines adaptive route segmentation with dynamic customer redistribution and probabilistic route merging to intelligently restructure solutions while maintaining feasibility and exploring trade-offs between distance and makespan through guided perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + obj[0] + 0.5 * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        segment_length = random.randint(2, min(4, len(route) - 3))\n        segment_pos = random.randint(1, len(route) - segment_length - 1)\n\n        segment = route[segment_pos:segment_pos + segment_length]\n        remaining_route = np.concatenate((route[:segment_pos], route[segment_pos + segment_length:]))\n\n        if np.sum(demand[remaining_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = remaining_route\n\n        for _ in range(2):\n            target_route_idx = random.randint(0, len(new_solution) - 1)\n            if target_route_idx == route_idx:\n                continue\n\n            target_route = new_solution[target_route_idx]\n\n            if np.sum(demand[target_route[1:-1]]) + np.sum(demand[segment]) > capacity:\n                continue\n\n            insert_pos = random.randint(1, len(target_route) - 1)\n            new_target_route = np.insert(target_route, insert_pos, segment)\n\n            new_solution[target_route_idx] = new_target_route\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 10:\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        swap_pos1 = random.randint(1, len(route) - 3)\n        swap_pos2 = random.randint(swap_pos1 + 1, len(route) - 2)\n\n        new_route = route.copy()\n        new_route[swap_pos1], new_route[swap_pos2] = new_route[swap_pos2], new_route[swap_pos1]\n\n        if np.sum(demand[new_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.8658654072253626,
            0.14337903261184692
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized score combining total distance and makespan with different weights, then applies a hybrid local search combining route decomposition with adaptive demand balancing, spatial-aware customer reinsertion, and dynamic route merging to simultaneously optimize both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.4 + (makespans / np.max(makespans)) * 0.6\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            if total_demand <= 2 * capacity:\n                split_pos = len(route1) // 2 if len(route1) > len(route2) else len(route2) // 2\n                split_route = route1 if len(route1) > len(route2) else route2\n                new_route1 = np.concatenate([[0], split_route[1:split_pos], [0]])\n                new_route2 = np.concatenate([[0], split_route[split_pos:-1], [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    if len(route1) > len(route2):\n                        new_solution[route1_idx] = new_route1\n                        new_solution.insert(route1_idx + 1, new_route2)\n                    else:\n                        new_solution[route2_idx] = new_route1\n                        new_solution.insert(route2_idx + 1, new_route2)\n                    continue\n\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_score = -float('inf')\n\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n\n                    target_route = new_solution[i]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n\n                        spatial_score = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node]) / distance_matrix[prev_node, next_node]\n\n                        demand_score = (capacity - sum(demand[target_route[1:-1]])) / capacity\n\n                        total_score = spatial_score * 0.5 + demand_score * 0.5\n\n                        if total_score > best_score:\n                            best_score = total_score\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                if best_route_idx != -1:\n                    target_route = new_solution[best_route_idx]\n                    new_target_route = np.insert(target_route, best_insert_pos, customer)\n                    new_solution[best_route_idx] = new_target_route\n\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            combined_demand = demand1 + demand2\n\n            if combined_demand <= capacity:\n                route1_last = route1[-2]\n                route2_first = route2[1]\n                route2_last = route2[-2]\n\n                original_dist = (distance_matrix[route1_last, 0] +\n                               distance_matrix[0, route2_first] +\n                               distance_matrix[route2_last, 0])\n\n                merged_dist = (distance_matrix[route1_last, route2_first] +\n                             distance_matrix[route2_last, 0])\n\n                if merged_dist < original_dist:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9849273142234284,
            0.28760358691215515
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of normalized total distance and makespan, then applies a hybrid local search combining route decomposition with adaptive demand balancing, spatial-aware customer reinsertion, and dynamic route merging, while prioritizing solutions with lower makespan to improve the longest route.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.3 + (makespans / np.max(makespans)) * 0.7\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            if total_demand <= 2 * capacity:\n                split_pos = len(route1) // 2 if len(route1) > len(route2) else len(route2) // 2\n                split_route = route1 if len(route1) > len(route2) else route2\n                new_route1 = np.concatenate([[0], split_route[1:split_pos], [0]])\n                new_route2 = np.concatenate([[0], split_route[split_pos:-1], [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    if len(route1) > len(route2):\n                        new_solution[route1_idx] = new_route1\n                        new_solution.insert(route1_idx + 1, new_route2)\n                    else:\n                        new_solution[route2_idx] = new_route1\n                        new_solution.insert(route2_idx + 1, new_route2)\n                    continue\n\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_score = -float('inf')\n\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n\n                    target_route = new_solution[i]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n\n                        spatial_score = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node]) / distance_matrix[prev_node, next_node]\n\n                        demand_score = (capacity - sum(demand[target_route[1:-1]])) / capacity\n\n                        total_score = spatial_score * 0.5 + demand_score * 0.5\n\n                        if total_score > best_score:\n                            best_score = total_score\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                if best_route_idx != -1:\n                    target_route = new_solution[best_route_idx]\n                    new_target_route = np.insert(target_route, best_insert_pos, customer)\n                    new_solution[best_route_idx] = new_target_route\n\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            combined_demand = demand1 + demand2\n\n            if combined_demand <= capacity:\n                route1_last = route1[-2]\n                route2_first = route2[1]\n                route2_last = route2[-2]\n\n                original_dist = (distance_matrix[route1_last, 0] +\n                               distance_matrix[0, route2_first] +\n                               distance_matrix[route2_last, 0])\n\n                merged_dist = (distance_matrix[route1_last, route2_first] +\n                             distance_matrix[route2_last, 0])\n\n                if merged_dist < original_dist:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.934257187156666,
            0.2868064045906067
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-stage perturbation strategy combining adaptive route inversion, strategic customer reinsertion, and dynamic route consolidation to create diverse neighbors while balancing distance and makespan through probabilistic route transformations and capacity-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + 0.4 * obj[0] + 0.6 * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        start_pos = random.randint(1, len(route) - 3)\n        end_pos = random.randint(start_pos + 1, len(route) - 2)\n\n        reversed_segment = route[start_pos:end_pos][::-1]\n        new_route = np.concatenate((route[:start_pos], reversed_segment, route[end_pos:]))\n\n        if np.sum(demand[new_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = new_route\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        customer_pos = random.randint(1, len(route) - 2)\n        customer = route[customer_pos]\n\n        temp_route = np.delete(route, customer_pos)\n\n        if np.sum(demand[temp_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = temp_route\n\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        target_route = new_solution[target_route_idx]\n\n        if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n            continue\n\n        insert_pos = random.randint(1, len(target_route) - 1)\n        new_target_route = np.insert(target_route, insert_pos, customer)\n        new_solution[target_route_idx] = new_target_route\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 9:\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "score": [
            -0.9022976638264517,
            0.12261202931404114
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized score combining total distance and makespan with different weights, then applies a hybrid local search combining route decomposition with adaptive demand balancing, spatial-aware customer reinsertion, and dynamic route merging to simultaneously optimize both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.4 + (makespans / np.max(makespans)) * 0.6\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            if total_demand <= 2 * capacity:\n                split_pos = len(route1) // 2 if len(route1) > len(route2) else len(route2) // 2\n                split_route = route1 if len(route1) > len(route2) else route2\n                new_route1 = np.concatenate([[0], split_route[1:split_pos], [0]])\n                new_route2 = np.concatenate([[0], split_route[split_pos:-1], [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    if len(route1) > len(route2):\n                        new_solution[route1_idx] = new_route1\n                        new_solution.insert(route1_idx + 1, new_route2)\n                    else:\n                        new_solution[route2_idx] = new_route1\n                        new_solution.insert(route2_idx + 1, new_route2)\n                    continue\n\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_score = -float('inf')\n\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n\n                    target_route = new_solution[i]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n\n                        spatial_score = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node]) / distance_matrix[prev_node, next_node]\n\n                        demand_score = (capacity - sum(demand[target_route[1:-1]])) / capacity\n\n                        total_score = spatial_score * 0.5 + demand_score * 0.5\n\n                        if total_score > best_score:\n                            best_score = total_score\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                if best_route_idx != -1:\n                    target_route = new_solution[best_route_idx]\n                    new_target_route = np.insert(target_route, best_insert_pos, customer)\n                    new_solution[best_route_idx] = new_target_route\n\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            combined_demand = demand1 + demand2\n\n            if combined_demand <= capacity:\n                route1_last = route1[-2]\n                route2_first = route2[1]\n                route2_last = route2[-2]\n\n                original_dist = (distance_matrix[route1_last, 0] +\n                               distance_matrix[0, route2_first] +\n                               distance_matrix[route2_last, 0])\n\n                merged_dist = (distance_matrix[route1_last, route2_first] +\n                             distance_matrix[route2_last, 0])\n\n                if merged_dist < original_dist:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9849273142234284,
            0.28760358691215515
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of normalized total distance and makespan, then applies a hybrid local search combining route decomposition with adaptive demand balancing, spatial-aware customer reinsertion, and dynamic route merging, while prioritizing solutions with lower makespan to improve the longest route.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.3 + (makespans / np.max(makespans)) * 0.7\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            if total_demand <= 2 * capacity:\n                split_pos = len(route1) // 2 if len(route1) > len(route2) else len(route2) // 2\n                split_route = route1 if len(route1) > len(route2) else route2\n                new_route1 = np.concatenate([[0], split_route[1:split_pos], [0]])\n                new_route2 = np.concatenate([[0], split_route[split_pos:-1], [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    if len(route1) > len(route2):\n                        new_solution[route1_idx] = new_route1\n                        new_solution.insert(route1_idx + 1, new_route2)\n                    else:\n                        new_solution[route2_idx] = new_route1\n                        new_solution.insert(route2_idx + 1, new_route2)\n                    continue\n\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_score = -float('inf')\n\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n\n                    target_route = new_solution[i]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n\n                        spatial_score = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node]) / distance_matrix[prev_node, next_node]\n\n                        demand_score = (capacity - sum(demand[target_route[1:-1]])) / capacity\n\n                        total_score = spatial_score * 0.5 + demand_score * 0.5\n\n                        if total_score > best_score:\n                            best_score = total_score\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                if best_route_idx != -1:\n                    target_route = new_solution[best_route_idx]\n                    new_target_route = np.insert(target_route, best_insert_pos, customer)\n                    new_solution[best_route_idx] = new_target_route\n\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            combined_demand = demand1 + demand2\n\n            if combined_demand <= capacity:\n                route1_last = route1[-2]\n                route2_first = route2[1]\n                route2_last = route2[-2]\n\n                original_dist = (distance_matrix[route1_last, 0] +\n                               distance_matrix[0, route2_first] +\n                               distance_matrix[route2_last, 0])\n\n                merged_dist = (distance_matrix[route1_last, route2_first] +\n                             distance_matrix[route2_last, 0])\n\n                if merged_dist < original_dist:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.934257187156666,
            0.2868064045906067
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-stage perturbation strategy combining adaptive route inversion, strategic customer reinsertion, and dynamic route consolidation to create diverse neighbors while balancing distance and makespan through probabilistic route transformations and capacity-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + 0.4 * obj[0] + 0.6 * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        start_pos = random.randint(1, len(route) - 3)\n        end_pos = random.randint(start_pos + 1, len(route) - 2)\n\n        reversed_segment = route[start_pos:end_pos][::-1]\n        new_route = np.concatenate((route[:start_pos], reversed_segment, route[end_pos:]))\n\n        if np.sum(demand[new_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = new_route\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        customer_pos = random.randint(1, len(route) - 2)\n        customer = route[customer_pos]\n\n        temp_route = np.delete(route, customer_pos)\n\n        if np.sum(demand[temp_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = temp_route\n\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        target_route = new_solution[target_route_idx]\n\n        if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n            continue\n\n        insert_pos = random.randint(1, len(target_route) - 1)\n        new_target_route = np.insert(target_route, insert_pos, customer)\n        new_solution[target_route_idx] = new_target_route\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 9:\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "score": [
            -0.9022976638264517,
            0.12261202931404114
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized score combining total distance and makespan with different weights, then applies a hybrid local search combining route decomposition with adaptive demand balancing, spatial-aware customer reinsertion, and dynamic route merging to simultaneously optimize both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.4 + (makespans / np.max(makespans)) * 0.6\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            if total_demand <= 2 * capacity:\n                split_pos = len(route1) // 2 if len(route1) > len(route2) else len(route2) // 2\n                split_route = route1 if len(route1) > len(route2) else route2\n                new_route1 = np.concatenate([[0], split_route[1:split_pos], [0]])\n                new_route2 = np.concatenate([[0], split_route[split_pos:-1], [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    if len(route1) > len(route2):\n                        new_solution[route1_idx] = new_route1\n                        new_solution.insert(route1_idx + 1, new_route2)\n                    else:\n                        new_solution[route2_idx] = new_route1\n                        new_solution.insert(route2_idx + 1, new_route2)\n                    continue\n\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_score = -float('inf')\n\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n\n                    target_route = new_solution[i]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n\n                        spatial_score = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node]) / distance_matrix[prev_node, next_node]\n\n                        demand_score = (capacity - sum(demand[target_route[1:-1]])) / capacity\n\n                        total_score = spatial_score * 0.5 + demand_score * 0.5\n\n                        if total_score > best_score:\n                            best_score = total_score\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                if best_route_idx != -1:\n                    target_route = new_solution[best_route_idx]\n                    new_target_route = np.insert(target_route, best_insert_pos, customer)\n                    new_solution[best_route_idx] = new_target_route\n\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            combined_demand = demand1 + demand2\n\n            if combined_demand <= capacity:\n                route1_last = route1[-2]\n                route2_first = route2[1]\n                route2_last = route2[-2]\n\n                original_dist = (distance_matrix[route1_last, 0] +\n                               distance_matrix[0, route2_first] +\n                               distance_matrix[route2_last, 0])\n\n                merged_dist = (distance_matrix[route1_last, route2_first] +\n                             distance_matrix[route2_last, 0])\n\n                if merged_dist < original_dist:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9849273142234284,
            0.28760358691215515
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of normalized total distance and makespan, then applies a hybrid local search combining route decomposition with adaptive demand balancing, spatial-aware customer reinsertion, and dynamic route merging, while prioritizing solutions with lower makespan to improve the longest route.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.3 + (makespans / np.max(makespans)) * 0.7\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            if total_demand <= 2 * capacity:\n                split_pos = len(route1) // 2 if len(route1) > len(route2) else len(route2) // 2\n                split_route = route1 if len(route1) > len(route2) else route2\n                new_route1 = np.concatenate([[0], split_route[1:split_pos], [0]])\n                new_route2 = np.concatenate([[0], split_route[split_pos:-1], [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    if len(route1) > len(route2):\n                        new_solution[route1_idx] = new_route1\n                        new_solution.insert(route1_idx + 1, new_route2)\n                    else:\n                        new_solution[route2_idx] = new_route1\n                        new_solution.insert(route2_idx + 1, new_route2)\n                    continue\n\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_score = -float('inf')\n\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n\n                    target_route = new_solution[i]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n\n                        spatial_score = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node]) / distance_matrix[prev_node, next_node]\n\n                        demand_score = (capacity - sum(demand[target_route[1:-1]])) / capacity\n\n                        total_score = spatial_score * 0.5 + demand_score * 0.5\n\n                        if total_score > best_score:\n                            best_score = total_score\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                if best_route_idx != -1:\n                    target_route = new_solution[best_route_idx]\n                    new_target_route = np.insert(target_route, best_insert_pos, customer)\n                    new_solution[best_route_idx] = new_target_route\n\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            combined_demand = demand1 + demand2\n\n            if combined_demand <= capacity:\n                route1_last = route1[-2]\n                route2_first = route2[1]\n                route2_last = route2[-2]\n\n                original_dist = (distance_matrix[route1_last, 0] +\n                               distance_matrix[0, route2_first] +\n                               distance_matrix[route2_last, 0])\n\n                merged_dist = (distance_matrix[route1_last, route2_first] +\n                             distance_matrix[route2_last, 0])\n\n                if merged_dist < original_dist:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.934257187156666,
            0.2868064045906067
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-stage perturbation strategy combining adaptive route inversion, strategic customer reinsertion, and dynamic route consolidation to create diverse neighbors while balancing distance and makespan through probabilistic route transformations and capacity-aware perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + 0.4 * obj[0] + 0.6 * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        start_pos = random.randint(1, len(route) - 3)\n        end_pos = random.randint(start_pos + 1, len(route) - 2)\n\n        reversed_segment = route[start_pos:end_pos][::-1]\n        new_route = np.concatenate((route[:start_pos], reversed_segment, route[end_pos:]))\n\n        if np.sum(demand[new_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = new_route\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        customer_pos = random.randint(1, len(route) - 2)\n        customer = route[customer_pos]\n\n        temp_route = np.delete(route, customer_pos)\n\n        if np.sum(demand[temp_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = temp_route\n\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        target_route = new_solution[target_route_idx]\n\n        if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n            continue\n\n        insert_pos = random.randint(1, len(target_route) - 1)\n        new_target_route = np.insert(target_route, insert_pos, customer)\n        new_solution[target_route_idx] = new_target_route\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 9:\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "score": [
            -0.9022976638264517,
            0.12261202931404114
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized score combining total distance and makespan with different weights, then applies a hybrid local search combining route decomposition with adaptive demand balancing, spatial-aware customer reinsertion, and dynamic route merging to simultaneously optimize both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.4 + (makespans / np.max(makespans)) * 0.6\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            if total_demand <= 2 * capacity:\n                split_pos = len(route1) // 2 if len(route1) > len(route2) else len(route2) // 2\n                split_route = route1 if len(route1) > len(route2) else route2\n                new_route1 = np.concatenate([[0], split_route[1:split_pos], [0]])\n                new_route2 = np.concatenate([[0], split_route[split_pos:-1], [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    if len(route1) > len(route2):\n                        new_solution[route1_idx] = new_route1\n                        new_solution.insert(route1_idx + 1, new_route2)\n                    else:\n                        new_solution[route2_idx] = new_route1\n                        new_solution.insert(route2_idx + 1, new_route2)\n                    continue\n\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_score = -float('inf')\n\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n\n                    target_route = new_solution[i]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n\n                        spatial_score = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node]) / distance_matrix[prev_node, next_node]\n\n                        demand_score = (capacity - sum(demand[target_route[1:-1]])) / capacity\n\n                        total_score = spatial_score * 0.5 + demand_score * 0.5\n\n                        if total_score > best_score:\n                            best_score = total_score\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                if best_route_idx != -1:\n                    target_route = new_solution[best_route_idx]\n                    new_target_route = np.insert(target_route, best_insert_pos, customer)\n                    new_solution[best_route_idx] = new_target_route\n\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            combined_demand = demand1 + demand2\n\n            if combined_demand <= capacity:\n                route1_last = route1[-2]\n                route2_first = route2[1]\n                route2_last = route2[-2]\n\n                original_dist = (distance_matrix[route1_last, 0] +\n                               distance_matrix[0, route2_first] +\n                               distance_matrix[route2_last, 0])\n\n                merged_dist = (distance_matrix[route1_last, route2_first] +\n                             distance_matrix[route2_last, 0])\n\n                if merged_dist < original_dist:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9849273142234284,
            0.28760358691215515
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of normalized total distance and makespan, then applies a hybrid local search combining route decomposition with adaptive demand balancing, spatial-aware customer reinsertion, and dynamic route merging, while prioritizing solutions with lower makespan to improve the longest route.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.3 + (makespans / np.max(makespans)) * 0.7\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            if total_demand <= 2 * capacity:\n                split_pos = len(route1) // 2 if len(route1) > len(route2) else len(route2) // 2\n                split_route = route1 if len(route1) > len(route2) else route2\n                new_route1 = np.concatenate([[0], split_route[1:split_pos], [0]])\n                new_route2 = np.concatenate([[0], split_route[split_pos:-1], [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    if len(route1) > len(route2):\n                        new_solution[route1_idx] = new_route1\n                        new_solution.insert(route1_idx + 1, new_route2)\n                    else:\n                        new_solution[route2_idx] = new_route1\n                        new_solution.insert(route2_idx + 1, new_route2)\n                    continue\n\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_score = -float('inf')\n\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n\n                    target_route = new_solution[i]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n\n                        spatial_score = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node]) / distance_matrix[prev_node, next_node]\n\n                        demand_score = (capacity - sum(demand[target_route[1:-1]])) / capacity\n\n                        total_score = spatial_score * 0.5 + demand_score * 0.5\n\n                        if total_score > best_score:\n                            best_score = total_score\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                if best_route_idx != -1:\n                    target_route = new_solution[best_route_idx]\n                    new_target_route = np.insert(target_route, best_insert_pos, customer)\n                    new_solution[best_route_idx] = new_target_route\n\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            combined_demand = demand1 + demand2\n\n            if combined_demand <= capacity:\n                route1_last = route1[-2]\n                route2_first = route2[1]\n                route2_last = route2[-2]\n\n                original_dist = (distance_matrix[route1_last, 0] +\n                               distance_matrix[0, route2_first] +\n                               distance_matrix[route2_last, 0])\n\n                merged_dist = (distance_matrix[route1_last, route2_first] +\n                             distance_matrix[route2_last, 0])\n\n                if merged_dist < original_dist:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.934257187156666,
            0.2868064045906067
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized score combining total distance and makespan with different weights, then applies a hybrid local search combining route decomposition with adaptive demand balancing, spatial-aware customer reinsertion, and dynamic route merging to simultaneously optimize both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.4 + (makespans / np.max(makespans)) * 0.6\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            if total_demand <= 2 * capacity:\n                split_pos = len(route1) // 2 if len(route1) > len(route2) else len(route2) // 2\n                split_route = route1 if len(route1) > len(route2) else route2\n                new_route1 = np.concatenate([[0], split_route[1:split_pos], [0]])\n                new_route2 = np.concatenate([[0], split_route[split_pos:-1], [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    if len(route1) > len(route2):\n                        new_solution[route1_idx] = new_route1\n                        new_solution.insert(route1_idx + 1, new_route2)\n                    else:\n                        new_solution[route2_idx] = new_route1\n                        new_solution.insert(route2_idx + 1, new_route2)\n                    continue\n\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_score = -float('inf')\n\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n\n                    target_route = new_solution[i]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n\n                        spatial_score = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node]) / distance_matrix[prev_node, next_node]\n\n                        demand_score = (capacity - sum(demand[target_route[1:-1]])) / capacity\n\n                        total_score = spatial_score * 0.5 + demand_score * 0.5\n\n                        if total_score > best_score:\n                            best_score = total_score\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                if best_route_idx != -1:\n                    target_route = new_solution[best_route_idx]\n                    new_target_route = np.insert(target_route, best_insert_pos, customer)\n                    new_solution[best_route_idx] = new_target_route\n\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            combined_demand = demand1 + demand2\n\n            if combined_demand <= capacity:\n                route1_last = route1[-2]\n                route2_first = route2[1]\n                route2_last = route2[-2]\n\n                original_dist = (distance_matrix[route1_last, 0] +\n                               distance_matrix[0, route2_first] +\n                               distance_matrix[route2_last, 0])\n\n                merged_dist = (distance_matrix[route1_last, route2_first] +\n                             distance_matrix[route2_last, 0])\n\n                if merged_dist < original_dist:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9849273142234284,
            0.28760358691215515
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized score combining total distance and makespan with different weights, then applies a hybrid local search combining route decomposition with adaptive demand balancing, spatial-aware customer reinsertion, and dynamic route merging to simultaneously optimize both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.4 + (makespans / np.max(makespans)) * 0.6\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            if total_demand <= 2 * capacity:\n                split_pos = len(route1) // 2 if len(route1) > len(route2) else len(route2) // 2\n                split_route = route1 if len(route1) > len(route2) else route2\n                new_route1 = np.concatenate([[0], split_route[1:split_pos], [0]])\n                new_route2 = np.concatenate([[0], split_route[split_pos:-1], [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    if len(route1) > len(route2):\n                        new_solution[route1_idx] = new_route1\n                        new_solution.insert(route1_idx + 1, new_route2)\n                    else:\n                        new_solution[route2_idx] = new_route1\n                        new_solution.insert(route2_idx + 1, new_route2)\n                    continue\n\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_score = -float('inf')\n\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n\n                    target_route = new_solution[i]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n\n                        spatial_score = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node]) / distance_matrix[prev_node, next_node]\n\n                        demand_score = (capacity - sum(demand[target_route[1:-1]])) / capacity\n\n                        total_score = spatial_score * 0.5 + demand_score * 0.5\n\n                        if total_score > best_score:\n                            best_score = total_score\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                if best_route_idx != -1:\n                    target_route = new_solution[best_route_idx]\n                    new_target_route = np.insert(target_route, best_insert_pos, customer)\n                    new_solution[best_route_idx] = new_target_route\n\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            combined_demand = demand1 + demand2\n\n            if combined_demand <= capacity:\n                route1_last = route1[-2]\n                route2_first = route2[1]\n                route2_last = route2[-2]\n\n                original_dist = (distance_matrix[route1_last, 0] +\n                               distance_matrix[0, route2_first] +\n                               distance_matrix[route2_last, 0])\n\n                merged_dist = (distance_matrix[route1_last, route2_first] +\n                             distance_matrix[route2_last, 0])\n\n                if merged_dist < original_dist:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9849273142234284,
            0.28760358691215515
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    }
]