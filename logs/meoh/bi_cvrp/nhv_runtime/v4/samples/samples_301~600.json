[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized score combining total distance and makespan with different weights, then applies a hybrid local search combining route decomposition with adaptive demand balancing, spatial-aware customer reinsertion, and dynamic route merging to simultaneously optimize both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.4 + (makespans / np.max(makespans)) * 0.6\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            if total_demand <= 2 * capacity:\n                split_pos = len(route1) // 2 if len(route1) > len(route2) else len(route2) // 2\n                split_route = route1 if len(route1) > len(route2) else route2\n                new_route1 = np.concatenate([[0], split_route[1:split_pos], [0]])\n                new_route2 = np.concatenate([[0], split_route[split_pos:-1], [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    if len(route1) > len(route2):\n                        new_solution[route1_idx] = new_route1\n                        new_solution.insert(route1_idx + 1, new_route2)\n                    else:\n                        new_solution[route2_idx] = new_route1\n                        new_solution.insert(route2_idx + 1, new_route2)\n                    continue\n\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_score = -float('inf')\n\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n\n                    target_route = new_solution[i]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n\n                        spatial_score = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node]) / distance_matrix[prev_node, next_node]\n\n                        demand_score = (capacity - sum(demand[target_route[1:-1]])) / capacity\n\n                        total_score = spatial_score * 0.5 + demand_score * 0.5\n\n                        if total_score > best_score:\n                            best_score = total_score\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                if best_route_idx != -1:\n                    target_route = new_solution[best_route_idx]\n                    new_target_route = np.insert(target_route, best_insert_pos, customer)\n                    new_solution[best_route_idx] = new_target_route\n\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            combined_demand = demand1 + demand2\n\n            if combined_demand <= capacity:\n                route1_last = route1[-2]\n                route2_first = route2[1]\n                route2_last = route2[-2]\n\n                original_dist = (distance_matrix[route1_last, 0] +\n                               distance_matrix[0, route2_first] +\n                               distance_matrix[route2_last, 0])\n\n                merged_dist = (distance_matrix[route1_last, route2_first] +\n                             distance_matrix[route2_last, 0])\n\n                if merged_dist < original_dist:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm implements a multi-phase local search strategy combining route fragmentation, probabilistic customer exchange, and adaptive route merging, where solutions are selected based on a weighted combination of distance and makespan objectives, with higher weights on makespan reduction to balance the bi-objective optimization.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (0.3 * obj[0] + 0.7 * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        split_pos = random.randint(1, len(route) - 2)\n        first_part = route[:split_pos + 1]\n        second_part = route[split_pos:]\n\n        if np.sum(demand[first_part[1:-1]]) > capacity or np.sum(demand[second_part[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = first_part\n        new_solution.insert(route_idx + 1, second_part)\n\n    for _ in range(5):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        customer_idx = random.randint(1, len(route) - 2)\n        customer = route[customer_idx]\n\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        if target_route_idx == route_idx:\n            continue\n\n        target_route = new_solution[target_route_idx]\n\n        if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n            continue\n\n        insert_pos = random.randint(1, len(target_route) - 1)\n        new_target_route = np.insert(target_route, insert_pos, customer)\n        new_route = np.delete(route, customer_idx)\n\n        new_solution[route_idx] = new_route\n        new_solution[target_route_idx] = new_target_route\n\n    for _ in range(4):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 12:\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid fitness metric combining normalized distance and makespan, then applies a novel three-phase local search strategy that first performs adaptive route fragmentation, followed by spatial-aware customer reallocation, and finally dynamic route consolidation with capacity-aware merging to simultaneously optimize both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    fitness = (total_distances / np.max(total_distances)) * 0.3 + (makespans / np.max(makespans)) * 0.7\n    weights = 1.0 / (fitness + 1e-6)\n    weights /= np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        split_pos = random.randint(2, len(route) - 3)\n        first_part = route[:split_pos + 1]\n        second_part = route[split_pos:]\n\n        if (np.sum(demand[first_part[1:-1]]) > capacity or\n            np.sum(demand[second_part[1:-1]]) > capacity):\n            continue\n\n        new_solution[route_idx] = first_part\n        new_solution.insert(route_idx + 1, second_part)\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        customer_idx = random.randint(1, len(route) - 2)\n        customer = route[customer_idx]\n\n        candidate_routes = []\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue\n\n            target_route = new_solution[i]\n            if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            candidate_routes.append(i)\n\n        if not candidate_routes:\n            continue\n\n        target_route_idx = random.choice(candidate_routes)\n        target_route = new_solution[target_route_idx]\n\n        spatial_scores = []\n        for pos in range(1, len(target_route)):\n            prev_node = target_route[pos-1]\n            next_node = target_route[pos]\n\n            spatial_score = (distance_matrix[prev_node, customer] +\n                           distance_matrix[customer, next_node] -\n                           distance_matrix[prev_node, next_node])\n\n            spatial_scores.append((pos, spatial_score))\n\n        spatial_scores.sort(key=lambda x: -x[1])\n        best_pos = spatial_scores[0][0]\n\n        new_target_route = np.insert(target_route, best_pos, customer)\n        new_route = np.delete(route, customer_idx)\n\n        new_solution[route_idx] = new_route\n        new_solution[target_route_idx] = new_target_route\n\n    for _ in range(4):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if (len(route1) + len(route2) - 2 > 12 or\n            np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) > capacity):\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7531756296045415,
            0.4071929454803467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    fitness = (total_distances / np.max(total_distances)) * 0.3 + (makespans / np.max(makespans)) * 0.7\n    weights = 1.0 / (fitness + 1e-6)\n    weights /= np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        split_pos = random.randint(2, len(route) - 3)\n        first_part = route[:split_pos + 1]\n        second_part = route[split_pos:]\n\n        if (np.sum(demand[first_part[1:-1]]) > capacity or\n            np.sum(demand[second_part[1:-1]]) > capacity):\n            continue\n\n        new_solution[route_idx] = first_part\n        new_solution.insert(route_idx + 1, second_part)\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        customer_idx = random.randint(1, len(route) - 2)\n        customer = route[customer_idx]\n\n        candidate_routes = []\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue\n\n            target_route = new_solution[i]\n            if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            candidate_routes.append(i)\n\n        if not candidate_routes:\n            continue\n\n        target_route_idx = random.choice(candidate_routes)\n        target_route = new_solution[target_route_idx]\n\n        spatial_scores = []\n        for pos in range(1, len(target_route)):\n            prev_node = target_route[pos-1]\n            next_node = target_route[pos]\n\n            spatial_score = (distance_matrix[prev_node, customer] +\n                           distance_matrix[customer, next_node] -\n                           distance_matrix[prev_node, next_node])\n\n            spatial_scores.append((pos, spatial_score))\n\n        spatial_scores.sort(key=lambda x: -x[1])\n        best_pos = spatial_scores[0][0]\n\n        new_target_route = np.insert(target_route, best_pos, customer)\n        new_route = np.delete(route, customer_idx)\n\n        new_solution[route_idx] = new_route\n        new_solution[target_route_idx] = new_target_route\n\n    for _ in range(4):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if (len(route1) + len(route2) - 2 > 12 or\n            np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) > capacity):\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm employs a hybrid approach combining adaptive route segmentation, probabilistic customer relocation, and capacity-aware route splitting to generate diverse neighbors while balancing distance and makespan through dynamic route transformations and demand-constrained perturbations.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + 0.5 * obj[0] + 0.5 * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        split_pos = random.randint(2, len(route) - 3)\n        segment1 = route[:split_pos]\n        segment2 = route[split_pos:]\n\n        if np.sum(demand[segment1[1:-1]]) > capacity or np.sum(demand[segment2[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = segment1\n        new_solution.insert(route_idx + 1, segment2)\n\n    for _ in range(4):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 8:\n            continue\n\n        customer_pos = random.randint(1, len(route1) - 2)\n        customer = route1[customer_pos]\n\n        if np.sum(demand[route2[1:-1]]) + demand[customer] > capacity:\n            continue\n\n        new_route1 = np.delete(route1, customer_pos)\n        new_route2 = np.insert(route2, random.randint(1, len(route2) - 1), customer)\n\n        new_solution[route1_idx] = new_route1\n        new_solution[route2_idx] = new_route2\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        start_pos = random.randint(1, len(route) - 3)\n        end_pos = random.randint(start_pos + 1, len(route) - 2)\n\n        segment = route[start_pos:end_pos]\n        reversed_segment = segment[::-1]\n        new_route = np.concatenate((route[:start_pos], reversed_segment, route[end_pos:]))\n\n        if np.sum(demand[new_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = new_route\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This algorithm employs a hybrid approach combining adaptive route clustering, probabilistic segment reversal, and capacity-aware route merging to generate diverse neighbors while balancing distance and makespan through dynamic route transformations and demand-constrained perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + 0.3 * obj[0] + 0.7 * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 5:\n            continue\n\n        split_pos = random.randint(2, len(route) - 3)\n        segment1 = route[:split_pos]\n        segment2 = route[split_pos:]\n\n        if np.sum(demand[segment1[1:-1]]) > capacity or np.sum(demand[segment2[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = segment1\n        new_solution.insert(route_idx + 1, segment2)\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 7:\n            continue\n\n        customer_pos = random.randint(1, len(route1) - 2)\n        customer = route1[customer_pos]\n\n        if np.sum(demand[route2[1:-1]]) + demand[customer] > capacity:\n            continue\n\n        new_route1 = np.delete(route1, customer_pos)\n        new_route2 = np.insert(route2, random.randint(1, len(route2) - 1), customer)\n\n        new_solution[route1_idx] = new_route1\n        new_solution[route2_idx] = new_route2\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        start_pos = random.randint(1, len(route) - 3)\n        end_pos = random.randint(start_pos + 1, len(route) - 2)\n\n        segment = route[start_pos:end_pos]\n        reversed_segment = segment[::-1]\n        new_route = np.concatenate((route[:start_pos], reversed_segment, route[end_pos:]))\n\n        if np.sum(demand[new_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7824975439627411,
            0.08780267834663391
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + 0.3 * obj[0] + 0.7 * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 5:\n            continue\n\n        split_pos = random.randint(2, len(route) - 3)\n        segment1 = route[:split_pos]\n        segment2 = route[split_pos:]\n\n        if np.sum(demand[segment1[1:-1]]) > capacity or np.sum(demand[segment2[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = segment1\n        new_solution.insert(route_idx + 1, segment2)\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 7:\n            continue\n\n        customer_pos = random.randint(1, len(route1) - 2)\n        customer = route1[customer_pos]\n\n        if np.sum(demand[route2[1:-1]]) + demand[customer] > capacity:\n            continue\n\n        new_route1 = np.delete(route1, customer_pos)\n        new_route2 = np.insert(route2, random.randint(1, len(route2) - 1), customer)\n\n        new_solution[route1_idx] = new_route1\n        new_solution[route2_idx] = new_route2\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        start_pos = random.randint(1, len(route) - 3)\n        end_pos = random.randint(start_pos + 1, len(route) - 2)\n\n        segment = route[start_pos:end_pos]\n        reversed_segment = segment[::-1]\n        new_route = np.concatenate((route[:start_pos], reversed_segment, route[end_pos:]))\n\n        if np.sum(demand[new_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = new_route\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This algorithm selects a solution from the archive using a novelty-aware selection strategy that prioritizes solutions with high potential for improvement, then applies a hybrid local search combining route merging, adaptive insertion, and capacity-aware swaps to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    novelty_scores = []\n    for sol, _ in archive:\n        # Calculate novelty based on route diversity and balance\n        diversity = len(sol) / (1 + sum(len(route) for route in sol))\n        balance = np.std([sum(demand[route[1:-1]]) for route in sol])\n        novelty_scores.append(diversity + balance)\n\n    novelty_scores = np.array(novelty_scores)\n    weights = novelty_scores / np.sum(novelty_scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, adaptive insertion, and capacity-aware swaps\n    for _ in range(3):  # Number of iterations\n        if not new_solution:\n            break\n\n        # Route merging: combine two short routes if feasible\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Check if merging is feasible\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Create merged route\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution.append(merged_route)\n                new_solution.pop(max(route1_idx, route2_idx))\n                new_solution.pop(min(route1_idx, route2_idx))\n                continue\n\n        # Adaptive insertion: move a customer to a new route if beneficial\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Create new route with just this customer\n                new_route = np.array([0, customer, 0])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    # Insert new route into solution\n                    new_solution.append(new_route)\n\n                    # Remove customer from original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Capacity-aware swaps: perform swaps that maintain capacity\n        for route in new_solution:\n            if len(route) > 3:\n                for _ in range(2):  # Limit the number of swaps per route\n                    i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                    # Check if swap maintains capacity\n                    if (sum(demand[route[1:i]]) + demand[route[j]] + sum(demand[route[i+1:j]]) + demand[route[i]] + sum(demand[route[j+1:-1]])) <= capacity:\n                        # Perform swap\n                        route[i], route[j] = route[j], route[i]\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.5368604023830607,
            0.8978785872459412
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    novelty_scores = []\n    for sol, _ in archive:\n        # Calculate novelty based on route diversity and balance\n        diversity = len(sol) / (1 + sum(len(route) for route in sol))\n        balance = np.std([sum(demand[route[1:-1]]) for route in sol])\n        novelty_scores.append(diversity + balance)\n\n    novelty_scores = np.array(novelty_scores)\n    weights = novelty_scores / np.sum(novelty_scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, adaptive insertion, and capacity-aware swaps\n    for _ in range(3):  # Number of iterations\n        if not new_solution:\n            break\n\n        # Route merging: combine two short routes if feasible\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Check if merging is feasible\n            total_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_demand <= capacity:\n                # Create merged route\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution.append(merged_route)\n                new_solution.pop(max(route1_idx, route2_idx))\n                new_solution.pop(min(route1_idx, route2_idx))\n                continue\n\n        # Adaptive insertion: move a customer to a new route if beneficial\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Create new route with just this customer\n                new_route = np.array([0, customer, 0])\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    # Insert new route into solution\n                    new_solution.append(new_route)\n\n                    # Remove customer from original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Capacity-aware swaps: perform swaps that maintain capacity\n        for route in new_solution:\n            if len(route) > 3:\n                for _ in range(2):  # Limit the number of swaps per route\n                    i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                    # Check if swap maintains capacity\n                    if (sum(demand[route[1:i]]) + demand[route[j]] + sum(demand[route[i+1:j]]) + demand[route[i]] + sum(demand[route[j+1:-1]])) <= capacity:\n                        # Perform swap\n                        route[i], route[j] = route[j], route[i]\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a multi-phase approach combining adaptive route fragmentation, probabilistic customer redistribution, and dynamic route consolidation to restructure solutions while balancing distance and makespan through adaptive perturbation probabilities and capacity-aware merging strategies.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + 0.4 * obj[0] + 0.6 * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        split_pos = random.randint(1, len(route) - 2)\n        first_part = route[:split_pos + 1]\n        second_part = route[split_pos:]\n\n        if np.sum(demand[first_part[1:-1]]) > capacity or np.sum(demand[second_part[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = first_part\n        new_solution.insert(route_idx + 1, second_part)\n\n    for _ in range(4):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        customer_idx = random.randint(1, len(route) - 2)\n        customer = route[customer_idx]\n\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        if target_route_idx == route_idx:\n            continue\n\n        target_route = new_solution[target_route_idx]\n\n        if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n            continue\n\n        insert_pos = random.randint(1, len(target_route) - 1)\n        new_target_route = np.insert(target_route, insert_pos, customer)\n        new_route = np.delete(route, customer_idx)\n\n        new_solution[route_idx] = new_route\n        new_solution[target_route_idx] = new_target_route\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 10:\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized score combining total distance and makespan with different weights, then applies a hybrid local search combining route decomposition with adaptive demand balancing, spatial-aware customer reinsertion, and dynamic route merging to simultaneously optimize both objectives while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.4 + (makespans / np.max(makespans)) * 0.6\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            if total_demand <= 2 * capacity:\n                split_pos = len(route1) // 2 if len(route1) > len(route2) else len(route2) // 2\n                split_route = route1 if len(route1) > len(route2) else route2\n                new_route1 = np.concatenate([[0], split_route[1:split_pos], [0]])\n                new_route2 = np.concatenate([[0], split_route[split_pos:-1], [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    if len(route1) > len(route2):\n                        new_solution[route1_idx] = new_route1\n                        new_solution.insert(route1_idx + 1, new_route2)\n                    else:\n                        new_solution[route2_idx] = new_route1\n                        new_solution.insert(route2_idx + 1, new_route2)\n                    continue\n\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_score = -float('inf')\n\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n\n                    target_route = new_solution[i]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n\n                        spatial_score = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node]) / distance_matrix[prev_node, next_node]\n\n                        demand_score = (capacity - sum(demand[target_route[1:-1]])) / capacity\n\n                        total_score = spatial_score * 0.5 + demand_score * 0.5\n\n                        if total_score > best_score:\n                            best_score = total_score\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                if best_route_idx != -1:\n                    target_route = new_solution[best_route_idx]\n                    new_target_route = np.insert(target_route, best_insert_pos, customer)\n                    new_solution[best_route_idx] = new_target_route\n\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            combined_demand = demand1 + demand2\n\n            if combined_demand <= capacity:\n                route1_last = route1[-2]\n                route2_first = route2[1]\n                route2_last = route2[-2]\n\n                original_dist = (distance_matrix[route1_last, 0] +\n                               distance_matrix[0, route2_first] +\n                               distance_matrix[route2_last, 0])\n\n                merged_dist = (distance_matrix[route1_last, route2_first] +\n                             distance_matrix[route2_last, 0])\n\n                if merged_dist < original_dist:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection criterion combining both objectives, then applies a novel spatial-cluster-based local search that dynamically groups customers based on their spatial proximity and demand patterns, followed by adaptive route restructuring to simultaneously optimize both distance and makespan while maintaining feasibility through capacity-constrained merging and splitting.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [0.3 * obj[0] / archive[0][1][0] + 0.7 * obj[1] / archive[0][1][1] for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Spatial-cluster-based local search\n    all_customers = []\n    for route in new_solution:\n        all_customers.extend(route[1:-1])\n    if not all_customers:\n        return new_solution\n\n    # Dynamic clustering based on spatial proximity and demand patterns\n    from sklearn.cluster import KMeans\n    n_clusters = min(5, len(all_customers))\n    if n_clusters < 2:\n        return new_solution\n\n    cluster_data = np.column_stack((coords[all_customers], demand[all_customers]))\n    kmeans = KMeans(n_clusters=n_clusters, random_state=42).fit(cluster_data)\n    clusters = [[] for _ in range(n_clusters)]\n    for i, label in enumerate(kmeans.labels_):\n        clusters[label].append(all_customers[i])\n\n    # Adaptive route restructuring\n    temp_solution = []\n    for cluster in clusters:\n        if not cluster:\n            continue\n        cluster_demand = sum(demand[cluster])\n        if cluster_demand > capacity:\n            # Split large clusters\n            cluster.sort(key=lambda x: coords[x, 0] + coords[x, 1])\n            current_demand = 0\n            current_cluster = []\n            for node in cluster:\n                if current_demand + demand[node] <= capacity:\n                    current_cluster.append(node)\n                    current_demand += demand[node]\n                else:\n                    if current_cluster:\n                        temp_solution.append(np.concatenate([[0], current_cluster, [0]]))\n                    current_cluster = [node]\n                    current_demand = demand[node]\n            if current_cluster:\n                temp_solution.append(np.concatenate([[0], current_cluster, [0]]))\n        else:\n            temp_solution.append(np.concatenate([[0], cluster, [0]]))\n\n    # Merge small routes if possible\n    final_solution = []\n    for route in temp_solution:\n        if len(route) <= 3:\n            if final_solution:\n                last_route = final_solution[-1]\n                if sum(demand[last_route[1:-1]]) + sum(demand[route[1:-1]]) <= capacity:\n                    merged = np.concatenate([last_route[:-1], route[1:]])\n                    final_solution[-1] = merged\n                    continue\n            else:\n                final_solution.append(route)\n        else:\n            final_solution.append(route)\n\n    # Final capacity check and adjustment\n    for i in range(len(final_solution)):\n        route = final_solution[i]\n        while sum(demand[route[1:-1]]) > capacity:\n            # Find the most distant customer to remove\n            distances = [distance_matrix[route[j], route[j+1]] for j in range(1, len(route)-1)]\n            max_dist_idx = np.argmax(distances) + 1\n            customer = route[max_dist_idx]\n            # Find alternative route\n            best_route_idx = -1\n            best_insert_pos = -1\n            best_score = -float('inf')\n            for j in range(len(final_solution)):\n                if j == i:\n                    continue\n                target_route = final_solution[j]\n                if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                    continue\n                for pos in range(1, len(target_route)):\n                    score = -distance_matrix[target_route[pos-1], customer] - distance_matrix[customer, target_route[pos]]\n                    if score > best_score:\n                        best_score = score\n                        best_route_idx = j\n                        best_insert_pos = pos\n            if best_route_idx != -1:\n                final_solution[best_route_idx] = np.insert(final_solution[best_route_idx], best_insert_pos, customer)\n                final_solution[i] = np.delete(route, max_dist_idx)\n                route = final_solution[i]\n            else:\n                break\n\n    return final_solution if final_solution else new_solution\n\n",
        "score": [
            -0.781385516337251,
            3.209080845117569
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [0.3 * obj[0] / archive[0][1][0] + 0.7 * obj[1] / archive[0][1][1] for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.exp(-np.array(scores)) / np.sum(np.exp(-np.array(scores))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Spatial-cluster-based local search\n    all_customers = []\n    for route in new_solution:\n        all_customers.extend(route[1:-1])\n    if not all_customers:\n        return new_solution\n\n    # Dynamic clustering based on spatial proximity and demand patterns\n    from sklearn.cluster import KMeans\n    n_clusters = min(5, len(all_customers))\n    if n_clusters < 2:\n        return new_solution\n\n    cluster_data = np.column_stack((coords[all_customers], demand[all_customers]))\n    kmeans = KMeans(n_clusters=n_clusters, random_state=42).fit(cluster_data)\n    clusters = [[] for _ in range(n_clusters)]\n    for i, label in enumerate(kmeans.labels_):\n        clusters[label].append(all_customers[i])\n\n    # Adaptive route restructuring\n    temp_solution = []\n    for cluster in clusters:\n        if not cluster:\n            continue\n        cluster_demand = sum(demand[cluster])\n        if cluster_demand > capacity:\n            # Split large clusters\n            cluster.sort(key=lambda x: coords[x, 0] + coords[x, 1])\n            current_demand = 0\n            current_cluster = []\n            for node in cluster:\n                if current_demand + demand[node] <= capacity:\n                    current_cluster.append(node)\n                    current_demand += demand[node]\n                else:\n                    if current_cluster:\n                        temp_solution.append(np.concatenate([[0], current_cluster, [0]]))\n                    current_cluster = [node]\n                    current_demand = demand[node]\n            if current_cluster:\n                temp_solution.append(np.concatenate([[0], current_cluster, [0]]))\n        else:\n            temp_solution.append(np.concatenate([[0], cluster, [0]]))\n\n    # Merge small routes if possible\n    final_solution = []\n    for route in temp_solution:\n        if len(route) <= 3:\n            if final_solution:\n                last_route = final_solution[-1]\n                if sum(demand[last_route[1:-1]]) + sum(demand[route[1:-1]]) <= capacity:\n                    merged = np.concatenate([last_route[:-1], route[1:]])\n                    final_solution[-1] = merged\n                    continue\n            else:\n                final_solution.append(route)\n        else:\n            final_solution.append(route)\n\n    # Final capacity check and adjustment\n    for i in range(len(final_solution)):\n        route = final_solution[i]\n        while sum(demand[route[1:-1]]) > capacity:\n            # Find the most distant customer to remove\n            distances = [distance_matrix[route[j], route[j+1]] for j in range(1, len(route)-1)]\n            max_dist_idx = np.argmax(distances) + 1\n            customer = route[max_dist_idx]\n            # Find alternative route\n            best_route_idx = -1\n            best_insert_pos = -1\n            best_score = -float('inf')\n            for j in range(len(final_solution)):\n                if j == i:\n                    continue\n                target_route = final_solution[j]\n                if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                    continue\n                for pos in range(1, len(target_route)):\n                    score = -distance_matrix[target_route[pos-1], customer] - distance_matrix[customer, target_route[pos]]\n                    if score > best_score:\n                        best_score = score\n                        best_route_idx = j\n                        best_insert_pos = pos\n            if best_route_idx != -1:\n                final_solution[best_route_idx] = np.insert(final_solution[best_route_idx], best_insert_pos, customer)\n                final_solution[i] = np.delete(route, max_dist_idx)\n                route = final_solution[i]\n            else:\n                break\n\n    return final_solution if final_solution else new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm employs a multi-phase approach combining adaptive route fragmentation, probabilistic customer redistribution, and dynamic route consolidation to restructure solutions while balancing distance and makespan through adaptive perturbation probabilities and capacity-aware merging strategies.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + 0.4 * obj[0] + 0.6 * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        split_pos = random.randint(1, len(route) - 2)\n        first_part = route[:split_pos + 1]\n        second_part = route[split_pos:]\n\n        if np.sum(demand[first_part[1:-1]]) > capacity or np.sum(demand[second_part[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = first_part\n        new_solution.insert(route_idx + 1, second_part)\n\n    for _ in range(4):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        customer_idx = random.randint(1, len(route) - 2)\n        customer = route[customer_idx]\n\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        if target_route_idx == route_idx:\n            continue\n\n        target_route = new_solution[target_route_idx]\n\n        if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n            continue\n\n        insert_pos = random.randint(1, len(target_route) - 1)\n        new_target_route = np.insert(target_route, insert_pos, customer)\n        new_route = np.delete(route, customer_idx)\n\n        new_solution[route_idx] = new_route\n        new_solution[target_route_idx] = new_target_route\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 10:\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of normalized total distance and makespan, then applies a hybrid local search combining route decomposition with adaptive demand balancing, spatial-aware customer reinsertion, and dynamic route merging, while prioritizing solutions with lower makespan to improve the longest route.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.3 + (makespans / np.max(makespans)) * 0.7\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            if total_demand <= 2 * capacity:\n                split_pos = len(route1) // 2 if len(route1) > len(route2) else len(route2) // 2\n                split_route = route1 if len(route1) > len(route2) else route2\n                new_route1 = np.concatenate([[0], split_route[1:split_pos], [0]])\n                new_route2 = np.concatenate([[0], split_route[split_pos:-1], [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    if len(route1) > len(route2):\n                        new_solution[route1_idx] = new_route1\n                        new_solution.insert(route1_idx + 1, new_route2)\n                    else:\n                        new_solution[route2_idx] = new_route1\n                        new_solution.insert(route2_idx + 1, new_route2)\n                    continue\n\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_score = -float('inf')\n\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n\n                    target_route = new_solution[i]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n\n                        spatial_score = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node]) / distance_matrix[prev_node, next_node]\n\n                        demand_score = (capacity - sum(demand[target_route[1:-1]])) / capacity\n\n                        total_score = spatial_score * 0.5 + demand_score * 0.5\n\n                        if total_score > best_score:\n                            best_score = total_score\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                if best_route_idx != -1:\n                    target_route = new_solution[best_route_idx]\n                    new_target_route = np.insert(target_route, best_insert_pos, customer)\n                    new_solution[best_route_idx] = new_target_route\n\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            combined_demand = demand1 + demand2\n\n            if combined_demand <= capacity:\n                route1_last = route1[-2]\n                route2_first = route2[1]\n                route2_last = route2[-2]\n\n                original_dist = (distance_matrix[route1_last, 0] +\n                               distance_matrix[0, route2_first] +\n                               distance_matrix[route2_last, 0])\n\n                merged_dist = (distance_matrix[route1_last, route2_first] +\n                             distance_matrix[route2_last, 0])\n\n                if merged_dist < original_dist:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{This algorithm combines adaptive route segmentation with spatial clustering and demand-aware customer reassignment, using a multi-stage optimization process that prioritizes both distance reduction and makespan minimization through geometric pattern analysis and capacity-constrained swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        centroids = []\n        for sol, _ in archive:\n            route_coords = [coords[route[1:-1]] for route in sol]\n            if route_coords:\n                cluster_center = np.mean(np.concatenate(route_coords), axis=0)\n                centroids.append(cluster_center)\n            else:\n                centroids.append(np.zeros(2))\n\n        centroids = np.array(centroids)\n        centroid_distances = np.linalg.norm(centroids[:, None] - centroids, axis=2)\n        diversity_weights = np.mean(centroid_distances, axis=1)\n\n        obj_weights = np.array([0.4 * obj[0] + 0.6 * obj[1] for _, obj in archive])\n        combined_weights = diversity_weights / (obj_weights + 1e-6)\n        combined_weights = combined_weights / np.sum(combined_weights)\n\n        selected_idx = np.random.choice(len(archive), p=combined_weights)\n        base_solution, _ = archive[selected_idx]\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Adaptive route segmentation\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Select longest route with high spatial variance\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        route_variances = []\n        for route in new_solution:\n            route_coords = coords[route[1:-1]]\n            if len(route_coords) > 1:\n                route_variances.append(np.max(np.linalg.norm(route_coords - np.mean(route_coords, axis=0), axis=1)))\n            else:\n                route_variances.append(0)\n\n        combined_scores = [l * v for l, v in zip(route_lengths, route_variances)]\n        if not combined_scores:\n            break\n\n        route_idx = np.argmax(combined_scores)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        # Find optimal split point based on demand balance and spatial separation\n        best_split = 1\n        best_balance = float('inf')\n\n        for split in range(1, len(route)-1):\n            first_part = route[:split+1]\n            second_part = route[split:]\n\n            demand1 = np.sum(demand[first_part[1:-1]])\n            demand2 = np.sum(demand[second_part[1:-1]])\n\n            spatial_dist = np.linalg.norm(coords[first_part[-2]] - coords[second_part[1]])\n            balance = abs(demand1 - demand2) + 0.5 * spatial_dist\n\n            if balance < best_balance and demand1 <= capacity and demand2 <= capacity:\n                best_balance = balance\n                best_split = split\n\n        if best_balance < float('inf'):\n            new_solution[route_idx] = route[:best_split+1]\n            new_solution.insert(route_idx + 1, route[best_split:])\n\n    # Phase 2: Demand-aware customer reassignment\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        # Select customers with high demand and spatial isolation\n        all_customers = []\n        for route in new_solution:\n            all_customers.extend(route[1:-1])\n\n        if not all_customers:\n            break\n\n        customer_scores = []\n        for cust in all_customers:\n            # Demand score\n            demand_score = demand[cust] / capacity\n\n            # Spatial score (distance to nearest neighbor)\n            distances = distance_matrix[cust, all_customers]\n            distances[distances == 0] = float('inf')\n            spatial_score = np.min(distances) / np.max(distance_matrix)\n\n            customer_scores.append(demand_score + 0.5 * spatial_score)\n\n        if not customer_scores:\n            break\n\n        selected_cust = all_customers[np.argmax(customer_scores)]\n\n        # Find best route to reassign to\n        best_route_idx = -1\n        best_position = -1\n        best_score = -float('inf')\n\n        for i, route in enumerate(new_solution):\n            if selected_cust in route:\n                original_route = route.copy()\n                original_pos = np.where(route == selected_cust)[0][0]\n                original_route = np.delete(original_route, original_pos)\n\n                if len(original_route) > 2:\n                    new_solution[i] = original_route\n                else:\n                    del new_solution[i]\n                    break\n\n            for pos in range(1, len(route)):\n                prev_node = route[pos-1]\n                next_node = route[pos]\n\n                current_demand = np.sum(demand[route[1:-1]])\n                new_demand = current_demand + demand[selected_cust]\n\n                if new_demand > capacity:\n                    continue\n\n                # Calculate insertion score\n                dist_saving = (distance_matrix[prev_node, selected_cust] +\n                              distance_matrix[selected_cust, next_node] -\n                              distance_matrix[prev_node, next_node])\n\n                demand_util = new_demand / capacity\n                spatial_score = 1 - (distance_matrix[prev_node, selected_cust] +\n                                   distance_matrix[selected_cust, next_node]) / np.max(distance_matrix)\n\n                total_score = -dist_saving + 0.3 * demand_util + 0.2 * spatial_score\n\n                if total_score < best_score:\n                    best_score = total_score\n                    best_route_idx = i\n                    best_position = pos\n\n        if best_route_idx != -1:\n            target_route = new_solution[best_route_idx]\n            new_route = np.insert(target_route, best_position, selected_cust)\n            new_solution[best_route_idx] = new_route\n\n    # Phase 3: Dynamic route merging\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Select routes with high spatial proximity and complementary demands\n        if len(new_solution) < 2:\n            break\n\n        route_centers = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                center = np.mean(route_coords, axis=0)\n            else:\n                center = np.zeros(2)\n            route_centers.append(center)\n\n        route_centers = np.array(route_centers)\n        centroid_distances = np.linalg.norm(route_centers[:, None] - route_centers, axis=2)\n\n        best_pair = None\n        best_score = float('inf')\n\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1, route2 = new_solution[i], new_solution[j]\n\n                demand1 = np.sum(demand[route1[1:-1]])\n                demand2 = np.sum(demand[route2[1:-1]])\n\n                if demand1 + demand2 > capacity:\n                    continue\n\n                spatial_dist = centroid_distances[i, j]\n                if spatial_dist == 0:\n                    spatial_dist = 1e-6\n\n                score = (demand1 + demand2) / capacity + 0.5 * spatial_dist\n\n                if score < best_score:\n                    best_score = score\n                    best_pair = (i, j)\n\n        if best_pair:\n            i, j = best_pair\n            route1, route2 = new_solution[i], new_solution[j]\n\n            # Find optimal merge point based on spatial proximity\n            best_pos1 = 0\n            best_pos2 = 0\n            best_dist = float('inf')\n\n            for pos1 in range(1, len(route1)):\n                for pos2 in range(1, len(route2)):\n                    dist = distance_matrix[route1[pos1-1], route2[pos2]]\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_pos1 = pos1\n                        best_pos2 = pos2\n\n            merged_route = np.concatenate([route1[:best_pos1], route2[best_pos2:], route2[:best_pos2], route1[best_pos1:]])\n            merged_route = np.unique(merged_route, axis=0)\n            merged_route = np.insert(merged_route, 0, 0)\n            merged_route = np.append(merged_route, 0)\n\n            new_solution.pop(max(i, j))\n            new_solution.pop(min(i, j))\n            new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7792040697360035,
            10.552066028118134
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    if len(archive) > 1:\n        centroids = []\n        for sol, _ in archive:\n            route_coords = [coords[route[1:-1]] for route in sol]\n            if route_coords:\n                cluster_center = np.mean(np.concatenate(route_coords), axis=0)\n                centroids.append(cluster_center)\n            else:\n                centroids.append(np.zeros(2))\n\n        centroids = np.array(centroids)\n        centroid_distances = np.linalg.norm(centroids[:, None] - centroids, axis=2)\n        diversity_weights = np.mean(centroid_distances, axis=1)\n\n        obj_weights = np.array([0.4 * obj[0] + 0.6 * obj[1] for _, obj in archive])\n        combined_weights = diversity_weights / (obj_weights + 1e-6)\n        combined_weights = combined_weights / np.sum(combined_weights)\n\n        selected_idx = np.random.choice(len(archive), p=combined_weights)\n        base_solution, _ = archive[selected_idx]\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Phase 1: Adaptive route segmentation\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Select longest route with high spatial variance\n        route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n        route_variances = []\n        for route in new_solution:\n            route_coords = coords[route[1:-1]]\n            if len(route_coords) > 1:\n                route_variances.append(np.max(np.linalg.norm(route_coords - np.mean(route_coords, axis=0), axis=1)))\n            else:\n                route_variances.append(0)\n\n        combined_scores = [l * v for l, v in zip(route_lengths, route_variances)]\n        if not combined_scores:\n            break\n\n        route_idx = np.argmax(combined_scores)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        # Find optimal split point based on demand balance and spatial separation\n        best_split = 1\n        best_balance = float('inf')\n\n        for split in range(1, len(route)-1):\n            first_part = route[:split+1]\n            second_part = route[split:]\n\n            demand1 = np.sum(demand[first_part[1:-1]])\n            demand2 = np.sum(demand[second_part[1:-1]])\n\n            spatial_dist = np.linalg.norm(coords[first_part[-2]] - coords[second_part[1]])\n            balance = abs(demand1 - demand2) + 0.5 * spatial_dist\n\n            if balance < best_balance and demand1 <= capacity and demand2 <= capacity:\n                best_balance = balance\n                best_split = split\n\n        if best_balance < float('inf'):\n            new_solution[route_idx] = route[:best_split+1]\n            new_solution.insert(route_idx + 1, route[best_split:])\n\n    # Phase 2: Demand-aware customer reassignment\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        # Select customers with high demand and spatial isolation\n        all_customers = []\n        for route in new_solution:\n            all_customers.extend(route[1:-1])\n\n        if not all_customers:\n            break\n\n        customer_scores = []\n        for cust in all_customers:\n            # Demand score\n            demand_score = demand[cust] / capacity\n\n            # Spatial score (distance to nearest neighbor)\n            distances = distance_matrix[cust, all_customers]\n            distances[distances == 0] = float('inf')\n            spatial_score = np.min(distances) / np.max(distance_matrix)\n\n            customer_scores.append(demand_score + 0.5 * spatial_score)\n\n        if not customer_scores:\n            break\n\n        selected_cust = all_customers[np.argmax(customer_scores)]\n\n        # Find best route to reassign to\n        best_route_idx = -1\n        best_position = -1\n        best_score = -float('inf')\n\n        for i, route in enumerate(new_solution):\n            if selected_cust in route:\n                original_route = route.copy()\n                original_pos = np.where(route == selected_cust)[0][0]\n                original_route = np.delete(original_route, original_pos)\n\n                if len(original_route) > 2:\n                    new_solution[i] = original_route\n                else:\n                    del new_solution[i]\n                    break\n\n            for pos in range(1, len(route)):\n                prev_node = route[pos-1]\n                next_node = route[pos]\n\n                current_demand = np.sum(demand[route[1:-1]])\n                new_demand = current_demand + demand[selected_cust]\n\n                if new_demand > capacity:\n                    continue\n\n                # Calculate insertion score\n                dist_saving = (distance_matrix[prev_node, selected_cust] +\n                              distance_matrix[selected_cust, next_node] -\n                              distance_matrix[prev_node, next_node])\n\n                demand_util = new_demand / capacity\n                spatial_score = 1 - (distance_matrix[prev_node, selected_cust] +\n                                   distance_matrix[selected_cust, next_node]) / np.max(distance_matrix)\n\n                total_score = -dist_saving + 0.3 * demand_util + 0.2 * spatial_score\n\n                if total_score < best_score:\n                    best_score = total_score\n                    best_route_idx = i\n                    best_position = pos\n\n        if best_route_idx != -1:\n            target_route = new_solution[best_route_idx]\n            new_route = np.insert(target_route, best_position, selected_cust)\n            new_solution[best_route_idx] = new_route\n\n    # Phase 3: Dynamic route merging\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Select routes with high spatial proximity and complementary demands\n        if len(new_solution) < 2:\n            break\n\n        route_centers = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                center = np.mean(route_coords, axis=0)\n            else:\n                center = np.zeros(2)\n            route_centers.append(center)\n\n        route_centers = np.array(route_centers)\n        centroid_distances = np.linalg.norm(route_centers[:, None] - route_centers, axis=2)\n\n        best_pair = None\n        best_score = float('inf')\n\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1, route2 = new_solution[i], new_solution[j]\n\n                demand1 = np.sum(demand[route1[1:-1]])\n                demand2 = np.sum(demand[route2[1:-1]])\n\n                if demand1 + demand2 > capacity:\n                    continue\n\n                spatial_dist = centroid_distances[i, j]\n                if spatial_dist == 0:\n                    spatial_dist = 1e-6\n\n                score = (demand1 + demand2) / capacity + 0.5 * spatial_dist\n\n                if score < best_score:\n                    best_score = score\n                    best_pair = (i, j)\n\n        if best_pair:\n            i, j = best_pair\n            route1, route2 = new_solution[i], new_solution[j]\n\n            # Find optimal merge point based on spatial proximity\n            best_pos1 = 0\n            best_pos2 = 0\n            best_dist = float('inf')\n\n            for pos1 in range(1, len(route1)):\n                for pos2 in range(1, len(route2)):\n                    dist = distance_matrix[route1[pos1-1], route2[pos2]]\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_pos1 = pos1\n                        best_pos2 = pos2\n\n            merged_route = np.concatenate([route1[:best_pos1], route2[best_pos2:], route2[:best_pos2], route1[best_pos1:]])\n            merged_route = np.unique(merged_route, axis=0)\n            merged_route = np.insert(merged_route, 0, 0)\n            merged_route = np.append(merged_route, 0)\n\n            new_solution.pop(max(i, j))\n            new_solution.pop(min(i, j))\n            new_solution.append(merged_route)\n\n    return new_solution\n\n"
    }
]