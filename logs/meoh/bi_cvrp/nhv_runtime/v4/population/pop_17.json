[
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a normalized score combining total distance and makespan, then applies a hybrid local search combining route merging, customer reinsertion, and adaptive 3-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) + (makespans / np.max(makespans))\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, customer reinsertion, and adaptive 3-opt\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route merging: merge two routes if their combined demand is within capacity\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n            if combined_demand <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n                continue\n\n        # Customer reinsertion: remove a customer and reinsert it into another route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Find feasible insertion positions in other routes\n            feasible_routes = []\n            for i, other_route in enumerate(new_solution):\n                if i != route_idx and sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    feasible_routes.append(i)\n\n            if feasible_routes:\n                insert_route_idx = random.choice(feasible_routes)\n                insert_pos = random.randint(1, len(new_solution[insert_route_idx]) - 1)\n\n                # Insert customer into the selected route\n                new_route = np.insert(new_solution[insert_route_idx], insert_pos, customer)\n                new_solution[insert_route_idx] = new_route\n\n                # Remove customer from the original route\n                new_route = np.delete(route, customer_pos)\n                if len(new_route) > 2:\n                    new_solution[route_idx] = new_route\n                else:\n                    del new_solution[route_idx]\n\n        # Adaptive 3-opt: perform a limited number of 3-opt swaps\n        if len(route) > 4:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.853243689215822,
            0.2600117027759552
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined score of total distance and makespan, then applies a novel hybrid local search combining route decomposition with adaptive demand balancing, spatial-aware customer reinsertion, and dynamic route merging to simultaneously optimize both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route decomposition, spatial-aware reinsertion, and dynamic merging\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route decomposition with adaptive demand balancing\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Calculate demand distributions\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            total_demand = demand1 + demand2\n\n            # Split based on demand balance\n            if total_demand <= 2 * capacity:\n                split_pos = len(route1) // 2 if len(route1) > len(route2) else len(route2) // 2\n                split_route = route1 if len(route1) > len(route2) else route2\n                new_route1 = np.concatenate([[0], split_route[1:split_pos], [0]])\n                new_route2 = np.concatenate([[0], split_route[split_pos:-1], [0]])\n\n                if (sum(demand[new_route1[1:-1]]) <= capacity and\n                    sum(demand[new_route2[1:-1]]) <= capacity):\n                    if len(route1) > len(route2):\n                        new_solution[route1_idx] = new_route1\n                        new_solution.insert(route1_idx + 1, new_route2)\n                    else:\n                        new_solution[route2_idx] = new_route1\n                        new_solution.insert(route2_idx + 1, new_route2)\n                    continue\n\n        # Spatial-aware customer reinsertion\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Find best insertion position based on spatial proximity and demand\n                best_route_idx = -1\n                best_insert_pos = -1\n                best_score = -float('inf')\n\n                for i in range(len(new_solution)):\n                    if i == route_idx:\n                        continue\n\n                    target_route = new_solution[i]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                        continue\n\n                    for pos in range(1, len(target_route)):\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n\n                        # Calculate spatial and demand-based score\n                        spatial_score = (distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] -\n                                       distance_matrix[prev_node, next_node]) / distance_matrix[prev_node, next_node]\n\n                        demand_score = (capacity - sum(demand[target_route[1:-1]])) / capacity\n\n                        total_score = spatial_score * 0.7 + demand_score * 0.3\n\n                        if total_score > best_score:\n                            best_score = total_score\n                            best_route_idx = i\n                            best_insert_pos = pos\n\n                if best_route_idx != -1:\n                    target_route = new_solution[best_route_idx]\n                    new_target_route = np.insert(target_route, best_insert_pos, customer)\n                    new_solution[best_route_idx] = new_target_route\n\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Dynamic route merging\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            # Calculate demand and distance metrics\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n            combined_demand = demand1 + demand2\n\n            if combined_demand <= capacity:\n                # Calculate distance savings\n                route1_last = route1[-2]\n                route2_first = route2[1]\n                route2_last = route2[-2]\n\n                original_dist = (distance_matrix[route1_last, 0] +\n                               distance_matrix[0, route2_first] +\n                               distance_matrix[route2_last, 0])\n\n                merged_dist = (distance_matrix[route1_last, route2_first] +\n                             distance_matrix[route2_last, 0])\n\n                if merged_dist < original_dist:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[route1_idx] = merged_route\n                    del new_solution[route2_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9537671508982641,
            0.2979012727737427
        ]
    },
    {
        "algorithm": "{This novel algorithm combines adaptive route clustering and dynamic customer rebalancing with a probabilistic swap mechanism to intelligently restructure solutions while maintaining feasibility and exploring trade-offs between distance and makespan through guided perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + obj[0] * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        cluster_size = random.randint(2, min(5, len(route) - 2))\n        cluster_pos = random.randint(1, len(route) - cluster_size - 1)\n\n        cluster = route[cluster_pos:cluster_pos + cluster_size]\n        remaining_route = np.concatenate((route[:cluster_pos], route[cluster_pos + cluster_size:]))\n\n        if np.sum(demand[remaining_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = remaining_route\n\n        for _ in range(2):\n            target_route_idx = random.randint(0, len(new_solution) - 1)\n            if target_route_idx == route_idx:\n                continue\n\n            target_route = new_solution[target_route_idx]\n\n            if np.sum(demand[target_route[1:-1]]) + np.sum(demand[cluster]) > capacity:\n                continue\n\n            insert_pos = random.randint(1, len(target_route) - 1)\n            new_target_route = np.insert(target_route, insert_pos, cluster)\n\n            new_solution[target_route_idx] = new_target_route\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 10:\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        swap_pos1 = random.randint(1, len(route) - 3)\n        swap_pos2 = random.randint(swap_pos1 + 1, len(route) - 2)\n\n        new_route = route.copy()\n        new_route[swap_pos1], new_route[swap_pos2] = new_route[swap_pos2], new_route[swap_pos1]\n\n        if np.sum(demand[new_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.8377483251160325,
            0.13107585906982422
        ]
    },
    {
        "algorithm": "{This algorithm employs a hybrid approach of route decomposition, probabilistic insertion, and adaptive customer redistribution to generate high-quality neighbors by intelligently redistributing customers across routes while maintaining feasibility and exploring the trade-off between distance and makespan through guided perturbations, using a combination of split, merge, and relocation operations with probabilistic selection based on capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        split_pos = random.randint(1, len(route) - 2)\n        first_part = route[:split_pos + 1]\n        second_part = route[split_pos:]\n\n        if np.sum(demand[first_part[1:-1]]) > capacity or np.sum(demand[second_part[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = first_part\n        new_solution.insert(route_idx + 1, second_part)\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 10:\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        customer_pos = random.randint(1, len(route) - 2)\n        customer = route[customer_pos]\n\n        remaining_route = np.concatenate((route[:customer_pos], route[customer_pos + 1:]))\n\n        if np.sum(demand[remaining_route[1:-1]]) > capacity:\n            continue\n\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        if target_route_idx == route_idx:\n            continue\n\n        target_route = new_solution[target_route_idx]\n\n        if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n            continue\n\n        insert_pos = random.randint(1, len(target_route) - 1)\n        new_target_route = np.insert(target_route, insert_pos, customer)\n\n        new_solution[route_idx] = remaining_route\n        new_solution[target_route_idx] = new_target_route\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        pos1 = random.randint(1, len(route) - 3)\n        pos2 = random.randint(pos1 + 1, len(route) - 2)\n\n        new_route = route.copy()\n        new_route[pos1], new_route[pos2] = new_route[pos2], new_route[pos1]\n\n        if np.sum(demand[new_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.8311055738578959,
            0.09319069981575012
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines route decomposition with adaptive demand balancing and spatial-aware customer reinsertion to simultaneously optimize total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Route decomposition with demand balancing\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Sort customers by demand in descending order\n        customers = route[1:-1]\n        sorted_indices = np.argsort(demand[customers])[::-1]\n        sorted_customers = customers[sorted_indices]\n\n        # Split into two routes with balanced demand\n        split_pos = len(sorted_customers) // 2\n        route1_customers = sorted_customers[:split_pos]\n        route2_customers = sorted_customers[split_pos:]\n\n        # Create new routes\n        route1 = np.concatenate([[0], route1_customers, [0]])\n        route2 = np.concatenate([[0], route2_customers, [0]])\n\n        # Check feasibility\n        if (np.sum(demand[route1_customers]) <= capacity and\n            np.sum(demand[route2_customers]) <= capacity):\n            new_solution[i] = route1\n            new_solution.insert(i+1, route2)\n            break\n\n    # Spatial-aware customer reinsertion\n    for _ in range(3):\n        # Select a random route to modify\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        # Select a random customer to reinsert\n        customer_pos = random.randint(1, len(route)-2)\n        customer = route[customer_pos]\n\n        # Find the most spatially compatible route for insertion\n        best_route_idx = -1\n        best_insert_pos = -1\n        best_distance_savings = -float('inf')\n\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue\n\n            target_route = new_solution[i]\n            if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Find best insertion position based on spatial proximity\n            min_distance = float('inf')\n            best_pos = -1\n\n            for pos in range(1, len(target_route)):\n                # Calculate distance savings if inserted here\n                prev_node = target_route[pos-1]\n                next_node = target_route[pos]\n                original_dist = distance_matrix[prev_node, next_node]\n                new_dist = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node]\n                savings = original_dist - new_dist\n\n                if savings > best_distance_savings:\n                    best_distance_savings = savings\n                    best_route_idx = i\n                    best_insert_pos = pos\n\n        if best_route_idx != -1:\n            # Perform the reinsertion\n            target_route = new_solution[best_route_idx]\n            new_target_route = np.insert(target_route, best_insert_pos, customer)\n            new_solution[best_route_idx] = new_target_route\n\n            # Remove from original route\n            new_route = np.delete(route, customer_pos)\n            new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.9227661053493067,
            0.7142148911952972
        ]
    },
    {
        "algorithm": "{This algorithm employs a hybrid approach of adaptive route merging, probabilistic customer reallocation with capacity-aware insertion, and guided route splitting to create high-quality neighbors by intelligently redistributing customers while maintaining feasibility and exploring the trade-off between distance and makespan through capacity-balanced perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + obj[0] + 2 * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Adaptive route merging with capacity check\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Select two routes with high capacity utilization\n        route_weights = [np.sum(demand[route[1:-1]]) / capacity for route in new_solution]\n        route1_idx, route2_idx = random.choices(\n            range(len(new_solution)),\n            weights=route_weights,\n            k=2\n        )\n\n        if route1_idx == route2_idx:\n            continue\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Merge routes if their combined demand is within capacity\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n            merged_route = np.insert(merged_route, 0, 0)\n            merged_route = np.append(merged_route, 0)\n\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n\n    # Probabilistic customer reallocation with capacity-aware insertion\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        # Select a route with high capacity utilization\n        route_weights = [np.sum(demand[route[1:-1]]) / capacity for route in new_solution]\n        route_idx = random.choices(\n            range(len(new_solution)),\n            weights=route_weights,\n            k=1\n        )[0]\n\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        # Select a customer to reallocate\n        customer_pos = random.randint(1, len(route) - 2)\n        customer = route[customer_pos]\n\n        # Find target routes with sufficient capacity\n        valid_targets = []\n        for i, target_route in enumerate(new_solution):\n            if i != route_idx and np.sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                valid_targets.append(i)\n\n        if not valid_targets:\n            continue\n\n        target_route_idx = random.choice(valid_targets)\n        target_route = new_solution[target_route_idx]\n\n        # Find insertion position that minimizes distance increase\n        min_increase = float('inf')\n        best_pos = 1\n        for pos in range(1, len(target_route)):\n            prev_node = target_route[pos - 1]\n            next_node = target_route[pos]\n            increase = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n            if increase < min_increase:\n                min_increase = increase\n                best_pos = pos\n\n        # Perform the reallocation\n        new_target_route = np.insert(target_route, best_pos, customer)\n        remaining_route = np.concatenate((route[:customer_pos], route[customer_pos + 1:]))\n\n        new_solution[route_idx] = remaining_route\n        new_solution[target_route_idx] = new_target_route\n\n    # Guided route splitting based on distance and demand balance\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Select a route with high makespan contribution\n        makespan_contributions = []\n        for route in new_solution:\n            route_distance = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n            makespan_contributions.append(route_distance)\n\n        route_weights = [contrib / sum(makespan_contributions) for contrib in makespan_contributions]\n        route_idx = random.choices(\n            range(len(new_solution)),\n            weights=route_weights,\n            k=1\n        )[0]\n\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        # Find split point that balances distance and demand\n        best_split = None\n        min_balance = float('inf')\n\n        for split_pos in range(2, len(route) - 2):\n            first_part = route[:split_pos + 1]\n            second_part = route[split_pos:]\n\n            demand_balance = abs(np.sum(demand[first_part[1:-1]]) - np.sum(demand[second_part[1:-1]]))\n            distance_balance = abs(\n                sum(distance_matrix[first_part[i], first_part[i+1]] for i in range(len(first_part)-1)) -\n                sum(distance_matrix[second_part[i], second_part[i+1]] for i in range(len(second_part)-1))\n            )\n\n            total_balance = demand_balance + distance_balance\n\n            if total_balance < min_balance:\n                min_balance = total_balance\n                best_split = split_pos\n\n        if best_split is not None:\n            first_part = route[:best_split + 1]\n            second_part = route[best_split:]\n\n            if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n                new_solution[route_idx] = first_part\n                new_solution.insert(route_idx + 1, second_part)\n\n    return new_solution\n\n",
        "score": [
            -0.8787906017480076,
            0.829309344291687
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a weighted score based on normalized total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2.5-opt moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (0.6 * (total_distances / np.max(total_distances))) + (0.4 * (makespans / np.max(makespans)))\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(4):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if it's too long relative to makespan\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 5:\n                split_pos = len(route) // 2\n                first_part = route[:split_pos + 1]\n                second_part = np.concatenate([[0], route[split_pos + 1:]])\n\n                if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n                    new_solution[route_idx] = first_part\n                    new_solution.insert(route_idx + 1, second_part)\n                    continue\n\n        # Customer reallocation: move a customer to another route if it reduces total distance\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                for i, other_route in enumerate(new_solution):\n                    if i != route_idx and sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        # Calculate potential new distance\n                        original_dist = distance_matrix[route[customer_pos - 1]][customer] + distance_matrix[customer][route[customer_pos + 1]]\n                        new_dist = distance_matrix[other_route[-2]][customer] + distance_matrix[customer][0]\n\n                        if new_dist < original_dist:\n                            # Insert into new route\n                            new_route = np.concatenate([other_route[:-1], [customer], [0]])\n                            new_solution[i] = new_route\n\n                            # Remove from original route\n                            new_route = np.delete(route, customer_pos)\n                            if len(new_route) > 2:\n                                new_solution[route_idx] = new_route\n                            else:\n                                del new_solution[route_idx]\n                            break\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (2-opt with one additional insertion)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], [route[k]], route[k:]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7779633815810102,
            0.09633633494377136
        ]
    },
    {
        "algorithm": "{This algorithm uses a combination of adaptive route segmentation, probabilistic customer reallocation, and capacity-aware route merging to create high-quality neighbors by dynamically balancing route lengths and customer assignments while respecting capacity constraints and exploring the trade-off between distance and makespan through guided perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + obj[0] * 0.7 + obj[1] * 0.3) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        split_pos = random.randint(2, len(route) - 3)\n        first_part = route[:split_pos + 1]\n        second_part = route[split_pos:]\n\n        if np.sum(demand[first_part[1:-1]]) > capacity or np.sum(demand[second_part[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = first_part\n        new_solution.insert(route_idx + 1, second_part)\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        customer_pos = random.randint(1, len(route) - 2)\n        customer = route[customer_pos]\n\n        remaining_route = np.concatenate((route[:customer_pos], route[customer_pos + 1:]))\n\n        if np.sum(demand[remaining_route[1:-1]]) > capacity:\n            continue\n\n        target_route_idx = random.randint(0, len(new_solution) - 1)\n        if target_route_idx == route_idx:\n            continue\n\n        target_route = new_solution[target_route_idx]\n\n        if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n            continue\n\n        insert_pos = random.randint(1, len(target_route) - 1)\n        new_target_route = np.insert(target_route, insert_pos, customer)\n\n        new_solution[route_idx] = remaining_route\n        new_solution[target_route_idx] = new_target_route\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 10:\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        pos1 = random.randint(1, len(route) - 3)\n        pos2 = random.randint(pos1 + 1, len(route) - 2)\n\n        new_route = route.copy()\n        new_route[pos1], new_route[pos2] = new_route[pos2], new_route[pos1]\n\n        if np.sum(demand[new_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.8258308123891142,
            0.10760411620140076
        ]
    }
]