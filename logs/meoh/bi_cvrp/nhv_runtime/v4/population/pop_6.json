[
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a normalized score combining total distance and makespan, then applies a hybrid local search combining route merging, customer reinsertion, and adaptive 3-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) + (makespans / np.max(makespans))\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, customer reinsertion, and adaptive 3-opt\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route merging: merge two routes if their combined demand is within capacity\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n            if combined_demand <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n                continue\n\n        # Customer reinsertion: remove a customer and reinsert it into another route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Find feasible insertion positions in other routes\n            feasible_routes = []\n            for i, other_route in enumerate(new_solution):\n                if i != route_idx and sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    feasible_routes.append(i)\n\n            if feasible_routes:\n                insert_route_idx = random.choice(feasible_routes)\n                insert_pos = random.randint(1, len(new_solution[insert_route_idx]) - 1)\n\n                # Insert customer into the selected route\n                new_route = np.insert(new_solution[insert_route_idx], insert_pos, customer)\n                new_solution[insert_route_idx] = new_route\n\n                # Remove customer from the original route\n                new_route = np.delete(route, customer_pos)\n                if len(new_route) > 2:\n                    new_solution[route_idx] = new_route\n                else:\n                    del new_solution[route_idx]\n\n        # Adaptive 3-opt: perform a limited number of 3-opt swaps\n        if len(route) > 4:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.853243689215822,
            0.2600117027759552
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines route decomposition with adaptive demand balancing and spatial-aware customer reinsertion to simultaneously optimize total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Route decomposition with demand balancing\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Sort customers by demand in descending order\n        customers = route[1:-1]\n        sorted_indices = np.argsort(demand[customers])[::-1]\n        sorted_customers = customers[sorted_indices]\n\n        # Split into two routes with balanced demand\n        split_pos = len(sorted_customers) // 2\n        route1_customers = sorted_customers[:split_pos]\n        route2_customers = sorted_customers[split_pos:]\n\n        # Create new routes\n        route1 = np.concatenate([[0], route1_customers, [0]])\n        route2 = np.concatenate([[0], route2_customers, [0]])\n\n        # Check feasibility\n        if (np.sum(demand[route1_customers]) <= capacity and\n            np.sum(demand[route2_customers]) <= capacity):\n            new_solution[i] = route1\n            new_solution.insert(i+1, route2)\n            break\n\n    # Spatial-aware customer reinsertion\n    for _ in range(3):\n        # Select a random route to modify\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        # Select a random customer to reinsert\n        customer_pos = random.randint(1, len(route)-2)\n        customer = route[customer_pos]\n\n        # Find the most spatially compatible route for insertion\n        best_route_idx = -1\n        best_insert_pos = -1\n        best_distance_savings = -float('inf')\n\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue\n\n            target_route = new_solution[i]\n            if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Find best insertion position based on spatial proximity\n            min_distance = float('inf')\n            best_pos = -1\n\n            for pos in range(1, len(target_route)):\n                # Calculate distance savings if inserted here\n                prev_node = target_route[pos-1]\n                next_node = target_route[pos]\n                original_dist = distance_matrix[prev_node, next_node]\n                new_dist = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node]\n                savings = original_dist - new_dist\n\n                if savings > best_distance_savings:\n                    best_distance_savings = savings\n                    best_route_idx = i\n                    best_insert_pos = pos\n\n        if best_route_idx != -1:\n            # Perform the reinsertion\n            target_route = new_solution[best_route_idx]\n            new_target_route = np.insert(target_route, best_insert_pos, customer)\n            new_solution[best_route_idx] = new_target_route\n\n            # Remove from original route\n            new_route = np.delete(route, customer_pos)\n            new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.9227661053493067,
            0.7142148911952972
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines route splitting and customer reallocation with a biased random walk to explore the solution space while balancing the trade-off between total distance and makespan, ensuring feasibility through capacity-aware transformations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + obj[0] * obj[1]) for _, obj in archive],  # Prefer solutions with better balance between objectives\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search operator: Route splitting and customer reallocation with biased random walk\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Step 1: Randomly select a route to split or modify\n        if len(new_solution) < 2:\n            break  # Need at least two routes to perform meaningful operations\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Step 2: Split the route into two parts at a random position\n        split_pos = random.randint(1, len(route) - 2)\n        new_route1 = route[:split_pos + 1]\n        new_route2 = [0] + route[split_pos:]\n\n        # Step 3: Check capacity feasibility for the new routes\n        def is_feasible(r):\n            return np.sum(demand[r[1:-1]]) <= capacity\n\n        if not is_feasible(new_route1) or not is_feasible(new_route2):\n            continue  # Skip if splitting violates capacity\n\n        # Replace the original route with the two new routes\n        new_solution.pop(route_idx)\n        new_solution.insert(route_idx, new_route2)\n        new_solution.insert(route_idx, new_route1)\n\n        # Step 4: Perform biased random walk to reallocate customers between routes\n        for _ in range(2):  # Limit the number of reallocations\n            # Select a random customer from a random route\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            from_route = new_solution[from_route_idx]\n            if len(from_route) <= 3:  # Skip if route is too short\n                continue\n\n            customer_pos = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_pos]\n\n            # Try to insert the customer into another route\n            to_route_idx = random.randint(0, len(new_solution) - 1)\n            if to_route_idx == from_route_idx:\n                continue  # Skip if same route\n\n            to_route = new_solution[to_route_idx]\n            if np.sum(demand[to_route[1:-1]]) + demand[customer] > capacity:\n                continue  # Skip if capacity is exceeded\n\n            # Insert the customer into the target route at a random position\n            insert_pos = random.randint(1, len(to_route) - 1)\n            new_route = np.insert(to_route, insert_pos, customer)\n\n            # Remove the customer from the original route\n            new_from_route = np.delete(from_route, customer_pos)\n\n            # Update the solution\n            new_solution[to_route_idx] = new_route\n            new_solution[from_route_idx] = new_from_route\n\n    return new_solution\n\n",
        "score": [
            -0.7939521796066197,
            0.13688308000564575
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines route merging and customer redistribution with a biased random walk to explore the solution space while balancing the trade-off between total distance and makespan, ensuring feasibility through capacity-aware transformations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + obj[0] * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        split_pos = random.randint(1, len(route) - 2)\n        new_route1 = route[:split_pos + 1]\n        new_route2 = [0] + route[split_pos:]\n\n        def is_feasible(r):\n            return np.sum(demand[r[1:-1]]) <= capacity\n\n        if not is_feasible(new_route1) or not is_feasible(new_route2):\n            continue\n\n        new_solution.pop(route_idx)\n        new_solution.insert(route_idx, new_route2)\n        new_solution.insert(route_idx, new_route1)\n\n        for _ in range(2):\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            from_route = new_solution[from_route_idx]\n            if len(from_route) <= 3:\n                continue\n\n            customer_pos = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_pos]\n\n            to_route_idx = random.randint(0, len(new_solution) - 1)\n            if to_route_idx == from_route_idx:\n                continue\n\n            to_route = new_solution[to_route_idx]\n            if np.sum(demand[to_route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            insert_pos = random.randint(1, len(to_route) - 1)\n            new_route = np.insert(to_route, insert_pos, customer)\n\n            new_from_route = np.delete(from_route, customer_pos)\n\n            new_solution[to_route_idx] = new_route\n            new_solution[from_route_idx] = new_from_route\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 10:\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7070146148070439,
            0.1301042139530182
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of distance and makespan, then applies a novel hybrid local search combining route merging, demand-balanced customer insertion, and adaptive route shortening to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [0.7 * obj[0] + 0.3 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, demand-balanced insertion, and adaptive shortening\n    for _ in range(2):  # Limit iterations\n        # Route merging: combine short routes if they fit capacity\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            if len(route1) + len(route2) - 4 <= 20:  # Limit merged route length\n                combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[j]\n                    continue\n\n        # Demand-balanced customer insertion: move customers between routes\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            if len(route1) > 3 and len(route2) > 3:\n                # Find customer with demand closest to average demand\n                avg_demand = (sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])) / (len(route1) + len(route2) - 4)\n                candidates = [c for c in route1[1:-1] if abs(demand[c] - avg_demand) < 0.3 * avg_demand]\n\n                if candidates:\n                    customer = random.choice(candidates)\n                    # Find best insertion in route2\n                    best_pos = 1\n                    min_cost = float('inf')\n                    for pos in range(1, len(route2)):\n                        cost = distance_matrix[route2[pos-1], customer] + distance_matrix[customer, route2[pos]] - distance_matrix[route2[pos-1], route2[pos]]\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Remove from route1\n                        new_route1 = np.delete(route1, np.where(route1 == customer)[0][0])\n                        if len(new_route1) > 2:\n                            new_solution[i] = new_route1\n                        else:\n                            del new_solution[i]\n\n                        # Insert into route2\n                        new_route2 = np.insert(route2, best_pos, customer)\n                        new_solution[j] = new_route2\n\n        # Adaptive route shortening: remove non-critical customers\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:\n                # Find customer with smallest demand\n                customers = route[1:-1]\n                min_demand_idx = np.argmin(demand[customers])\n                customer = customers[min_demand_idx]\n\n                # Check if removal is feasible\n                new_route = np.delete(route, np.where(route == customer)[0][0])\n                if len(new_route) > 2:\n                    new_solution[i] = new_route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.7563857408360191,
            0.3505585789680481
        ]
    },
    {
        "algorithm": "{This algorithm combines adaptive route clustering with spatial-aware customer redistribution, using a novel demand-aware distance metric to simultaneously optimize total distance and makespan while maintaining feasibility through iterative capacity-balanced route adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    normalized_scores = np.array([(obj[0]/max(1, np.max([o[0] for _, o in archive])) + obj[1]/max(1, np.max([o[1] for _, o in archive]))) for _, obj in archive])\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route clustering based on demand and spatial proximity\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Calculate demand-weighted centroids for each route\n        centroids = []\n        for route in new_solution:\n            customers = route[1:-1]\n            if len(customers) == 0:\n                centroids.append(coords[0])\n                continue\n            weighted_coords = np.average(coords[customers], axis=0, weights=demand[customers])\n            centroids.append(weighted_coords)\n\n        # Find the two most similar routes based on demand-weighted distance\n        min_distance = float('inf')\n        pair = (0, 1)\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route_i = new_solution[i]\n                route_j = new_solution[j]\n                dist = np.linalg.norm(centroids[i] - centroids[j])\n                demand_diff = abs(np.sum(demand[route_i[1:-1]]) - np.sum(demand[route_j[1:-1]]))\n                combined_demand = np.sum(demand[route_i[1:-1]]) + np.sum(demand[route_j[1:-1]])\n\n                if combined_demand <= capacity and dist < min_distance:\n                    min_distance = dist\n                    pair = (i, j)\n\n        # Merge the most similar routes\n        i, j = pair\n        route_i = new_solution[i]\n        route_j = new_solution[j]\n        merged_route = np.concatenate([route_i[:-1], route_j[1:]])\n        new_solution[i] = merged_route\n        del new_solution[j]\n\n    # Spatial-aware customer redistribution with demand balancing\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        # Select a route to redistribute customers from\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        # Calculate demand-weighted distance metric for each customer\n        customers = route[1:-1]\n        distances = []\n        for customer in customers:\n            # Distance to depot\n            dist_to_depot = distance_matrix[customer, 0]\n            # Average distance to other customers in the route\n            avg_dist = np.mean([distance_matrix[customer, other] for other in customers if other != customer])\n            # Demand-weighted metric\n            weighted_metric = (dist_to_depot + avg_dist) * demand[customer]\n            distances.append(weighted_metric)\n\n        # Sort customers by demand-weighted metric\n        sorted_customers = [x for _, x in sorted(zip(distances, customers), key=lambda pair: pair[0])]\n\n        # Try to redistribute customers to other routes\n        for customer in sorted_customers:\n            best_route_idx = -1\n            best_pos = -1\n            best_improvement = -float('inf')\n\n            for i in range(len(new_solution)):\n                if i == route_idx:\n                    continue\n\n                target_route = new_solution[i]\n                if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                # Find best insertion position based on demand-weighted distance metric\n                for pos in range(1, len(target_route)):\n                    prev_node = target_route[pos-1]\n                    next_node = target_route[pos]\n\n                    # Calculate improvement in demand-weighted distance metric\n                    original_dist = distance_matrix[prev_node, next_node]\n                    new_dist = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node]\n                    improvement = original_dist - new_dist\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_route_idx = i\n                        best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the redistribution\n                target_route = new_solution[best_route_idx]\n                new_target_route = np.insert(target_route, best_pos, customer)\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove from original route\n                customer_pos = np.where(route == customer)[0][0]\n                new_route = np.delete(route, customer_pos)\n                if len(new_route) > 2:\n                    new_solution[route_idx] = new_route\n                else:\n                    del new_solution[route_idx]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8414082895778254,
            4.528796285390854
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines spatial clustering of customers with adaptive route merging to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a deep copy of the solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Spatial clustering and adaptive route merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Find spatial clusters within the route\n        cluster_centers = []\n        for node in route[1:-1]:\n            cluster_centers.append(coords[node])\n\n        if len(cluster_centers) > 1:\n            # Perform simple spatial clustering (k-means with k=2 for demonstration)\n            from sklearn.cluster import KMeans\n            kmeans = KMeans(n_clusters=2, random_state=0).fit(cluster_centers)\n            labels = kmeans.labels_\n\n            # Split route based on clusters\n            cluster1_nodes = [route[1:-1][i] for i in range(len(route[1:-1])) if labels[i] == 0]\n            cluster2_nodes = [route[1:-1][i] for i in range(len(route[1:-1])) if labels[i] == 1]\n\n            # Create new routes if clusters are valid\n            if len(cluster1_nodes) > 0 and len(cluster2_nodes) > 0:\n                new_route1 = np.concatenate([[0], np.array(cluster1_nodes), [0]])\n                new_route2 = np.concatenate([[0], np.array(cluster2_nodes), [0]])\n\n                # Check feasibility\n                if (np.sum(demand[cluster1_nodes]) <= capacity and\n                    np.sum(demand[cluster2_nodes]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n    # Adaptive route merging: try to merge routes if beneficial\n    if len(new_solution) > 1:\n        # Find the two routes with the shortest connection between them\n        best_merge = None\n        best_merge_gain = 0\n\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Calculate potential merge gain\n                original_dist = (distance_matrix[route1[0], route1[-2]] +\n                                distance_matrix[route2[0], route2[-2]])\n\n                # Find best connection between routes\n                best_connection = float('inf')\n                for node1 in route1[1:-1]:\n                    for node2 in route2[1:-1]:\n                        connection_dist = distance_matrix[node1, node2]\n                        if connection_dist < best_connection:\n                            best_connection = connection_dist\n\n                if best_connection < float('inf'):\n                    total_gain = original_dist - best_connection\n                    if total_gain > best_merge_gain:\n                        # Check capacity constraint\n                        if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity):\n                            best_merge_gain = total_gain\n                            best_merge = (i, j)\n\n        if best_merge is not None:\n            i, j = best_merge\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Find best connection between routes\n            best_node1 = None\n            best_node2 = None\n            best_connection = float('inf')\n\n            for node1 in route1[1:-1]:\n                for node2 in route2[1:-1]:\n                    connection_dist = distance_matrix[node1, node2]\n                    if connection_dist < best_connection:\n                        best_connection = connection_dist\n                        best_node1 = node1\n                        best_node2 = node2\n\n            # Create merged route\n            pos1 = np.where(route1 == best_node1)[0][0]\n            pos2 = np.where(route2 == best_node2)[0][0]\n\n            # Merge routes by connecting at the best nodes\n            merged_route = np.concatenate([\n                route1[:pos1+1],\n                route2[pos2:-1],\n                [0]\n            ])\n\n            # Update solution\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.7966236737510608,
            4.89894512295723
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines adaptive route clustering with spatial-aware demand redistribution and makespan-aware customer reinsertion to simultaneously optimize total distance and makespan while maintaining feasibility through capacity-constrained transformations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] / (1 + x[1][1]))[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Adaptive route clustering based on spatial and demand characteristics\n    cluster_centers = []\n    for route in new_solution:\n        if len(route) > 2:\n            cluster_center = np.mean(coords[route[1:-1]], axis=0)\n            cluster_centers.append((cluster_center, route))\n\n    # Spatial-aware demand redistribution\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Find closest cluster center\n        route_center = np.mean(coords[route[1:-1]], axis=0)\n        closest_cluster = min(cluster_centers, key=lambda x: np.linalg.norm(x[0] - route_center))\n\n        # Redistribute customers to balance demand and spatial distribution\n        customers = route[1:-1]\n        sorted_indices = np.argsort(distance_matrix[0, customers])\n        redistribute_customers = customers[sorted_indices[:len(customers)//2]]\n\n        # Create new route with redistributed customers\n        new_route = np.concatenate([[0], redistribute_customers, [0]])\n        if np.sum(demand[new_route[1:-1]]) <= capacity:\n            new_solution[i] = new_route\n\n    # Makespan-aware customer reinsertion\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Select longest route\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) <= 3:\n            continue\n\n        # Find customer with highest potential for makespan reduction\n        customer_pos = max(range(1, len(longest_route)-1),\n                          key=lambda p: distance_matrix[longest_route[p-1], longest_route[p]] +\n                          distance_matrix[longest_route[p], longest_route[p+1]])\n\n        customer = longest_route[customer_pos]\n\n        # Find best insertion point in other routes based on makespan improvement\n        best_route_idx = -1\n        best_insert_pos = -1\n        best_makespan_improvement = 0\n\n        for i in range(len(new_solution)):\n            if i == longest_route_idx:\n                continue\n\n            target_route = new_solution[i]\n            if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            for pos in range(1, len(target_route)):\n                # Calculate potential makespan improvement\n                original_dist = distance_matrix[target_route[pos-1], target_route[pos]]\n                new_dist = distance_matrix[target_route[pos-1], customer] + distance_matrix[customer, target_route[pos]]\n                improvement = original_dist - new_dist\n\n                if improvement > best_makespan_improvement:\n                    best_makespan_improvement = improvement\n                    best_route_idx = i\n                    best_insert_pos = pos\n\n        if best_route_idx != -1:\n            # Perform the reinsertion\n            target_route = new_solution[best_route_idx]\n            new_target_route = np.insert(target_route, best_insert_pos, customer)\n            new_solution[best_route_idx] = new_target_route\n\n            # Remove from original route\n            new_route = np.delete(longest_route, customer_pos)\n            new_solution[longest_route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.7815066927706826,
            0.9666451215744019
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objectives and applies a hybrid local search combining route merging, demand-balanced customer reallocation, and adaptive 3-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([(obj[0] * 0.6 + obj[1] * 0.4) for _, obj in archive])\n    weights = np.exp(-objectives / np.max(objectives))  # Prefer better solutions\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, demand-balanced reallocation, and adaptive 3-opt\n    for _ in range(3):  # Number of iterations\n        if len(new_solution) < 2:\n            break\n\n        # Route merging: combine two short routes if capacity allows\n        route1_idx, route2_idx = sorted(random.sample(range(len(new_solution)), 2))\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 <= 15 and sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n            continue\n\n        # Demand-balanced customer reallocation: move customers between routes to balance demands\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 3:\n                continue\n\n            current_demand = sum(demand[route[1:-1]])\n            for other_idx in range(len(new_solution)):\n                if route_idx == other_idx:\n                    continue\n                other_route = new_solution[other_idx]\n                other_demand = sum(demand[other_route[1:-1]])\n\n                if abs(current_demand - capacity/2) > abs(other_demand - capacity/2):\n                    # Try to move a customer to balance demands\n                    for customer_pos in range(1, len(route)-1):\n                        customer = route[customer_pos]\n                        if other_demand + demand[customer] <= capacity:\n                            # Find best insertion point in other route\n                            min_insert_cost = float('inf')\n                            best_pos = None\n                            for pos in range(1, len(other_route)):\n                                insert_cost = distance_matrix[other_route[pos-1], customer] + \\\n                                             distance_matrix[customer, other_route[pos]] - \\\n                                             distance_matrix[other_route[pos-1], other_route[pos]]\n                                if insert_cost < min_insert_cost:\n                                    min_insert_cost = insert_cost\n                                    best_pos = pos\n\n                            if best_pos is not None:\n                                # Perform the move\n                                new_route = np.delete(route, customer_pos)\n                                new_other_route = np.insert(other_route, best_pos, customer)\n\n                                # Update routes\n                                if len(new_route) >= 2:\n                                    new_solution[route_idx] = new_route\n                                else:\n                                    del new_solution[route_idx]\n                                new_solution[other_idx] = new_other_route\n                                break\n\n        # Adaptive 3-opt: perform a limited number of 3-opt swaps\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 4:\n                continue\n\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j, k = sorted(random.sample(range(1, len(route)-1), 3))\n                # Try all possible 3-opt configurations\n                options = [\n                    np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:]]),\n                    np.concatenate([route[:i], route[j:k][::-1], route[i:j], route[k:]]),\n                    np.concatenate([route[:i], route[j:k], route[i:j][::-1], route[k:]])\n                ]\n\n                best_option = None\n                min_cost = float('inf')\n                for option in options:\n                    if sum(demand[option[1:-1]]) <= capacity:\n                        cost = sum(distance_matrix[option[i], option[i+1]] for i in range(len(option)-1))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_option = option\n\n                if best_option is not None:\n                    new_solution[route_idx] = best_option\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.8092992201493914,
            7.086251676082611
        ]
    }
]