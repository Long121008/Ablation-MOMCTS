[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objectives and applies a hybrid local search combining route merging, demand-balanced customer reallocation, and adaptive 3-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    objectives = np.array([(obj[0] * 0.6 + obj[1] * 0.4) for _, obj in archive])\n    weights = np.exp(-objectives / np.max(objectives))  # Prefer better solutions\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, demand-balanced reallocation, and adaptive 3-opt\n    for _ in range(3):  # Number of iterations\n        if len(new_solution) < 2:\n            break\n\n        # Route merging: combine two short routes if capacity allows\n        route1_idx, route2_idx = sorted(random.sample(range(len(new_solution)), 2))\n        route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 <= 15 and sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]]) <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n            continue\n\n        # Demand-balanced customer reallocation: move customers between routes to balance demands\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 3:\n                continue\n\n            current_demand = sum(demand[route[1:-1]])\n            for other_idx in range(len(new_solution)):\n                if route_idx == other_idx:\n                    continue\n                other_route = new_solution[other_idx]\n                other_demand = sum(demand[other_route[1:-1]])\n\n                if abs(current_demand - capacity/2) > abs(other_demand - capacity/2):\n                    # Try to move a customer to balance demands\n                    for customer_pos in range(1, len(route)-1):\n                        customer = route[customer_pos]\n                        if other_demand + demand[customer] <= capacity:\n                            # Find best insertion point in other route\n                            min_insert_cost = float('inf')\n                            best_pos = None\n                            for pos in range(1, len(other_route)):\n                                insert_cost = distance_matrix[other_route[pos-1], customer] + \\\n                                             distance_matrix[customer, other_route[pos]] - \\\n                                             distance_matrix[other_route[pos-1], other_route[pos]]\n                                if insert_cost < min_insert_cost:\n                                    min_insert_cost = insert_cost\n                                    best_pos = pos\n\n                            if best_pos is not None:\n                                # Perform the move\n                                new_route = np.delete(route, customer_pos)\n                                new_other_route = np.insert(other_route, best_pos, customer)\n\n                                # Update routes\n                                if len(new_route) >= 2:\n                                    new_solution[route_idx] = new_route\n                                else:\n                                    del new_solution[route_idx]\n                                new_solution[other_idx] = new_other_route\n                                break\n\n        # Adaptive 3-opt: perform a limited number of 3-opt swaps\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 4:\n                continue\n\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j, k = sorted(random.sample(range(1, len(route)-1), 3))\n                # Try all possible 3-opt configurations\n                options = [\n                    np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:]]),\n                    np.concatenate([route[:i], route[j:k][::-1], route[i:j], route[k:]]),\n                    np.concatenate([route[:i], route[j:k], route[i:j][::-1], route[k:]])\n                ]\n\n                best_option = None\n                min_cost = float('inf')\n                for option in options:\n                    if sum(demand[option[1:-1]]) <= capacity:\n                        cost = sum(distance_matrix[option[i], option[i+1]] for i in range(len(option)-1))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_option = option\n\n                if best_option is not None:\n                    new_solution[route_idx] = best_option\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.8092992201493914,
            7.086251676082611
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines spatial clustering of customers with adaptive route merging to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Make a deep copy of the solution\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Spatial clustering and adaptive route merging\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Find spatial clusters within the route\n        cluster_centers = []\n        for node in route[1:-1]:\n            cluster_centers.append(coords[node])\n\n        if len(cluster_centers) > 1:\n            # Perform simple spatial clustering (k-means with k=2 for demonstration)\n            from sklearn.cluster import KMeans\n            kmeans = KMeans(n_clusters=2, random_state=0).fit(cluster_centers)\n            labels = kmeans.labels_\n\n            # Split route based on clusters\n            cluster1_nodes = [route[1:-1][i] for i in range(len(route[1:-1])) if labels[i] == 0]\n            cluster2_nodes = [route[1:-1][i] for i in range(len(route[1:-1])) if labels[i] == 1]\n\n            # Create new routes if clusters are valid\n            if len(cluster1_nodes) > 0 and len(cluster2_nodes) > 0:\n                new_route1 = np.concatenate([[0], np.array(cluster1_nodes), [0]])\n                new_route2 = np.concatenate([[0], np.array(cluster2_nodes), [0]])\n\n                # Check feasibility\n                if (np.sum(demand[cluster1_nodes]) <= capacity and\n                    np.sum(demand[cluster2_nodes]) <= capacity):\n                    new_solution[i] = new_route1\n                    new_solution.insert(i+1, new_route2)\n                    break\n\n    # Adaptive route merging: try to merge routes if beneficial\n    if len(new_solution) > 1:\n        # Find the two routes with the shortest connection between them\n        best_merge = None\n        best_merge_gain = 0\n\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                route1 = new_solution[i]\n                route2 = new_solution[j]\n\n                # Calculate potential merge gain\n                original_dist = (distance_matrix[route1[0], route1[-2]] +\n                                distance_matrix[route2[0], route2[-2]])\n\n                # Find best connection between routes\n                best_connection = float('inf')\n                for node1 in route1[1:-1]:\n                    for node2 in route2[1:-1]:\n                        connection_dist = distance_matrix[node1, node2]\n                        if connection_dist < best_connection:\n                            best_connection = connection_dist\n\n                if best_connection < float('inf'):\n                    total_gain = original_dist - best_connection\n                    if total_gain > best_merge_gain:\n                        # Check capacity constraint\n                        if (np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity):\n                            best_merge_gain = total_gain\n                            best_merge = (i, j)\n\n        if best_merge is not None:\n            i, j = best_merge\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            # Find best connection between routes\n            best_node1 = None\n            best_node2 = None\n            best_connection = float('inf')\n\n            for node1 in route1[1:-1]:\n                for node2 in route2[1:-1]:\n                    connection_dist = distance_matrix[node1, node2]\n                    if connection_dist < best_connection:\n                        best_connection = connection_dist\n                        best_node1 = node1\n                        best_node2 = node2\n\n            # Create merged route\n            pos1 = np.where(route1 == best_node1)[0][0]\n            pos2 = np.where(route2 == best_node2)[0][0]\n\n            # Merge routes by connecting at the best nodes\n            merged_route = np.concatenate([\n                route1[:pos1+1],\n                route2[pos2:-1],\n                [0]\n            ])\n\n            # Update solution\n            new_solution[i] = merged_route\n            del new_solution[j]\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.7966236737510608,
            4.89894512295723
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines route splitting and customer reallocation with a biased random walk to explore the solution space while balancing the trade-off between total distance and makespan, ensuring feasibility through capacity-aware transformations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + obj[0] * obj[1]) for _, obj in archive],  # Prefer solutions with better balance between objectives\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search operator: Route splitting and customer reallocation with biased random walk\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Step 1: Randomly select a route to split or modify\n        if len(new_solution) < 2:\n            break  # Need at least two routes to perform meaningful operations\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Step 2: Split the route into two parts at a random position\n        split_pos = random.randint(1, len(route) - 2)\n        new_route1 = route[:split_pos + 1]\n        new_route2 = [0] + route[split_pos:]\n\n        # Step 3: Check capacity feasibility for the new routes\n        def is_feasible(r):\n            return np.sum(demand[r[1:-1]]) <= capacity\n\n        if not is_feasible(new_route1) or not is_feasible(new_route2):\n            continue  # Skip if splitting violates capacity\n\n        # Replace the original route with the two new routes\n        new_solution.pop(route_idx)\n        new_solution.insert(route_idx, new_route2)\n        new_solution.insert(route_idx, new_route1)\n\n        # Step 4: Perform biased random walk to reallocate customers between routes\n        for _ in range(2):  # Limit the number of reallocations\n            # Select a random customer from a random route\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            from_route = new_solution[from_route_idx]\n            if len(from_route) <= 3:  # Skip if route is too short\n                continue\n\n            customer_pos = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_pos]\n\n            # Try to insert the customer into another route\n            to_route_idx = random.randint(0, len(new_solution) - 1)\n            if to_route_idx == from_route_idx:\n                continue  # Skip if same route\n\n            to_route = new_solution[to_route_idx]\n            if np.sum(demand[to_route[1:-1]]) + demand[customer] > capacity:\n                continue  # Skip if capacity is exceeded\n\n            # Insert the customer into the target route at a random position\n            insert_pos = random.randint(1, len(to_route) - 1)\n            new_route = np.insert(to_route, insert_pos, customer)\n\n            # Remove the customer from the original route\n            new_from_route = np.delete(from_route, customer_pos)\n\n            # Update the solution\n            new_solution[to_route_idx] = new_route\n            new_solution[from_route_idx] = new_from_route\n\n    return new_solution\n\n",
        "score": [
            -0.7939521796066197,
            0.13688308000564575
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of distance and makespan, then applies a novel hybrid local search combining route merging, demand-balanced customer insertion, and adaptive route shortening to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [0.7 * obj[0] + 0.3 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, demand-balanced insertion, and adaptive shortening\n    for _ in range(2):  # Limit iterations\n        # Route merging: combine short routes if they fit capacity\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            if len(route1) + len(route2) - 4 <= 20:  # Limit merged route length\n                combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route1[:-1], route2[1:]])\n                    new_solution[i] = merged_route\n                    del new_solution[j]\n                    continue\n\n        # Demand-balanced customer insertion: move customers between routes\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            if len(route1) > 3 and len(route2) > 3:\n                # Find customer with demand closest to average demand\n                avg_demand = (sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])) / (len(route1) + len(route2) - 4)\n                candidates = [c for c in route1[1:-1] if abs(demand[c] - avg_demand) < 0.3 * avg_demand]\n\n                if candidates:\n                    customer = random.choice(candidates)\n                    # Find best insertion in route2\n                    best_pos = 1\n                    min_cost = float('inf')\n                    for pos in range(1, len(route2)):\n                        cost = distance_matrix[route2[pos-1], customer] + distance_matrix[customer, route2[pos]] - distance_matrix[route2[pos-1], route2[pos]]\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Remove from route1\n                        new_route1 = np.delete(route1, np.where(route1 == customer)[0][0])\n                        if len(new_route1) > 2:\n                            new_solution[i] = new_route1\n                        else:\n                            del new_solution[i]\n\n                        # Insert into route2\n                        new_route2 = np.insert(route2, best_pos, customer)\n                        new_solution[j] = new_route2\n\n        # Adaptive route shortening: remove non-critical customers\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:\n                # Find customer with smallest demand\n                customers = route[1:-1]\n                min_demand_idx = np.argmin(demand[customers])\n                customer = customers[min_demand_idx]\n\n                # Check if removal is feasible\n                new_route = np.delete(route, np.where(route == customer)[0][0])\n                if len(new_route) > 2:\n                    new_solution[i] = new_route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.7563857408360191,
            0.3505585789680481
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-frontier dominance score, then applies a hybrid local search combining route merging, customer swapping between routes, and adaptive 3-opt moves to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    pareto_scores = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_scores.append(1.0)\n        else:\n            pareto_scores.append(0.1)\n\n    weights = np.array(pareto_scores) / np.sum(pareto_scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, customer swapping, and adaptive 3-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route merging: combine with a nearby route\n        if len(new_solution) > 1:\n            # Find the closest route\n            min_dist = float('inf')\n            closest_idx = -1\n            for i, other_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n                # Distance between last customer of route and first customer of other_route\n                dist = distance_matrix[route[-2], other_route[1]]\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_idx = i\n\n            if closest_idx != -1:\n                other_route = new_solution[closest_idx]\n                # Check capacity constraint\n                if sum(demand[route[1:-1]]) + sum(demand[other_route[1:-1]]) <= capacity:\n                    # Merge the routes\n                    merged_route = np.concatenate([route[:-1], other_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[closest_idx]\n                    continue\n\n        # Customer swapping between routes\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3 and len(other_route) > 3:\n                # Select a customer from each route\n                customer_pos = random.randint(1, len(route) - 2)\n                other_customer_pos = random.randint(1, len(other_route) - 2)\n                customer = route[customer_pos]\n                other_customer = other_route[other_customer_pos]\n\n                # Check capacity constraints\n                if (sum(demand[route[1:-1]]) - demand[customer] + demand[other_customer] <= capacity and\n                    sum(demand[other_route[1:-1]]) - demand[other_customer] + demand[customer] <= capacity):\n                    # Swap the customers\n                    new_route = route.copy()\n                    new_route[customer_pos] = other_customer\n                    new_other_route = other_route.copy()\n                    new_other_route[other_customer_pos] = customer\n\n                    new_solution[route_idx] = new_route\n                    new_solution[other_route_idx] = new_other_route\n\n        # Adaptive 3-opt: perform a limited number of moves\n        if len(route) > 4:\n            for _ in range(2):  # Limit the number of moves per route\n                # Select three distinct positions\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                # Try all possible 3-opt configurations\n                for config in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n                    a, b, c = config\n                    new_route = np.concatenate([\n                        route[:a], route[b:c][::-1], route[a:b], route[c:]\n                    ])\n                    # Check capacity constraint\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[route_idx] = new_route\n                        break\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.3324894365007257,
            0.19245308637619019
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives (total distance and makespan) with different weights, and applies a hybrid local search combining route splitting, demand-aware customer reallocation, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    objectives = np.array([(obj[0] * 0.3 + obj[1] * 0.7) for _, obj in archive])\n    weights = np.exp(-objectives / np.max(objectives))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, demand-aware reallocation, and adaptive 2.5-opt\n    for _ in range(3):  # Number of iterations\n        if len(new_solution) < 2:\n            break\n\n        # Route splitting: split a long route into two if it's too long\n        longest_route_idx = np.argmax([sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution])\n        longest_route = new_solution[longest_route_idx]\n\n        if len(longest_route) > 10:  # Arbitrary threshold for route length\n            split_pos = len(longest_route) // 2\n            new_route1 = np.concatenate([longest_route[:split_pos], [0]])\n            new_route2 = np.concatenate([[0], longest_route[split_pos:-1]])\n\n            if sum(demand[new_route1[1:-1]]) <= capacity and sum(demand[new_route2[1:-1]]) <= capacity:\n                new_solution[longest_route_idx] = new_route1\n                new_solution.insert(longest_route_idx + 1, new_route2)\n                continue\n\n        # Demand-aware customer reallocation: move customers between routes to balance demands\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 3:\n                continue\n\n            current_demand = sum(demand[route[1:-1]])\n            for other_idx in range(len(new_solution)):\n                if route_idx == other_idx:\n                    continue\n                other_route = new_solution[other_idx]\n                other_demand = sum(demand[other_route[1:-1]])\n\n                if abs(current_demand - capacity/2) > abs(other_demand - capacity/2):\n                    # Try to move a customer to balance demands\n                    for customer_pos in range(1, len(route)-1):\n                        customer = route[customer_pos]\n                        if other_demand + demand[customer] <= capacity:\n                            # Find best insertion point in other route\n                            min_insert_cost = float('inf')\n                            best_pos = None\n                            for pos in range(1, len(other_route)):\n                                insert_cost = distance_matrix[other_route[pos-1], customer] + \\\n                                             distance_matrix[customer, other_route[pos]] - \\\n                                             distance_matrix[other_route[pos-1], other_route[pos]]\n                                if insert_cost < min_insert_cost:\n                                    min_insert_cost = insert_cost\n                                    best_pos = pos\n\n                            if best_pos is not None:\n                                # Perform the move\n                                new_route = np.delete(route, customer_pos)\n                                new_other_route = np.insert(other_route, best_pos, customer)\n\n                                # Update routes\n                                if len(new_route) >= 2:\n                                    new_solution[route_idx] = new_route\n                                else:\n                                    del new_solution[route_idx]\n                                new_solution[other_idx] = new_other_route\n                                break\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps\n        for route_idx in range(len(new_solution)):\n            route = new_solution[route_idx]\n            if len(route) <= 5:\n                continue\n\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route)-1), 2))\n                # Try all possible 2.5-opt configurations\n                options = [\n                    np.concatenate([route[:i], route[i:j][::-1], route[j:]]),\n                    np.concatenate([route[:i], route[j:], route[i:j][::-1]]),\n                    np.concatenate([route[:i+1], route[i:j][::-1], route[j-1:]]),\n                    np.concatenate([route[:i+1], route[j:], route[i:j][::-1]])\n                ]\n\n                best_option = None\n                min_cost = float('inf')\n                for option in options:\n                    if sum(demand[option[1:-1]]) <= capacity:\n                        cost = sum(distance_matrix[option[i], option[i+1]] for i in range(len(option)-1))\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_option = option\n\n                if best_option is not None:\n                    new_solution[route_idx] = best_option\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.6963940404151062,
            0.6827333867549896
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a normalized combination of total distance and makespan, then applies a hybrid local search combining route merging, customer reinsertion, and adaptive 3-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    normalized_distances = total_distances / np.max(total_distances)\n    normalized_makespans = makespans / np.max(makespans)\n    scores = 0.6 * normalized_distances + 0.4 * normalized_makespans  # More weight on makespan\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, customer reinsertion, and adaptive 3-opt\n    for _ in range(3):  # Number of iterations\n        if not new_solution:\n            break\n\n        # Route merging: merge two routes if their combined demand is feasible\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if combined_demand <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n                continue\n\n        # Customer reinsertion: remove a customer and reinsert it into another route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:  # Ensure route has customers to move\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Remove customer from the original route\n            new_route = np.delete(route, customer_pos)\n            if len(new_route) > 2:  # Ensure route remains valid\n                new_solution[route_idx] = new_route\n            else:\n                del new_solution[route_idx]\n\n            # Find the best position to insert the customer into another route\n            best_insertion = None\n            best_cost = float('inf')\n\n            for other_route_idx, other_route in enumerate(new_solution):\n                if other_route_idx == route_idx:\n                    continue\n                if sum(demand[other_route[1:-1]]) + demand[customer] > capacity:\n                    continue\n\n                for insert_pos in range(1, len(other_route)):\n                    # Calculate the cost of inserting the customer at this position\n                    prev_node = other_route[insert_pos - 1]\n                    next_node = other_route[insert_pos]\n                    insertion_cost = (distance_matrix[prev_node][customer] +\n                                     distance_matrix[customer][next_node] -\n                                     distance_matrix[prev_node][next_node])\n\n                    if insertion_cost < best_cost:\n                        best_cost = insertion_cost\n                        best_insertion = (other_route_idx, insert_pos)\n\n            if best_insertion is not None:\n                other_route_idx, insert_pos = best_insertion\n                new_other_route = np.insert(new_solution[other_route_idx], insert_pos, customer)\n                new_solution[other_route_idx] = new_other_route\n\n        # Adaptive 3-opt: perform a limited number of swaps\n        if len(route) > 4:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                # Try all possible 3-opt configurations\n                options = [\n                    np.concatenate([route[:i], route[i:j][::-1], route[j:k][::-1], route[k:]]),\n                    np.concatenate([route[:i], route[j:k], route[i:j], route[k:]]),\n                    np.concatenate([route[:i], route[j:k], route[i:j][::-1], route[k:]])\n                ]\n                for new_route in options:\n                    if sum(demand[new_route[1:-1]]) <= capacity:\n                        new_solution[route_idx] = new_route\n                        break\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.6271019169929782,
            0.4354616105556488
        ]
    },
    {
        "algorithm": "{This algorithm employs a novel combination of adaptive route clustering and demand-aware customer reinsertion with a dynamic neighborhood exploration strategy, where routes are grouped based on spatial proximity and customer demands, followed by strategic reinsertion of customers to balance loads and reduce makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Adaptive route clustering based on spatial proximity and demand similarity\n    if len(new_solution) > 1:\n        # Group routes by spatial proximity and demand similarity\n        route_centers = []\n        for route in new_solution:\n            if len(route) > 2:\n                route_coords = coords[route[1:-1]]\n                center = np.mean(route_coords, axis=0)\n                total_demand = np.sum(demand[route[1:-1]])\n                route_centers.append((center, total_demand))\n\n        # Cluster routes using hierarchical clustering\n        if len(route_centers) > 1:\n            from scipy.cluster.hierarchy import linkage, fcluster\n            features = np.array([np.concatenate([center, [demand]]) for center, demand in route_centers])\n            Z = linkage(features, method='ward')\n            clusters = fcluster(Z, t=2, criterion='maxclust')\n\n            # Merge routes within the same cluster if capacity allows\n            cluster_routes = {}\n            for idx, cluster in enumerate(clusters):\n                if cluster not in cluster_routes:\n                    cluster_routes[cluster] = []\n                cluster_routes[cluster].append(idx)\n\n            for cluster, route_indices in cluster_routes.items():\n                if len(route_indices) > 1:\n                    # Try to merge routes in the cluster\n                    merged_routes = []\n                    for idx in sorted(route_indices, reverse=True):\n                        route = new_solution.pop(idx)\n                        merged_routes.append(route)\n\n                    # Attempt to merge all routes in the cluster\n                    merged_route = merged_routes[0]\n                    for other_route in merged_routes[1:]:\n                        if len(merged_route) + len(other_route) - 2 <= 100 and sum(demand[merged_route[1:-1]]) + sum(demand[other_route[1:-1]]) <= capacity:\n                            merged_route = np.concatenate([merged_route[:-1], other_route[1:]])\n                        else:\n                            new_solution.append(merged_route)\n                            merged_route = other_route\n                    new_solution.append(merged_route)\n\n    # Demand-aware customer reinsertion with dynamic neighborhood\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        # Select a route with high demand variance\n        demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n        route_idx = np.argmax(demands)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        # Find customers with demands closest to the route's average demand\n        route_demand = demands[route_idx]\n        avg_demand = route_demand / (len(route) - 2)\n        customer_demands = demand[route[1:-1]]\n        demand_diff = np.abs(customer_demands - avg_demand)\n        candidate_pos = np.argmin(demand_diff)\n        customer = route[candidate_pos + 1]\n\n        # Find best insertion point in another route\n        best_route_idx = None\n        best_pos = None\n        best_improvement = 0\n\n        for other_idx in range(len(new_solution)):\n            if other_idx == route_idx:\n                continue\n\n            other_route = new_solution[other_idx]\n            other_demand = demands[other_idx]\n\n            if other_demand + demand[customer] > capacity:\n                continue\n\n            # Evaluate insertion points in the other route\n            for pos in range(1, len(other_route)):\n                # Calculate potential improvement in makespan\n                old_dist = distance_matrix[other_route[pos-1], other_route[pos]]\n                new_dist = distance_matrix[other_route[pos-1], customer] + distance_matrix[customer, other_route[pos]]\n                improvement = old_dist - new_dist\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_route_idx = other_idx\n                    best_pos = pos\n\n        if best_route_idx is not None:\n            # Perform the reinsertion\n            new_route = np.insert(new_solution[best_route_idx], best_pos, customer)\n            new_from_route = np.delete(route, candidate_pos + 1)\n\n            new_solution[best_route_idx] = new_route\n            if len(new_from_route) >= 2:\n                new_solution[route_idx] = new_from_route\n            else:\n                new_solution.pop(route_idx)\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.6482330745430674,
            2.4822207391262054
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of distance and makespan, then applies a novel hybrid local search combining route splitting, demand-aware customer reallocation, and spatial clustering-based route optimization to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [0.6 * obj[0] + 0.4 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, demand-aware reallocation, and spatial clustering\n    for _ in range(3):  # Limit iterations\n        # Route splitting: divide long routes into two balanced parts\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 5:  # Only split if route is long enough\n                # Find split point that balances demand and distance\n                total_demand = sum(demand[route[1:-1]])\n                target_demand = total_demand / 2\n                current_demand = 0\n                best_split = len(route) // 2\n\n                for j in range(1, len(route)-1):\n                    current_demand += demand[route[j]]\n                    if abs(current_demand - target_demand) < abs(current_demand - target_demand - demand[route[j]]):\n                        best_split = j\n\n                # Create two new routes\n                route1 = np.concatenate([[0], route[1:best_split+1], [0]])\n                route2 = np.concatenate([[0], route[best_split+1:-1], [0]])\n\n                # Check capacity constraints\n                if (sum(demand[route1[1:-1]]) <= capacity and\n                    sum(demand[route2[1:-1]]) <= capacity):\n                    new_solution[i] = route1\n                    new_solution.append(route2)\n                    break\n\n        # Demand-aware customer reallocation: move customers between nearby routes\n        if len(new_solution) > 1:\n            i, j = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[i]\n            route2 = new_solution[j]\n\n            if len(route1) > 3 and len(route2) > 3:\n                # Find customers in route1 that are closest to route2\n                route2_customers = route2[1:-1]\n                candidates = []\n                for c in route1[1:-1]:\n                    min_dist = min(distance_matrix[c, route2_customers])\n                    if min_dist < 0.5 * np.mean(distance_matrix[route2_customers]):\n                        candidates.append(c)\n\n                if candidates:\n                    customer = random.choice(candidates)\n                    # Find best insertion in route2\n                    best_pos = 1\n                    min_cost = float('inf')\n                    for pos in range(1, len(route2)):\n                        cost = (distance_matrix[route2[pos-1], customer] +\n                                distance_matrix[customer, route2[pos]] -\n                                distance_matrix[route2[pos-1], route2[pos]])\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pos = pos\n\n                    if sum(demand[route2[1:-1]]) + demand[customer] <= capacity:\n                        # Remove from route1\n                        new_route1 = np.delete(route1, np.where(route1 == customer)[0][0])\n                        if len(new_route1) > 2:\n                            new_solution[i] = new_route1\n                        else:\n                            del new_solution[i]\n\n                        # Insert into route2\n                        new_route2 = np.insert(route2, best_pos, customer)\n                        new_solution[j] = new_route2\n\n        # Spatial clustering-based route optimization: group nearby customers\n        for i in range(len(new_solution)):\n            route = new_solution[i]\n            if len(route) > 4:\n                customers = route[1:-1]\n                if len(customers) > 2:\n                    # Find most isolated customer\n                    isolation_scores = []\n                    for c in customers:\n                        dists = distance_matrix[c, customers]\n                        isolation_scores.append(np.mean(dists[dists > 0]))\n\n                    if isolation_scores:\n                        most_isolated = customers[np.argmax(isolation_scores)]\n                        # Find nearest customer in the same route\n                        dists = distance_matrix[most_isolated, customers]\n                        nearest = customers[np.argmin(dists[dists > 0])]\n\n                        # Swap positions if it reduces total distance\n                        original_dist = (distance_matrix[route[np.where(route == most_isolated)[0][0]-1], most_isolated] +\n                                       distance_matrix[most_isolated, route[np.where(route == most_isolated)[0][0]+1]] +\n                                       distance_matrix[route[np.where(route == nearest)[0][0]-1], nearest] +\n                                       distance_matrix[nearest, route[np.where(route == nearest)[0][0]+1]])\n\n                        swapped_dist = (distance_matrix[route[np.where(route == most_isolated)[0][0]-1], nearest] +\n                                       distance_matrix[nearest, route[np.where(route == most_isolated)[0][0]+1]] +\n                                       distance_matrix[route[np.where(route == nearest)[0][0]-1], most_isolated] +\n                                       distance_matrix[most_isolated, route[np.where(route == nearest)[0][0]+1]])\n\n                        if swapped_dist < original_dist:\n                            # Perform swap\n                            pos1 = np.where(route == most_isolated)[0][0]\n                            pos2 = np.where(route == nearest)[0][0]\n                            route[pos1], route[pos2] = route[pos2], route[pos1]\n                            new_solution[i] = route\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0 or new_solution[i][-1] != 0:\n            new_solution[i] = np.concatenate([[0], new_solution[i][1:-1], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.6755381053868886,
            4.281536430120468
        ]
    }
]