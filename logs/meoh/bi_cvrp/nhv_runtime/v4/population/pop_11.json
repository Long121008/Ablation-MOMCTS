[
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route splitting, customer reallocation, and adaptive 2-opt\n    for _ in range(3):  # Number of iterations\n        # Randomly select a route to modify\n        if not new_solution:\n            break\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        # Route splitting: split a long route into two\n        if len(route) > 4:  # Avoid splitting very short routes\n            split_pos = random.randint(2, len(route) - 3)\n            new_route1 = route[:split_pos + 1]\n            new_route2 = route[split_pos:]\n\n            # Check capacity constraints\n            demand1 = sum(demand[new_route1[1:-1]])\n            demand2 = sum(demand[new_route2[1:-1]])\n\n            if demand1 <= capacity and demand2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n                continue\n\n        # Customer reallocation: move a customer to another route\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(route) > 3:  # Ensure route has customers to move\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                # Check if moving the customer to the other route is feasible\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    # Insert customer into the other route (random position)\n                    insert_pos = random.randint(1, len(other_route) - 1)\n                    new_other_route = np.insert(other_route, insert_pos, customer)\n                    new_solution[other_route_idx] = new_other_route\n\n                    # Remove customer from the original route\n                    new_route = np.delete(route, customer_pos)\n                    if len(new_route) > 2:  # Ensure route remains valid\n                        new_solution[route_idx] = new_route\n                    else:\n                        del new_solution[route_idx]\n\n        # Adaptive 2-opt: perform a limited number of swaps\n        if len(route) > 3:\n            for _ in range(2):  # Limit the number of swaps per route\n                i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n\n                # Check capacity constraint\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7142238614790346,
            0.06631940603256226
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a normalized score combining total distance and makespan, then applies a hybrid local search combining route merging, customer reinsertion, and adaptive 3-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) + (makespans / np.max(makespans))\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Make a copy of the selected solution\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging, customer reinsertion, and adaptive 3-opt\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route merging: merge two routes if their combined demand is within capacity\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            combined_demand = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n\n            if combined_demand <= capacity:\n                merged_route = np.concatenate([route1[:-1], route2[1:]])\n                new_solution[route1_idx] = merged_route\n                del new_solution[route2_idx]\n                continue\n\n        # Customer reinsertion: remove a customer and reinsert it into another route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            customer_pos = random.randint(1, len(route) - 2)\n            customer = route[customer_pos]\n\n            # Find feasible insertion positions in other routes\n            feasible_routes = []\n            for i, other_route in enumerate(new_solution):\n                if i != route_idx and sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    feasible_routes.append(i)\n\n            if feasible_routes:\n                insert_route_idx = random.choice(feasible_routes)\n                insert_pos = random.randint(1, len(new_solution[insert_route_idx]) - 1)\n\n                # Insert customer into the selected route\n                new_route = np.insert(new_solution[insert_route_idx], insert_pos, customer)\n                new_solution[insert_route_idx] = new_route\n\n                # Remove customer from the original route\n                new_route = np.delete(route, customer_pos)\n                if len(new_route) > 2:\n                    new_solution[route_idx] = new_route\n                else:\n                    del new_solution[route_idx]\n\n        # Adaptive 3-opt: perform a limited number of 3-opt swaps\n        if len(route) > 4:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    # Convert the list of routes to the required format\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.853243689215822,
            0.2600117027759552
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, demand-based customer shuffling, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (total_distances / np.max(total_distances)) * 0.6 + (makespans / np.max(makespans)) * 0.4\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if demand allows\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                route1 = route[:split_pos + 1]\n                route2 = route[split_pos:]\n                if sum(demand[route1[1:-1]]) <= capacity and sum(demand[route2[1:-1]]) <= capacity:\n                    new_solution[route_idx] = route1\n                    new_solution.insert(route_idx + 1, route2)\n                    continue\n\n        # Demand-based customer shuffling: move customers between routes based on demand balance\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n            demand1 = sum(demand[route1[1:-1]])\n            demand2 = sum(demand[route2[1:-1]])\n\n            if abs(demand1 - demand2) > capacity * 0.2:\n                if demand1 > demand2:\n                    source_route, target_route = route1, route2\n                else:\n                    source_route, target_route = route2, route1\n\n                if len(source_route) > 3:\n                    customer_pos = random.randint(1, len(source_route) - 2)\n                    customer = source_route[customer_pos]\n                    if sum(demand[target_route[1:-1]]) + demand[customer] <= capacity:\n                        insert_pos = random.randint(1, len(target_route) - 1)\n                        new_target = np.insert(target_route, insert_pos, customer)\n                        new_source = np.delete(source_route, customer_pos)\n                        if len(new_source) > 2:\n                            new_solution[route1_idx if demand1 > demand2 else route2_idx] = new_source\n                            new_solution[route2_idx if demand1 > demand2 else route1_idx] = new_target\n                        else:\n                            if demand1 > demand2:\n                                new_solution[route1_idx] = new_target\n                                del new_solution[route2_idx]\n                            else:\n                                new_solution[route2_idx] = new_target\n                                del new_solution[route1_idx]\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (a combination of 2-opt and 3-opt)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                if random.random() < 0.5:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.8499293129109834,
            0.07336944341659546
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines route decomposition with adaptive demand balancing and spatial-aware customer reinsertion to simultaneously optimize total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Route decomposition with demand balancing\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Sort customers by demand in descending order\n        customers = route[1:-1]\n        sorted_indices = np.argsort(demand[customers])[::-1]\n        sorted_customers = customers[sorted_indices]\n\n        # Split into two routes with balanced demand\n        split_pos = len(sorted_customers) // 2\n        route1_customers = sorted_customers[:split_pos]\n        route2_customers = sorted_customers[split_pos:]\n\n        # Create new routes\n        route1 = np.concatenate([[0], route1_customers, [0]])\n        route2 = np.concatenate([[0], route2_customers, [0]])\n\n        # Check feasibility\n        if (np.sum(demand[route1_customers]) <= capacity and\n            np.sum(demand[route2_customers]) <= capacity):\n            new_solution[i] = route1\n            new_solution.insert(i+1, route2)\n            break\n\n    # Spatial-aware customer reinsertion\n    for _ in range(3):\n        # Select a random route to modify\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        # Select a random customer to reinsert\n        customer_pos = random.randint(1, len(route)-2)\n        customer = route[customer_pos]\n\n        # Find the most spatially compatible route for insertion\n        best_route_idx = -1\n        best_insert_pos = -1\n        best_distance_savings = -float('inf')\n\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue\n\n            target_route = new_solution[i]\n            if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Find best insertion position based on spatial proximity\n            min_distance = float('inf')\n            best_pos = -1\n\n            for pos in range(1, len(target_route)):\n                # Calculate distance savings if inserted here\n                prev_node = target_route[pos-1]\n                next_node = target_route[pos]\n                original_dist = distance_matrix[prev_node, next_node]\n                new_dist = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node]\n                savings = original_dist - new_dist\n\n                if savings > best_distance_savings:\n                    best_distance_savings = savings\n                    best_route_idx = i\n                    best_insert_pos = pos\n\n        if best_route_idx != -1:\n            # Perform the reinsertion\n            target_route = new_solution[best_route_idx]\n            new_target_route = np.insert(target_route, best_insert_pos, customer)\n            new_solution[best_route_idx] = new_target_route\n\n            # Remove from original route\n            new_route = np.delete(route, customer_pos)\n            new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.9227661053493067,
            0.7142148911952972
        ]
    },
    {
        "algorithm": "{This novel algorithm combines adaptive route clustering and dynamic customer rebalancing with a probabilistic swap mechanism to intelligently restructure solutions while maintaining feasibility and exploring trade-offs between distance and makespan through guided perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + obj[0] * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        cluster_size = random.randint(2, min(5, len(route) - 2))\n        cluster_pos = random.randint(1, len(route) - cluster_size - 1)\n\n        cluster = route[cluster_pos:cluster_pos + cluster_size]\n        remaining_route = np.concatenate((route[:cluster_pos], route[cluster_pos + cluster_size:]))\n\n        if np.sum(demand[remaining_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = remaining_route\n\n        for _ in range(2):\n            target_route_idx = random.randint(0, len(new_solution) - 1)\n            if target_route_idx == route_idx:\n                continue\n\n            target_route = new_solution[target_route_idx]\n\n            if np.sum(demand[target_route[1:-1]]) + np.sum(demand[cluster]) > capacity:\n                continue\n\n            insert_pos = random.randint(1, len(target_route) - 1)\n            new_target_route = np.insert(target_route, insert_pos, cluster)\n\n            new_solution[target_route_idx] = new_target_route\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 10:\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 4:\n            continue\n\n        swap_pos1 = random.randint(1, len(route) - 3)\n        swap_pos2 = random.randint(swap_pos1 + 1, len(route) - 2)\n\n        new_route = route.copy()\n        new_route[swap_pos1], new_route[swap_pos2] = new_route[swap_pos2], new_route[swap_pos1]\n\n        if np.sum(demand[new_route[1:-1]]) > capacity:\n            continue\n\n        new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.8377483251160325,
            0.13107585906982422
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a weighted score based on normalized total distance and makespan, then applies a hybrid local search combining route splitting, customer reallocation, and adaptive 2.5-opt moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = (0.6 * (total_distances / np.max(total_distances))) + (0.4 * (makespans / np.max(makespans)))\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(4):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if it's too long relative to makespan\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n            if len(route) > 5:\n                split_pos = len(route) // 2\n                first_part = route[:split_pos + 1]\n                second_part = np.concatenate([[0], route[split_pos + 1:]])\n\n                if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n                    new_solution[route_idx] = first_part\n                    new_solution.insert(route_idx + 1, second_part)\n                    continue\n\n        # Customer reallocation: move a customer to another route if it reduces total distance\n        if len(new_solution) > 1:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                customer_pos = random.randint(1, len(route) - 2)\n                customer = route[customer_pos]\n\n                for i, other_route in enumerate(new_solution):\n                    if i != route_idx and sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                        # Calculate potential new distance\n                        original_dist = distance_matrix[route[customer_pos - 1]][customer] + distance_matrix[customer][route[customer_pos + 1]]\n                        new_dist = distance_matrix[other_route[-2]][customer] + distance_matrix[customer][0]\n\n                        if new_dist < original_dist:\n                            # Insert into new route\n                            new_route = np.concatenate([other_route[:-1], [customer], [0]])\n                            new_solution[i] = new_route\n\n                            # Remove from original route\n                            new_route = np.delete(route, customer_pos)\n                            if len(new_route) > 2:\n                                new_solution[route_idx] = new_route\n                            else:\n                                del new_solution[route_idx]\n                            break\n\n        # Adaptive 2.5-opt: perform a limited number of 2.5-opt swaps (2-opt with one additional insertion)\n        if len(route) > 5:\n            for _ in range(2):\n                i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                new_route = np.concatenate([route[:i], route[i:j][::-1], [route[k]], route[k:]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.7779633815810102,
            0.09633633494377136
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines route splitting and customer reallocation with a biased random walk to explore the solution space while balancing the trade-off between total distance and makespan, ensuring feasibility through capacity-aware transformations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + obj[0] * obj[1]) for _, obj in archive],  # Prefer solutions with better balance between objectives\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Hybrid local search operator: Route splitting and customer reallocation with biased random walk\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Step 1: Randomly select a route to split or modify\n        if len(new_solution) < 2:\n            break  # Need at least two routes to perform meaningful operations\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:  # Skip if route is too short\n            continue\n\n        # Step 2: Split the route into two parts at a random position\n        split_pos = random.randint(1, len(route) - 2)\n        new_route1 = route[:split_pos + 1]\n        new_route2 = [0] + route[split_pos:]\n\n        # Step 3: Check capacity feasibility for the new routes\n        def is_feasible(r):\n            return np.sum(demand[r[1:-1]]) <= capacity\n\n        if not is_feasible(new_route1) or not is_feasible(new_route2):\n            continue  # Skip if splitting violates capacity\n\n        # Replace the original route with the two new routes\n        new_solution.pop(route_idx)\n        new_solution.insert(route_idx, new_route2)\n        new_solution.insert(route_idx, new_route1)\n\n        # Step 4: Perform biased random walk to reallocate customers between routes\n        for _ in range(2):  # Limit the number of reallocations\n            # Select a random customer from a random route\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            from_route = new_solution[from_route_idx]\n            if len(from_route) <= 3:  # Skip if route is too short\n                continue\n\n            customer_pos = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_pos]\n\n            # Try to insert the customer into another route\n            to_route_idx = random.randint(0, len(new_solution) - 1)\n            if to_route_idx == from_route_idx:\n                continue  # Skip if same route\n\n            to_route = new_solution[to_route_idx]\n            if np.sum(demand[to_route[1:-1]]) + demand[customer] > capacity:\n                continue  # Skip if capacity is exceeded\n\n            # Insert the customer into the target route at a random position\n            insert_pos = random.randint(1, len(to_route) - 1)\n            new_route = np.insert(to_route, insert_pos, customer)\n\n            # Remove the customer from the original route\n            new_from_route = np.delete(from_route, customer_pos)\n\n            # Update the solution\n            new_solution[to_route_idx] = new_route\n            new_solution[from_route_idx] = new_from_route\n\n    return new_solution\n\n",
        "score": [
            -0.7939521796066197,
            0.13688308000564575
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining route splitting, customer swapping, and adaptive 2.5-opt swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    total_distances = np.array([obj[0] for _, obj in archive])\n    makespans = np.array([obj[1] for _, obj in archive])\n    scores = 0.7 * (total_distances / np.max(total_distances)) + 0.3 * (makespans / np.max(makespans))\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = [route.copy() for route in base_solution]\n\n    for _ in range(3):\n        if not new_solution:\n            break\n\n        # Route splitting: split a long route into two if feasible\n        if len(new_solution) > 0:\n            route_idx = random.randint(0, len(new_solution) - 1)\n            route = new_solution[route_idx]\n\n            if len(route) > 4:\n                split_pos = random.randint(2, len(route) - 3)\n                first_part = route[:split_pos + 1]\n                second_part = np.concatenate([[0], route[split_pos + 1:]])\n\n                if sum(demand[first_part[1:-1]]) <= capacity and sum(demand[second_part[1:-1]]) <= capacity:\n                    new_solution[route_idx] = first_part\n                    new_solution.insert(route_idx + 1, second_part)\n                    continue\n\n        # Customer swapping: swap two customers between two different routes\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1, route2 = new_solution[route1_idx], new_solution[route2_idx]\n\n            if len(route1) > 3 and len(route2) > 3:\n                cust1_pos = random.randint(1, len(route1) - 2)\n                cust2_pos = random.randint(1, len(route2) - 2)\n                cust1, cust2 = route1[cust1_pos], route2[cust2_pos]\n\n                new_route1 = np.delete(route1, cust1_pos)\n                new_route1 = np.insert(new_route1, cust1_pos, cust2)\n\n                new_route2 = np.delete(route2, cust2_pos)\n                new_route2 = np.insert(new_route2, cust2_pos, cust1)\n\n                if sum(demand[new_route1[1:-1]]) <= capacity and sum(demand[new_route2[1:-1]]) <= capacity:\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n        # Adaptive 2.5-opt: perform a limited number of hybrid 2-opt and 3-opt swaps\n        if len(route) > 5:\n            for _ in range(2):\n                if random.random() < 0.7:\n                    i, j = sorted(random.sample(range(1, len(route) - 1), 2))\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:]])\n                else:\n                    i, j, k = sorted(random.sample(range(1, len(route) - 1), 3))\n                    new_route = np.concatenate([route[:i], route[i:j][::-1], route[j:k], route[k:][::-1]])\n\n                if sum(demand[new_route[1:-1]]) <= capacity:\n                    new_solution[route_idx] = new_route\n\n    new_solution = [np.array(route) for route in new_solution]\n    return new_solution\n\n",
        "score": [
            -0.6837579839736119,
            0.08499518036842346
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines adaptive route segmentation with spatial-aware demand redistribution and proximity-based customer reassignment to balance total distance and makespan while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.4 + x[1][1] * 0.6))[0].copy()\n    new_solution = [route.copy() for route in selected_solution]\n\n    # Adaptive route segmentation based on spatial density\n    for i in range(len(new_solution)):\n        route = new_solution[i]\n        if len(route) <= 3:\n            continue\n\n        # Calculate spatial density of customers in route\n        customers = route[1:-1]\n        if len(customers) < 2:\n            continue\n\n        # Find the pair of customers with maximum distance\n        max_dist = -1\n        split_pos = -1\n        for j in range(1, len(customers)):\n            dist = distance_matrix[customers[j-1], customers[j]]\n            if dist > max_dist:\n                max_dist = dist\n                split_pos = j\n\n        if split_pos > 0:\n            # Split route at the position with maximum distance\n            route1_customers = customers[:split_pos]\n            route2_customers = customers[split_pos:]\n\n            # Create new routes\n            route1 = np.concatenate([[0], route1_customers, [0]])\n            route2 = np.concatenate([[0], route2_customers, [0]])\n\n            # Check feasibility\n            if (np.sum(demand[route1_customers]) <= capacity and\n                np.sum(demand[route2_customers]) <= capacity):\n                new_solution[i] = route1\n                new_solution.insert(i+1, route2)\n                break\n\n    # Proximity-based customer reassignment\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        # Select route with highest load ratio\n        load_ratios = [np.sum(demand[route[1:-1]]) / capacity for route in new_solution]\n        route_idx = np.argmax(load_ratios)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        # Find customer with highest demand\n        customers = route[1:-1]\n        customer_idx = np.argmax(demand[customers])\n        customer = customers[customer_idx]\n\n        # Find best target route based on spatial proximity and capacity\n        best_route_idx = -1\n        best_insert_pos = -1\n        best_score = -float('inf')\n\n        for i in range(len(new_solution)):\n            if i == route_idx:\n                continue\n\n            target_route = new_solution[i]\n            if np.sum(demand[target_route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            # Calculate spatial proximity score\n            route_center = np.mean(coords[target_route[1:-1]], axis=0)\n            customer_pos = coords[customer]\n            proximity_score = -np.linalg.norm(route_center - customer_pos)\n\n            # Calculate load balance score\n            current_load = np.sum(demand[target_route[1:-1]])\n            load_balance_score = capacity - current_load - demand[customer]\n\n            # Combined score\n            score = 0.6 * proximity_score + 0.4 * load_balance_score\n\n            if score > best_score:\n                best_score = score\n                best_route_idx = i\n\n                # Find best insertion position\n                min_distance = float('inf')\n                best_pos = -1\n                for pos in range(1, len(target_route)):\n                    prev_node = target_route[pos-1]\n                    next_node = target_route[pos]\n                    dist = distance_matrix[prev_node, customer] + distance_matrix[customer, next_node] - distance_matrix[prev_node, next_node]\n                    if dist < min_distance:\n                        min_distance = dist\n                        best_pos = pos\n\n                best_insert_pos = best_pos\n\n        if best_route_idx != -1:\n            # Perform the reassignment\n            target_route = new_solution[best_route_idx]\n            new_target_route = np.insert(target_route, best_insert_pos, customer)\n            new_solution[best_route_idx] = new_target_route\n\n            # Remove from original route\n            new_route = np.delete(route, customer_idx + 1)\n            new_solution[route_idx] = new_route\n\n    return new_solution\n\n",
        "score": [
            -0.8337601450363273,
            0.5068813264369965
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines route merging and customer redistribution with a biased random walk to explore the solution space while balancing the trade-off between total distance and makespan, ensuring feasibility through capacity-aware transformations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution, _ = random.choices(\n        archive,\n        weights=[1.0 / (1 + obj[0] * obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = [route.copy() for route in selected_solution]\n\n    for _ in range(3):\n        if len(new_solution) < 2:\n            break\n\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) <= 3:\n            continue\n\n        split_pos = random.randint(1, len(route) - 2)\n        new_route1 = route[:split_pos + 1]\n        new_route2 = [0] + route[split_pos:]\n\n        def is_feasible(r):\n            return np.sum(demand[r[1:-1]]) <= capacity\n\n        if not is_feasible(new_route1) or not is_feasible(new_route2):\n            continue\n\n        new_solution.pop(route_idx)\n        new_solution.insert(route_idx, new_route2)\n        new_solution.insert(route_idx, new_route1)\n\n        for _ in range(2):\n            from_route_idx = random.randint(0, len(new_solution) - 1)\n            from_route = new_solution[from_route_idx]\n            if len(from_route) <= 3:\n                continue\n\n            customer_pos = random.randint(1, len(from_route) - 2)\n            customer = from_route[customer_pos]\n\n            to_route_idx = random.randint(0, len(new_solution) - 1)\n            if to_route_idx == from_route_idx:\n                continue\n\n            to_route = new_solution[to_route_idx]\n            if np.sum(demand[to_route[1:-1]]) + demand[customer] > capacity:\n                continue\n\n            insert_pos = random.randint(1, len(to_route) - 1)\n            new_route = np.insert(to_route, insert_pos, customer)\n\n            new_from_route = np.delete(from_route, customer_pos)\n\n            new_solution[to_route_idx] = new_route\n            new_solution[from_route_idx] = new_from_route\n\n    for _ in range(2):\n        if len(new_solution) < 2:\n            break\n\n        route1_idx = random.randint(0, len(new_solution) - 1)\n        route1 = new_solution[route1_idx]\n        if len(route1) <= 3:\n            continue\n\n        route2_idx = random.randint(0, len(new_solution) - 1)\n        if route2_idx == route1_idx:\n            continue\n\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 > 10:\n            continue\n\n        merged_route = np.concatenate((route1[1:-1], route2[1:-1]))\n        merged_route = np.insert(merged_route, 0, 0)\n        merged_route = np.append(merged_route, 0)\n\n        if np.sum(demand[merged_route[1:-1]]) > capacity:\n            continue\n\n        new_solution.pop(max(route1_idx, route2_idx))\n        new_solution.pop(min(route1_idx, route2_idx))\n        new_solution.append(merged_route)\n\n    return new_solution\n\n",
        "score": [
            -0.7070146148070439,
            0.1301042139530182
        ]
    }
]