[
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route splitting, customer reinsertion, and depot relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance then makespan\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: split a route, reinsert customers, and relocate depot\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Split the route into two parts\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1].copy()\n        part2 = route[split_idx:].copy()\n\n        # Step 2: Reinsert customers from part2 into part1 while respecting capacity\n        customers_to_reinsert = part2[1:-1].copy()\n        random.shuffle(customers_to_reinsert)\n\n        for customer in customers_to_reinsert:\n            best_pos = -1\n            min_increase = float('inf')\n\n            # Find the best insertion position in part1\n            for i in range(1, len(part1)):\n                temp_route = np.insert(part1, i, customer)\n                if sum(demand[temp_route[1:-1]]) <= capacity:\n                    dist_increase = (distance_matrix[temp_route[i-1]][customer] +\n                                    distance_matrix[customer][temp_route[i]] -\n                                    distance_matrix[temp_route[i-1]][temp_route[i]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = i\n\n            if best_pos != -1:\n                part1 = np.insert(part1, best_pos, customer)\n\n        # Step 3: Relocate depot in part1 to balance the route\n        if len(part1) > 3:\n            best_depot_pos = -1\n            min_makespan = float('inf')\n\n            for i in range(1, len(part1)):\n                temp_route = np.insert(part1, i, 0)\n                temp_route = np.delete(temp_route, np.where(temp_route == 0)[0][1])  # Ensure only one depot\n                temp_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                if temp_dist < min_makespan and sum(demand[temp_route[1:-1]]) <= capacity:\n                    min_makespan = temp_dist\n                    best_depot_pos = i\n\n            if best_depot_pos != -1:\n                part1 = np.insert(part1, best_depot_pos, 0)\n                part1 = np.delete(part1, np.where(part1 == 0)[0][1])  # Ensure only one depot\n\n        new_solution.extend([part1, part2])\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0:\n            new_solution[i] = np.insert(new_solution[i], 0, 0)\n        if new_solution[i][-1] != 0:\n            new_solution[i] = np.append(new_solution[i], 0)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8854103612598478,
            6.212688565254211
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by identifying routes with the largest makespan, then applies a hybrid local search operator that combines route segmentation and insertion heuristics to balance distance and makespan reduction, while ensuring feasibility through capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search: segment and reinsert routes to balance distance and makespan\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes (depot-depot or single customer)\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two segments at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_idx + 1]\n        segment2 = route[split_idx:]\n\n        # Check capacity feasibility for both segments\n        seg1_demand = np.sum(demand[segment1[1:-1]])\n        seg2_demand = np.sum(demand[segment2[1:-1]])\n\n        if seg1_demand <= capacity and seg2_demand <= capacity:\n            new_solution.append(segment1.copy())\n            new_solution.append(segment2.copy())\n        else:\n            # If split is infeasible, try inserting a random customer from another route\n            other_route = np.random.choice([r for r in base_solution if len(r) > 3 and r is not route])\n            if len(other_route) > 3:\n                insert_pos = np.random.randint(1, len(other_route) - 1)\n                customer = other_route[insert_pos]\n                if np.sum(demand[segment1[1:-1]]) + demand[customer] <= capacity:\n                    new_segment = np.insert(segment1, -1, customer)\n                    new_solution.append(new_segment)\n                    # Remove the customer from the other route\n                    new_other_route = np.delete(other_route, insert_pos)\n                    new_solution.append(new_other_route)\n                else:\n                    new_solution.append(route.copy())\n\n    # Ensure all customers are served (fallback if some are missing)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing = all_customers - served_customers\n    if missing:\n        # Reassign missing customers to routes with available capacity\n        for customer in missing:\n            for i, route in enumerate(new_solution):\n                if np.sum(demand[list(route[1:-1])]) + demand[customer] <= capacity:\n                    new_route = np.insert(route, -1, customer)\n                    new_solution[i] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8634949154541082,
            0.36051949858665466
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            # If splitting is infeasible, try reinserting customers from the longer part\n            longer_part = part1 if len(part1) > len(part2) else part2\n            shorter_part = part2 if len(part1) > len(part2) else part1\n\n            # Randomly select a customer to reinsert\n            if len(longer_part) > 2:\n                customer_idx = np.random.randint(1, len(longer_part) - 1)\n                customer = longer_part[customer_idx]\n                # Try inserting the customer into the shorter part at the best feasible position\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(shorter_part)):\n                    temp_route = np.insert(shorter_part, i, customer)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[temp_route[i-1], customer] + distance_matrix[customer, temp_route[i+1]] - distance_matrix[temp_route[i-1], temp_route[i+1]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n                if best_cost < float('inf'):\n                    shorter_part = np.insert(shorter_part, best_pos, customer)\n                    longer_part = np.delete(longer_part, customer_idx)\n                    if len(longer_part) > 2:\n                        new_solution.append(longer_part)\n                    if len(shorter_part) > 2:\n                        new_solution.append(shorter_part)\n                else:\n                    new_solution.append(route)\n            else:\n                new_solution.append(route)\n\n    return new_solution\n\n",
        "score": [
            -0.7148990727857493,
            0.11328020691871643
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i, route in enumerate(new_solution):\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check if splitting is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n        else:\n            # If splitting is not feasible, try reallocating a customer to another route\n            for j in range(1, len(route) - 1):\n                customer = route[j]\n                # Find the best route to insert this customer\n                best_route = -1\n                best_pos = -1\n                best_cost = float('inf')\n\n                for k, other_route in enumerate(new_solution):\n                    if k == i:\n                        continue\n                    # Try inserting the customer at all possible positions\n                    for pos in range(1, len(other_route)):\n                        temp_route = np.insert(other_route, pos, customer)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            # Calculate the additional cost\n                            cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                                   distance_matrix[customer][temp_route[pos+1]] - \\\n                                   distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = k\n                                best_pos = pos\n\n                if best_route != -1:\n                    # Perform the reallocation\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                    new_solution[i] = np.delete(new_solution[i], j)\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7903060370334931,
            0.268205463886261
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with intelligent customer reinsertion, prioritizing load-balancing and spatial proximity to improve both total distance and makespan objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Select two routes to potentially merge\n    route_indices = np.random.choice(len(new_solution), size=2, replace=False)\n    route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n    # Calculate potential merged load\n    total_load = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n\n    if total_load <= capacity:\n        # Find the closest pair of customers (one from each route) to minimize insertion cost\n        best_cost = float('inf')\n        best_pair = (0, 0)\n\n        for i in range(1, len(route1) - 1):\n            for j in range(1, len(route2) - 1):\n                cost = distance_matrix[route1[i]][route2[j]] + \\\n                       distance_matrix[route2[j]][route1[i+1]] + \\\n                       distance_matrix[route2[j-1]][route2[j+1]] - \\\n                       (distance_matrix[route1[i]][route1[i+1]] + distance_matrix[route2[j-1]][route2[j]] + distance_matrix[route2[j]][route2[j+1]])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pair = (i, j)\n\n        # Merge the routes at the best position\n        merged_route = np.concatenate([route1[:best_pair[0]+1], route2[best_pair[1]:], route2[:best_pair[1]+1], route1[best_pair[0]+1:]])\n        new_solution[route_indices[0]] = merged_route\n        new_solution.pop(route_indices[1])\n    else:\n        # If merging is not feasible, try reallocating the heaviest customer to another route\n        all_customers = []\n        for route in new_solution:\n            all_customers.extend(route[1:-1])\n\n        if not all_customers:\n            return new_solution\n\n        # Find the customer with maximum demand\n        heaviest_customer = max(all_customers, key=lambda x: demand[x])\n\n        # Find the best route to insert this customer\n        best_route = -1\n        best_pos = -1\n        best_cost = float('inf')\n\n        for k, route in enumerate(new_solution):\n            if heaviest_customer in route:\n                continue\n            for pos in range(1, len(route)):\n                temp_route = np.insert(route, pos, heaviest_customer)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    cost = distance_matrix[temp_route[pos-1]][heaviest_customer] + \\\n                           distance_matrix[heaviest_customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route = k\n                        best_pos = pos\n\n        if best_route != -1:\n            # Perform the reallocation\n            new_solution[best_route] = np.insert(new_solution[best_route], best_pos, heaviest_customer)\n            # Remove the customer from its original route\n            for route in new_solution:\n                if heaviest_customer in route:\n                    route = np.delete(route, np.where(route == heaviest_customer)[0][0])\n                    break\n\n    # Remove empty routes (though in this case, we don't create any)\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8476555168263109,
            1.374678611755371
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route splitting and merging\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Find the best merge point (minimizing the increase in total distance)\n        min_increase = float('inf')\n        best_merge = None\n\n        for k in range(1, len(route1) - 1):\n            for l in range(1, len(route2) - 1):\n                # Try merging route1 and route2 at positions k and l\n                merged_route = np.concatenate([route1[:k], route2[1:l], route1[k:]])\n                if np.sum(demand[merged_route[1:-1]]) > capacity:\n                    continue  # Skip if capacity is exceeded\n\n                # Calculate the increase in total distance\n                increase = (distance_matrix[route1[k-1], route2[1]] +\n                            distance_matrix[route2[l-1], route1[k]] -\n                            distance_matrix[route1[k-1], route1[k]] -\n                            distance_matrix[route2[l-1], route2[l]])\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_merge = merged_route\n\n        if best_merge is not None:\n            # Apply the best merge and remove the original routes\n            new_solution.append(best_merge)\n            new_solution.pop(i)\n            new_solution.pop(j-1 if j > i else j)\n\n    # If no merge was possible, try splitting a long route\n    else:\n        longest_route = max(new_solution, key=len)\n        if len(longest_route) > 3:  # Ensure the route can be split\n            split_pos = np.random.randint(1, len(longest_route) - 1)\n            route1 = longest_route[:split_pos + 1]\n            route2 = longest_route[split_pos:]\n\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n                new_solution.remove(longest_route)\n                new_solution.extend([route1, route2])\n\n    return new_solution\n\n",
        "score": [
            -0.8063581755893915,
            0.5286880731582642
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid score combining distance and makespan, then applies a novel local search combining route merging, customer reallocation, and adaptive insertion to balance both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Apply hybrid local search: route merging + customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Try merging with adjacent routes if capacity allows\n        merged = False\n        for i, other_route in enumerate(selected_solution):\n            if np.array_equal(route, other_route) or len(other_route) <= 2:\n                continue\n            # Check if merging is feasible\n            combined_demand = np.sum(demand[route[1:-1]]) + np.sum(demand[other_route[1:-1]])\n            if combined_demand <= capacity:\n                # Merge routes by inserting other_route into this one at best position\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(route)):\n                    temp_route = np.insert(route, pos, other_route[1:-1])\n                    cost = (distance_matrix[route[pos-1], other_route[1]] +\n                            distance_matrix[other_route[-2], route[pos]] -\n                            distance_matrix[route[pos-1], route[pos]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                if best_cost < float('inf'):\n                    merged_route = np.insert(route, best_pos, other_route[1:-1])\n                    new_solution.append(merged_route)\n                    selected_solution[i] = np.array([0])  # Mark other route as merged\n                    merged = True\n                    break\n\n        if not merged:\n            # If no merge, try reallocating customers to balance makespan\n            if np.random.random() < 0.3:  # 30% chance of reallocation\n                for _ in range(2):  # Try reallocating 2 customers max\n                    if len(route) <= 3:\n                        break\n                    # Select customer with highest demand\n                    customer_idx = np.argmax(demand[route[1:-1]]) + 1\n                    customer = route[customer_idx]\n                    # Try inserting into another route at best position\n                    best_route_idx = -1\n                    best_pos = -1\n                    best_cost = float('inf')\n                    for i, other_route in enumerate(selected_solution):\n                        if np.array_equal(route, other_route) or len(other_route) <= 2:\n                            continue\n                        if np.sum(demand[other_route[1:-1]]) + demand[customer] > capacity:\n                            continue\n                        for pos in range(1, len(other_route)):\n                            cost = (distance_matrix[other_route[pos-1], customer] +\n                                    distance_matrix[customer, other_route[pos]] -\n                                    distance_matrix[other_route[pos-1], other_route[pos]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route_idx = i\n                                best_pos = pos\n                    if best_route_idx != -1:\n                        # Perform the reallocation\n                        selected_solution[best_route_idx] = np.insert(\n                            selected_solution[best_route_idx], best_pos, customer)\n                        route = np.delete(route, customer_idx)\n            new_solution.append(route)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8050534777962574,
            1.3223348557949066
        ]
    },
    {
        "algorithm": "{The new algorithm combines route merging with strategic customer reinsertion, where it intelligently merges compatible routes while reinserting customers from the merged route into other feasible positions to balance the objectives of total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route merging with strategic customer reinsertion\n    if len(new_solution) > 1:\n        # Select two routes to merge\n        route1_idx, route2_idx = np.random.choice(len(new_solution), 2, replace=False)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Check if merging is feasible (capacity constraint)\n        if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Remove the old routes and add the merged route\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.append(merged_route)\n\n            # Reinsert customers from the merged route into other feasible positions\n            for customer in merged_route[1:-1]:\n                best_route = -1\n                best_pos = -1\n                best_cost = float('inf')\n\n                for i, route in enumerate(new_solution):\n                    if i == len(new_solution) - 1:  # Skip the newly merged route\n                        continue\n                    for pos in range(1, len(route)):\n                        temp_route = np.insert(route, pos, customer)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                                   distance_matrix[customer][temp_route[pos+1]] - \\\n                                   distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = i\n                                best_pos = pos\n\n                if best_route != -1:\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                    merged_route = np.delete(merged_route, np.where(merged_route == customer)[0][0])\n\n            # Add back the modified merged route if it still has customers\n            if len(merged_route) > 2:\n                new_solution.append(merged_route)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7230956843493572,
            0.4863170087337494
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with the worst total distance from the archive and applies a novel hybrid local search that combines route merging, customer reallocation, and adaptive splitting to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n\n    # Initialize the new solution\n    new_solution = []\n\n    # Apply hybrid local search: route merging, customer reallocation, and adaptive splitting\n    for i in range(len(selected_solution)):\n        for j in range(i + 1, len(selected_solution)):\n            # Try merging routes i and j\n            merged_route = np.concatenate((selected_solution[i][:-1], selected_solution[j][1:]))\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # If feasible, check if merging improves the makespan\n                current_makespan = max([len(r) - 1 for r in selected_solution])\n                new_makespan = max([len(r) - 1 for r in selected_solution if r is not selected_solution[i] and r is not selected_solution[j]] + [len(merged_route) - 1])\n                if new_makespan < current_makespan:\n                    new_solution.append(merged_route)\n                    # Remove the merged routes\n                    selected_solution = [r for r in selected_solution if r is not selected_solution[i] and r is not selected_solution[j]]\n                    break\n        else:\n            continue\n        break\n\n    # Add remaining routes\n    new_solution.extend([r for r in selected_solution if r not in new_solution])\n\n    # Perform customer reallocation to balance makespan\n    if len(new_solution) > 1:\n        # Find the longest and shortest routes\n        longest_route = max(new_solution, key=lambda x: len(x))\n        shortest_route = min(new_solution, key=lambda x: len(x))\n\n        if len(longest_route) > 3 and len(shortest_route) > 2:\n            # Try moving a customer from the longest to the shortest route\n            candidate_customers = [c for c in longest_route[1:-1] if np.sum(demand[shortest_route[1:-1]]) + demand[c] <= capacity]\n            if candidate_customers:\n                # Select the customer that would most reduce the makespan\n                best_customer = None\n                best_reduction = 0\n                for c in candidate_customers:\n                    temp_route = np.delete(longest_route, np.where(longest_route == c)[0][0])\n                    new_longest = len(temp_route) - 1 if len(temp_route) > 2 else 0\n                    new_shortest = len(shortest_route) + 1\n                    reduction = (len(longest_route) - 1) - max(new_longest, new_shortest)\n                    if reduction > best_reduction:\n                        best_reduction = reduction\n                        best_customer = c\n\n                if best_customer is not None:\n                    # Perform the move\n                    idx = np.where(longest_route == best_customer)[0][0]\n                    longest_route = np.delete(longest_route, idx)\n                    shortest_route = np.insert(shortest_route, -1, best_customer)\n\n                    # Update the solution\n                    new_solution = [r for r in new_solution if not np.array_equal(r, longest_route) and not np.array_equal(r, shortest_route)]\n                    if len(longest_route) > 2:\n                        new_solution.append(longest_route)\n                    new_solution.append(shortest_route)\n\n    # Perform adaptive splitting for routes that are too long\n    for route in new_solution:\n        if len(route) > 10:  # Arbitrary threshold for \"too long\"\n            # Find the best split point that balances distance and makespan\n            best_split = None\n            best_score = float('inf')\n            for k in range(2, len(route) - 2):\n                part1 = route[:k + 1]\n                part2 = route[k:]\n                if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n                    # Calculate a score that balances distance and makespan\n                    dist_part1 = sum(distance_matrix[part1[i], part1[i+1]] for i in range(len(part1)-1))\n                    dist_part2 = sum(distance_matrix[part2[i], part2[i+1]] for i in range(len(part2)-1))\n                    makespan_score = abs((len(part1) - 1) - (len(part2) - 1))\n                    score = 0.7 * (dist_part1 + dist_part2) + 0.3 * makespan_score\n                    if score < best_score:\n                        best_score = score\n                        best_split = k\n\n            if best_split is not None:\n                part1 = route[:best_split + 1]\n                part2 = route[best_split:]\n                new_solution = [r for r in new_solution if not np.array_equal(r, route)]\n                new_solution.append(part1)\n                new_solution.append(part2)\n\n    return new_solution\n\n",
        "score": [
            -0.7861715311080972,
            1.4776295721530914
        ]
    },
    {
        "algorithm": "{The new algorithm combines route clustering based on spatial proximity with demand-aware route merging to balance distance and makespan objectives, while ensuring feasibility through capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Cluster routes based on spatial proximity and demand similarity\n    clustered_routes = []\n    for route in selected_solution:\n        if len(route) <= 3:\n            clustered_routes.append(route)\n            continue\n\n        # Calculate centroid of the route's customers\n        customers = route[1:-1]\n        if len(customers) == 0:\n            clustered_routes.append(route)\n            continue\n\n        centroid = np.mean(coords[customers], axis=0)\n\n        # Find the closest existing cluster\n        closest_cluster = None\n        min_distance = float('inf')\n        for i, cluster in enumerate(clustered_routes):\n            if len(cluster) <= 3:\n                continue\n            cluster_customers = cluster[1:-1]\n            if len(cluster_customers) == 0:\n                continue\n            cluster_centroid = np.mean(coords[cluster_customers], axis=0)\n            dist = np.linalg.norm(centroid - cluster_centroid)\n\n            if dist < min_distance:\n                min_distance = dist\n                closest_cluster = i\n\n        # Merge with closest cluster if feasible\n        if closest_cluster is not None and min_distance < np.mean(distance_matrix[0]):\n            cluster = clustered_routes[closest_cluster]\n            merged_route = np.concatenate((cluster[:-1], route[1:]))\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                clustered_routes[closest_cluster] = merged_route\n            else:\n                clustered_routes.append(route)\n        else:\n            clustered_routes.append(route)\n\n    # Apply demand-aware route splitting to balance makespan\n    final_solution = []\n    for route in clustered_routes:\n        if len(route) <= 3:\n            final_solution.append(route)\n            continue\n\n        # Split route at the point where demand is closest to half capacity\n        customers = route[1:-1]\n        cumulative_demand = np.cumsum(demand[customers])\n        half_cap = np.sum(demand[customers]) / 2\n        split_idx = np.argmin(np.abs(cumulative_demand - half_cap)) + 1\n\n        part1 = np.concatenate(([0], customers[:split_idx], [0]))\n        part2 = np.concatenate(([0], customers[split_idx:], [0]))\n\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            final_solution.append(part1)\n            final_solution.append(part2)\n        else:\n            final_solution.append(route)\n\n    return final_solution\n\n",
        "score": [
            -0.743319739731461,
            4.537335216999054
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i, route in enumerate(new_solution):\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check if splitting is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n        else:\n            # If splitting is not feasible, try reallocating a customer to another route\n            for j in range(1, len(route) - 1):\n                customer = route[j]\n                # Find the best route to insert this customer\n                best_route = -1\n                best_pos = -1\n                best_cost = float('inf')\n\n                for k, other_route in enumerate(new_solution):\n                    if k == i:\n                        continue\n                    # Try inserting the customer at all possible positions\n                    for pos in range(1, len(other_route)):\n                        temp_route = np.insert(other_route, pos, customer)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            # Calculate the additional cost\n                            cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                                   distance_matrix[customer][temp_route[pos+1]] - \\\n                                   distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = k\n                                best_pos = pos\n\n                if best_route != -1:\n                    # Perform the reallocation\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                    new_solution[i] = np.delete(new_solution[i], j)\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7903060370334931,
            0.268205463886261
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            # If splitting is infeasible, try reinserting customers from the longer part\n            longer_part = part1 if len(part1) > len(part2) else part2\n            shorter_part = part2 if len(part1) > len(part2) else part1\n\n            # Randomly select a customer to reinsert\n            if len(longer_part) > 2:\n                customer_idx = np.random.randint(1, len(longer_part) - 1)\n                customer = longer_part[customer_idx]\n                # Try inserting the customer into the shorter part at the best feasible position\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(shorter_part)):\n                    temp_route = np.insert(shorter_part, i, customer)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[temp_route[i-1], customer] + distance_matrix[customer, temp_route[i+1]] - distance_matrix[temp_route[i-1], temp_route[i+1]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n                if best_cost < float('inf'):\n                    shorter_part = np.insert(shorter_part, best_pos, customer)\n                    longer_part = np.delete(longer_part, customer_idx)\n                    if len(longer_part) > 2:\n                        new_solution.append(longer_part)\n                    if len(shorter_part) > 2:\n                        new_solution.append(shorter_part)\n                else:\n                    new_solution.append(route)\n            else:\n                new_solution.append(route)\n\n    return new_solution\n\n",
        "score": [
            -0.7148990727857493,
            0.11328020691871643
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by identifying routes with the largest makespan, then applies a hybrid local search operator that combines route segmentation and insertion heuristics to balance distance and makespan reduction, while ensuring feasibility through capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search: segment and reinsert routes to balance distance and makespan\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes (depot-depot or single customer)\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two segments at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_idx + 1]\n        segment2 = route[split_idx:]\n\n        # Check capacity feasibility for both segments\n        seg1_demand = np.sum(demand[segment1[1:-1]])\n        seg2_demand = np.sum(demand[segment2[1:-1]])\n\n        if seg1_demand <= capacity and seg2_demand <= capacity:\n            new_solution.append(segment1.copy())\n            new_solution.append(segment2.copy())\n        else:\n            # If split is infeasible, try inserting a random customer from another route\n            other_route = np.random.choice([r for r in base_solution if len(r) > 3 and r is not route])\n            if len(other_route) > 3:\n                insert_pos = np.random.randint(1, len(other_route) - 1)\n                customer = other_route[insert_pos]\n                if np.sum(demand[segment1[1:-1]]) + demand[customer] <= capacity:\n                    new_segment = np.insert(segment1, -1, customer)\n                    new_solution.append(new_segment)\n                    # Remove the customer from the other route\n                    new_other_route = np.delete(other_route, insert_pos)\n                    new_solution.append(new_other_route)\n                else:\n                    new_solution.append(route.copy())\n\n    # Ensure all customers are served (fallback if some are missing)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing = all_customers - served_customers\n    if missing:\n        # Reassign missing customers to routes with available capacity\n        for customer in missing:\n            for i, route in enumerate(new_solution):\n                if np.sum(demand[list(route[1:-1])]) + demand[customer] <= capacity:\n                    new_route = np.insert(route, -1, customer)\n                    new_solution[i] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8634949154541082,
            0.36051949858665466
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route splitting, customer reinsertion, and depot relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance then makespan\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: split a route, reinsert customers, and relocate depot\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Split the route into two parts\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1].copy()\n        part2 = route[split_idx:].copy()\n\n        # Step 2: Reinsert customers from part2 into part1 while respecting capacity\n        customers_to_reinsert = part2[1:-1].copy()\n        random.shuffle(customers_to_reinsert)\n\n        for customer in customers_to_reinsert:\n            best_pos = -1\n            min_increase = float('inf')\n\n            # Find the best insertion position in part1\n            for i in range(1, len(part1)):\n                temp_route = np.insert(part1, i, customer)\n                if sum(demand[temp_route[1:-1]]) <= capacity:\n                    dist_increase = (distance_matrix[temp_route[i-1]][customer] +\n                                    distance_matrix[customer][temp_route[i]] -\n                                    distance_matrix[temp_route[i-1]][temp_route[i]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = i\n\n            if best_pos != -1:\n                part1 = np.insert(part1, best_pos, customer)\n\n        # Step 3: Relocate depot in part1 to balance the route\n        if len(part1) > 3:\n            best_depot_pos = -1\n            min_makespan = float('inf')\n\n            for i in range(1, len(part1)):\n                temp_route = np.insert(part1, i, 0)\n                temp_route = np.delete(temp_route, np.where(temp_route == 0)[0][1])  # Ensure only one depot\n                temp_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                if temp_dist < min_makespan and sum(demand[temp_route[1:-1]]) <= capacity:\n                    min_makespan = temp_dist\n                    best_depot_pos = i\n\n            if best_depot_pos != -1:\n                part1 = np.insert(part1, best_depot_pos, 0)\n                part1 = np.delete(part1, np.where(part1 == 0)[0][1])  # Ensure only one depot\n\n        new_solution.extend([part1, part2])\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0:\n            new_solution[i] = np.insert(new_solution[i], 0, 0)\n        if new_solution[i][-1] != 0:\n            new_solution[i] = np.append(new_solution[i], 0)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8854103612598478,
            6.212688565254211
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            # If splitting is infeasible, try reinserting customers from the longer part\n            longer_part = part1 if len(part1) > len(part2) else part2\n            shorter_part = part2 if len(part1) > len(part2) else part1\n\n            # Randomly select a customer to reinsert\n            if len(longer_part) > 2:\n                customer_idx = np.random.randint(1, len(longer_part) - 1)\n                customer = longer_part[customer_idx]\n                # Try inserting the customer into the shorter part at the best feasible position\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(shorter_part)):\n                    temp_route = np.insert(shorter_part, i, customer)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[temp_route[i-1], customer] + distance_matrix[customer, temp_route[i+1]] - distance_matrix[temp_route[i-1], temp_route[i+1]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n                if best_cost < float('inf'):\n                    shorter_part = np.insert(shorter_part, best_pos, customer)\n                    longer_part = np.delete(longer_part, customer_idx)\n                    if len(longer_part) > 2:\n                        new_solution.append(longer_part)\n                    if len(shorter_part) > 2:\n                        new_solution.append(shorter_part)\n                else:\n                    new_solution.append(route)\n            else:\n                new_solution.append(route)\n\n    return new_solution\n\n",
        "score": [
            -0.7148990727857493,
            0.11328020691871643
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i, route in enumerate(new_solution):\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check if splitting is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n        else:\n            # If splitting is not feasible, try reallocating a customer to another route\n            for j in range(1, len(route) - 1):\n                customer = route[j]\n                # Find the best route to insert this customer\n                best_route = -1\n                best_pos = -1\n                best_cost = float('inf')\n\n                for k, other_route in enumerate(new_solution):\n                    if k == i:\n                        continue\n                    # Try inserting the customer at all possible positions\n                    for pos in range(1, len(other_route)):\n                        temp_route = np.insert(other_route, pos, customer)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            # Calculate the additional cost\n                            cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                                   distance_matrix[customer][temp_route[pos+1]] - \\\n                                   distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = k\n                                best_pos = pos\n\n                if best_route != -1:\n                    # Perform the reallocation\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                    new_solution[i] = np.delete(new_solution[i], j)\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7903060370334931,
            0.268205463886261
        ]
    }
]