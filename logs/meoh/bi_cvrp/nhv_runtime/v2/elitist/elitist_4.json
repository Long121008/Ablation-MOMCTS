[
    {
        "algorithm": "{The new algorithm implements a hybrid approach combining route splitting with spatial clustering and demand-aware customer reallocation to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Select a route to potentially split or modify\n    route_idx = np.random.randint(0, len(new_solution))\n    selected_route = new_solution[route_idx]\n\n    # Calculate spatial and demand metrics for the selected route\n    customers = selected_route[1:-1]\n    if len(customers) <= 2:\n        return new_solution\n\n    # Find the customer with maximum demand in the route\n    heaviest_customer = max(customers, key=lambda x: demand[x])\n\n    # Calculate spatial centroid of the route\n    route_coords = coords[customers]\n    centroid = np.mean(route_coords, axis=0)\n\n    # Find the customer farthest from centroid (potential split point)\n    farthest_customer = max(customers, key=lambda x: np.linalg.norm(coords[x] - centroid))\n\n    # Try to split the route at the farthest customer\n    split_pos = np.where(selected_route == farthest_customer)[0][0]\n    first_part = selected_route[:split_pos+1]\n    second_part = selected_route[split_pos:]\n\n    # Check if both parts are feasible\n    if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n        new_solution[route_idx] = first_part\n        new_solution.insert(route_idx + 1, second_part)\n    else:\n        # If split is not feasible, try reallocating the heaviest customer\n        best_route = -1\n        best_pos = -1\n        best_score = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == route_idx:\n                continue\n            for pos in range(1, len(route)):\n                temp_route = np.insert(route, pos, heaviest_customer)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    # Score based on distance increase and makespan balance\n                    dist_increase = (distance_matrix[temp_route[pos-1]][heaviest_customer] +\n                                    distance_matrix[heaviest_customer][temp_route[pos+1]] -\n                                    distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                    makespan_diff = abs(len(temp_route) - len(selected_route)) * 0.5\n                    score = dist_increase + makespan_diff\n                    if score < best_score:\n                        best_score = score\n                        best_route = i\n                        best_pos = pos\n\n        if best_route != -1:\n            # Perform the reallocation\n            new_solution[best_route] = np.insert(new_solution[best_route], best_pos, heaviest_customer)\n            new_solution[route_idx] = np.delete(new_solution[route_idx], np.where(new_solution[route_idx] == heaviest_customer)[0][0])\n\n    return new_solution\n\n",
        "score": [
            -0.7906421695167611,
            0.09088990092277527
        ]
    },
    {
        "algorithm": "{The new algorithm combines spatial clustering with adaptive route splitting to balance load and distance, prioritizing high-demand customers and minimizing the longest route while considering geographic proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])  # Sort by makespan\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Select the longest route to consider splitting\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Find high-demand customers in the longest route\n    high_demand_customers = sorted(longest_route[1:-1], key=lambda x: demand[x], reverse=True)\n\n    if not high_demand_customers:\n        return new_solution\n\n    # Try to create a new route with the highest demand customer\n    highest_demand = high_demand_customers[0]\n    new_route = np.array([0, highest_demand, 0])\n\n    # Remove the customer from the original route\n    new_solution[longest_route_idx] = np.delete(longest_route, np.where(longest_route == highest_demand)[0][0])\n\n    # Try to insert remaining high-demand customers into the new route\n    for customer in high_demand_customers[1:]:\n        current_load = np.sum(demand[new_route[1:-1]])\n        if current_load + demand[customer] <= capacity:\n            # Find the best insertion position\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(new_route)):\n                temp_route = np.insert(new_route, pos, customer)\n                cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                       distance_matrix[customer][temp_route[pos+1]] - \\\n                       distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            new_route = np.insert(new_route, best_pos, customer)\n\n    # Add the new route to the solution\n    new_solution.append(new_route)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8730305050643937,
            0.7784204483032227
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by identifying routes with the largest makespan, then applies a hybrid local search operator that combines route segmentation and insertion heuristics to balance distance and makespan reduction, while ensuring feasibility through capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search: segment and reinsert routes to balance distance and makespan\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes (depot-depot or single customer)\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two segments at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_idx + 1]\n        segment2 = route[split_idx:]\n\n        # Check capacity feasibility for both segments\n        seg1_demand = np.sum(demand[segment1[1:-1]])\n        seg2_demand = np.sum(demand[segment2[1:-1]])\n\n        if seg1_demand <= capacity and seg2_demand <= capacity:\n            new_solution.append(segment1.copy())\n            new_solution.append(segment2.copy())\n        else:\n            # If split is infeasible, try inserting a random customer from another route\n            other_route = np.random.choice([r for r in base_solution if len(r) > 3 and r is not route])\n            if len(other_route) > 3:\n                insert_pos = np.random.randint(1, len(other_route) - 1)\n                customer = other_route[insert_pos]\n                if np.sum(demand[segment1[1:-1]]) + demand[customer] <= capacity:\n                    new_segment = np.insert(segment1, -1, customer)\n                    new_solution.append(new_segment)\n                    # Remove the customer from the other route\n                    new_other_route = np.delete(other_route, insert_pos)\n                    new_solution.append(new_other_route)\n                else:\n                    new_solution.append(route.copy())\n\n    # Ensure all customers are served (fallback if some are missing)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing = all_customers - served_customers\n    if missing:\n        # Reassign missing customers to routes with available capacity\n        for customer in missing:\n            for i, route in enumerate(new_solution):\n                if np.sum(demand[list(route[1:-1])]) + demand[customer] <= capacity:\n                    new_route = np.insert(route, -1, customer)\n                    new_solution[i] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8634949154541082,
            0.36051949858665466
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route splitting, customer reinsertion, and depot relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance then makespan\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: split a route, reinsert customers, and relocate depot\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Split the route into two parts\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1].copy()\n        part2 = route[split_idx:].copy()\n\n        # Step 2: Reinsert customers from part2 into part1 while respecting capacity\n        customers_to_reinsert = part2[1:-1].copy()\n        random.shuffle(customers_to_reinsert)\n\n        for customer in customers_to_reinsert:\n            best_pos = -1\n            min_increase = float('inf')\n\n            # Find the best insertion position in part1\n            for i in range(1, len(part1)):\n                temp_route = np.insert(part1, i, customer)\n                if sum(demand[temp_route[1:-1]]) <= capacity:\n                    dist_increase = (distance_matrix[temp_route[i-1]][customer] +\n                                    distance_matrix[customer][temp_route[i]] -\n                                    distance_matrix[temp_route[i-1]][temp_route[i]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = i\n\n            if best_pos != -1:\n                part1 = np.insert(part1, best_pos, customer)\n\n        # Step 3: Relocate depot in part1 to balance the route\n        if len(part1) > 3:\n            best_depot_pos = -1\n            min_makespan = float('inf')\n\n            for i in range(1, len(part1)):\n                temp_route = np.insert(part1, i, 0)\n                temp_route = np.delete(temp_route, np.where(temp_route == 0)[0][1])  # Ensure only one depot\n                temp_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                if temp_dist < min_makespan and sum(demand[temp_route[1:-1]]) <= capacity:\n                    min_makespan = temp_dist\n                    best_depot_pos = i\n\n            if best_depot_pos != -1:\n                part1 = np.insert(part1, best_depot_pos, 0)\n                part1 = np.delete(part1, np.where(part1 == 0)[0][1])  # Ensure only one depot\n\n        new_solution.extend([part1, part2])\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0:\n            new_solution[i] = np.insert(new_solution[i], 0, 0)\n        if new_solution[i][-1] != 0:\n            new_solution[i] = np.append(new_solution[i], 0)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8854103612598478,
            6.212688565254211
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: route splitting and merging\n    if len(new_solution) > 1:\n        # Randomly select two routes to merge\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        route1, route2 = new_solution[i], new_solution[j]\n\n        # Find the best merge point (minimizing the increase in total distance)\n        min_increase = float('inf')\n        best_merge = None\n\n        for k in range(1, len(route1) - 1):\n            for l in range(1, len(route2) - 1):\n                # Try merging route1 and route2 at positions k and l\n                merged_route = np.concatenate([route1[:k], route2[1:l], route1[k:]])\n                if np.sum(demand[merged_route[1:-1]]) > capacity:\n                    continue  # Skip if capacity is exceeded\n\n                # Calculate the increase in total distance\n                increase = (distance_matrix[route1[k-1], route2[1]] +\n                            distance_matrix[route2[l-1], route1[k]] -\n                            distance_matrix[route1[k-1], route1[k]] -\n                            distance_matrix[route2[l-1], route2[l]])\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_merge = merged_route\n\n        if best_merge is not None:\n            # Apply the best merge and remove the original routes\n            new_solution.append(best_merge)\n            new_solution.pop(i)\n            new_solution.pop(j-1 if j > i else j)\n\n    # If no merge was possible, try splitting a long route\n    else:\n        longest_route = max(new_solution, key=len)\n        if len(longest_route) > 3:  # Ensure the route can be split\n            split_pos = np.random.randint(1, len(longest_route) - 1)\n            route1 = longest_route[:split_pos + 1]\n            route2 = longest_route[split_pos:]\n\n            if (np.sum(demand[route1[1:-1]]) <= capacity and\n                np.sum(demand[route2[1:-1]]) <= capacity):\n                new_solution.remove(longest_route)\n                new_solution.extend([route1, route2])\n\n    return new_solution\n\n",
        "score": [
            -0.8063581755893915,
            0.5286880731582642
        ]
    },
    {
        "algorithm": "{The new algorithm combines route reversal with adaptive customer reallocation, where it reverses selected route segments and intelligently reallocates customers to other routes based on their spatial proximity and demand compatibility, while ensuring feasibility through a capacity-aware reinsertion mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Reverse a random segment of the route\n            start = np.random.randint(1, len(route)-2)\n            end = np.random.randint(start+1, len(route)-1)\n            route[start:end+1] = route[start:end+1][::-1]\n\n            # Check capacity feasibility\n            if np.sum(demand[route[1:-1]]) > capacity:\n                # If infeasible, reallocate excess customers to other routes\n                current_demand = 0\n                excess_customers = []\n                for customer in route[1:-1]:\n                    if current_demand + demand[customer] <= capacity:\n                        current_demand += demand[customer]\n                    else:\n                        excess_customers.append(customer)\n\n                if excess_customers:\n                    # Find best routes to reallocate excess customers\n                    for customer in excess_customers:\n                        best_route = -1\n                        best_pos = -1\n                        best_dist = float('inf')\n\n                        for i, other_route in enumerate(new_solution):\n                            if i == route_idx:\n                                continue\n                            for pos in range(1, len(other_route)):\n                                temp_route = np.insert(other_route, pos, customer)\n                                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                                    dist_change = (distance_matrix[temp_route[pos-1]][customer] +\n                                                 distance_matrix[customer][temp_route[pos+1]] -\n                                                 distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                                    if dist_change < best_dist:\n                                        best_dist = dist_change\n                                        best_route = i\n                                        best_pos = pos\n\n                        if best_route != -1:\n                            new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                            route = np.delete(route, np.where(route == customer)[0][0])\n\n            # Update the modified route\n            new_solution[route_idx] = route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.69210967943795,
            0.10920712351799011
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i, route in enumerate(new_solution):\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check if splitting is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n        else:\n            # If splitting is not feasible, try reallocating a customer to another route\n            for j in range(1, len(route) - 1):\n                customer = route[j]\n                # Find the best route to insert this customer\n                best_route = -1\n                best_pos = -1\n                best_cost = float('inf')\n\n                for k, other_route in enumerate(new_solution):\n                    if k == i:\n                        continue\n                    # Try inserting the customer at all possible positions\n                    for pos in range(1, len(other_route)):\n                        temp_route = np.insert(other_route, pos, customer)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            # Calculate the additional cost\n                            cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                                   distance_matrix[customer][temp_route[pos+1]] - \\\n                                   distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = k\n                                best_pos = pos\n\n                if best_route != -1:\n                    # Perform the reallocation\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                    new_solution[i] = np.delete(new_solution[i], j)\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7903060370334931,
            0.268205463886261
        ]
    },
    {
        "algorithm": "{This algorithm combines route splitting with spatial clustering and demand-aware rebalancing to improve both total distance and makespan by strategically partitioning routes and redistributing customers based on spatial proximity and demand patterns.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Select a route to potentially split\n    route_idx = np.random.choice(len(new_solution))\n    selected_route = new_solution[route_idx]\n\n    # Cluster customers in the selected route based on spatial proximity\n    customers = selected_route[1:-1]\n    if len(customers) <= 1:\n        return new_solution\n\n    # Find the customer with maximum demand in the route\n    heaviest_customer = max(customers, key=lambda x: demand[x])\n\n    # Find the best split point based on spatial and demand criteria\n    best_split_pos = -1\n    best_split_cost = float('inf')\n\n    for i in range(1, len(selected_route) - 1):\n        # Split the route at position i\n        first_part = selected_route[:i+1]\n        second_part = selected_route[i:]\n\n        # Calculate the cost of the split\n        cost = distance_matrix[first_part[-2]][first_part[-1]] + \\\n               distance_matrix[second_part[0]][second_part[1]] + \\\n               distance_matrix[selected_route[i-1]][selected_route[i+1]] - \\\n               distance_matrix[selected_route[i-1]][selected_route[i]] - \\\n               distance_matrix[selected_route[i]][selected_route[i+1]]\n\n        if cost < best_split_cost:\n            best_split_cost = cost\n            best_split_pos = i\n\n    if best_split_cost < float('inf'):\n        # Perform the split\n        first_part = selected_route[:best_split_pos+1]\n        second_part = selected_route[best_split_pos:]\n\n        # Check capacity constraints\n        if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[route_idx] = first_part\n            new_solution.insert(route_idx + 1, second_part)\n\n    # Rebalance demand between routes\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Find customers to reallocate\n            customers = route[1:-1]\n            customers_sorted = sorted(customers, key=lambda x: demand[x], reverse=True)\n\n            for customer in customers_sorted:\n                # Find the best route to insert this customer\n                best_route = -1\n                best_pos = -1\n                best_cost = float('inf')\n\n                for k, candidate_route in enumerate(new_solution):\n                    if customer in candidate_route:\n                        continue\n                    for pos in range(1, len(candidate_route)):\n                        temp_route = np.insert(candidate_route, pos, customer)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                                   distance_matrix[customer][temp_route[pos+1]] - \\\n                                   distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = k\n                                best_pos = pos\n\n                if best_route != -1:\n                    # Perform the reallocation\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                    # Remove the customer from its original route\n                    route = np.delete(route, np.where(route == customer)[0][0])\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7226158674237273,
            0.10963800549507141
        ]
    },
    {
        "algorithm": "{This algorithm implements a hybrid approach combining route merging with demand-based clustering and spatial optimization to balance distance and makespan objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] - x[1][0])  # Sort by makespan minus distance to prioritize balanced solutions\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Select two routes to potentially merge\n    route_indices = np.random.choice(len(new_solution), size=2, replace=False)\n    route1_idx, route2_idx = min(route_indices), max(route_indices)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Calculate demand and spatial metrics\n    demand1 = np.sum(demand[route1[1:-1]])\n    demand2 = np.sum(demand[route2[1:-1]])\n\n    # Check if merging is feasible\n    if demand1 + demand2 <= capacity:\n        # Find optimal merge point using spatial and demand-based criteria\n        customers1 = route1[1:-1]\n        customers2 = route2[1:-1]\n\n        # Calculate centroids\n        centroid1 = np.mean(coords[customers1], axis=0)\n        centroid2 = np.mean(coords[customers2], axis=0)\n\n        # Find the closest pair of customers from different routes\n        min_dist = float('inf')\n        best_pair = (None, None)\n\n        for c1 in customers1:\n            for c2 in customers2:\n                dist = np.linalg.norm(coords[c1] - coords[c2])\n                if dist < min_dist:\n                    min_dist = dist\n                    best_pair = (c1, c2)\n\n        # Create merged route\n        merged_route = np.concatenate([route1, route2[1:]])\n\n        # Check if the merge is feasible\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            # Find optimal insertion point\n            best_pos = -1\n            best_score = float('inf')\n\n            for pos in range(1, len(merged_route)-1):\n                temp_route = np.insert(merged_route, pos, 0)  # Temporarily insert depot\n                # Calculate score based on distance and makespan balance\n                dist = np.sum([distance_matrix[temp_route[i]][temp_route[i+1]] for i in range(len(temp_route)-1)])\n                makespan = len(temp_route)\n                score = dist + 0.5 * makespan  # Weight makespan slightly\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            if best_pos != -1:\n                # Insert depot at optimal position\n                new_route = np.insert(merged_route, best_pos, 0)\n                # Remove the two original routes and add the new merged route\n                new_solution.pop(route2_idx)\n                new_solution.pop(route1_idx)\n                new_solution.append(new_route)\n        else:\n            # If merge is not feasible, try demand-based reallocation\n            lightest_customer = min(customers1 + customers2, key=lambda x: demand[x])\n            best_route = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, route in enumerate(new_solution):\n                if i == route1_idx or i == route2_idx:\n                    continue\n                for pos in range(1, len(route)):\n                    temp_route = np.insert(route, pos, lightest_customer)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        dist_increase = (distance_matrix[temp_route[pos-1]][lightest_customer] +\n                                       distance_matrix[lightest_customer][temp_route[pos+1]] -\n                                       distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                        makespan_diff = abs(len(temp_route) - len(route)) * 0.3\n                        score = dist_increase + makespan_diff\n                        if score < best_score:\n                            best_score = score\n                            best_route = i\n                            best_pos = pos\n\n            if best_route != -1:\n                # Perform the reallocation\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, lightest_customer)\n                # Remove from original route\n                original_route = new_solution[route1_idx if lightest_customer in customers1 else route2_idx]\n                pos_to_remove = np.where(original_route == lightest_customer)[0][0]\n                new_solution[route1_idx if lightest_customer in customers1 else route2_idx] = np.delete(original_route, pos_to_remove)\n\n    return new_solution\n\n",
        "score": [
            -0.752016649393435,
            0.12005874514579773
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            # If splitting is infeasible, try reinserting customers from the longer part\n            longer_part = part1 if len(part1) > len(part2) else part2\n            shorter_part = part2 if len(part1) > len(part2) else part1\n\n            # Randomly select a customer to reinsert\n            if len(longer_part) > 2:\n                customer_idx = np.random.randint(1, len(longer_part) - 1)\n                customer = longer_part[customer_idx]\n                # Try inserting the customer into the shorter part at the best feasible position\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(shorter_part)):\n                    temp_route = np.insert(shorter_part, i, customer)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[temp_route[i-1], customer] + distance_matrix[customer, temp_route[i+1]] - distance_matrix[temp_route[i-1], temp_route[i+1]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n                if best_cost < float('inf'):\n                    shorter_part = np.insert(shorter_part, best_pos, customer)\n                    longer_part = np.delete(longer_part, customer_idx)\n                    if len(longer_part) > 2:\n                        new_solution.append(longer_part)\n                    if len(shorter_part) > 2:\n                        new_solution.append(shorter_part)\n                else:\n                    new_solution.append(route)\n            else:\n                new_solution.append(route)\n\n    return new_solution\n\n",
        "score": [
            -0.7148990727857493,
            0.11328020691871643
        ]
    },
    {
        "algorithm": "{The new algorithm implements a hybrid approach combining route splitting with spatial clustering and demand-aware customer reallocation to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Select a route to potentially split or modify\n    route_idx = np.random.randint(0, len(new_solution))\n    selected_route = new_solution[route_idx]\n\n    # Calculate spatial and demand metrics for the selected route\n    customers = selected_route[1:-1]\n    if len(customers) <= 2:\n        return new_solution\n\n    # Find the customer with maximum demand in the route\n    heaviest_customer = max(customers, key=lambda x: demand[x])\n\n    # Calculate spatial centroid of the route\n    route_coords = coords[customers]\n    centroid = np.mean(route_coords, axis=0)\n\n    # Find the customer farthest from centroid (potential split point)\n    farthest_customer = max(customers, key=lambda x: np.linalg.norm(coords[x] - centroid))\n\n    # Try to split the route at the farthest customer\n    split_pos = np.where(selected_route == farthest_customer)[0][0]\n    first_part = selected_route[:split_pos+1]\n    second_part = selected_route[split_pos:]\n\n    # Check if both parts are feasible\n    if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n        new_solution[route_idx] = first_part\n        new_solution.insert(route_idx + 1, second_part)\n    else:\n        # If split is not feasible, try reallocating the heaviest customer\n        best_route = -1\n        best_pos = -1\n        best_score = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == route_idx:\n                continue\n            for pos in range(1, len(route)):\n                temp_route = np.insert(route, pos, heaviest_customer)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    # Score based on distance increase and makespan balance\n                    dist_increase = (distance_matrix[temp_route[pos-1]][heaviest_customer] +\n                                    distance_matrix[heaviest_customer][temp_route[pos+1]] -\n                                    distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                    makespan_diff = abs(len(temp_route) - len(selected_route)) * 0.5\n                    score = dist_increase + makespan_diff\n                    if score < best_score:\n                        best_score = score\n                        best_route = i\n                        best_pos = pos\n\n        if best_route != -1:\n            # Perform the reallocation\n            new_solution[best_route] = np.insert(new_solution[best_route], best_pos, heaviest_customer)\n            new_solution[route_idx] = np.delete(new_solution[route_idx], np.where(new_solution[route_idx] == heaviest_customer)[0][0])\n\n    return new_solution\n\n",
        "score": [
            -0.7906421695167611,
            0.09088990092277527
        ]
    },
    {
        "algorithm": "{The new algorithm combines spatial clustering with adaptive route splitting to balance load and distance, prioritizing high-demand customers and minimizing the longest route while considering geographic proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])  # Sort by makespan\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Select the longest route to consider splitting\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Find high-demand customers in the longest route\n    high_demand_customers = sorted(longest_route[1:-1], key=lambda x: demand[x], reverse=True)\n\n    if not high_demand_customers:\n        return new_solution\n\n    # Try to create a new route with the highest demand customer\n    highest_demand = high_demand_customers[0]\n    new_route = np.array([0, highest_demand, 0])\n\n    # Remove the customer from the original route\n    new_solution[longest_route_idx] = np.delete(longest_route, np.where(longest_route == highest_demand)[0][0])\n\n    # Try to insert remaining high-demand customers into the new route\n    for customer in high_demand_customers[1:]:\n        current_load = np.sum(demand[new_route[1:-1]])\n        if current_load + demand[customer] <= capacity:\n            # Find the best insertion position\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(new_route)):\n                temp_route = np.insert(new_route, pos, customer)\n                cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                       distance_matrix[customer][temp_route[pos+1]] - \\\n                       distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            new_route = np.insert(new_route, best_pos, customer)\n\n    # Add the new route to the solution\n    new_solution.append(new_route)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8730305050643937,
            0.7784204483032227
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by identifying routes with the largest makespan, then applies a hybrid local search operator that combines route segmentation and insertion heuristics to balance distance and makespan reduction, while ensuring feasibility through capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search: segment and reinsert routes to balance distance and makespan\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes (depot-depot or single customer)\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two segments at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_idx + 1]\n        segment2 = route[split_idx:]\n\n        # Check capacity feasibility for both segments\n        seg1_demand = np.sum(demand[segment1[1:-1]])\n        seg2_demand = np.sum(demand[segment2[1:-1]])\n\n        if seg1_demand <= capacity and seg2_demand <= capacity:\n            new_solution.append(segment1.copy())\n            new_solution.append(segment2.copy())\n        else:\n            # If split is infeasible, try inserting a random customer from another route\n            other_route = np.random.choice([r for r in base_solution if len(r) > 3 and r is not route])\n            if len(other_route) > 3:\n                insert_pos = np.random.randint(1, len(other_route) - 1)\n                customer = other_route[insert_pos]\n                if np.sum(demand[segment1[1:-1]]) + demand[customer] <= capacity:\n                    new_segment = np.insert(segment1, -1, customer)\n                    new_solution.append(new_segment)\n                    # Remove the customer from the other route\n                    new_other_route = np.delete(other_route, insert_pos)\n                    new_solution.append(new_other_route)\n                else:\n                    new_solution.append(route.copy())\n\n    # Ensure all customers are served (fallback if some are missing)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing = all_customers - served_customers\n    if missing:\n        # Reassign missing customers to routes with available capacity\n        for customer in missing:\n            for i, route in enumerate(new_solution):\n                if np.sum(demand[list(route[1:-1])]) + demand[customer] <= capacity:\n                    new_route = np.insert(route, -1, customer)\n                    new_solution[i] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8634949154541082,
            0.36051949858665466
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route splitting, customer reinsertion, and depot relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance then makespan\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: split a route, reinsert customers, and relocate depot\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Split the route into two parts\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1].copy()\n        part2 = route[split_idx:].copy()\n\n        # Step 2: Reinsert customers from part2 into part1 while respecting capacity\n        customers_to_reinsert = part2[1:-1].copy()\n        random.shuffle(customers_to_reinsert)\n\n        for customer in customers_to_reinsert:\n            best_pos = -1\n            min_increase = float('inf')\n\n            # Find the best insertion position in part1\n            for i in range(1, len(part1)):\n                temp_route = np.insert(part1, i, customer)\n                if sum(demand[temp_route[1:-1]]) <= capacity:\n                    dist_increase = (distance_matrix[temp_route[i-1]][customer] +\n                                    distance_matrix[customer][temp_route[i]] -\n                                    distance_matrix[temp_route[i-1]][temp_route[i]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = i\n\n            if best_pos != -1:\n                part1 = np.insert(part1, best_pos, customer)\n\n        # Step 3: Relocate depot in part1 to balance the route\n        if len(part1) > 3:\n            best_depot_pos = -1\n            min_makespan = float('inf')\n\n            for i in range(1, len(part1)):\n                temp_route = np.insert(part1, i, 0)\n                temp_route = np.delete(temp_route, np.where(temp_route == 0)[0][1])  # Ensure only one depot\n                temp_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                if temp_dist < min_makespan and sum(demand[temp_route[1:-1]]) <= capacity:\n                    min_makespan = temp_dist\n                    best_depot_pos = i\n\n            if best_depot_pos != -1:\n                part1 = np.insert(part1, best_depot_pos, 0)\n                part1 = np.delete(part1, np.where(part1 == 0)[0][1])  # Ensure only one depot\n\n        new_solution.extend([part1, part2])\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0:\n            new_solution[i] = np.insert(new_solution[i], 0, 0)\n        if new_solution[i][-1] != 0:\n            new_solution[i] = np.append(new_solution[i], 0)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8854103612598478,
            6.212688565254211
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route splitting, customer reinsertion, and depot relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance then makespan\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: split a route, reinsert customers, and relocate depot\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Split the route into two parts\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1].copy()\n        part2 = route[split_idx:].copy()\n\n        # Step 2: Reinsert customers from part2 into part1 while respecting capacity\n        customers_to_reinsert = part2[1:-1].copy()\n        random.shuffle(customers_to_reinsert)\n\n        for customer in customers_to_reinsert:\n            best_pos = -1\n            min_increase = float('inf')\n\n            # Find the best insertion position in part1\n            for i in range(1, len(part1)):\n                temp_route = np.insert(part1, i, customer)\n                if sum(demand[temp_route[1:-1]]) <= capacity:\n                    dist_increase = (distance_matrix[temp_route[i-1]][customer] +\n                                    distance_matrix[customer][temp_route[i]] -\n                                    distance_matrix[temp_route[i-1]][temp_route[i]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = i\n\n            if best_pos != -1:\n                part1 = np.insert(part1, best_pos, customer)\n\n        # Step 3: Relocate depot in part1 to balance the route\n        if len(part1) > 3:\n            best_depot_pos = -1\n            min_makespan = float('inf')\n\n            for i in range(1, len(part1)):\n                temp_route = np.insert(part1, i, 0)\n                temp_route = np.delete(temp_route, np.where(temp_route == 0)[0][1])  # Ensure only one depot\n                temp_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                if temp_dist < min_makespan and sum(demand[temp_route[1:-1]]) <= capacity:\n                    min_makespan = temp_dist\n                    best_depot_pos = i\n\n            if best_depot_pos != -1:\n                part1 = np.insert(part1, best_depot_pos, 0)\n                part1 = np.delete(part1, np.where(part1 == 0)[0][1])  # Ensure only one depot\n\n        new_solution.extend([part1, part2])\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0:\n            new_solution[i] = np.insert(new_solution[i], 0, 0)\n        if new_solution[i][-1] != 0:\n            new_solution[i] = np.append(new_solution[i], 0)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8854103612598478,
            6.212688565254211
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by identifying routes with the largest makespan, then applies a hybrid local search operator that combines route segmentation and insertion heuristics to balance distance and makespan reduction, while ensuring feasibility through capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search: segment and reinsert routes to balance distance and makespan\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes (depot-depot or single customer)\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two segments at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_idx + 1]\n        segment2 = route[split_idx:]\n\n        # Check capacity feasibility for both segments\n        seg1_demand = np.sum(demand[segment1[1:-1]])\n        seg2_demand = np.sum(demand[segment2[1:-1]])\n\n        if seg1_demand <= capacity and seg2_demand <= capacity:\n            new_solution.append(segment1.copy())\n            new_solution.append(segment2.copy())\n        else:\n            # If split is infeasible, try inserting a random customer from another route\n            other_route = np.random.choice([r for r in base_solution if len(r) > 3 and r is not route])\n            if len(other_route) > 3:\n                insert_pos = np.random.randint(1, len(other_route) - 1)\n                customer = other_route[insert_pos]\n                if np.sum(demand[segment1[1:-1]]) + demand[customer] <= capacity:\n                    new_segment = np.insert(segment1, -1, customer)\n                    new_solution.append(new_segment)\n                    # Remove the customer from the other route\n                    new_other_route = np.delete(other_route, insert_pos)\n                    new_solution.append(new_other_route)\n                else:\n                    new_solution.append(route.copy())\n\n    # Ensure all customers are served (fallback if some are missing)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing = all_customers - served_customers\n    if missing:\n        # Reassign missing customers to routes with available capacity\n        for customer in missing:\n            for i, route in enumerate(new_solution):\n                if np.sum(demand[list(route[1:-1])]) + demand[customer] <= capacity:\n                    new_route = np.insert(route, -1, customer)\n                    new_solution[i] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8634949154541082,
            0.36051949858665466
        ]
    },
    {
        "algorithm": "{The new algorithm combines spatial clustering with adaptive route splitting to balance load and distance, prioritizing high-demand customers and minimizing the longest route while considering geographic proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])  # Sort by makespan\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Select the longest route to consider splitting\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Find high-demand customers in the longest route\n    high_demand_customers = sorted(longest_route[1:-1], key=lambda x: demand[x], reverse=True)\n\n    if not high_demand_customers:\n        return new_solution\n\n    # Try to create a new route with the highest demand customer\n    highest_demand = high_demand_customers[0]\n    new_route = np.array([0, highest_demand, 0])\n\n    # Remove the customer from the original route\n    new_solution[longest_route_idx] = np.delete(longest_route, np.where(longest_route == highest_demand)[0][0])\n\n    # Try to insert remaining high-demand customers into the new route\n    for customer in high_demand_customers[1:]:\n        current_load = np.sum(demand[new_route[1:-1]])\n        if current_load + demand[customer] <= capacity:\n            # Find the best insertion position\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(new_route)):\n                temp_route = np.insert(new_route, pos, customer)\n                cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                       distance_matrix[customer][temp_route[pos+1]] - \\\n                       distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            new_route = np.insert(new_route, best_pos, customer)\n\n    # Add the new route to the solution\n    new_solution.append(new_route)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8730305050643937,
            0.7784204483032227
        ]
    },
    {
        "algorithm": "{The new algorithm implements a hybrid approach combining route splitting with spatial clustering and demand-aware customer reallocation to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Select a route to potentially split or modify\n    route_idx = np.random.randint(0, len(new_solution))\n    selected_route = new_solution[route_idx]\n\n    # Calculate spatial and demand metrics for the selected route\n    customers = selected_route[1:-1]\n    if len(customers) <= 2:\n        return new_solution\n\n    # Find the customer with maximum demand in the route\n    heaviest_customer = max(customers, key=lambda x: demand[x])\n\n    # Calculate spatial centroid of the route\n    route_coords = coords[customers]\n    centroid = np.mean(route_coords, axis=0)\n\n    # Find the customer farthest from centroid (potential split point)\n    farthest_customer = max(customers, key=lambda x: np.linalg.norm(coords[x] - centroid))\n\n    # Try to split the route at the farthest customer\n    split_pos = np.where(selected_route == farthest_customer)[0][0]\n    first_part = selected_route[:split_pos+1]\n    second_part = selected_route[split_pos:]\n\n    # Check if both parts are feasible\n    if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n        new_solution[route_idx] = first_part\n        new_solution.insert(route_idx + 1, second_part)\n    else:\n        # If split is not feasible, try reallocating the heaviest customer\n        best_route = -1\n        best_pos = -1\n        best_score = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == route_idx:\n                continue\n            for pos in range(1, len(route)):\n                temp_route = np.insert(route, pos, heaviest_customer)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    # Score based on distance increase and makespan balance\n                    dist_increase = (distance_matrix[temp_route[pos-1]][heaviest_customer] +\n                                    distance_matrix[heaviest_customer][temp_route[pos+1]] -\n                                    distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                    makespan_diff = abs(len(temp_route) - len(selected_route)) * 0.5\n                    score = dist_increase + makespan_diff\n                    if score < best_score:\n                        best_score = score\n                        best_route = i\n                        best_pos = pos\n\n        if best_route != -1:\n            # Perform the reallocation\n            new_solution[best_route] = np.insert(new_solution[best_route], best_pos, heaviest_customer)\n            new_solution[route_idx] = np.delete(new_solution[route_idx], np.where(new_solution[route_idx] == heaviest_customer)[0][0])\n\n    return new_solution\n\n",
        "score": [
            -0.7906421695167611,
            0.09088990092277527
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by identifying routes with the largest makespan, then applies a hybrid local search operator that combines route segmentation and insertion heuristics to balance distance and makespan reduction, while ensuring feasibility through capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search: segment and reinsert routes to balance distance and makespan\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes (depot-depot or single customer)\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two segments at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_idx + 1]\n        segment2 = route[split_idx:]\n\n        # Check capacity feasibility for both segments\n        seg1_demand = np.sum(demand[segment1[1:-1]])\n        seg2_demand = np.sum(demand[segment2[1:-1]])\n\n        if seg1_demand <= capacity and seg2_demand <= capacity:\n            new_solution.append(segment1.copy())\n            new_solution.append(segment2.copy())\n        else:\n            # If split is infeasible, try inserting a random customer from another route\n            other_route = np.random.choice([r for r in base_solution if len(r) > 3 and r is not route])\n            if len(other_route) > 3:\n                insert_pos = np.random.randint(1, len(other_route) - 1)\n                customer = other_route[insert_pos]\n                if np.sum(demand[segment1[1:-1]]) + demand[customer] <= capacity:\n                    new_segment = np.insert(segment1, -1, customer)\n                    new_solution.append(new_segment)\n                    # Remove the customer from the other route\n                    new_other_route = np.delete(other_route, insert_pos)\n                    new_solution.append(new_other_route)\n                else:\n                    new_solution.append(route.copy())\n\n    # Ensure all customers are served (fallback if some are missing)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing = all_customers - served_customers\n    if missing:\n        # Reassign missing customers to routes with available capacity\n        for customer in missing:\n            for i, route in enumerate(new_solution):\n                if np.sum(demand[list(route[1:-1])]) + demand[customer] <= capacity:\n                    new_route = np.insert(route, -1, customer)\n                    new_solution[i] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8634949154541082,
            0.36051949858665466
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with low total distance and makespan, then applies a hybrid local search combining route splitting, customer reinsertion, and depot relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))  # Sort by total distance then makespan\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: split a route, reinsert customers, and relocate depot\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Step 1: Split the route into two parts\n        split_idx = random.randint(1, len(route) - 2)\n        part1 = route[:split_idx + 1].copy()\n        part2 = route[split_idx:].copy()\n\n        # Step 2: Reinsert customers from part2 into part1 while respecting capacity\n        customers_to_reinsert = part2[1:-1].copy()\n        random.shuffle(customers_to_reinsert)\n\n        for customer in customers_to_reinsert:\n            best_pos = -1\n            min_increase = float('inf')\n\n            # Find the best insertion position in part1\n            for i in range(1, len(part1)):\n                temp_route = np.insert(part1, i, customer)\n                if sum(demand[temp_route[1:-1]]) <= capacity:\n                    dist_increase = (distance_matrix[temp_route[i-1]][customer] +\n                                    distance_matrix[customer][temp_route[i]] -\n                                    distance_matrix[temp_route[i-1]][temp_route[i]])\n                    if dist_increase < min_increase:\n                        min_increase = dist_increase\n                        best_pos = i\n\n            if best_pos != -1:\n                part1 = np.insert(part1, best_pos, customer)\n\n        # Step 3: Relocate depot in part1 to balance the route\n        if len(part1) > 3:\n            best_depot_pos = -1\n            min_makespan = float('inf')\n\n            for i in range(1, len(part1)):\n                temp_route = np.insert(part1, i, 0)\n                temp_route = np.delete(temp_route, np.where(temp_route == 0)[0][1])  # Ensure only one depot\n                temp_dist = sum(distance_matrix[temp_route[j]][temp_route[j+1]] for j in range(len(temp_route)-1))\n\n                if temp_dist < min_makespan and sum(demand[temp_route[1:-1]]) <= capacity:\n                    min_makespan = temp_dist\n                    best_depot_pos = i\n\n            if best_depot_pos != -1:\n                part1 = np.insert(part1, best_depot_pos, 0)\n                part1 = np.delete(part1, np.where(part1 == 0)[0][1])  # Ensure only one depot\n\n        new_solution.extend([part1, part2])\n\n    # Ensure all routes start and end with depot\n    for i in range(len(new_solution)):\n        if new_solution[i][0] != 0:\n            new_solution[i] = np.insert(new_solution[i], 0, 0)\n        if new_solution[i][-1] != 0:\n            new_solution[i] = np.append(new_solution[i], 0)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8854103612598478,
            6.212688565254211
        ]
    }
]