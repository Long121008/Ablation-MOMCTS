[
    {
        "algorithm": "{This algorithm combines route splitting with demand-aware customer rebalancing by strategically dividing overloaded routes and redistributing customers to underutilized routes while respecting capacity constraints, aiming to balance the makespan without significantly increasing the total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the route with the highest demand utilization\n    demand_utilization = [np.sum(demand[route[1:-1]]) / capacity for route in new_solution]\n    overloaded_route_idx = np.argmax(demand_utilization)\n    overloaded_route = new_solution[overloaded_route_idx]\n\n    if len(overloaded_route) <= 3:\n        return new_solution\n\n    # Try to split the overloaded route into two balanced routes\n    split_pos = len(overloaded_route) // 2\n    first_part = overloaded_route[:split_pos]\n    second_part = overloaded_route[split_pos:]\n\n    # Check if both parts are feasible\n    if (np.sum(demand[first_part[1:-1]]) <= capacity and\n        np.sum(demand[second_part[1:-1]]) <= capacity):\n\n        # Replace the original route with the two new routes\n        new_solution[overloaded_route_idx] = first_part\n        new_solution.insert(overloaded_route_idx + 1, second_part)\n    else:\n        # If split is infeasible, try to redistribute customers from the overloaded route\n        customers_to_redistribute = overloaded_route[1:-1]\n        for customer in customers_to_redistribute:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == overloaded_route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = (distance_matrix[temp_route[pos-1]][customer] +\n                            distance_matrix[customer][temp_route[pos+1]] -\n                            distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the customer from the original route\n        for i in range(len(new_solution)):\n            if overloaded_route_idx in range(len(new_solution)):\n                if np.array_equal(new_solution[overloaded_route_idx], overloaded_route):\n                    new_solution[i] = np.delete(overloaded_route, np.where(overloaded_route == customer)[0][0])\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9041740497853441,
            0.05824071168899536
        ]
    },
    {
        "algorithm": "{This new algorithm combines route merging with demand-aware customer rebalancing to create more efficient routes by strategically combining short routes and redistributing customers to optimize both total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the two shortest routes to merge\n    route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n    shortest_route_idx1 = np.argmin(route_lengths)\n    shortest_route1 = new_solution[shortest_route_idx1]\n    route_lengths[shortest_route_idx1] = float('inf')\n    shortest_route_idx2 = np.argmin(route_lengths)\n    shortest_route2 = new_solution[shortest_route_idx2]\n\n    # Combine the two shortest routes\n    combined_route = np.concatenate([shortest_route1[:-1], shortest_route2[1:]])\n\n    # Check capacity feasibility\n    combined_demand = np.sum(demand[combined_route[1:-1]])\n    if combined_demand <= capacity:\n        new_solution.append(combined_route)\n        del new_solution[max(shortest_route_idx1, shortest_route_idx2)]\n        del new_solution[min(shortest_route_idx1, shortest_route_idx2)]\n    else:\n        # If merge is infeasible, redistribute customers to other routes\n        customers = np.concatenate([shortest_route1[1:-1], shortest_route2[1:-1]])\n        for customer in customers:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i in [shortest_route_idx1, shortest_route_idx2]:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                           distance_matrix[customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original short routes if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[max(shortest_route_idx1, shortest_route_idx2)]\n            del new_solution[min(shortest_route_idx1, shortest_route_idx2)]\n\n    return new_solution\n\n",
        "score": [
            -0.9104693069688522,
            1.1583054661750793
        ]
    },
    {
        "algorithm": "{This novel algorithm combines spatial clustering with demand-aware route reconstruction, where it first groups customers based on spatial proximity and demand similarity, then reconstructs routes by iteratively assigning clusters to vehicles while balancing capacity and minimizing route length, creating a hybrid of spatial partitioning and demand-aware optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] / x[1][0], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Collect all unserved customers from the base solution\n    served_customers = set()\n    for route in base_solution:\n        served_customers.update(route[1:-1])\n    unserved_customers = [i for i in range(1, len(coords)) if i not in served_customers]\n\n    # Spatial clustering: group customers based on proximity and demand similarity\n    clusters = []\n    remaining_customers = set(unserved_customers)\n\n    while remaining_customers:\n        # Select a seed customer (highest demand)\n        seed = max(remaining_customers, key=lambda x: demand[x])\n        cluster = [seed]\n        remaining_customers.remove(seed)\n        current_demand = demand[seed]\n\n        # Grow the cluster with nearby customers that fit demand constraints\n        for customer in list(remaining_customers):\n            if (distance_matrix[seed][customer] < 1.5 * np.mean(distance_matrix[0]) and\n                current_demand + demand[customer] <= capacity * 0.8):\n                cluster.append(customer)\n                current_demand += demand[customer]\n                remaining_customers.remove(customer)\n\n        clusters.append(cluster)\n\n    # Demand-aware route reconstruction\n    new_solution = []\n    for cluster in clusters:\n        # Sort cluster by distance from depot\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0][x])\n\n        # Create a new route starting from the depot\n        current_route = [0]\n        current_load = 0\n\n        for customer in cluster_sorted:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                # Close current route and start a new one\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        # Close the last route\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    # Merge routes if possible to reduce makespan\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Skip empty or single-customer routes\n            continue\n\n        merged = False\n        for i, existing_route in enumerate(merged_solution):\n            combined_demand = np.sum(demand[route[1:-1]]) + np.sum(demand[existing_route[1:-1]])\n            if combined_demand <= capacity:\n                # Merge routes by connecting them\n                merged_route = np.concatenate([existing_route[:-1], route[1:]])\n                merged_solution[i] = merged_route\n                merged = True\n                break\n\n        if not merged:\n            merged_solution.append(route)\n\n    # Add any remaining unserved customers to new routes\n    if unserved_customers:\n        for customer in unserved_customers:\n            new_route = np.array([0, customer, 0])\n            merged_solution.append(new_route)\n\n    return merged_solution\n\n",
        "score": [
            -0.7727560458592287,
            0.027076750993728638
        ]
    },
    {
        "algorithm": "{This new algorithm combines spatial clustering with demand-aware route splitting to create balanced routes by first grouping customers based on their spatial proximity and then intelligently splitting these clusters into feasible routes while considering both demand and distance constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Collect all unassigned customers\n    assigned_customers = set()\n    for route in new_solution:\n        assigned_customers.update(route[1:-1])\n    all_customers = set(range(1, len(demand)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    if not unassigned_customers:\n        # If no unassigned customers, try to improve existing routes\n        if len(new_solution) > 1:\n            # Select a random route to split\n            route_idx = np.random.randint(0, len(new_solution))\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find the best split point\n                best_split = 1\n                best_score = float('inf')\n\n                for split in range(2, len(route)-1):\n                    # Check if the split creates feasible routes\n                    first_part = route[:split+1]\n                    second_part = route[split:]\n\n                    if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                        np.sum(demand[second_part[1:-1]]) <= capacity):\n                        # Calculate the score based on distance reduction\n                        original_dist = (distance_matrix[route[split-1]][route[split]] +\n                                       distance_matrix[route[split]][route[split+1]])\n                        new_dist = (distance_matrix[route[split-1]][0] +\n                                   distance_matrix[0][route[split]] +\n                                   distance_matrix[route[split]][0] +\n                                   distance_matrix[0][route[split+1]])\n\n                        score = new_dist - original_dist\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = split\n\n                if best_split > 1:\n                    # Perform the split\n                    first_part = route[:best_split+1]\n                    second_part = route[best_split:]\n                    new_solution[route_idx] = first_part\n                    new_solution.insert(route_idx + 1, second_part)\n    else:\n        # Create new routes for unassigned customers\n        remaining_customers = unassigned_customers.copy()\n\n        while remaining_customers:\n            # Select a customer to start a new route\n            current_customer = remaining_customers.pop(0)\n            current_demand = demand[current_customer]\n            current_route = [0, current_customer, 0]\n\n            # Try to add compatible customers\n            for _ in range(len(remaining_customers)):\n                if np.sum(demand[current_route[1:-1]]) + demand[remaining_customers[0]] <= capacity:\n                    # Find the best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n\n                    for pos in range(1, len(current_route)):\n                        temp_route = np.insert(current_route, pos, remaining_customers[0])\n                        cost = (distance_matrix[temp_route[pos-1]][remaining_customers[0]] +\n                               distance_matrix[remaining_customers[0]][temp_route[pos+1]] -\n                               distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    current_route = np.insert(current_route, best_pos, remaining_customers[0])\n                    remaining_customers.pop(0)\n                else:\n                    break\n\n            new_solution.append(np.array(current_route))\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8749576738664353,
            0.17882221937179565
        ]
    },
    {
        "algorithm": "{This new algorithm implements a hybrid approach combining route merging with demand-aware spatial clustering and adaptive route splitting, which intelligently balances the trade-off between minimizing total distance and makespan by considering both spatial distribution and demand patterns while ensuring feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Cluster routes based on spatial proximity and demand similarity\n    route_clusters = []\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) > 0:\n            route_coords = coords[customers]\n            centroid = np.mean(route_coords, axis=0)\n            total_demand = np.sum(demand[customers])\n            route_clusters.append((centroid, total_demand, route))\n\n    # Find the most imbalanced cluster (either too large or too small)\n    if route_clusters:\n        avg_demand = sum(d[1] for d in route_clusters) / len(route_clusters)\n        imbalanced_route = max(route_clusters, key=lambda x: abs(x[1] - avg_demand))\n        imbalanced_idx = [i for i, r in enumerate(new_solution) if np.array_equal(r, imbalanced_route[2])][0]\n\n        # Try to rebalance by merging with a nearby route\n        best_merge = None\n        min_distance_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == imbalanced_idx:\n                continue\n\n            # Calculate spatial proximity\n            route_centroid = np.mean(coords[route[1:-1]], axis=0)\n            distance = np.linalg.norm(imbalanced_route[0] - route_centroid)\n\n            # Calculate potential merged demand\n            merged_demand = imbalanced_route[1] + np.sum(demand[route[1:-1]])\n\n            if merged_demand <= capacity:\n                # Calculate distance increase if merged\n                distance_increase = (distance_matrix[imbalanced_route[2][-2], route[1]] +\n                                    distance_matrix[route[-2], imbalanced_route[2][1]] -\n                                    distance_matrix[imbalanced_route[2][-2], imbalanced_route[2][1]] -\n                                    distance_matrix[route[-2], route[1]])\n\n                if distance_increase < min_distance_increase:\n                    min_distance_increase = distance_increase\n                    best_merge = i\n\n        if best_merge is not None:\n            # Perform the merge\n            merged_route = np.concatenate([new_solution[imbalanced_idx][:-1], new_solution[best_merge][1:]])\n            new_solution[imbalanced_idx] = merged_route\n            new_solution.pop(best_merge)\n        else:\n            # If no merge possible, try adaptive splitting\n            route_to_split = new_solution[imbalanced_idx]\n            if len(route_to_split) > 4:  # Ensure we can split meaningfully\n                # Find the customer with median demand in the route\n                customers = route_to_split[1:-1]\n                sorted_customers = sorted(customers, key=lambda x: demand[x])\n                median_customer = sorted_customers[len(sorted_customers)//2]\n\n                split_pos = np.where(route_to_split == median_customer)[0][0]\n                first_part = route_to_split[:split_pos+1]\n                second_part = route_to_split[split_pos:]\n\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[imbalanced_idx] = first_part\n                    new_solution.insert(imbalanced_idx + 1, second_part)\n\n    return new_solution\n\n",
        "score": [
            -0.8923017731161753,
            0.7799195647239685
        ]
    },
    {
        "algorithm": "{This new algorithm combines route merging with demand-aware customer redistribution to create balanced routes by strategically merging shorter routes and redistributing customers to longer routes while respecting capacity constraints, aiming to reduce the total distance without significantly increasing the makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Find the shortest route\n    shortest_route_idx = np.argmin([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    shortest_route = new_solution[shortest_route_idx]\n\n    # Find the longest route\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    if shortest_route_idx == longest_route_idx:\n        return new_solution\n\n    # Try to merge the shortest route into the longest route\n    customers_to_merge = shortest_route[1:-1]\n    remaining_capacity = capacity - np.sum(demand[longest_route[1:-1]])\n\n    if np.sum(demand[customers_to_merge]) <= remaining_capacity:\n        # Find the best insertion position in the longest route\n        best_pos = 1\n        best_cost = float('inf')\n\n        for pos in range(1, len(longest_route)):\n            temp_route = np.insert(longest_route, pos, customers_to_merge)\n            cost = (distance_matrix[longest_route[pos-1]][customers_to_merge[0]] +\n                    distance_matrix[customers_to_merge[-1]][longest_route[pos]] -\n                    distance_matrix[longest_route[pos-1]][longest_route[pos]])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n\n        # Perform the merge\n        new_longest_route = np.insert(longest_route, best_pos, customers_to_merge)\n        new_solution[longest_route_idx] = new_longest_route\n        del new_solution[shortest_route_idx]\n    else:\n        # If merge is not possible, try to redistribute customers from the shortest route\n        for customer in customers_to_merge:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == shortest_route_idx or i == longest_route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = (distance_matrix[temp_route[pos-1]][customer] +\n                            distance_matrix[customer][temp_route[pos+1]] -\n                            distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original shortest route if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[shortest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.88209445391029,
            0.7248702943325043
        ]
    },
    {
        "algorithm": "{This new algorithm combines route fragmentation with demand-aware customer redistribution to create balanced routes by strategically splitting long routes and redistributing customers to shorter routes while respecting capacity constraints, aiming to reduce makespan without significantly increasing total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the longest route to fragment\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:  # Skip if route is too short\n        return new_solution\n\n    # Split the longest route into two segments\n    split_idx = np.random.randint(1, len(longest_route) - 1)\n    segment1 = longest_route[:split_idx + 1]\n    segment2 = longest_route[split_idx:]\n\n    # Check capacity feasibility for both segments\n    seg1_demand = np.sum(demand[segment1[1:-1]])\n    seg2_demand = np.sum(demand[segment2[1:-1]])\n\n    if seg1_demand <= capacity and seg2_demand <= capacity:\n        new_solution[longest_route_idx] = segment1\n        new_solution.append(segment2)\n    else:\n        # If split is infeasible, redistribute customers to other routes\n        customers = longest_route[1:-1]\n        for customer in customers:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                           distance_matrix[customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original long route if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8538019298383264,
            0.0867181122303009
        ]
    },
    {
        "algorithm": "{This algorithm combines route splitting with demand-aware customer redistribution to create balanced routes by strategically splitting longer routes into multiple shorter routes and redistributing customers to existing routes while respecting capacity constraints, aiming to reduce the makespan without significantly increasing the total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:\n        return new_solution\n\n    split_pos = len(longest_route) // 2\n    first_part = longest_route[:split_pos + 1]\n    second_part = longest_route[split_pos:]\n\n    if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n        new_solution[longest_route_idx] = first_part\n        new_solution.insert(longest_route_idx + 1, second_part)\n    else:\n        customers_to_redistribute = longest_route[1:-1]\n        del new_solution[longest_route_idx]\n\n        for customer in customers_to_redistribute:\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = (distance_matrix[temp_route[pos-1]][customer] +\n                            distance_matrix[customer][temp_route[pos+1]] -\n                            distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n            else:\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.7791394859347123,
            0.0775003433227539
        ]
    },
    {
        "algorithm": "{This novel algorithm employs a hybrid of spatial partitioning and demand-aware optimization by first clustering customers based on proximity and demand similarity, then reconstructing routes by iteratively assigning clusters to vehicles while balancing capacity and minimizing route length, and finally merging routes to reduce makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] / (x[1][0] + 1e-6), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Collect all unserved customers from the base solution\n    served_customers = set()\n    for route in base_solution:\n        served_customers.update(route[1:-1])\n    unserved_customers = [i for i in range(1, len(coords)) if i not in served_customers]\n\n    # Spatial clustering: group customers based on proximity and demand similarity\n    clusters = []\n    remaining_customers = set(unserved_customers)\n\n    while remaining_customers:\n        # Select a seed customer (highest demand)\n        seed = max(remaining_customers, key=lambda x: demand[x])\n        cluster = [seed]\n        remaining_customers.remove(seed)\n        current_demand = demand[seed]\n\n        # Grow the cluster with nearby customers that fit demand constraints\n        for customer in list(remaining_customers):\n            if (distance_matrix[seed][customer] < 2.0 * np.mean(distance_matrix[0]) and\n                current_demand + demand[customer] <= capacity * 0.9):\n                cluster.append(customer)\n                current_demand += demand[customer]\n                remaining_customers.remove(customer)\n\n        clusters.append(cluster)\n\n    # Demand-aware route reconstruction\n    new_solution = []\n    for cluster in clusters:\n        # Sort cluster by distance from depot\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0][x])\n\n        # Create a new route starting from the depot\n        current_route = [0]\n        current_load = 0\n\n        for customer in cluster_sorted:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                # Close current route and start a new one\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        # Close the last route\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    # Merge routes if possible to reduce makespan\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Skip empty or single-customer routes\n            continue\n\n        merged = False\n        for i, existing_route in enumerate(merged_solution):\n            combined_demand = np.sum(demand[route[1:-1]]) + np.sum(demand[existing_route[1:-1]])\n            if combined_demand <= capacity:\n                # Merge routes by connecting them\n                merged_route = np.concatenate([existing_route[:-1], route[1:]])\n                merged_solution[i] = merged_route\n                merged = True\n                break\n\n        if not merged:\n            merged_solution.append(route)\n\n    # Add any remaining unserved customers to new routes\n    if unserved_customers:\n        for customer in unserved_customers:\n            new_route = np.array([0, customer, 0])\n            merged_solution.append(new_route)\n\n    return merged_solution\n\n",
        "score": [
            -0.7621583348904908,
            0.028165817260742188
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by identifying routes with the largest makespan and the smallest distance, then applies a hybrid local search operator that combines route reversal and customer reallocation to balance distance and makespan reduction, while ensuring feasibility through capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes\n            new_solution.append(route.copy())\n            continue\n\n        # Reverse a segment of the route to explore new configurations\n        start_idx = np.random.randint(1, len(route) - 2)\n        end_idx = np.random.randint(start_idx + 1, len(route) - 1)\n        reversed_segment = route[start_idx:end_idx][::-1]\n        modified_route = np.concatenate([route[:start_idx], reversed_segment, route[end_idx:]])\n\n        # Check capacity feasibility\n        if np.sum(demand[modified_route[1:-1]]) <= capacity:\n            new_solution.append(modified_route.copy())\n        else:\n            # If reversed segment is infeasible, try reallocating a customer to another route\n            customer_to_move = modified_route[np.random.randint(1, len(modified_route) - 1)]\n            for i, other_route in enumerate(base_solution):\n                if other_route is not route:\n                    if np.sum(demand[list(other_route[1:-1])]) + demand[customer_to_move] <= capacity:\n                        # Remove customer from current route and add to other route\n                        new_route = np.delete(modified_route, np.where(modified_route == customer_to_move)[0][0])\n                        new_other_route = np.insert(other_route, -1, customer_to_move)\n                        new_solution.append(new_route)\n                        new_solution.append(new_other_route)\n                        break\n            else:\n                new_solution.append(route.copy())\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing = all_customers - served_customers\n    if missing:\n        for customer in missing:\n            for i, route in enumerate(new_solution):\n                if np.sum(demand[list(route[1:-1])]) + demand[customer] <= capacity:\n                    new_route = np.insert(route, -1, customer)\n                    new_solution[i] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.866394006782323,
            0.2480582594871521
        ]
    },
    {
        "algorithm": "{This algorithm combines route splitting with demand-aware customer rebalancing by strategically dividing overloaded routes and redistributing customers to underutilized routes while respecting capacity constraints, aiming to balance the makespan without significantly increasing the total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the route with the highest demand utilization\n    demand_utilization = [np.sum(demand[route[1:-1]]) / capacity for route in new_solution]\n    overloaded_route_idx = np.argmax(demand_utilization)\n    overloaded_route = new_solution[overloaded_route_idx]\n\n    if len(overloaded_route) <= 3:\n        return new_solution\n\n    # Try to split the overloaded route into two balanced routes\n    split_pos = len(overloaded_route) // 2\n    first_part = overloaded_route[:split_pos]\n    second_part = overloaded_route[split_pos:]\n\n    # Check if both parts are feasible\n    if (np.sum(demand[first_part[1:-1]]) <= capacity and\n        np.sum(demand[second_part[1:-1]]) <= capacity):\n\n        # Replace the original route with the two new routes\n        new_solution[overloaded_route_idx] = first_part\n        new_solution.insert(overloaded_route_idx + 1, second_part)\n    else:\n        # If split is infeasible, try to redistribute customers from the overloaded route\n        customers_to_redistribute = overloaded_route[1:-1]\n        for customer in customers_to_redistribute:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == overloaded_route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = (distance_matrix[temp_route[pos-1]][customer] +\n                            distance_matrix[customer][temp_route[pos+1]] -\n                            distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the customer from the original route\n        for i in range(len(new_solution)):\n            if overloaded_route_idx in range(len(new_solution)):\n                if np.array_equal(new_solution[overloaded_route_idx], overloaded_route):\n                    new_solution[i] = np.delete(overloaded_route, np.where(overloaded_route == customer)[0][0])\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9041740497853441,
            0.05824071168899536
        ]
    },
    {
        "algorithm": "{This new algorithm combines route merging with demand-aware customer rebalancing to create more efficient routes by strategically combining short routes and redistributing customers to optimize both total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the two shortest routes to merge\n    route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n    shortest_route_idx1 = np.argmin(route_lengths)\n    shortest_route1 = new_solution[shortest_route_idx1]\n    route_lengths[shortest_route_idx1] = float('inf')\n    shortest_route_idx2 = np.argmin(route_lengths)\n    shortest_route2 = new_solution[shortest_route_idx2]\n\n    # Combine the two shortest routes\n    combined_route = np.concatenate([shortest_route1[:-1], shortest_route2[1:]])\n\n    # Check capacity feasibility\n    combined_demand = np.sum(demand[combined_route[1:-1]])\n    if combined_demand <= capacity:\n        new_solution.append(combined_route)\n        del new_solution[max(shortest_route_idx1, shortest_route_idx2)]\n        del new_solution[min(shortest_route_idx1, shortest_route_idx2)]\n    else:\n        # If merge is infeasible, redistribute customers to other routes\n        customers = np.concatenate([shortest_route1[1:-1], shortest_route2[1:-1]])\n        for customer in customers:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i in [shortest_route_idx1, shortest_route_idx2]:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                           distance_matrix[customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original short routes if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[max(shortest_route_idx1, shortest_route_idx2)]\n            del new_solution[min(shortest_route_idx1, shortest_route_idx2)]\n\n    return new_solution\n\n",
        "score": [
            -0.9104693069688522,
            1.1583054661750793
        ]
    },
    {
        "algorithm": "{This novel algorithm combines spatial clustering with demand-aware route reconstruction, where it first groups customers based on spatial proximity and demand similarity, then reconstructs routes by iteratively assigning clusters to vehicles while balancing capacity and minimizing route length, creating a hybrid of spatial partitioning and demand-aware optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] / x[1][0], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Collect all unserved customers from the base solution\n    served_customers = set()\n    for route in base_solution:\n        served_customers.update(route[1:-1])\n    unserved_customers = [i for i in range(1, len(coords)) if i not in served_customers]\n\n    # Spatial clustering: group customers based on proximity and demand similarity\n    clusters = []\n    remaining_customers = set(unserved_customers)\n\n    while remaining_customers:\n        # Select a seed customer (highest demand)\n        seed = max(remaining_customers, key=lambda x: demand[x])\n        cluster = [seed]\n        remaining_customers.remove(seed)\n        current_demand = demand[seed]\n\n        # Grow the cluster with nearby customers that fit demand constraints\n        for customer in list(remaining_customers):\n            if (distance_matrix[seed][customer] < 1.5 * np.mean(distance_matrix[0]) and\n                current_demand + demand[customer] <= capacity * 0.8):\n                cluster.append(customer)\n                current_demand += demand[customer]\n                remaining_customers.remove(customer)\n\n        clusters.append(cluster)\n\n    # Demand-aware route reconstruction\n    new_solution = []\n    for cluster in clusters:\n        # Sort cluster by distance from depot\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0][x])\n\n        # Create a new route starting from the depot\n        current_route = [0]\n        current_load = 0\n\n        for customer in cluster_sorted:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                # Close current route and start a new one\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        # Close the last route\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    # Merge routes if possible to reduce makespan\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Skip empty or single-customer routes\n            continue\n\n        merged = False\n        for i, existing_route in enumerate(merged_solution):\n            combined_demand = np.sum(demand[route[1:-1]]) + np.sum(demand[existing_route[1:-1]])\n            if combined_demand <= capacity:\n                # Merge routes by connecting them\n                merged_route = np.concatenate([existing_route[:-1], route[1:]])\n                merged_solution[i] = merged_route\n                merged = True\n                break\n\n        if not merged:\n            merged_solution.append(route)\n\n    # Add any remaining unserved customers to new routes\n    if unserved_customers:\n        for customer in unserved_customers:\n            new_route = np.array([0, customer, 0])\n            merged_solution.append(new_route)\n\n    return merged_solution\n\n",
        "score": [
            -0.7727560458592287,
            0.027076750993728638
        ]
    },
    {
        "algorithm": "{This algorithm combines route splitting with demand-aware customer rebalancing by strategically dividing overloaded routes and redistributing customers to underutilized routes while respecting capacity constraints, aiming to balance the makespan without significantly increasing the total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the route with the highest demand utilization\n    demand_utilization = [np.sum(demand[route[1:-1]]) / capacity for route in new_solution]\n    overloaded_route_idx = np.argmax(demand_utilization)\n    overloaded_route = new_solution[overloaded_route_idx]\n\n    if len(overloaded_route) <= 3:\n        return new_solution\n\n    # Try to split the overloaded route into two balanced routes\n    split_pos = len(overloaded_route) // 2\n    first_part = overloaded_route[:split_pos]\n    second_part = overloaded_route[split_pos:]\n\n    # Check if both parts are feasible\n    if (np.sum(demand[first_part[1:-1]]) <= capacity and\n        np.sum(demand[second_part[1:-1]]) <= capacity):\n\n        # Replace the original route with the two new routes\n        new_solution[overloaded_route_idx] = first_part\n        new_solution.insert(overloaded_route_idx + 1, second_part)\n    else:\n        # If split is infeasible, try to redistribute customers from the overloaded route\n        customers_to_redistribute = overloaded_route[1:-1]\n        for customer in customers_to_redistribute:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == overloaded_route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = (distance_matrix[temp_route[pos-1]][customer] +\n                            distance_matrix[customer][temp_route[pos+1]] -\n                            distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the customer from the original route\n        for i in range(len(new_solution)):\n            if overloaded_route_idx in range(len(new_solution)):\n                if np.array_equal(new_solution[overloaded_route_idx], overloaded_route):\n                    new_solution[i] = np.delete(overloaded_route, np.where(overloaded_route == customer)[0][0])\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9041740497853441,
            0.05824071168899536
        ]
    },
    {
        "algorithm": "{This new algorithm combines route merging with demand-aware customer rebalancing to create more efficient routes by strategically combining short routes and redistributing customers to optimize both total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the two shortest routes to merge\n    route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n    shortest_route_idx1 = np.argmin(route_lengths)\n    shortest_route1 = new_solution[shortest_route_idx1]\n    route_lengths[shortest_route_idx1] = float('inf')\n    shortest_route_idx2 = np.argmin(route_lengths)\n    shortest_route2 = new_solution[shortest_route_idx2]\n\n    # Combine the two shortest routes\n    combined_route = np.concatenate([shortest_route1[:-1], shortest_route2[1:]])\n\n    # Check capacity feasibility\n    combined_demand = np.sum(demand[combined_route[1:-1]])\n    if combined_demand <= capacity:\n        new_solution.append(combined_route)\n        del new_solution[max(shortest_route_idx1, shortest_route_idx2)]\n        del new_solution[min(shortest_route_idx1, shortest_route_idx2)]\n    else:\n        # If merge is infeasible, redistribute customers to other routes\n        customers = np.concatenate([shortest_route1[1:-1], shortest_route2[1:-1]])\n        for customer in customers:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i in [shortest_route_idx1, shortest_route_idx2]:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                           distance_matrix[customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original short routes if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[max(shortest_route_idx1, shortest_route_idx2)]\n            del new_solution[min(shortest_route_idx1, shortest_route_idx2)]\n\n    return new_solution\n\n",
        "score": [
            -0.9104693069688522,
            1.1583054661750793
        ]
    },
    {
        "algorithm": "{This novel algorithm combines spatial clustering with demand-aware route reconstruction, where it first groups customers based on spatial proximity and demand similarity, then reconstructs routes by iteratively assigning clusters to vehicles while balancing capacity and minimizing route length, creating a hybrid of spatial partitioning and demand-aware optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] / x[1][0], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Collect all unserved customers from the base solution\n    served_customers = set()\n    for route in base_solution:\n        served_customers.update(route[1:-1])\n    unserved_customers = [i for i in range(1, len(coords)) if i not in served_customers]\n\n    # Spatial clustering: group customers based on proximity and demand similarity\n    clusters = []\n    remaining_customers = set(unserved_customers)\n\n    while remaining_customers:\n        # Select a seed customer (highest demand)\n        seed = max(remaining_customers, key=lambda x: demand[x])\n        cluster = [seed]\n        remaining_customers.remove(seed)\n        current_demand = demand[seed]\n\n        # Grow the cluster with nearby customers that fit demand constraints\n        for customer in list(remaining_customers):\n            if (distance_matrix[seed][customer] < 1.5 * np.mean(distance_matrix[0]) and\n                current_demand + demand[customer] <= capacity * 0.8):\n                cluster.append(customer)\n                current_demand += demand[customer]\n                remaining_customers.remove(customer)\n\n        clusters.append(cluster)\n\n    # Demand-aware route reconstruction\n    new_solution = []\n    for cluster in clusters:\n        # Sort cluster by distance from depot\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0][x])\n\n        # Create a new route starting from the depot\n        current_route = [0]\n        current_load = 0\n\n        for customer in cluster_sorted:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                # Close current route and start a new one\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        # Close the last route\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    # Merge routes if possible to reduce makespan\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Skip empty or single-customer routes\n            continue\n\n        merged = False\n        for i, existing_route in enumerate(merged_solution):\n            combined_demand = np.sum(demand[route[1:-1]]) + np.sum(demand[existing_route[1:-1]])\n            if combined_demand <= capacity:\n                # Merge routes by connecting them\n                merged_route = np.concatenate([existing_route[:-1], route[1:]])\n                merged_solution[i] = merged_route\n                merged = True\n                break\n\n        if not merged:\n            merged_solution.append(route)\n\n    # Add any remaining unserved customers to new routes\n    if unserved_customers:\n        for customer in unserved_customers:\n            new_route = np.array([0, customer, 0])\n            merged_solution.append(new_route)\n\n    return merged_solution\n\n",
        "score": [
            -0.7727560458592287,
            0.027076750993728638
        ]
    },
    {
        "algorithm": "{This algorithm combines route splitting with demand-aware customer rebalancing by strategically dividing overloaded routes and redistributing customers to underutilized routes while respecting capacity constraints, aiming to balance the makespan without significantly increasing the total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the route with the highest demand utilization\n    demand_utilization = [np.sum(demand[route[1:-1]]) / capacity for route in new_solution]\n    overloaded_route_idx = np.argmax(demand_utilization)\n    overloaded_route = new_solution[overloaded_route_idx]\n\n    if len(overloaded_route) <= 3:\n        return new_solution\n\n    # Try to split the overloaded route into two balanced routes\n    split_pos = len(overloaded_route) // 2\n    first_part = overloaded_route[:split_pos]\n    second_part = overloaded_route[split_pos:]\n\n    # Check if both parts are feasible\n    if (np.sum(demand[first_part[1:-1]]) <= capacity and\n        np.sum(demand[second_part[1:-1]]) <= capacity):\n\n        # Replace the original route with the two new routes\n        new_solution[overloaded_route_idx] = first_part\n        new_solution.insert(overloaded_route_idx + 1, second_part)\n    else:\n        # If split is infeasible, try to redistribute customers from the overloaded route\n        customers_to_redistribute = overloaded_route[1:-1]\n        for customer in customers_to_redistribute:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == overloaded_route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = (distance_matrix[temp_route[pos-1]][customer] +\n                            distance_matrix[customer][temp_route[pos+1]] -\n                            distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the customer from the original route\n        for i in range(len(new_solution)):\n            if overloaded_route_idx in range(len(new_solution)):\n                if np.array_equal(new_solution[overloaded_route_idx], overloaded_route):\n                    new_solution[i] = np.delete(overloaded_route, np.where(overloaded_route == customer)[0][0])\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9041740497853441,
            0.05824071168899536
        ]
    },
    {
        "algorithm": "{This new algorithm combines route merging with demand-aware customer rebalancing to create more efficient routes by strategically combining short routes and redistributing customers to optimize both total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the two shortest routes to merge\n    route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n    shortest_route_idx1 = np.argmin(route_lengths)\n    shortest_route1 = new_solution[shortest_route_idx1]\n    route_lengths[shortest_route_idx1] = float('inf')\n    shortest_route_idx2 = np.argmin(route_lengths)\n    shortest_route2 = new_solution[shortest_route_idx2]\n\n    # Combine the two shortest routes\n    combined_route = np.concatenate([shortest_route1[:-1], shortest_route2[1:]])\n\n    # Check capacity feasibility\n    combined_demand = np.sum(demand[combined_route[1:-1]])\n    if combined_demand <= capacity:\n        new_solution.append(combined_route)\n        del new_solution[max(shortest_route_idx1, shortest_route_idx2)]\n        del new_solution[min(shortest_route_idx1, shortest_route_idx2)]\n    else:\n        # If merge is infeasible, redistribute customers to other routes\n        customers = np.concatenate([shortest_route1[1:-1], shortest_route2[1:-1]])\n        for customer in customers:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i in [shortest_route_idx1, shortest_route_idx2]:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                           distance_matrix[customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original short routes if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[max(shortest_route_idx1, shortest_route_idx2)]\n            del new_solution[min(shortest_route_idx1, shortest_route_idx2)]\n\n    return new_solution\n\n",
        "score": [
            -0.9104693069688522,
            1.1583054661750793
        ]
    },
    {
        "algorithm": "{This novel algorithm combines spatial clustering with demand-aware route reconstruction, where it first groups customers based on spatial proximity and demand similarity, then reconstructs routes by iteratively assigning clusters to vehicles while balancing capacity and minimizing route length, creating a hybrid of spatial partitioning and demand-aware optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] / x[1][0], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Collect all unserved customers from the base solution\n    served_customers = set()\n    for route in base_solution:\n        served_customers.update(route[1:-1])\n    unserved_customers = [i for i in range(1, len(coords)) if i not in served_customers]\n\n    # Spatial clustering: group customers based on proximity and demand similarity\n    clusters = []\n    remaining_customers = set(unserved_customers)\n\n    while remaining_customers:\n        # Select a seed customer (highest demand)\n        seed = max(remaining_customers, key=lambda x: demand[x])\n        cluster = [seed]\n        remaining_customers.remove(seed)\n        current_demand = demand[seed]\n\n        # Grow the cluster with nearby customers that fit demand constraints\n        for customer in list(remaining_customers):\n            if (distance_matrix[seed][customer] < 1.5 * np.mean(distance_matrix[0]) and\n                current_demand + demand[customer] <= capacity * 0.8):\n                cluster.append(customer)\n                current_demand += demand[customer]\n                remaining_customers.remove(customer)\n\n        clusters.append(cluster)\n\n    # Demand-aware route reconstruction\n    new_solution = []\n    for cluster in clusters:\n        # Sort cluster by distance from depot\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0][x])\n\n        # Create a new route starting from the depot\n        current_route = [0]\n        current_load = 0\n\n        for customer in cluster_sorted:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                # Close current route and start a new one\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        # Close the last route\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    # Merge routes if possible to reduce makespan\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Skip empty or single-customer routes\n            continue\n\n        merged = False\n        for i, existing_route in enumerate(merged_solution):\n            combined_demand = np.sum(demand[route[1:-1]]) + np.sum(demand[existing_route[1:-1]])\n            if combined_demand <= capacity:\n                # Merge routes by connecting them\n                merged_route = np.concatenate([existing_route[:-1], route[1:]])\n                merged_solution[i] = merged_route\n                merged = True\n                break\n\n        if not merged:\n            merged_solution.append(route)\n\n    # Add any remaining unserved customers to new routes\n    if unserved_customers:\n        for customer in unserved_customers:\n            new_route = np.array([0, customer, 0])\n            merged_solution.append(new_route)\n\n    return merged_solution\n\n",
        "score": [
            -0.7727560458592287,
            0.027076750993728638
        ]
    },
    {
        "algorithm": "{This new algorithm combines route merging with demand-aware customer rebalancing to create more efficient routes by strategically combining short routes and redistributing customers to optimize both total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the two shortest routes to merge\n    route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n    shortest_route_idx1 = np.argmin(route_lengths)\n    shortest_route1 = new_solution[shortest_route_idx1]\n    route_lengths[shortest_route_idx1] = float('inf')\n    shortest_route_idx2 = np.argmin(route_lengths)\n    shortest_route2 = new_solution[shortest_route_idx2]\n\n    # Combine the two shortest routes\n    combined_route = np.concatenate([shortest_route1[:-1], shortest_route2[1:]])\n\n    # Check capacity feasibility\n    combined_demand = np.sum(demand[combined_route[1:-1]])\n    if combined_demand <= capacity:\n        new_solution.append(combined_route)\n        del new_solution[max(shortest_route_idx1, shortest_route_idx2)]\n        del new_solution[min(shortest_route_idx1, shortest_route_idx2)]\n    else:\n        # If merge is infeasible, redistribute customers to other routes\n        customers = np.concatenate([shortest_route1[1:-1], shortest_route2[1:-1]])\n        for customer in customers:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i in [shortest_route_idx1, shortest_route_idx2]:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                           distance_matrix[customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original short routes if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[max(shortest_route_idx1, shortest_route_idx2)]\n            del new_solution[min(shortest_route_idx1, shortest_route_idx2)]\n\n    return new_solution\n\n",
        "score": [
            -0.9104693069688522,
            1.1583054661750793
        ]
    },
    {
        "algorithm": "{This novel algorithm combines spatial clustering with demand-aware route reconstruction, where it first groups customers based on spatial proximity and demand similarity, then reconstructs routes by iteratively assigning clusters to vehicles while balancing capacity and minimizing route length, creating a hybrid of spatial partitioning and demand-aware optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] / x[1][0], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Collect all unserved customers from the base solution\n    served_customers = set()\n    for route in base_solution:\n        served_customers.update(route[1:-1])\n    unserved_customers = [i for i in range(1, len(coords)) if i not in served_customers]\n\n    # Spatial clustering: group customers based on proximity and demand similarity\n    clusters = []\n    remaining_customers = set(unserved_customers)\n\n    while remaining_customers:\n        # Select a seed customer (highest demand)\n        seed = max(remaining_customers, key=lambda x: demand[x])\n        cluster = [seed]\n        remaining_customers.remove(seed)\n        current_demand = demand[seed]\n\n        # Grow the cluster with nearby customers that fit demand constraints\n        for customer in list(remaining_customers):\n            if (distance_matrix[seed][customer] < 1.5 * np.mean(distance_matrix[0]) and\n                current_demand + demand[customer] <= capacity * 0.8):\n                cluster.append(customer)\n                current_demand += demand[customer]\n                remaining_customers.remove(customer)\n\n        clusters.append(cluster)\n\n    # Demand-aware route reconstruction\n    new_solution = []\n    for cluster in clusters:\n        # Sort cluster by distance from depot\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0][x])\n\n        # Create a new route starting from the depot\n        current_route = [0]\n        current_load = 0\n\n        for customer in cluster_sorted:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                # Close current route and start a new one\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        # Close the last route\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    # Merge routes if possible to reduce makespan\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Skip empty or single-customer routes\n            continue\n\n        merged = False\n        for i, existing_route in enumerate(merged_solution):\n            combined_demand = np.sum(demand[route[1:-1]]) + np.sum(demand[existing_route[1:-1]])\n            if combined_demand <= capacity:\n                # Merge routes by connecting them\n                merged_route = np.concatenate([existing_route[:-1], route[1:]])\n                merged_solution[i] = merged_route\n                merged = True\n                break\n\n        if not merged:\n            merged_solution.append(route)\n\n    # Add any remaining unserved customers to new routes\n    if unserved_customers:\n        for customer in unserved_customers:\n            new_route = np.array([0, customer, 0])\n            merged_solution.append(new_route)\n\n    return merged_solution\n\n",
        "score": [
            -0.7727560458592287,
            0.027076750993728638
        ]
    },
    {
        "algorithm": "{This algorithm combines route splitting with demand-aware customer rebalancing by strategically dividing overloaded routes and redistributing customers to underutilized routes while respecting capacity constraints, aiming to balance the makespan without significantly increasing the total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (-x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the route with the highest demand utilization\n    demand_utilization = [np.sum(demand[route[1:-1]]) / capacity for route in new_solution]\n    overloaded_route_idx = np.argmax(demand_utilization)\n    overloaded_route = new_solution[overloaded_route_idx]\n\n    if len(overloaded_route) <= 3:\n        return new_solution\n\n    # Try to split the overloaded route into two balanced routes\n    split_pos = len(overloaded_route) // 2\n    first_part = overloaded_route[:split_pos]\n    second_part = overloaded_route[split_pos:]\n\n    # Check if both parts are feasible\n    if (np.sum(demand[first_part[1:-1]]) <= capacity and\n        np.sum(demand[second_part[1:-1]]) <= capacity):\n\n        # Replace the original route with the two new routes\n        new_solution[overloaded_route_idx] = first_part\n        new_solution.insert(overloaded_route_idx + 1, second_part)\n    else:\n        # If split is infeasible, try to redistribute customers from the overloaded route\n        customers_to_redistribute = overloaded_route[1:-1]\n        for customer in customers_to_redistribute:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == overloaded_route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = (distance_matrix[temp_route[pos-1]][customer] +\n                            distance_matrix[customer][temp_route[pos+1]] -\n                            distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the customer from the original route\n        for i in range(len(new_solution)):\n            if overloaded_route_idx in range(len(new_solution)):\n                if np.array_equal(new_solution[overloaded_route_idx], overloaded_route):\n                    new_solution[i] = np.delete(overloaded_route, np.where(overloaded_route == customer)[0][0])\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9041740497853441,
            0.05824071168899536
        ]
    },
    {
        "algorithm": "{This new algorithm combines route merging with demand-aware customer rebalancing to create more efficient routes by strategically combining short routes and redistributing customers to optimize both total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the two shortest routes to merge\n    route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n    shortest_route_idx1 = np.argmin(route_lengths)\n    shortest_route1 = new_solution[shortest_route_idx1]\n    route_lengths[shortest_route_idx1] = float('inf')\n    shortest_route_idx2 = np.argmin(route_lengths)\n    shortest_route2 = new_solution[shortest_route_idx2]\n\n    # Combine the two shortest routes\n    combined_route = np.concatenate([shortest_route1[:-1], shortest_route2[1:]])\n\n    # Check capacity feasibility\n    combined_demand = np.sum(demand[combined_route[1:-1]])\n    if combined_demand <= capacity:\n        new_solution.append(combined_route)\n        del new_solution[max(shortest_route_idx1, shortest_route_idx2)]\n        del new_solution[min(shortest_route_idx1, shortest_route_idx2)]\n    else:\n        # If merge is infeasible, redistribute customers to other routes\n        customers = np.concatenate([shortest_route1[1:-1], shortest_route2[1:-1]])\n        for customer in customers:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i in [shortest_route_idx1, shortest_route_idx2]:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                           distance_matrix[customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original short routes if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[max(shortest_route_idx1, shortest_route_idx2)]\n            del new_solution[min(shortest_route_idx1, shortest_route_idx2)]\n\n    return new_solution\n\n",
        "score": [
            -0.9104693069688522,
            1.1583054661750793
        ]
    },
    {
        "algorithm": "{This novel algorithm combines spatial clustering with demand-aware route reconstruction, where it first groups customers based on spatial proximity and demand similarity, then reconstructs routes by iteratively assigning clusters to vehicles while balancing capacity and minimizing route length, creating a hybrid of spatial partitioning and demand-aware optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] / x[1][0], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Collect all unserved customers from the base solution\n    served_customers = set()\n    for route in base_solution:\n        served_customers.update(route[1:-1])\n    unserved_customers = [i for i in range(1, len(coords)) if i not in served_customers]\n\n    # Spatial clustering: group customers based on proximity and demand similarity\n    clusters = []\n    remaining_customers = set(unserved_customers)\n\n    while remaining_customers:\n        # Select a seed customer (highest demand)\n        seed = max(remaining_customers, key=lambda x: demand[x])\n        cluster = [seed]\n        remaining_customers.remove(seed)\n        current_demand = demand[seed]\n\n        # Grow the cluster with nearby customers that fit demand constraints\n        for customer in list(remaining_customers):\n            if (distance_matrix[seed][customer] < 1.5 * np.mean(distance_matrix[0]) and\n                current_demand + demand[customer] <= capacity * 0.8):\n                cluster.append(customer)\n                current_demand += demand[customer]\n                remaining_customers.remove(customer)\n\n        clusters.append(cluster)\n\n    # Demand-aware route reconstruction\n    new_solution = []\n    for cluster in clusters:\n        # Sort cluster by distance from depot\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0][x])\n\n        # Create a new route starting from the depot\n        current_route = [0]\n        current_load = 0\n\n        for customer in cluster_sorted:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                # Close current route and start a new one\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        # Close the last route\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    # Merge routes if possible to reduce makespan\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Skip empty or single-customer routes\n            continue\n\n        merged = False\n        for i, existing_route in enumerate(merged_solution):\n            combined_demand = np.sum(demand[route[1:-1]]) + np.sum(demand[existing_route[1:-1]])\n            if combined_demand <= capacity:\n                # Merge routes by connecting them\n                merged_route = np.concatenate([existing_route[:-1], route[1:]])\n                merged_solution[i] = merged_route\n                merged = True\n                break\n\n        if not merged:\n            merged_solution.append(route)\n\n    # Add any remaining unserved customers to new routes\n    if unserved_customers:\n        for customer in unserved_customers:\n            new_route = np.array([0, customer, 0])\n            merged_solution.append(new_route)\n\n    return merged_solution\n\n",
        "score": [
            -0.7727560458592287,
            0.027076750993728638
        ]
    },
    {
        "algorithm": "{This novel algorithm combines spatial clustering with demand-aware route reconstruction, where it first groups customers based on spatial proximity and demand similarity, then reconstructs routes by iteratively assigning clusters to vehicles while balancing capacity and minimizing route length, creating a hybrid of spatial partitioning and demand-aware optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] / x[1][0], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Collect all unserved customers from the base solution\n    served_customers = set()\n    for route in base_solution:\n        served_customers.update(route[1:-1])\n    unserved_customers = [i for i in range(1, len(coords)) if i not in served_customers]\n\n    # Spatial clustering: group customers based on proximity and demand similarity\n    clusters = []\n    remaining_customers = set(unserved_customers)\n\n    while remaining_customers:\n        # Select a seed customer (highest demand)\n        seed = max(remaining_customers, key=lambda x: demand[x])\n        cluster = [seed]\n        remaining_customers.remove(seed)\n        current_demand = demand[seed]\n\n        # Grow the cluster with nearby customers that fit demand constraints\n        for customer in list(remaining_customers):\n            if (distance_matrix[seed][customer] < 1.5 * np.mean(distance_matrix[0]) and\n                current_demand + demand[customer] <= capacity * 0.8):\n                cluster.append(customer)\n                current_demand += demand[customer]\n                remaining_customers.remove(customer)\n\n        clusters.append(cluster)\n\n    # Demand-aware route reconstruction\n    new_solution = []\n    for cluster in clusters:\n        # Sort cluster by distance from depot\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0][x])\n\n        # Create a new route starting from the depot\n        current_route = [0]\n        current_load = 0\n\n        for customer in cluster_sorted:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                # Close current route and start a new one\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        # Close the last route\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    # Merge routes if possible to reduce makespan\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Skip empty or single-customer routes\n            continue\n\n        merged = False\n        for i, existing_route in enumerate(merged_solution):\n            combined_demand = np.sum(demand[route[1:-1]]) + np.sum(demand[existing_route[1:-1]])\n            if combined_demand <= capacity:\n                # Merge routes by connecting them\n                merged_route = np.concatenate([existing_route[:-1], route[1:]])\n                merged_solution[i] = merged_route\n                merged = True\n                break\n\n        if not merged:\n            merged_solution.append(route)\n\n    # Add any remaining unserved customers to new routes\n    if unserved_customers:\n        for customer in unserved_customers:\n            new_route = np.array([0, customer, 0])\n            merged_solution.append(new_route)\n\n    return merged_solution\n\n",
        "score": [
            -0.7727560458592287,
            0.027076750993728638
        ]
    },
    {
        "algorithm": "{This new algorithm combines route merging with demand-aware customer rebalancing to create more efficient routes by strategically combining short routes and redistributing customers to optimize both total distance and makespan while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the two shortest routes to merge\n    route_lengths = [np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution]\n    shortest_route_idx1 = np.argmin(route_lengths)\n    shortest_route1 = new_solution[shortest_route_idx1]\n    route_lengths[shortest_route_idx1] = float('inf')\n    shortest_route_idx2 = np.argmin(route_lengths)\n    shortest_route2 = new_solution[shortest_route_idx2]\n\n    # Combine the two shortest routes\n    combined_route = np.concatenate([shortest_route1[:-1], shortest_route2[1:]])\n\n    # Check capacity feasibility\n    combined_demand = np.sum(demand[combined_route[1:-1]])\n    if combined_demand <= capacity:\n        new_solution.append(combined_route)\n        del new_solution[max(shortest_route_idx1, shortest_route_idx2)]\n        del new_solution[min(shortest_route_idx1, shortest_route_idx2)]\n    else:\n        # If merge is infeasible, redistribute customers to other routes\n        customers = np.concatenate([shortest_route1[1:-1], shortest_route2[1:-1]])\n        for customer in customers:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i in [shortest_route_idx1, shortest_route_idx2]:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                           distance_matrix[customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original short routes if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[max(shortest_route_idx1, shortest_route_idx2)]\n            del new_solution[min(shortest_route_idx1, shortest_route_idx2)]\n\n    return new_solution\n\n",
        "score": [
            -0.9104693069688522,
            1.1583054661750793
        ]
    },
    {
        "algorithm": "{This novel algorithm combines spatial clustering with demand-aware route reconstruction, where it first groups customers based on spatial proximity and demand similarity, then reconstructs routes by iteratively assigning clusters to vehicles while balancing capacity and minimizing route length, creating a hybrid of spatial partitioning and demand-aware optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] / x[1][0], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Collect all unserved customers from the base solution\n    served_customers = set()\n    for route in base_solution:\n        served_customers.update(route[1:-1])\n    unserved_customers = [i for i in range(1, len(coords)) if i not in served_customers]\n\n    # Spatial clustering: group customers based on proximity and demand similarity\n    clusters = []\n    remaining_customers = set(unserved_customers)\n\n    while remaining_customers:\n        # Select a seed customer (highest demand)\n        seed = max(remaining_customers, key=lambda x: demand[x])\n        cluster = [seed]\n        remaining_customers.remove(seed)\n        current_demand = demand[seed]\n\n        # Grow the cluster with nearby customers that fit demand constraints\n        for customer in list(remaining_customers):\n            if (distance_matrix[seed][customer] < 1.5 * np.mean(distance_matrix[0]) and\n                current_demand + demand[customer] <= capacity * 0.8):\n                cluster.append(customer)\n                current_demand += demand[customer]\n                remaining_customers.remove(customer)\n\n        clusters.append(cluster)\n\n    # Demand-aware route reconstruction\n    new_solution = []\n    for cluster in clusters:\n        # Sort cluster by distance from depot\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0][x])\n\n        # Create a new route starting from the depot\n        current_route = [0]\n        current_load = 0\n\n        for customer in cluster_sorted:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                # Close current route and start a new one\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        # Close the last route\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    # Merge routes if possible to reduce makespan\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Skip empty or single-customer routes\n            continue\n\n        merged = False\n        for i, existing_route in enumerate(merged_solution):\n            combined_demand = np.sum(demand[route[1:-1]]) + np.sum(demand[existing_route[1:-1]])\n            if combined_demand <= capacity:\n                # Merge routes by connecting them\n                merged_route = np.concatenate([existing_route[:-1], route[1:]])\n                merged_solution[i] = merged_route\n                merged = True\n                break\n\n        if not merged:\n            merged_solution.append(route)\n\n    # Add any remaining unserved customers to new routes\n    if unserved_customers:\n        for customer in unserved_customers:\n            new_route = np.array([0, customer, 0])\n            merged_solution.append(new_route)\n\n    return merged_solution\n\n",
        "score": [
            -0.7727560458592287,
            0.027076750993728638
        ]
    },
    {
        "algorithm": "{This novel algorithm combines spatial clustering with demand-aware route reconstruction, where it first groups customers based on spatial proximity and demand similarity, then reconstructs routes by iteratively assigning clusters to vehicles while balancing capacity and minimizing route length, creating a hybrid of spatial partitioning and demand-aware optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] / x[1][0], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Collect all unserved customers from the base solution\n    served_customers = set()\n    for route in base_solution:\n        served_customers.update(route[1:-1])\n    unserved_customers = [i for i in range(1, len(coords)) if i not in served_customers]\n\n    # Spatial clustering: group customers based on proximity and demand similarity\n    clusters = []\n    remaining_customers = set(unserved_customers)\n\n    while remaining_customers:\n        # Select a seed customer (highest demand)\n        seed = max(remaining_customers, key=lambda x: demand[x])\n        cluster = [seed]\n        remaining_customers.remove(seed)\n        current_demand = demand[seed]\n\n        # Grow the cluster with nearby customers that fit demand constraints\n        for customer in list(remaining_customers):\n            if (distance_matrix[seed][customer] < 1.5 * np.mean(distance_matrix[0]) and\n                current_demand + demand[customer] <= capacity * 0.8):\n                cluster.append(customer)\n                current_demand += demand[customer]\n                remaining_customers.remove(customer)\n\n        clusters.append(cluster)\n\n    # Demand-aware route reconstruction\n    new_solution = []\n    for cluster in clusters:\n        # Sort cluster by distance from depot\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0][x])\n\n        # Create a new route starting from the depot\n        current_route = [0]\n        current_load = 0\n\n        for customer in cluster_sorted:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                # Close current route and start a new one\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        # Close the last route\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    # Merge routes if possible to reduce makespan\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Skip empty or single-customer routes\n            continue\n\n        merged = False\n        for i, existing_route in enumerate(merged_solution):\n            combined_demand = np.sum(demand[route[1:-1]]) + np.sum(demand[existing_route[1:-1]])\n            if combined_demand <= capacity:\n                # Merge routes by connecting them\n                merged_route = np.concatenate([existing_route[:-1], route[1:]])\n                merged_solution[i] = merged_route\n                merged = True\n                break\n\n        if not merged:\n            merged_solution.append(route)\n\n    # Add any remaining unserved customers to new routes\n    if unserved_customers:\n        for customer in unserved_customers:\n            new_route = np.array([0, customer, 0])\n            merged_solution.append(new_route)\n\n    return merged_solution\n\n",
        "score": [
            -0.7727560458592287,
            0.027076750993728638
        ]
    },
    {
        "algorithm": "{This novel algorithm combines spatial clustering with demand-aware route reconstruction, where it first groups customers based on spatial proximity and demand similarity, then reconstructs routes by iteratively assigning clusters to vehicles while balancing capacity and minimizing route length, creating a hybrid of spatial partitioning and demand-aware optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] / x[1][0], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Collect all unserved customers from the base solution\n    served_customers = set()\n    for route in base_solution:\n        served_customers.update(route[1:-1])\n    unserved_customers = [i for i in range(1, len(coords)) if i not in served_customers]\n\n    # Spatial clustering: group customers based on proximity and demand similarity\n    clusters = []\n    remaining_customers = set(unserved_customers)\n\n    while remaining_customers:\n        # Select a seed customer (highest demand)\n        seed = max(remaining_customers, key=lambda x: demand[x])\n        cluster = [seed]\n        remaining_customers.remove(seed)\n        current_demand = demand[seed]\n\n        # Grow the cluster with nearby customers that fit demand constraints\n        for customer in list(remaining_customers):\n            if (distance_matrix[seed][customer] < 1.5 * np.mean(distance_matrix[0]) and\n                current_demand + demand[customer] <= capacity * 0.8):\n                cluster.append(customer)\n                current_demand += demand[customer]\n                remaining_customers.remove(customer)\n\n        clusters.append(cluster)\n\n    # Demand-aware route reconstruction\n    new_solution = []\n    for cluster in clusters:\n        # Sort cluster by distance from depot\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0][x])\n\n        # Create a new route starting from the depot\n        current_route = [0]\n        current_load = 0\n\n        for customer in cluster_sorted:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                # Close current route and start a new one\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        # Close the last route\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    # Merge routes if possible to reduce makespan\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Skip empty or single-customer routes\n            continue\n\n        merged = False\n        for i, existing_route in enumerate(merged_solution):\n            combined_demand = np.sum(demand[route[1:-1]]) + np.sum(demand[existing_route[1:-1]])\n            if combined_demand <= capacity:\n                # Merge routes by connecting them\n                merged_route = np.concatenate([existing_route[:-1], route[1:]])\n                merged_solution[i] = merged_route\n                merged = True\n                break\n\n        if not merged:\n            merged_solution.append(route)\n\n    # Add any remaining unserved customers to new routes\n    if unserved_customers:\n        for customer in unserved_customers:\n            new_route = np.array([0, customer, 0])\n            merged_solution.append(new_route)\n\n    return merged_solution\n\n",
        "score": [
            -0.7727560458592287,
            0.027076750993728638
        ]
    }
]