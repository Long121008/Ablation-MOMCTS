[
    {
        "algorithm": "{This new algorithm combines route fragmentation with distance-aware customer redistribution to create balanced routes by strategically splitting long routes and redistributing customers to shorter routes while respecting capacity constraints, aiming to reduce makespan without significantly increasing total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the longest route to fragment\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:  # Skip if route is too short\n        return new_solution\n\n    # Split the longest route into two segments\n    split_idx = np.random.randint(1, len(longest_route) - 1)\n    segment1 = longest_route[:split_idx + 1]\n    segment2 = longest_route[split_idx:]\n\n    # Check capacity feasibility for both segments\n    seg1_demand = np.sum(demand[segment1[1:-1]])\n    seg2_demand = np.sum(demand[segment2[1:-1]])\n\n    if seg1_demand <= capacity and seg2_demand <= capacity:\n        new_solution[longest_route_idx] = segment1\n        new_solution.append(segment2)\n    else:\n        # If split is infeasible, redistribute customers to other routes\n        customers = longest_route[1:-1]\n        for customer in customers:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                           distance_matrix[customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original long route if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7361642978703139,
            0.0802602469921112
        ]
    },
    {
        "algorithm": "{This new algorithm combines spatial clustering with demand-aware route splitting to create balanced routes by first grouping customers based on their spatial proximity and then intelligently splitting these clusters into feasible routes while considering both demand and distance constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Collect all unassigned customers\n    assigned_customers = set()\n    for route in new_solution:\n        assigned_customers.update(route[1:-1])\n    all_customers = set(range(1, len(demand)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    if not unassigned_customers:\n        # If no unassigned customers, try to improve existing routes\n        if len(new_solution) > 1:\n            # Select a random route to split\n            route_idx = np.random.randint(0, len(new_solution))\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find the best split point\n                best_split = 1\n                best_score = float('inf')\n\n                for split in range(2, len(route)-1):\n                    # Check if the split creates feasible routes\n                    first_part = route[:split+1]\n                    second_part = route[split:]\n\n                    if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                        np.sum(demand[second_part[1:-1]]) <= capacity):\n                        # Calculate the score based on distance reduction\n                        original_dist = (distance_matrix[route[split-1]][route[split]] +\n                                       distance_matrix[route[split]][route[split+1]])\n                        new_dist = (distance_matrix[route[split-1]][0] +\n                                   distance_matrix[0][route[split]] +\n                                   distance_matrix[route[split]][0] +\n                                   distance_matrix[0][route[split+1]])\n\n                        score = new_dist - original_dist\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = split\n\n                if best_split > 1:\n                    # Perform the split\n                    first_part = route[:best_split+1]\n                    second_part = route[best_split:]\n                    new_solution[route_idx] = first_part\n                    new_solution.insert(route_idx + 1, second_part)\n    else:\n        # Create new routes for unassigned customers\n        remaining_customers = unassigned_customers.copy()\n\n        while remaining_customers:\n            # Select a customer to start a new route\n            current_customer = remaining_customers.pop(0)\n            current_demand = demand[current_customer]\n            current_route = [0, current_customer, 0]\n\n            # Try to add compatible customers\n            for _ in range(len(remaining_customers)):\n                if np.sum(demand[current_route[1:-1]]) + demand[remaining_customers[0]] <= capacity:\n                    # Find the best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n\n                    for pos in range(1, len(current_route)):\n                        temp_route = np.insert(current_route, pos, remaining_customers[0])\n                        cost = (distance_matrix[temp_route[pos-1]][remaining_customers[0]] +\n                               distance_matrix[remaining_customers[0]][temp_route[pos+1]] -\n                               distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    current_route = np.insert(current_route, best_pos, remaining_customers[0])\n                    remaining_customers.pop(0)\n                else:\n                    break\n\n            new_solution.append(np.array(current_route))\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8749576738664353,
            0.17882221937179565
        ]
    },
    {
        "algorithm": "{This new algorithm combines route fragmentation with demand-aware customer redistribution to create balanced routes by strategically splitting long routes and redistributing customers to shorter routes while respecting capacity constraints, aiming to reduce makespan without significantly increasing total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the longest route to fragment\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:  # Skip if route is too short\n        return new_solution\n\n    # Split the longest route into two segments\n    split_idx = np.random.randint(1, len(longest_route) - 1)\n    segment1 = longest_route[:split_idx + 1]\n    segment2 = longest_route[split_idx:]\n\n    # Check capacity feasibility for both segments\n    seg1_demand = np.sum(demand[segment1[1:-1]])\n    seg2_demand = np.sum(demand[segment2[1:-1]])\n\n    if seg1_demand <= capacity and seg2_demand <= capacity:\n        new_solution[longest_route_idx] = segment1\n        new_solution.append(segment2)\n    else:\n        # If split is infeasible, redistribute customers to other routes\n        customers = longest_route[1:-1]\n        for customer in customers:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                           distance_matrix[customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original long route if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8538019298383264,
            0.0867181122303009
        ]
    },
    {
        "algorithm": "{This new algorithm implements a hybrid approach combining route merging with demand-aware spatial clustering and adaptive route splitting, which intelligently balances the trade-off between minimizing total distance and makespan by considering both spatial distribution and demand patterns while ensuring feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Cluster routes based on spatial proximity and demand similarity\n    route_clusters = []\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) > 0:\n            route_coords = coords[customers]\n            centroid = np.mean(route_coords, axis=0)\n            total_demand = np.sum(demand[customers])\n            route_clusters.append((centroid, total_demand, route))\n\n    # Find the most imbalanced cluster (either too large or too small)\n    if route_clusters:\n        avg_demand = sum(d[1] for d in route_clusters) / len(route_clusters)\n        imbalanced_route = max(route_clusters, key=lambda x: abs(x[1] - avg_demand))\n        imbalanced_idx = [i for i, r in enumerate(new_solution) if np.array_equal(r, imbalanced_route[2])][0]\n\n        # Try to rebalance by merging with a nearby route\n        best_merge = None\n        min_distance_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == imbalanced_idx:\n                continue\n\n            # Calculate spatial proximity\n            route_centroid = np.mean(coords[route[1:-1]], axis=0)\n            distance = np.linalg.norm(imbalanced_route[0] - route_centroid)\n\n            # Calculate potential merged demand\n            merged_demand = imbalanced_route[1] + np.sum(demand[route[1:-1]])\n\n            if merged_demand <= capacity:\n                # Calculate distance increase if merged\n                distance_increase = (distance_matrix[imbalanced_route[2][-2], route[1]] +\n                                    distance_matrix[route[-2], imbalanced_route[2][1]] -\n                                    distance_matrix[imbalanced_route[2][-2], imbalanced_route[2][1]] -\n                                    distance_matrix[route[-2], route[1]])\n\n                if distance_increase < min_distance_increase:\n                    min_distance_increase = distance_increase\n                    best_merge = i\n\n        if best_merge is not None:\n            # Perform the merge\n            merged_route = np.concatenate([new_solution[imbalanced_idx][:-1], new_solution[best_merge][1:]])\n            new_solution[imbalanced_idx] = merged_route\n            new_solution.pop(best_merge)\n        else:\n            # If no merge possible, try adaptive splitting\n            route_to_split = new_solution[imbalanced_idx]\n            if len(route_to_split) > 4:  # Ensure we can split meaningfully\n                # Find the customer with median demand in the route\n                customers = route_to_split[1:-1]\n                sorted_customers = sorted(customers, key=lambda x: demand[x])\n                median_customer = sorted_customers[len(sorted_customers)//2]\n\n                split_pos = np.where(route_to_split == median_customer)[0][0]\n                first_part = route_to_split[:split_pos+1]\n                second_part = route_to_split[split_pos:]\n\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[imbalanced_idx] = first_part\n                    new_solution.insert(imbalanced_idx + 1, second_part)\n\n    return new_solution\n\n",
        "score": [
            -0.8923017731161753,
            0.7799195647239685
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by identifying routes with the largest makespan, then applies a hybrid local search operator that combines route segmentation and insertion heuristics to balance distance and makespan reduction, while ensuring feasibility through capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search: segment and reinsert routes to balance distance and makespan\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes (depot-depot or single customer)\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two segments at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_idx + 1]\n        segment2 = route[split_idx:]\n\n        # Check capacity feasibility for both segments\n        seg1_demand = np.sum(demand[segment1[1:-1]])\n        seg2_demand = np.sum(demand[segment2[1:-1]])\n\n        if seg1_demand <= capacity and seg2_demand <= capacity:\n            new_solution.append(segment1.copy())\n            new_solution.append(segment2.copy())\n        else:\n            # If split is infeasible, try inserting a random customer from another route\n            other_route = np.random.choice([r for r in base_solution if len(r) > 3 and r is not route])\n            if len(other_route) > 3:\n                insert_pos = np.random.randint(1, len(other_route) - 1)\n                customer = other_route[insert_pos]\n                if np.sum(demand[segment1[1:-1]]) + demand[customer] <= capacity:\n                    new_segment = np.insert(segment1, -1, customer)\n                    new_solution.append(new_segment)\n                    # Remove the customer from the other route\n                    new_other_route = np.delete(other_route, insert_pos)\n                    new_solution.append(new_other_route)\n                else:\n                    new_solution.append(route.copy())\n\n    # Ensure all customers are served (fallback if some are missing)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing = all_customers - served_customers\n    if missing:\n        # Reassign missing customers to routes with available capacity\n        for customer in missing:\n            for i, route in enumerate(new_solution):\n                if np.sum(demand[list(route[1:-1])]) + demand[customer] <= capacity:\n                    new_route = np.insert(route, -1, customer)\n                    new_solution[i] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8634949154541082,
            0.36051949858665466
        ]
    },
    {
        "algorithm": "{This new algorithm combines segment swapping with demand-balanced route merging, where it exchanges route segments between two routes and intelligently merges routes when their combined demand fits within capacity, while ensuring feasibility through a proximity-aware reinsertion mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Select two distinct routes\n        route_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        if len(route1) > 2 and len(route2) > 2:\n            # Select segments from both routes\n            seg1_start = np.random.randint(1, len(route1)-1)\n            seg1_end = np.random.randint(seg1_start, len(route1)-1)\n            seg2_start = np.random.randint(1, len(route2)-1)\n            seg2_end = np.random.randint(seg2_start, len(route2)-1)\n\n            # Extract segments\n            segment1 = route1[seg1_start:seg1_end+1]\n            segment2 = route2[seg2_start:seg2_end+1]\n\n            # Swap segments\n            route1 = np.concatenate([route1[:seg1_start], segment2, route1[seg1_end+1:]])\n            route2 = np.concatenate([route2[:seg2_start], segment1, route2[seg2_end+1:]])\n\n            # Check capacity feasibility for both routes\n            def is_feasible(route):\n                return np.sum(demand[route[1:-1]]) <= capacity\n\n            if not is_feasible(route1) or not is_feasible(route2):\n                # If infeasible, attempt to reallocate excess customers\n                for route in [route1, route2]:\n                    if not is_feasible(route):\n                        excess_demand = np.sum(demand[route[1:-1]]) - capacity\n                        # Remove customers until feasible\n                        while excess_demand > 0 and len(route) > 2:\n                            # Remove the customer with highest demand (greedy approach)\n                            customers = route[1:-1]\n                            customer_demands = demand[customers]\n                            remove_idx = np.argmax(customer_demands)\n                            excess_demand -= customer_demands[remove_idx]\n                            route = np.delete(route, remove_idx+1)\n\n                # Update the routes\n                new_solution[route_indices[0]] = route1\n                new_solution[route_indices[1]] = route2\n\n                # Check if routes can be merged (demand-balanced approach)\n                if len(route1) > 2 and len(route2) > 2:\n                    combined_demand = np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]])\n                    if combined_demand <= capacity:\n                        # Merge routes by connecting them\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        # Remove the two routes and add the merged one\n                        new_solution = [r for i, r in enumerate(new_solution) if i not in route_indices]\n                        new_solution.append(merged_route)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7932070545477892,
            0.1390448808670044
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive route merging with demand-aware customer reinsertion, prioritizing solutions with high makespan reduction potential while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] / x[1][0], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route merging and customer reinsertion\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            # Try merging routes i and j\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # If merging is feasible, perform it\n                new_solution[i] = merged_route\n                new_solution[j] = np.array([0, 0])  # Mark for removal\n                break\n\n    # Remove merged routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Demand-aware customer reinsertion\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n\n        # Identify customers with high demand\n        customers = route[1:-1]\n        high_demand_customers = customers[demand[customers] > capacity * 0.3]\n\n        for customer in high_demand_customers:\n            # Find the best position to reinsert this customer\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for k, other_route in enumerate(new_solution):\n                if other_route is route:\n                    continue\n\n                for pos in range(1, len(other_route)):\n                    temp_route = np.insert(other_route, pos, customer)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                               distance_matrix[customer][temp_route[pos+1]] - \\\n                               distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = k\n                            best_pos = pos\n\n            if best_route != -1:\n                # Perform the reinsertion\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                route[route == customer] = 0  # Mark for removal\n\n    # Remove empty spots and re-clean\n    new_solution = [route[route != 0] for route in new_solution if len(route[route != 0]) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8740276167320389,
            0.3970206677913666
        ]
    },
    {
        "algorithm": "{This new algorithm combines route merging with demand-based rebalancing to reduce the number of vehicles while maintaining load balance, by strategically combining shorter routes with high-demand customers into longer routes that better utilize vehicle capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])  # Sort by combined objectives\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Select the shortest route to consider merging\n    shortest_route_idx = np.argmin([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    shortest_route = new_solution[shortest_route_idx]\n\n    # Calculate total demand of the shortest route\n    route_demand = np.sum(demand[shortest_route[1:-1]])\n\n    # Find a compatible route to merge with\n    for i, route in enumerate(new_solution):\n        if i == shortest_route_idx:\n            continue\n        current_demand = np.sum(demand[route[1:-1]])\n        if current_demand + route_demand <= capacity:\n            # Merge the shortest route into this route\n            merged_route = np.concatenate([route[:-1], shortest_route[1:]])\n            new_solution[i] = merged_route\n            del new_solution[shortest_route_idx]\n            break\n\n    # If no merge was possible, try to rebalance demand\n    if len(new_solution) == len(base_solution):\n        # Find the route with the most excess capacity\n        excess_capacity = [(i, capacity - np.sum(demand[route[1:-1]])) for i, route in enumerate(new_solution)]\n        excess_capacity.sort(key=lambda x: x[1], reverse=True)\n\n        if excess_capacity and excess_capacity[0][1] > 0:\n            target_route_idx = excess_capacity[0][0]\n            target_route = new_solution[target_route_idx]\n\n            # Find the heaviest customer in other routes that can fit\n            for i, route in enumerate(new_solution):\n                if i == target_route_idx:\n                    continue\n                for customer in route[1:-1]:\n                    if demand[customer] <= excess_capacity[0][1]:\n                        # Try to move this customer\n                        new_solution[i] = np.delete(route, np.where(route == customer)[0][0])\n                        # Find best insertion position in target route\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(target_route)):\n                            temp_route = np.insert(target_route, pos, customer)\n                            cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                                   distance_matrix[customer][temp_route[pos+1]] - \\\n                                   distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                        new_solution[target_route_idx] = np.insert(target_route, best_pos, customer)\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8910943346271863,
            1.0947364568710327
        ]
    },
    {
        "algorithm": "{The new algorithm implements a hybrid approach combining route splitting with spatial clustering and demand-aware customer reallocation to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Select a route to potentially split or modify\n    route_idx = np.random.randint(0, len(new_solution))\n    selected_route = new_solution[route_idx]\n\n    # Calculate spatial and demand metrics for the selected route\n    customers = selected_route[1:-1]\n    if len(customers) <= 2:\n        return new_solution\n\n    # Find the customer with maximum demand in the route\n    heaviest_customer = max(customers, key=lambda x: demand[x])\n\n    # Calculate spatial centroid of the route\n    route_coords = coords[customers]\n    centroid = np.mean(route_coords, axis=0)\n\n    # Find the customer farthest from centroid (potential split point)\n    farthest_customer = max(customers, key=lambda x: np.linalg.norm(coords[x] - centroid))\n\n    # Try to split the route at the farthest customer\n    split_pos = np.where(selected_route == farthest_customer)[0][0]\n    first_part = selected_route[:split_pos+1]\n    second_part = selected_route[split_pos:]\n\n    # Check if both parts are feasible\n    if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n        new_solution[route_idx] = first_part\n        new_solution.insert(route_idx + 1, second_part)\n    else:\n        # If split is not feasible, try reallocating the heaviest customer\n        best_route = -1\n        best_pos = -1\n        best_score = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == route_idx:\n                continue\n            for pos in range(1, len(route)):\n                temp_route = np.insert(route, pos, heaviest_customer)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    # Score based on distance increase and makespan balance\n                    dist_increase = (distance_matrix[temp_route[pos-1]][heaviest_customer] +\n                                    distance_matrix[heaviest_customer][temp_route[pos+1]] -\n                                    distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                    makespan_diff = abs(len(temp_route) - len(selected_route)) * 0.5\n                    score = dist_increase + makespan_diff\n                    if score < best_score:\n                        best_score = score\n                        best_route = i\n                        best_pos = pos\n\n        if best_route != -1:\n            # Perform the reallocation\n            new_solution[best_route] = np.insert(new_solution[best_route], best_pos, heaviest_customer)\n            new_solution[route_idx] = np.delete(new_solution[route_idx], np.where(new_solution[route_idx] == heaviest_customer)[0][0])\n\n    return new_solution\n\n",
        "score": [
            -0.7906421695167611,
            0.09088990092277527
        ]
    },
    {
        "algorithm": "{This new algorithm employs a hybrid approach combining K-means clustering with demand-aware route balancing, where customers are first grouped based on spatial proximity and demand compatibility, then refined through intelligent route merging and splitting to minimize both total distance and makespan while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Collect all customers and their demands\n    assigned_customers = set()\n    for route in new_solution:\n        assigned_customers.update(route[1:-1])\n    all_customers = set(range(1, len(demand)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    if not unassigned_customers:\n        # If no unassigned customers, try to improve existing routes\n        if len(new_solution) > 1:\n            # Select two random routes to merge\n            route_indices = np.random.choice(len(new_solution), 2, replace=False)\n            route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n            # Check if merging is feasible\n            if np.sum(demand[route1[1:-1]]) + np.sum(demand[route2[1:-1]]) <= capacity:\n                # Find the best merge point\n                best_pos = 1\n                best_score = float('inf')\n\n                for pos in range(1, len(route1)):\n                    merged_route = np.concatenate([route1[:pos], route2[1:-1], route1[pos:]])\n\n                    # Calculate the score based on distance and load balance\n                    total_dist = sum(distance_matrix[merged_route[i]][merged_route[i+1]] for i in range(len(merged_route)-1))\n                    load_balance = abs(np.sum(demand[merged_route[1:-1]]) - capacity/2)\n                    score = total_dist + 0.5 * load_balance\n\n                    if score < best_score:\n                        best_score = score\n                        best_pos = pos\n\n                merged_route = np.concatenate([route1[:best_pos], route2[1:-1], route1[best_pos:]])\n                new_solution[route_indices[0]] = merged_route\n                new_solution.pop(route_indices[1])\n            else:\n                # If merging is not feasible, try to split the longer route\n                route_idx = 0 if len(route1) > len(route2) else 1\n                route = new_solution[route_indices[route_idx]]\n\n                if len(route) > 3:\n                    # Find the best split point\n                    best_split = 1\n                    best_score = float('inf')\n\n                    for split in range(2, len(route)-1):\n                        first_part = route[:split+1]\n                        second_part = route[split:]\n\n                        if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                            np.sum(demand[second_part[1:-1]]) <= capacity):\n                            # Calculate the score based on route balance and distance\n                            first_dist = sum(distance_matrix[first_part[i]][first_part[i+1]] for i in range(len(first_part)-1))\n                            second_dist = sum(distance_matrix[second_part[i]][second_part[i+1]] for i in range(len(second_part)-1))\n                            balance_score = abs(first_dist - second_dist)\n                            score = balance_score + 0.3 * (first_dist + second_dist)\n\n                            if score < best_score:\n                                best_score = score\n                                best_split = split\n\n                    if best_split > 1:\n                        first_part = route[:best_split+1]\n                        second_part = route[best_split:]\n                        new_solution[route_indices[route_idx]] = first_part\n                        new_solution.insert(route_indices[route_idx] + 1, second_part)\n    else:\n        # Create new routes for unassigned customers using K-means clustering\n        if len(unassigned_customers) > 1:\n            # Cluster customers based on coordinates\n            k = min(3, len(unassigned_customers))  # Limit to 3 clusters for simplicity\n            kmeans = KMeans(n_clusters=k, random_state=42).fit(coords[unassigned_customers])\n            clusters = kmeans.labels_\n\n            # Create routes for each cluster\n            for cluster_id in range(k):\n                cluster_customers = [unassigned_customers[i] for i, label in enumerate(clusters) if label == cluster_id]\n                if not cluster_customers:\n                    continue\n\n                # Sort customers by demand to create balanced routes\n                cluster_customers.sort(key=lambda x: demand[x], reverse=True)\n                current_route = [0]\n                current_demand = 0\n\n                for customer in cluster_customers:\n                    if current_demand + demand[customer] <= capacity:\n                        current_route.append(customer)\n                        current_demand += demand[customer]\n                    else:\n                        current_route.append(0)\n                        new_solution.append(np.array(current_route))\n                        current_route = [0, customer]\n                        current_demand = demand[customer]\n\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8610486952286553,
            0.2085079848766327
        ]
    },
    {
        "algorithm": "{This new algorithm implements a hybrid approach combining route merging with demand-aware spatial clustering and adaptive route splitting, which intelligently balances the trade-off between minimizing total distance and makespan by considering both spatial distribution and demand patterns while ensuring feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Cluster routes based on spatial proximity and demand similarity\n    route_clusters = []\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) > 0:\n            route_coords = coords[customers]\n            centroid = np.mean(route_coords, axis=0)\n            total_demand = np.sum(demand[customers])\n            route_clusters.append((centroid, total_demand, route))\n\n    # Find the most imbalanced cluster (either too large or too small)\n    if route_clusters:\n        avg_demand = sum(d[1] for d in route_clusters) / len(route_clusters)\n        imbalanced_route = max(route_clusters, key=lambda x: abs(x[1] - avg_demand))\n        imbalanced_idx = [i for i, r in enumerate(new_solution) if np.array_equal(r, imbalanced_route[2])][0]\n\n        # Try to rebalance by merging with a nearby route\n        best_merge = None\n        min_distance_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == imbalanced_idx:\n                continue\n\n            # Calculate spatial proximity\n            route_centroid = np.mean(coords[route[1:-1]], axis=0)\n            distance = np.linalg.norm(imbalanced_route[0] - route_centroid)\n\n            # Calculate potential merged demand\n            merged_demand = imbalanced_route[1] + np.sum(demand[route[1:-1]])\n\n            if merged_demand <= capacity:\n                # Calculate distance increase if merged\n                distance_increase = (distance_matrix[imbalanced_route[2][-2], route[1]] +\n                                    distance_matrix[route[-2], imbalanced_route[2][1]] -\n                                    distance_matrix[imbalanced_route[2][-2], imbalanced_route[2][1]] -\n                                    distance_matrix[route[-2], route[1]])\n\n                if distance_increase < min_distance_increase:\n                    min_distance_increase = distance_increase\n                    best_merge = i\n\n        if best_merge is not None:\n            # Perform the merge\n            merged_route = np.concatenate([new_solution[imbalanced_idx][:-1], new_solution[best_merge][1:]])\n            new_solution[imbalanced_idx] = merged_route\n            new_solution.pop(best_merge)\n        else:\n            # If no merge possible, try adaptive splitting\n            route_to_split = new_solution[imbalanced_idx]\n            if len(route_to_split) > 4:  # Ensure we can split meaningfully\n                # Find the customer with median demand in the route\n                customers = route_to_split[1:-1]\n                sorted_customers = sorted(customers, key=lambda x: demand[x])\n                median_customer = sorted_customers[len(sorted_customers)//2]\n\n                split_pos = np.where(route_to_split == median_customer)[0][0]\n                first_part = route_to_split[:split_pos+1]\n                second_part = route_to_split[split_pos:]\n\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[imbalanced_idx] = first_part\n                    new_solution.insert(imbalanced_idx + 1, second_part)\n\n    return new_solution\n\n",
        "score": [
            -0.8923017731161753,
            0.7799195647239685
        ]
    },
    {
        "algorithm": "{This new algorithm combines route fragmentation with demand-aware customer redistribution to create balanced routes by strategically splitting long routes and redistributing customers to shorter routes while respecting capacity constraints, aiming to reduce makespan without significantly increasing total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the longest route to fragment\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:  # Skip if route is too short\n        return new_solution\n\n    # Split the longest route into two segments\n    split_idx = np.random.randint(1, len(longest_route) - 1)\n    segment1 = longest_route[:split_idx + 1]\n    segment2 = longest_route[split_idx:]\n\n    # Check capacity feasibility for both segments\n    seg1_demand = np.sum(demand[segment1[1:-1]])\n    seg2_demand = np.sum(demand[segment2[1:-1]])\n\n    if seg1_demand <= capacity and seg2_demand <= capacity:\n        new_solution[longest_route_idx] = segment1\n        new_solution.append(segment2)\n    else:\n        # If split is infeasible, redistribute customers to other routes\n        customers = longest_route[1:-1]\n        for customer in customers:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                           distance_matrix[customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original long route if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8538019298383264,
            0.0867181122303009
        ]
    },
    {
        "algorithm": "{This new algorithm combines spatial clustering with demand-aware route splitting to create balanced routes by first grouping customers based on their spatial proximity and then intelligently splitting these clusters into feasible routes while considering both demand and distance constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Collect all unassigned customers\n    assigned_customers = set()\n    for route in new_solution:\n        assigned_customers.update(route[1:-1])\n    all_customers = set(range(1, len(demand)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    if not unassigned_customers:\n        # If no unassigned customers, try to improve existing routes\n        if len(new_solution) > 1:\n            # Select a random route to split\n            route_idx = np.random.randint(0, len(new_solution))\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find the best split point\n                best_split = 1\n                best_score = float('inf')\n\n                for split in range(2, len(route)-1):\n                    # Check if the split creates feasible routes\n                    first_part = route[:split+1]\n                    second_part = route[split:]\n\n                    if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                        np.sum(demand[second_part[1:-1]]) <= capacity):\n                        # Calculate the score based on distance reduction\n                        original_dist = (distance_matrix[route[split-1]][route[split]] +\n                                       distance_matrix[route[split]][route[split+1]])\n                        new_dist = (distance_matrix[route[split-1]][0] +\n                                   distance_matrix[0][route[split]] +\n                                   distance_matrix[route[split]][0] +\n                                   distance_matrix[0][route[split+1]])\n\n                        score = new_dist - original_dist\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = split\n\n                if best_split > 1:\n                    # Perform the split\n                    first_part = route[:best_split+1]\n                    second_part = route[best_split:]\n                    new_solution[route_idx] = first_part\n                    new_solution.insert(route_idx + 1, second_part)\n    else:\n        # Create new routes for unassigned customers\n        remaining_customers = unassigned_customers.copy()\n\n        while remaining_customers:\n            # Select a customer to start a new route\n            current_customer = remaining_customers.pop(0)\n            current_demand = demand[current_customer]\n            current_route = [0, current_customer, 0]\n\n            # Try to add compatible customers\n            for _ in range(len(remaining_customers)):\n                if np.sum(demand[current_route[1:-1]]) + demand[remaining_customers[0]] <= capacity:\n                    # Find the best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n\n                    for pos in range(1, len(current_route)):\n                        temp_route = np.insert(current_route, pos, remaining_customers[0])\n                        cost = (distance_matrix[temp_route[pos-1]][remaining_customers[0]] +\n                               distance_matrix[remaining_customers[0]][temp_route[pos+1]] -\n                               distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    current_route = np.insert(current_route, best_pos, remaining_customers[0])\n                    remaining_customers.pop(0)\n                else:\n                    break\n\n            new_solution.append(np.array(current_route))\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8749576738664353,
            0.17882221937179565
        ]
    },
    {
        "algorithm": "{This new algorithm combines route fragmentation with distance-aware customer redistribution to create balanced routes by strategically splitting long routes and redistributing customers to shorter routes while respecting capacity constraints, aiming to reduce makespan without significantly increasing total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the longest route to fragment\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:  # Skip if route is too short\n        return new_solution\n\n    # Split the longest route into two segments\n    split_idx = np.random.randint(1, len(longest_route) - 1)\n    segment1 = longest_route[:split_idx + 1]\n    segment2 = longest_route[split_idx:]\n\n    # Check capacity feasibility for both segments\n    seg1_demand = np.sum(demand[segment1[1:-1]])\n    seg2_demand = np.sum(demand[segment2[1:-1]])\n\n    if seg1_demand <= capacity and seg2_demand <= capacity:\n        new_solution[longest_route_idx] = segment1\n        new_solution.append(segment2)\n    else:\n        # If split is infeasible, redistribute customers to other routes\n        customers = longest_route[1:-1]\n        for customer in customers:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                           distance_matrix[customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original long route if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7361642978703139,
            0.0802602469921112
        ]
    },
    {
        "algorithm": "{This new algorithm implements a hybrid approach combining route merging with demand-aware spatial clustering and adaptive route splitting, which intelligently balances the trade-off between minimizing total distance and makespan by considering both spatial distribution and demand patterns while ensuring feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Cluster routes based on spatial proximity and demand similarity\n    route_clusters = []\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) > 0:\n            route_coords = coords[customers]\n            centroid = np.mean(route_coords, axis=0)\n            total_demand = np.sum(demand[customers])\n            route_clusters.append((centroid, total_demand, route))\n\n    # Find the most imbalanced cluster (either too large or too small)\n    if route_clusters:\n        avg_demand = sum(d[1] for d in route_clusters) / len(route_clusters)\n        imbalanced_route = max(route_clusters, key=lambda x: abs(x[1] - avg_demand))\n        imbalanced_idx = [i for i, r in enumerate(new_solution) if np.array_equal(r, imbalanced_route[2])][0]\n\n        # Try to rebalance by merging with a nearby route\n        best_merge = None\n        min_distance_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == imbalanced_idx:\n                continue\n\n            # Calculate spatial proximity\n            route_centroid = np.mean(coords[route[1:-1]], axis=0)\n            distance = np.linalg.norm(imbalanced_route[0] - route_centroid)\n\n            # Calculate potential merged demand\n            merged_demand = imbalanced_route[1] + np.sum(demand[route[1:-1]])\n\n            if merged_demand <= capacity:\n                # Calculate distance increase if merged\n                distance_increase = (distance_matrix[imbalanced_route[2][-2], route[1]] +\n                                    distance_matrix[route[-2], imbalanced_route[2][1]] -\n                                    distance_matrix[imbalanced_route[2][-2], imbalanced_route[2][1]] -\n                                    distance_matrix[route[-2], route[1]])\n\n                if distance_increase < min_distance_increase:\n                    min_distance_increase = distance_increase\n                    best_merge = i\n\n        if best_merge is not None:\n            # Perform the merge\n            merged_route = np.concatenate([new_solution[imbalanced_idx][:-1], new_solution[best_merge][1:]])\n            new_solution[imbalanced_idx] = merged_route\n            new_solution.pop(best_merge)\n        else:\n            # If no merge possible, try adaptive splitting\n            route_to_split = new_solution[imbalanced_idx]\n            if len(route_to_split) > 4:  # Ensure we can split meaningfully\n                # Find the customer with median demand in the route\n                customers = route_to_split[1:-1]\n                sorted_customers = sorted(customers, key=lambda x: demand[x])\n                median_customer = sorted_customers[len(sorted_customers)//2]\n\n                split_pos = np.where(route_to_split == median_customer)[0][0]\n                first_part = route_to_split[:split_pos+1]\n                second_part = route_to_split[split_pos:]\n\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[imbalanced_idx] = first_part\n                    new_solution.insert(imbalanced_idx + 1, second_part)\n\n    return new_solution\n\n",
        "score": [
            -0.8923017731161753,
            0.7799195647239685
        ]
    },
    {
        "algorithm": "{This new algorithm combines route fragmentation with demand-aware customer redistribution to create balanced routes by strategically splitting long routes and redistributing customers to shorter routes while respecting capacity constraints, aiming to reduce makespan without significantly increasing total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the longest route to fragment\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:  # Skip if route is too short\n        return new_solution\n\n    # Split the longest route into two segments\n    split_idx = np.random.randint(1, len(longest_route) - 1)\n    segment1 = longest_route[:split_idx + 1]\n    segment2 = longest_route[split_idx:]\n\n    # Check capacity feasibility for both segments\n    seg1_demand = np.sum(demand[segment1[1:-1]])\n    seg2_demand = np.sum(demand[segment2[1:-1]])\n\n    if seg1_demand <= capacity and seg2_demand <= capacity:\n        new_solution[longest_route_idx] = segment1\n        new_solution.append(segment2)\n    else:\n        # If split is infeasible, redistribute customers to other routes\n        customers = longest_route[1:-1]\n        for customer in customers:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                           distance_matrix[customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original long route if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8538019298383264,
            0.0867181122303009
        ]
    },
    {
        "algorithm": "{This new algorithm combines spatial clustering with demand-aware route splitting to create balanced routes by first grouping customers based on their spatial proximity and then intelligently splitting these clusters into feasible routes while considering both demand and distance constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Collect all unassigned customers\n    assigned_customers = set()\n    for route in new_solution:\n        assigned_customers.update(route[1:-1])\n    all_customers = set(range(1, len(demand)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    if not unassigned_customers:\n        # If no unassigned customers, try to improve existing routes\n        if len(new_solution) > 1:\n            # Select a random route to split\n            route_idx = np.random.randint(0, len(new_solution))\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find the best split point\n                best_split = 1\n                best_score = float('inf')\n\n                for split in range(2, len(route)-1):\n                    # Check if the split creates feasible routes\n                    first_part = route[:split+1]\n                    second_part = route[split:]\n\n                    if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                        np.sum(demand[second_part[1:-1]]) <= capacity):\n                        # Calculate the score based on distance reduction\n                        original_dist = (distance_matrix[route[split-1]][route[split]] +\n                                       distance_matrix[route[split]][route[split+1]])\n                        new_dist = (distance_matrix[route[split-1]][0] +\n                                   distance_matrix[0][route[split]] +\n                                   distance_matrix[route[split]][0] +\n                                   distance_matrix[0][route[split+1]])\n\n                        score = new_dist - original_dist\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = split\n\n                if best_split > 1:\n                    # Perform the split\n                    first_part = route[:best_split+1]\n                    second_part = route[best_split:]\n                    new_solution[route_idx] = first_part\n                    new_solution.insert(route_idx + 1, second_part)\n    else:\n        # Create new routes for unassigned customers\n        remaining_customers = unassigned_customers.copy()\n\n        while remaining_customers:\n            # Select a customer to start a new route\n            current_customer = remaining_customers.pop(0)\n            current_demand = demand[current_customer]\n            current_route = [0, current_customer, 0]\n\n            # Try to add compatible customers\n            for _ in range(len(remaining_customers)):\n                if np.sum(demand[current_route[1:-1]]) + demand[remaining_customers[0]] <= capacity:\n                    # Find the best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n\n                    for pos in range(1, len(current_route)):\n                        temp_route = np.insert(current_route, pos, remaining_customers[0])\n                        cost = (distance_matrix[temp_route[pos-1]][remaining_customers[0]] +\n                               distance_matrix[remaining_customers[0]][temp_route[pos+1]] -\n                               distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    current_route = np.insert(current_route, best_pos, remaining_customers[0])\n                    remaining_customers.pop(0)\n                else:\n                    break\n\n            new_solution.append(np.array(current_route))\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8749576738664353,
            0.17882221937179565
        ]
    },
    {
        "algorithm": "{This new algorithm implements a hybrid approach combining route merging with demand-aware spatial clustering and adaptive route splitting, which intelligently balances the trade-off between minimizing total distance and makespan by considering both spatial distribution and demand patterns while ensuring feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Cluster routes based on spatial proximity and demand similarity\n    route_clusters = []\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) > 0:\n            route_coords = coords[customers]\n            centroid = np.mean(route_coords, axis=0)\n            total_demand = np.sum(demand[customers])\n            route_clusters.append((centroid, total_demand, route))\n\n    # Find the most imbalanced cluster (either too large or too small)\n    if route_clusters:\n        avg_demand = sum(d[1] for d in route_clusters) / len(route_clusters)\n        imbalanced_route = max(route_clusters, key=lambda x: abs(x[1] - avg_demand))\n        imbalanced_idx = [i for i, r in enumerate(new_solution) if np.array_equal(r, imbalanced_route[2])][0]\n\n        # Try to rebalance by merging with a nearby route\n        best_merge = None\n        min_distance_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == imbalanced_idx:\n                continue\n\n            # Calculate spatial proximity\n            route_centroid = np.mean(coords[route[1:-1]], axis=0)\n            distance = np.linalg.norm(imbalanced_route[0] - route_centroid)\n\n            # Calculate potential merged demand\n            merged_demand = imbalanced_route[1] + np.sum(demand[route[1:-1]])\n\n            if merged_demand <= capacity:\n                # Calculate distance increase if merged\n                distance_increase = (distance_matrix[imbalanced_route[2][-2], route[1]] +\n                                    distance_matrix[route[-2], imbalanced_route[2][1]] -\n                                    distance_matrix[imbalanced_route[2][-2], imbalanced_route[2][1]] -\n                                    distance_matrix[route[-2], route[1]])\n\n                if distance_increase < min_distance_increase:\n                    min_distance_increase = distance_increase\n                    best_merge = i\n\n        if best_merge is not None:\n            # Perform the merge\n            merged_route = np.concatenate([new_solution[imbalanced_idx][:-1], new_solution[best_merge][1:]])\n            new_solution[imbalanced_idx] = merged_route\n            new_solution.pop(best_merge)\n        else:\n            # If no merge possible, try adaptive splitting\n            route_to_split = new_solution[imbalanced_idx]\n            if len(route_to_split) > 4:  # Ensure we can split meaningfully\n                # Find the customer with median demand in the route\n                customers = route_to_split[1:-1]\n                sorted_customers = sorted(customers, key=lambda x: demand[x])\n                median_customer = sorted_customers[len(sorted_customers)//2]\n\n                split_pos = np.where(route_to_split == median_customer)[0][0]\n                first_part = route_to_split[:split_pos+1]\n                second_part = route_to_split[split_pos:]\n\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[imbalanced_idx] = first_part\n                    new_solution.insert(imbalanced_idx + 1, second_part)\n\n    return new_solution\n\n",
        "score": [
            -0.8923017731161753,
            0.7799195647239685
        ]
    },
    {
        "algorithm": "{This new algorithm combines spatial clustering with demand-aware route splitting to create balanced routes by first grouping customers based on their spatial proximity and then intelligently splitting these clusters into feasible routes while considering both demand and distance constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Collect all unassigned customers\n    assigned_customers = set()\n    for route in new_solution:\n        assigned_customers.update(route[1:-1])\n    all_customers = set(range(1, len(demand)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    if not unassigned_customers:\n        # If no unassigned customers, try to improve existing routes\n        if len(new_solution) > 1:\n            # Select a random route to split\n            route_idx = np.random.randint(0, len(new_solution))\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find the best split point\n                best_split = 1\n                best_score = float('inf')\n\n                for split in range(2, len(route)-1):\n                    # Check if the split creates feasible routes\n                    first_part = route[:split+1]\n                    second_part = route[split:]\n\n                    if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                        np.sum(demand[second_part[1:-1]]) <= capacity):\n                        # Calculate the score based on distance reduction\n                        original_dist = (distance_matrix[route[split-1]][route[split]] +\n                                       distance_matrix[route[split]][route[split+1]])\n                        new_dist = (distance_matrix[route[split-1]][0] +\n                                   distance_matrix[0][route[split]] +\n                                   distance_matrix[route[split]][0] +\n                                   distance_matrix[0][route[split+1]])\n\n                        score = new_dist - original_dist\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = split\n\n                if best_split > 1:\n                    # Perform the split\n                    first_part = route[:best_split+1]\n                    second_part = route[best_split:]\n                    new_solution[route_idx] = first_part\n                    new_solution.insert(route_idx + 1, second_part)\n    else:\n        # Create new routes for unassigned customers\n        remaining_customers = unassigned_customers.copy()\n\n        while remaining_customers:\n            # Select a customer to start a new route\n            current_customer = remaining_customers.pop(0)\n            current_demand = demand[current_customer]\n            current_route = [0, current_customer, 0]\n\n            # Try to add compatible customers\n            for _ in range(len(remaining_customers)):\n                if np.sum(demand[current_route[1:-1]]) + demand[remaining_customers[0]] <= capacity:\n                    # Find the best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n\n                    for pos in range(1, len(current_route)):\n                        temp_route = np.insert(current_route, pos, remaining_customers[0])\n                        cost = (distance_matrix[temp_route[pos-1]][remaining_customers[0]] +\n                               distance_matrix[remaining_customers[0]][temp_route[pos+1]] -\n                               distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    current_route = np.insert(current_route, best_pos, remaining_customers[0])\n                    remaining_customers.pop(0)\n                else:\n                    break\n\n            new_solution.append(np.array(current_route))\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8749576738664353,
            0.17882221937179565
        ]
    },
    {
        "algorithm": "{This new algorithm combines route fragmentation with demand-aware customer redistribution to create balanced routes by strategically splitting long routes and redistributing customers to shorter routes while respecting capacity constraints, aiming to reduce makespan without significantly increasing total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the longest route to fragment\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:  # Skip if route is too short\n        return new_solution\n\n    # Split the longest route into two segments\n    split_idx = np.random.randint(1, len(longest_route) - 1)\n    segment1 = longest_route[:split_idx + 1]\n    segment2 = longest_route[split_idx:]\n\n    # Check capacity feasibility for both segments\n    seg1_demand = np.sum(demand[segment1[1:-1]])\n    seg2_demand = np.sum(demand[segment2[1:-1]])\n\n    if seg1_demand <= capacity and seg2_demand <= capacity:\n        new_solution[longest_route_idx] = segment1\n        new_solution.append(segment2)\n    else:\n        # If split is infeasible, redistribute customers to other routes\n        customers = longest_route[1:-1]\n        for customer in customers:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                           distance_matrix[customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original long route if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[longest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8538019298383264,
            0.0867181122303009
        ]
    },
    {
        "algorithm": "{This new algorithm implements a hybrid approach combining route merging with demand-aware spatial clustering and adaptive route splitting, which intelligently balances the trade-off between minimizing total distance and makespan by considering both spatial distribution and demand patterns while ensuring feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Cluster routes based on spatial proximity and demand similarity\n    route_clusters = []\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) > 0:\n            route_coords = coords[customers]\n            centroid = np.mean(route_coords, axis=0)\n            total_demand = np.sum(demand[customers])\n            route_clusters.append((centroid, total_demand, route))\n\n    # Find the most imbalanced cluster (either too large or too small)\n    if route_clusters:\n        avg_demand = sum(d[1] for d in route_clusters) / len(route_clusters)\n        imbalanced_route = max(route_clusters, key=lambda x: abs(x[1] - avg_demand))\n        imbalanced_idx = [i for i, r in enumerate(new_solution) if np.array_equal(r, imbalanced_route[2])][0]\n\n        # Try to rebalance by merging with a nearby route\n        best_merge = None\n        min_distance_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == imbalanced_idx:\n                continue\n\n            # Calculate spatial proximity\n            route_centroid = np.mean(coords[route[1:-1]], axis=0)\n            distance = np.linalg.norm(imbalanced_route[0] - route_centroid)\n\n            # Calculate potential merged demand\n            merged_demand = imbalanced_route[1] + np.sum(demand[route[1:-1]])\n\n            if merged_demand <= capacity:\n                # Calculate distance increase if merged\n                distance_increase = (distance_matrix[imbalanced_route[2][-2], route[1]] +\n                                    distance_matrix[route[-2], imbalanced_route[2][1]] -\n                                    distance_matrix[imbalanced_route[2][-2], imbalanced_route[2][1]] -\n                                    distance_matrix[route[-2], route[1]])\n\n                if distance_increase < min_distance_increase:\n                    min_distance_increase = distance_increase\n                    best_merge = i\n\n        if best_merge is not None:\n            # Perform the merge\n            merged_route = np.concatenate([new_solution[imbalanced_idx][:-1], new_solution[best_merge][1:]])\n            new_solution[imbalanced_idx] = merged_route\n            new_solution.pop(best_merge)\n        else:\n            # If no merge possible, try adaptive splitting\n            route_to_split = new_solution[imbalanced_idx]\n            if len(route_to_split) > 4:  # Ensure we can split meaningfully\n                # Find the customer with median demand in the route\n                customers = route_to_split[1:-1]\n                sorted_customers = sorted(customers, key=lambda x: demand[x])\n                median_customer = sorted_customers[len(sorted_customers)//2]\n\n                split_pos = np.where(route_to_split == median_customer)[0][0]\n                first_part = route_to_split[:split_pos+1]\n                second_part = route_to_split[split_pos:]\n\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[imbalanced_idx] = first_part\n                    new_solution.insert(imbalanced_idx + 1, second_part)\n\n    return new_solution\n\n",
        "score": [
            -0.8923017731161753,
            0.7799195647239685
        ]
    },
    {
        "algorithm": "{This new algorithm implements a hybrid approach combining route merging with demand-aware spatial clustering and adaptive route splitting, which intelligently balances the trade-off between minimizing total distance and makespan by considering both spatial distribution and demand patterns while ensuring feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Cluster routes based on spatial proximity and demand similarity\n    route_clusters = []\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) > 0:\n            route_coords = coords[customers]\n            centroid = np.mean(route_coords, axis=0)\n            total_demand = np.sum(demand[customers])\n            route_clusters.append((centroid, total_demand, route))\n\n    # Find the most imbalanced cluster (either too large or too small)\n    if route_clusters:\n        avg_demand = sum(d[1] for d in route_clusters) / len(route_clusters)\n        imbalanced_route = max(route_clusters, key=lambda x: abs(x[1] - avg_demand))\n        imbalanced_idx = [i for i, r in enumerate(new_solution) if np.array_equal(r, imbalanced_route[2])][0]\n\n        # Try to rebalance by merging with a nearby route\n        best_merge = None\n        min_distance_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == imbalanced_idx:\n                continue\n\n            # Calculate spatial proximity\n            route_centroid = np.mean(coords[route[1:-1]], axis=0)\n            distance = np.linalg.norm(imbalanced_route[0] - route_centroid)\n\n            # Calculate potential merged demand\n            merged_demand = imbalanced_route[1] + np.sum(demand[route[1:-1]])\n\n            if merged_demand <= capacity:\n                # Calculate distance increase if merged\n                distance_increase = (distance_matrix[imbalanced_route[2][-2], route[1]] +\n                                    distance_matrix[route[-2], imbalanced_route[2][1]] -\n                                    distance_matrix[imbalanced_route[2][-2], imbalanced_route[2][1]] -\n                                    distance_matrix[route[-2], route[1]])\n\n                if distance_increase < min_distance_increase:\n                    min_distance_increase = distance_increase\n                    best_merge = i\n\n        if best_merge is not None:\n            # Perform the merge\n            merged_route = np.concatenate([new_solution[imbalanced_idx][:-1], new_solution[best_merge][1:]])\n            new_solution[imbalanced_idx] = merged_route\n            new_solution.pop(best_merge)\n        else:\n            # If no merge possible, try adaptive splitting\n            route_to_split = new_solution[imbalanced_idx]\n            if len(route_to_split) > 4:  # Ensure we can split meaningfully\n                # Find the customer with median demand in the route\n                customers = route_to_split[1:-1]\n                sorted_customers = sorted(customers, key=lambda x: demand[x])\n                median_customer = sorted_customers[len(sorted_customers)//2]\n\n                split_pos = np.where(route_to_split == median_customer)[0][0]\n                first_part = route_to_split[:split_pos+1]\n                second_part = route_to_split[split_pos:]\n\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[imbalanced_idx] = first_part\n                    new_solution.insert(imbalanced_idx + 1, second_part)\n\n    return new_solution\n\n",
        "score": [
            -0.8923017731161753,
            0.7799195647239685
        ]
    },
    {
        "algorithm": "{This new algorithm implements a hybrid approach combining route merging with demand-aware spatial clustering and adaptive route splitting, which intelligently balances the trade-off between minimizing total distance and makespan by considering both spatial distribution and demand patterns while ensuring feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Cluster routes based on spatial proximity and demand similarity\n    route_clusters = []\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) > 0:\n            route_coords = coords[customers]\n            centroid = np.mean(route_coords, axis=0)\n            total_demand = np.sum(demand[customers])\n            route_clusters.append((centroid, total_demand, route))\n\n    # Find the most imbalanced cluster (either too large or too small)\n    if route_clusters:\n        avg_demand = sum(d[1] for d in route_clusters) / len(route_clusters)\n        imbalanced_route = max(route_clusters, key=lambda x: abs(x[1] - avg_demand))\n        imbalanced_idx = [i for i, r in enumerate(new_solution) if np.array_equal(r, imbalanced_route[2])][0]\n\n        # Try to rebalance by merging with a nearby route\n        best_merge = None\n        min_distance_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == imbalanced_idx:\n                continue\n\n            # Calculate spatial proximity\n            route_centroid = np.mean(coords[route[1:-1]], axis=0)\n            distance = np.linalg.norm(imbalanced_route[0] - route_centroid)\n\n            # Calculate potential merged demand\n            merged_demand = imbalanced_route[1] + np.sum(demand[route[1:-1]])\n\n            if merged_demand <= capacity:\n                # Calculate distance increase if merged\n                distance_increase = (distance_matrix[imbalanced_route[2][-2], route[1]] +\n                                    distance_matrix[route[-2], imbalanced_route[2][1]] -\n                                    distance_matrix[imbalanced_route[2][-2], imbalanced_route[2][1]] -\n                                    distance_matrix[route[-2], route[1]])\n\n                if distance_increase < min_distance_increase:\n                    min_distance_increase = distance_increase\n                    best_merge = i\n\n        if best_merge is not None:\n            # Perform the merge\n            merged_route = np.concatenate([new_solution[imbalanced_idx][:-1], new_solution[best_merge][1:]])\n            new_solution[imbalanced_idx] = merged_route\n            new_solution.pop(best_merge)\n        else:\n            # If no merge possible, try adaptive splitting\n            route_to_split = new_solution[imbalanced_idx]\n            if len(route_to_split) > 4:  # Ensure we can split meaningfully\n                # Find the customer with median demand in the route\n                customers = route_to_split[1:-1]\n                sorted_customers = sorted(customers, key=lambda x: demand[x])\n                median_customer = sorted_customers[len(sorted_customers)//2]\n\n                split_pos = np.where(route_to_split == median_customer)[0][0]\n                first_part = route_to_split[:split_pos+1]\n                second_part = route_to_split[split_pos:]\n\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[imbalanced_idx] = first_part\n                    new_solution.insert(imbalanced_idx + 1, second_part)\n\n    return new_solution\n\n",
        "score": [
            -0.8923017731161753,
            0.7799195647239685
        ]
    },
    {
        "algorithm": "{This new algorithm implements a hybrid approach combining route merging with demand-aware spatial clustering and adaptive route splitting, which intelligently balances the trade-off between minimizing total distance and makespan by considering both spatial distribution and demand patterns while ensuring feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Cluster routes based on spatial proximity and demand similarity\n    route_clusters = []\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) > 0:\n            route_coords = coords[customers]\n            centroid = np.mean(route_coords, axis=0)\n            total_demand = np.sum(demand[customers])\n            route_clusters.append((centroid, total_demand, route))\n\n    # Find the most imbalanced cluster (either too large or too small)\n    if route_clusters:\n        avg_demand = sum(d[1] for d in route_clusters) / len(route_clusters)\n        imbalanced_route = max(route_clusters, key=lambda x: abs(x[1] - avg_demand))\n        imbalanced_idx = [i for i, r in enumerate(new_solution) if np.array_equal(r, imbalanced_route[2])][0]\n\n        # Try to rebalance by merging with a nearby route\n        best_merge = None\n        min_distance_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == imbalanced_idx:\n                continue\n\n            # Calculate spatial proximity\n            route_centroid = np.mean(coords[route[1:-1]], axis=0)\n            distance = np.linalg.norm(imbalanced_route[0] - route_centroid)\n\n            # Calculate potential merged demand\n            merged_demand = imbalanced_route[1] + np.sum(demand[route[1:-1]])\n\n            if merged_demand <= capacity:\n                # Calculate distance increase if merged\n                distance_increase = (distance_matrix[imbalanced_route[2][-2], route[1]] +\n                                    distance_matrix[route[-2], imbalanced_route[2][1]] -\n                                    distance_matrix[imbalanced_route[2][-2], imbalanced_route[2][1]] -\n                                    distance_matrix[route[-2], route[1]])\n\n                if distance_increase < min_distance_increase:\n                    min_distance_increase = distance_increase\n                    best_merge = i\n\n        if best_merge is not None:\n            # Perform the merge\n            merged_route = np.concatenate([new_solution[imbalanced_idx][:-1], new_solution[best_merge][1:]])\n            new_solution[imbalanced_idx] = merged_route\n            new_solution.pop(best_merge)\n        else:\n            # If no merge possible, try adaptive splitting\n            route_to_split = new_solution[imbalanced_idx]\n            if len(route_to_split) > 4:  # Ensure we can split meaningfully\n                # Find the customer with median demand in the route\n                customers = route_to_split[1:-1]\n                sorted_customers = sorted(customers, key=lambda x: demand[x])\n                median_customer = sorted_customers[len(sorted_customers)//2]\n\n                split_pos = np.where(route_to_split == median_customer)[0][0]\n                first_part = route_to_split[:split_pos+1]\n                second_part = route_to_split[split_pos:]\n\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[imbalanced_idx] = first_part\n                    new_solution.insert(imbalanced_idx + 1, second_part)\n\n    return new_solution\n\n",
        "score": [
            -0.8923017731161753,
            0.7799195647239685
        ]
    },
    {
        "algorithm": "{This new algorithm implements a hybrid approach combining route merging with demand-aware spatial clustering and adaptive route splitting, which intelligently balances the trade-off between minimizing total distance and makespan by considering both spatial distribution and demand patterns while ensuring feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Cluster routes based on spatial proximity and demand similarity\n    route_clusters = []\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) > 0:\n            route_coords = coords[customers]\n            centroid = np.mean(route_coords, axis=0)\n            total_demand = np.sum(demand[customers])\n            route_clusters.append((centroid, total_demand, route))\n\n    # Find the most imbalanced cluster (either too large or too small)\n    if route_clusters:\n        avg_demand = sum(d[1] for d in route_clusters) / len(route_clusters)\n        imbalanced_route = max(route_clusters, key=lambda x: abs(x[1] - avg_demand))\n        imbalanced_idx = [i for i, r in enumerate(new_solution) if np.array_equal(r, imbalanced_route[2])][0]\n\n        # Try to rebalance by merging with a nearby route\n        best_merge = None\n        min_distance_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == imbalanced_idx:\n                continue\n\n            # Calculate spatial proximity\n            route_centroid = np.mean(coords[route[1:-1]], axis=0)\n            distance = np.linalg.norm(imbalanced_route[0] - route_centroid)\n\n            # Calculate potential merged demand\n            merged_demand = imbalanced_route[1] + np.sum(demand[route[1:-1]])\n\n            if merged_demand <= capacity:\n                # Calculate distance increase if merged\n                distance_increase = (distance_matrix[imbalanced_route[2][-2], route[1]] +\n                                    distance_matrix[route[-2], imbalanced_route[2][1]] -\n                                    distance_matrix[imbalanced_route[2][-2], imbalanced_route[2][1]] -\n                                    distance_matrix[route[-2], route[1]])\n\n                if distance_increase < min_distance_increase:\n                    min_distance_increase = distance_increase\n                    best_merge = i\n\n        if best_merge is not None:\n            # Perform the merge\n            merged_route = np.concatenate([new_solution[imbalanced_idx][:-1], new_solution[best_merge][1:]])\n            new_solution[imbalanced_idx] = merged_route\n            new_solution.pop(best_merge)\n        else:\n            # If no merge possible, try adaptive splitting\n            route_to_split = new_solution[imbalanced_idx]\n            if len(route_to_split) > 4:  # Ensure we can split meaningfully\n                # Find the customer with median demand in the route\n                customers = route_to_split[1:-1]\n                sorted_customers = sorted(customers, key=lambda x: demand[x])\n                median_customer = sorted_customers[len(sorted_customers)//2]\n\n                split_pos = np.where(route_to_split == median_customer)[0][0]\n                first_part = route_to_split[:split_pos+1]\n                second_part = route_to_split[split_pos:]\n\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[imbalanced_idx] = first_part\n                    new_solution.insert(imbalanced_idx + 1, second_part)\n\n    return new_solution\n\n",
        "score": [
            -0.8923017731161753,
            0.7799195647239685
        ]
    }
]