[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i, route in enumerate(new_solution):\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check if splitting is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n        else:\n            # If splitting is not feasible, try reallocating a customer to another route\n            for j in range(1, len(route) - 1):\n                customer = route[j]\n                # Find the best route to insert this customer\n                best_route = -1\n                best_pos = -1\n                best_cost = float('inf')\n\n                for k, other_route in enumerate(new_solution):\n                    if k == i:\n                        continue\n                    # Try inserting the customer at all possible positions\n                    for pos in range(1, len(other_route)):\n                        temp_route = np.insert(other_route, pos, customer)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            # Calculate the additional cost\n                            cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                                   distance_matrix[customer][temp_route[pos+1]] - \\\n                                   distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = k\n                                best_pos = pos\n\n                if best_route != -1:\n                    # Perform the reallocation\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                    new_solution[i] = np.delete(new_solution[i], j)\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7903060370334931,
            0.268205463886261
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            # If splitting is infeasible, try reinserting customers from the longer part\n            longer_part = part1 if len(part1) > len(part2) else part2\n            shorter_part = part2 if len(part1) > len(part2) else part1\n\n            # Randomly select a customer to reinsert\n            if len(longer_part) > 2:\n                customer_idx = np.random.randint(1, len(longer_part) - 1)\n                customer = longer_part[customer_idx]\n                # Try inserting the customer into the shorter part at the best feasible position\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(shorter_part)):\n                    temp_route = np.insert(shorter_part, i, customer)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[temp_route[i-1], customer] + distance_matrix[customer, temp_route[i+1]] - distance_matrix[temp_route[i-1], temp_route[i+1]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n                if best_cost < float('inf'):\n                    shorter_part = np.insert(shorter_part, best_pos, customer)\n                    longer_part = np.delete(longer_part, customer_idx)\n                    if len(longer_part) > 2:\n                        new_solution.append(longer_part)\n                    if len(shorter_part) > 2:\n                        new_solution.append(shorter_part)\n                else:\n                    new_solution.append(route)\n            else:\n                new_solution.append(route)\n\n    return new_solution\n\n",
        "score": [
            -0.7148990727857493,
            0.11328020691871643
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n\n    # Apply a hybrid local search: combine route splitting and customer reinsertion\n    new_solution = []\n    for route in selected_solution:\n        if len(route) <= 3:  # Skip very short routes\n            new_solution.append(route)\n            continue\n\n        # Split the route into two parts at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_idx + 1]\n        part2 = route[split_idx:]\n\n        # Check capacity feasibility for both parts\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution.append(part1)\n            new_solution.append(part2)\n        else:\n            # If splitting is infeasible, try reinserting customers from the longer part\n            longer_part = part1 if len(part1) > len(part2) else part2\n            shorter_part = part2 if len(part1) > len(part2) else part1\n\n            # Randomly select a customer to reinsert\n            if len(longer_part) > 2:\n                customer_idx = np.random.randint(1, len(longer_part) - 1)\n                customer = longer_part[customer_idx]\n                # Try inserting the customer into the shorter part at the best feasible position\n                best_pos = 1\n                best_cost = float('inf')\n                for i in range(1, len(shorter_part)):\n                    temp_route = np.insert(shorter_part, i, customer)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[temp_route[i-1], customer] + distance_matrix[customer, temp_route[i+1]] - distance_matrix[temp_route[i-1], temp_route[i+1]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = i\n                if best_cost < float('inf'):\n                    shorter_part = np.insert(shorter_part, best_pos, customer)\n                    longer_part = np.delete(longer_part, customer_idx)\n                    if len(longer_part) > 2:\n                        new_solution.append(longer_part)\n                    if len(shorter_part) > 2:\n                        new_solution.append(shorter_part)\n                else:\n                    new_solution.append(route)\n            else:\n                new_solution.append(route)\n\n    return new_solution\n\n",
        "score": [
            -0.7148990727857493,
            0.11328020691871643
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i, route in enumerate(new_solution):\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check if splitting is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n        else:\n            # If splitting is not feasible, try reallocating a customer to another route\n            for j in range(1, len(route) - 1):\n                customer = route[j]\n                # Find the best route to insert this customer\n                best_route = -1\n                best_pos = -1\n                best_cost = float('inf')\n\n                for k, other_route in enumerate(new_solution):\n                    if k == i:\n                        continue\n                    # Try inserting the customer at all possible positions\n                    for pos in range(1, len(other_route)):\n                        temp_route = np.insert(other_route, pos, customer)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            # Calculate the additional cost\n                            cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                                   distance_matrix[customer][temp_route[pos+1]] - \\\n                                   distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = k\n                                best_pos = pos\n\n                if best_route != -1:\n                    # Perform the reallocation\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                    new_solution[i] = np.delete(new_solution[i], j)\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7903060370334931,
            0.268205463886261
        ]
    }
]