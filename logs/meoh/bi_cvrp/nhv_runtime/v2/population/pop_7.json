[
    {
        "algorithm": "{The new algorithm implements a hybrid approach combining route splitting with spatial clustering and demand-aware customer reallocation to balance distance and makespan objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Select a route to potentially split or modify\n    route_idx = np.random.randint(0, len(new_solution))\n    selected_route = new_solution[route_idx]\n\n    # Calculate spatial and demand metrics for the selected route\n    customers = selected_route[1:-1]\n    if len(customers) <= 2:\n        return new_solution\n\n    # Find the customer with maximum demand in the route\n    heaviest_customer = max(customers, key=lambda x: demand[x])\n\n    # Calculate spatial centroid of the route\n    route_coords = coords[customers]\n    centroid = np.mean(route_coords, axis=0)\n\n    # Find the customer farthest from centroid (potential split point)\n    farthest_customer = max(customers, key=lambda x: np.linalg.norm(coords[x] - centroid))\n\n    # Try to split the route at the farthest customer\n    split_pos = np.where(selected_route == farthest_customer)[0][0]\n    first_part = selected_route[:split_pos+1]\n    second_part = selected_route[split_pos:]\n\n    # Check if both parts are feasible\n    if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n        new_solution[route_idx] = first_part\n        new_solution.insert(route_idx + 1, second_part)\n    else:\n        # If split is not feasible, try reallocating the heaviest customer\n        best_route = -1\n        best_pos = -1\n        best_score = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == route_idx:\n                continue\n            for pos in range(1, len(route)):\n                temp_route = np.insert(route, pos, heaviest_customer)\n                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                    # Score based on distance increase and makespan balance\n                    dist_increase = (distance_matrix[temp_route[pos-1]][heaviest_customer] +\n                                    distance_matrix[heaviest_customer][temp_route[pos+1]] -\n                                    distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                    makespan_diff = abs(len(temp_route) - len(selected_route)) * 0.5\n                    score = dist_increase + makespan_diff\n                    if score < best_score:\n                        best_score = score\n                        best_route = i\n                        best_pos = pos\n\n        if best_route != -1:\n            # Perform the reallocation\n            new_solution[best_route] = np.insert(new_solution[best_route], best_pos, heaviest_customer)\n            new_solution[route_idx] = np.delete(new_solution[route_idx], np.where(new_solution[route_idx] == heaviest_customer)[0][0])\n\n    return new_solution\n\n",
        "score": [
            -0.7906421695167611,
            0.09088990092277527
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive route merging with demand-aware customer reinsertion, prioritizing solutions with high makespan reduction potential while maintaining capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] / x[1][0], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route merging and customer reinsertion\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            # Try merging routes i and j\n            merged_route = np.concatenate([new_solution[i][:-1], new_solution[j][1:]])\n            if np.sum(demand[merged_route[1:-1]]) <= capacity:\n                # If merging is feasible, perform it\n                new_solution[i] = merged_route\n                new_solution[j] = np.array([0, 0])  # Mark for removal\n                break\n\n    # Remove merged routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    # Demand-aware customer reinsertion\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n\n        # Identify customers with high demand\n        customers = route[1:-1]\n        high_demand_customers = customers[demand[customers] > capacity * 0.3]\n\n        for customer in high_demand_customers:\n            # Find the best position to reinsert this customer\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for k, other_route in enumerate(new_solution):\n                if other_route is route:\n                    continue\n\n                for pos in range(1, len(other_route)):\n                    temp_route = np.insert(other_route, pos, customer)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                               distance_matrix[customer][temp_route[pos+1]] - \\\n                               distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_route = k\n                            best_pos = pos\n\n            if best_route != -1:\n                # Perform the reinsertion\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                route[route == customer] = 0  # Mark for removal\n\n    # Remove empty spots and re-clean\n    new_solution = [route[route != 0] for route in new_solution if len(route[route != 0]) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8740276167320389,
            0.3970206677913666
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the highest potential for improvement by identifying routes with the largest makespan, then applies a hybrid local search operator that combines route segmentation and insertion heuristics to balance distance and makespan reduction, while ensuring feasibility through capacity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply hybrid local search: segment and reinsert routes to balance distance and makespan\n    new_solution = []\n    for route in base_solution:\n        if len(route) <= 3:  # Skip trivial routes (depot-depot or single customer)\n            new_solution.append(route.copy())\n            continue\n\n        # Split route into two segments at a random point\n        split_idx = np.random.randint(1, len(route) - 1)\n        segment1 = route[:split_idx + 1]\n        segment2 = route[split_idx:]\n\n        # Check capacity feasibility for both segments\n        seg1_demand = np.sum(demand[segment1[1:-1]])\n        seg2_demand = np.sum(demand[segment2[1:-1]])\n\n        if seg1_demand <= capacity and seg2_demand <= capacity:\n            new_solution.append(segment1.copy())\n            new_solution.append(segment2.copy())\n        else:\n            # If split is infeasible, try inserting a random customer from another route\n            other_route = np.random.choice([r for r in base_solution if len(r) > 3 and r is not route])\n            if len(other_route) > 3:\n                insert_pos = np.random.randint(1, len(other_route) - 1)\n                customer = other_route[insert_pos]\n                if np.sum(demand[segment1[1:-1]]) + demand[customer] <= capacity:\n                    new_segment = np.insert(segment1, -1, customer)\n                    new_solution.append(new_segment)\n                    # Remove the customer from the other route\n                    new_other_route = np.delete(other_route, insert_pos)\n                    new_solution.append(new_other_route)\n                else:\n                    new_solution.append(route.copy())\n\n    # Ensure all customers are served (fallback if some are missing)\n    all_customers = set(range(1, len(coords)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing = all_customers - served_customers\n    if missing:\n        # Reassign missing customers to routes with available capacity\n        for customer in missing:\n            for i, route in enumerate(new_solution):\n                if np.sum(demand[list(route[1:-1])]) + demand[customer] <= capacity:\n                    new_route = np.insert(route, -1, customer)\n                    new_solution[i] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8634949154541082,
            0.36051949858665466
        ]
    },
    {
        "algorithm": "{This new algorithm implements a hybrid approach combining route merging with demand-aware spatial clustering and adaptive route splitting, which intelligently balances the trade-off between minimizing total distance and makespan by considering both spatial distribution and demand patterns while ensuring feasibility through capacity-constrained operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Cluster routes based on spatial proximity and demand similarity\n    route_clusters = []\n    for route in new_solution:\n        customers = route[1:-1]\n        if len(customers) > 0:\n            route_coords = coords[customers]\n            centroid = np.mean(route_coords, axis=0)\n            total_demand = np.sum(demand[customers])\n            route_clusters.append((centroid, total_demand, route))\n\n    # Find the most imbalanced cluster (either too large or too small)\n    if route_clusters:\n        avg_demand = sum(d[1] for d in route_clusters) / len(route_clusters)\n        imbalanced_route = max(route_clusters, key=lambda x: abs(x[1] - avg_demand))\n        imbalanced_idx = [i for i, r in enumerate(new_solution) if np.array_equal(r, imbalanced_route[2])][0]\n\n        # Try to rebalance by merging with a nearby route\n        best_merge = None\n        min_distance_increase = float('inf')\n\n        for i, route in enumerate(new_solution):\n            if i == imbalanced_idx:\n                continue\n\n            # Calculate spatial proximity\n            route_centroid = np.mean(coords[route[1:-1]], axis=0)\n            distance = np.linalg.norm(imbalanced_route[0] - route_centroid)\n\n            # Calculate potential merged demand\n            merged_demand = imbalanced_route[1] + np.sum(demand[route[1:-1]])\n\n            if merged_demand <= capacity:\n                # Calculate distance increase if merged\n                distance_increase = (distance_matrix[imbalanced_route[2][-2], route[1]] +\n                                    distance_matrix[route[-2], imbalanced_route[2][1]] -\n                                    distance_matrix[imbalanced_route[2][-2], imbalanced_route[2][1]] -\n                                    distance_matrix[route[-2], route[1]])\n\n                if distance_increase < min_distance_increase:\n                    min_distance_increase = distance_increase\n                    best_merge = i\n\n        if best_merge is not None:\n            # Perform the merge\n            merged_route = np.concatenate([new_solution[imbalanced_idx][:-1], new_solution[best_merge][1:]])\n            new_solution[imbalanced_idx] = merged_route\n            new_solution.pop(best_merge)\n        else:\n            # If no merge possible, try adaptive splitting\n            route_to_split = new_solution[imbalanced_idx]\n            if len(route_to_split) > 4:  # Ensure we can split meaningfully\n                # Find the customer with median demand in the route\n                customers = route_to_split[1:-1]\n                sorted_customers = sorted(customers, key=lambda x: demand[x])\n                median_customer = sorted_customers[len(sorted_customers)//2]\n\n                split_pos = np.where(route_to_split == median_customer)[0][0]\n                first_part = route_to_split[:split_pos+1]\n                second_part = route_to_split[split_pos:]\n\n                if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                    np.sum(demand[second_part[1:-1]]) <= capacity):\n                    new_solution[imbalanced_idx] = first_part\n                    new_solution.insert(imbalanced_idx + 1, second_part)\n\n    return new_solution\n\n",
        "score": [
            -0.8923017731161753,
            0.7799195647239685
        ]
    },
    {
        "algorithm": "{This new algorithm combines route merging with demand-based rebalancing to reduce the number of vehicles while maintaining load balance, by strategically combining shorter routes with high-demand customers into longer routes that better utilize vehicle capacity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])  # Sort by combined objectives\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Select the shortest route to consider merging\n    shortest_route_idx = np.argmin([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    shortest_route = new_solution[shortest_route_idx]\n\n    # Calculate total demand of the shortest route\n    route_demand = np.sum(demand[shortest_route[1:-1]])\n\n    # Find a compatible route to merge with\n    for i, route in enumerate(new_solution):\n        if i == shortest_route_idx:\n            continue\n        current_demand = np.sum(demand[route[1:-1]])\n        if current_demand + route_demand <= capacity:\n            # Merge the shortest route into this route\n            merged_route = np.concatenate([route[:-1], shortest_route[1:]])\n            new_solution[i] = merged_route\n            del new_solution[shortest_route_idx]\n            break\n\n    # If no merge was possible, try to rebalance demand\n    if len(new_solution) == len(base_solution):\n        # Find the route with the most excess capacity\n        excess_capacity = [(i, capacity - np.sum(demand[route[1:-1]])) for i, route in enumerate(new_solution)]\n        excess_capacity.sort(key=lambda x: x[1], reverse=True)\n\n        if excess_capacity and excess_capacity[0][1] > 0:\n            target_route_idx = excess_capacity[0][0]\n            target_route = new_solution[target_route_idx]\n\n            # Find the heaviest customer in other routes that can fit\n            for i, route in enumerate(new_solution):\n                if i == target_route_idx:\n                    continue\n                for customer in route[1:-1]:\n                    if demand[customer] <= excess_capacity[0][1]:\n                        # Try to move this customer\n                        new_solution[i] = np.delete(route, np.where(route == customer)[0][0])\n                        # Find best insertion position in target route\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for pos in range(1, len(target_route)):\n                            temp_route = np.insert(target_route, pos, customer)\n                            cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                                   distance_matrix[customer][temp_route[pos+1]] - \\\n                                   distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = pos\n                        new_solution[target_route_idx] = np.insert(target_route, best_pos, customer)\n                        break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8910943346271863,
            1.0947364568710327
        ]
    },
    {
        "algorithm": "{The new algorithm combines spatial clustering with adaptive route splitting to balance load and distance, prioritizing high-demand customers and minimizing the longest route while considering geographic proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])  # Sort by makespan\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Select the longest route to consider splitting\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Find high-demand customers in the longest route\n    high_demand_customers = sorted(longest_route[1:-1], key=lambda x: demand[x], reverse=True)\n\n    if not high_demand_customers:\n        return new_solution\n\n    # Try to create a new route with the highest demand customer\n    highest_demand = high_demand_customers[0]\n    new_route = np.array([0, highest_demand, 0])\n\n    # Remove the customer from the original route\n    new_solution[longest_route_idx] = np.delete(longest_route, np.where(longest_route == highest_demand)[0][0])\n\n    # Try to insert remaining high-demand customers into the new route\n    for customer in high_demand_customers[1:]:\n        current_load = np.sum(demand[new_route[1:-1]])\n        if current_load + demand[customer] <= capacity:\n            # Find the best insertion position\n            best_pos = 1\n            best_cost = float('inf')\n            for pos in range(1, len(new_route)):\n                temp_route = np.insert(new_route, pos, customer)\n                cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                       distance_matrix[customer][temp_route[pos+1]] - \\\n                       distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                if cost < best_cost:\n                    best_cost = cost\n                    best_pos = pos\n            new_route = np.insert(new_route, best_pos, customer)\n\n    # Add the new route to the solution\n    new_solution.append(new_route)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8730305050643937,
            0.7784204483032227
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the highest makespan, then applies a demand-driven route merging strategy combined with spatial rebalancing to reduce the longest route while maintaining feasibility by iteratively merging compatible routes and reallocating customers based on spatial proximity and demand balance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Select the longest route\n    longest_route_idx = np.argmax([len(route) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Calculate route demands and spatial properties\n    route_demands = [np.sum(demand[route[1:-1]]) for route in new_solution]\n    route_centroids = [np.mean(coords[route[1:-1]], axis=0) if len(route) > 2 else coords[0] for route in new_solution]\n\n    # Find compatible routes to merge with the longest route\n    compatible_routes = []\n    for i, route in enumerate(new_solution):\n        if i == longest_route_idx:\n            continue\n        combined_demand = route_demands[i] + route_demands[longest_route_idx]\n        if combined_demand <= capacity:\n            compatible_routes.append(i)\n\n    if not compatible_routes:\n        return new_solution\n\n    # Select the most demand-balanced compatible route\n    target_route_idx = min(compatible_routes, key=lambda i: abs(route_demands[i] - route_demands[longest_route_idx]))\n    target_route = new_solution[target_route_idx]\n\n    # Merge the two routes\n    merged_route = np.concatenate((longest_route[:-1], target_route[1:]))\n\n    # Update the solution\n    new_solution[longest_route_idx] = merged_route\n    del new_solution[target_route_idx]\n\n    # Perform spatial rebalancing by reallocating customers between routes\n    for route in new_solution:\n        if len(route) <= 3:\n            continue\n\n        customers = route[1:-1]\n        route_centroid = np.mean(coords[customers], axis=0)\n\n        # Find customers farthest from route centroid\n        farthest_customers = sorted(customers, key=lambda x: -np.linalg.norm(coords[x] - route_centroid))[:2]\n\n        for customer in farthest_customers:\n            # Find best compatible route for reallocation\n            best_route = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, candidate_route in enumerate(new_solution):\n                if i == new_solution.index(route):\n                    continue\n                for pos in range(1, len(candidate_route)):\n                    temp_route = np.insert(candidate_route, pos, customer)\n                    if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                        # Score based on spatial proximity and demand balance\n                        candidate_centroid = np.mean(coords[candidate_route[1:-1]], axis=0)\n                        score = (np.linalg.norm(coords[customer] - candidate_centroid) +\n                                abs(np.sum(demand[temp_route[1:-1]]) - route_demands[i]))\n                        if score < best_score:\n                            best_score = score\n                            best_route = i\n                            best_pos = pos\n\n            if best_route != -1:\n                # Perform reallocation\n                new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                route_pos = np.where(route == customer)[0][0]\n                new_solution[new_solution.index(route)] = np.delete(route, route_pos)\n                # Update the route reference\n                route = new_solution[new_solution.index(route)]\n                customers = route[1:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7868069841491452,
            0.24184396862983704
        ]
    },
    {
        "algorithm": "{The new algorithm combines route reversal with adaptive customer reallocation, where it reverses selected route segments and intelligently reallocates customers to other routes based on their spatial proximity and demand compatibility, while ensuring feasibility through a capacity-aware reinsertion mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = max(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = np.random.randint(0, len(new_solution))\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            # Reverse a random segment of the route\n            start = np.random.randint(1, len(route)-2)\n            end = np.random.randint(start+1, len(route)-1)\n            route[start:end+1] = route[start:end+1][::-1]\n\n            # Check capacity feasibility\n            if np.sum(demand[route[1:-1]]) > capacity:\n                # If infeasible, reallocate excess customers to other routes\n                current_demand = 0\n                excess_customers = []\n                for customer in route[1:-1]:\n                    if current_demand + demand[customer] <= capacity:\n                        current_demand += demand[customer]\n                    else:\n                        excess_customers.append(customer)\n\n                if excess_customers:\n                    # Find best routes to reallocate excess customers\n                    for customer in excess_customers:\n                        best_route = -1\n                        best_pos = -1\n                        best_dist = float('inf')\n\n                        for i, other_route in enumerate(new_solution):\n                            if i == route_idx:\n                                continue\n                            for pos in range(1, len(other_route)):\n                                temp_route = np.insert(other_route, pos, customer)\n                                if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                                    dist_change = (distance_matrix[temp_route[pos-1]][customer] +\n                                                 distance_matrix[customer][temp_route[pos+1]] -\n                                                 distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                                    if dist_change < best_dist:\n                                        best_dist = dist_change\n                                        best_route = i\n                                        best_pos = pos\n\n                        if best_route != -1:\n                            new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                            route = np.delete(route, np.where(route == customer)[0][0])\n\n            # Update the modified route\n            new_solution[route_idx] = route\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.69210967943795,
            0.10920712351799011
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: combine route splitting and customer reallocation\n    for i, route in enumerate(new_solution):\n        if len(route) <= 3:  # Skip trivial routes\n            continue\n\n        # Split the route into two parts at a random position\n        split_pos = np.random.randint(1, len(route) - 1)\n        part1 = route[:split_pos + 1]\n        part2 = route[split_pos:]\n\n        # Check if splitting is feasible\n        if np.sum(demand[part1[1:-1]]) <= capacity and np.sum(demand[part2[1:-1]]) <= capacity:\n            new_solution[i] = part1\n            new_solution.append(part2)\n        else:\n            # If splitting is not feasible, try reallocating a customer to another route\n            for j in range(1, len(route) - 1):\n                customer = route[j]\n                # Find the best route to insert this customer\n                best_route = -1\n                best_pos = -1\n                best_cost = float('inf')\n\n                for k, other_route in enumerate(new_solution):\n                    if k == i:\n                        continue\n                    # Try inserting the customer at all possible positions\n                    for pos in range(1, len(other_route)):\n                        temp_route = np.insert(other_route, pos, customer)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            # Calculate the additional cost\n                            cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                                   distance_matrix[customer][temp_route[pos+1]] - \\\n                                   distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = k\n                                best_pos = pos\n\n                if best_route != -1:\n                    # Perform the reallocation\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                    new_solution[i] = np.delete(new_solution[i], j)\n                    break\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7903060370334931,
            0.268205463886261
        ]
    },
    {
        "algorithm": "{This algorithm combines route splitting with spatial clustering and demand-aware rebalancing to improve both total distance and makespan by strategically partitioning routes and redistributing customers based on spatial proximity and demand patterns.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Select a route to potentially split\n    route_idx = np.random.choice(len(new_solution))\n    selected_route = new_solution[route_idx]\n\n    # Cluster customers in the selected route based on spatial proximity\n    customers = selected_route[1:-1]\n    if len(customers) <= 1:\n        return new_solution\n\n    # Find the customer with maximum demand in the route\n    heaviest_customer = max(customers, key=lambda x: demand[x])\n\n    # Find the best split point based on spatial and demand criteria\n    best_split_pos = -1\n    best_split_cost = float('inf')\n\n    for i in range(1, len(selected_route) - 1):\n        # Split the route at position i\n        first_part = selected_route[:i+1]\n        second_part = selected_route[i:]\n\n        # Calculate the cost of the split\n        cost = distance_matrix[first_part[-2]][first_part[-1]] + \\\n               distance_matrix[second_part[0]][second_part[1]] + \\\n               distance_matrix[selected_route[i-1]][selected_route[i+1]] - \\\n               distance_matrix[selected_route[i-1]][selected_route[i]] - \\\n               distance_matrix[selected_route[i]][selected_route[i+1]]\n\n        if cost < best_split_cost:\n            best_split_cost = cost\n            best_split_pos = i\n\n    if best_split_cost < float('inf'):\n        # Perform the split\n        first_part = selected_route[:best_split_pos+1]\n        second_part = selected_route[best_split_pos:]\n\n        # Check capacity constraints\n        if np.sum(demand[first_part[1:-1]]) <= capacity and np.sum(demand[second_part[1:-1]]) <= capacity:\n            new_solution[route_idx] = first_part\n            new_solution.insert(route_idx + 1, second_part)\n\n    # Rebalance demand between routes\n    for route in new_solution:\n        if np.sum(demand[route[1:-1]]) > capacity:\n            # Find customers to reallocate\n            customers = route[1:-1]\n            customers_sorted = sorted(customers, key=lambda x: demand[x], reverse=True)\n\n            for customer in customers_sorted:\n                # Find the best route to insert this customer\n                best_route = -1\n                best_pos = -1\n                best_cost = float('inf')\n\n                for k, candidate_route in enumerate(new_solution):\n                    if customer in candidate_route:\n                        continue\n                    for pos in range(1, len(candidate_route)):\n                        temp_route = np.insert(candidate_route, pos, customer)\n                        if np.sum(demand[temp_route[1:-1]]) <= capacity:\n                            cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                                   distance_matrix[customer][temp_route[pos+1]] - \\\n                                   distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route = k\n                                best_pos = pos\n\n                if best_route != -1:\n                    # Perform the reallocation\n                    new_solution[best_route] = np.insert(new_solution[best_route], best_pos, customer)\n                    # Remove the customer from its original route\n                    route = np.delete(route, np.where(route == customer)[0][0])\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.7226158674237273,
            0.10963800549507141
        ]
    }
]