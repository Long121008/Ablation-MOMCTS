[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm combines route fragmentation with demand-aware customer redistribution to create balanced routes by strategically splitting long routes and redistributing customers to shorter routes while respecting capacity constraints, aiming to reduce makespan without significantly increasing total distance.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: -x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the longest route to fragment\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    if len(longest_route) <= 3:  # Skip if route is too short\n        return new_solution\n\n    # Split the longest route into two segments\n    split_idx = np.random.randint(1, len(longest_route) - 1)\n    segment1 = longest_route[:split_idx + 1]\n    segment2 = longest_route[split_idx:]\n\n    # Check capacity feasibility for both segments\n    seg1_demand = np.sum(demand[segment1[1:-1]])\n    seg2_demand = np.sum(demand[segment2[1:-1]])\n\n    if seg1_demand <= capacity and seg2_demand <= capacity:\n        new_solution[longest_route_idx] = segment1\n        new_solution.append(segment2)\n    else:\n        # If split is infeasible, redistribute customers to other routes\n        customers = longest_route[1:-1]\n        for customer in customers:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == longest_route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                           distance_matrix[customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original long route if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[longest_route_idx]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm combines route merging with demand-aware customer reallocation to create balanced routes by strategically merging short routes and redistributing customers to longer routes while respecting capacity constraints, aiming to reduce total distance without significantly increasing makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the shortest route to merge\n    shortest_route_idx = np.argmin([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    shortest_route = new_solution[shortest_route_idx]\n\n    if len(shortest_route) <= 3:  # Skip if route is too short\n        return new_solution\n\n    # Calculate remaining capacity for each route\n    route_capacities = []\n    for route in new_solution:\n        route_capacities.append(capacity - np.sum(demand[route[1:-1]]))\n\n    # Find the route with the most remaining capacity that can accommodate the shortest route's customers\n    best_route_idx = None\n    max_remaining = -1\n    for i, route in enumerate(new_solution):\n        if i == shortest_route_idx:\n            continue\n        if route_capacities[i] >= np.sum(demand[shortest_route[1:-1]]) and route_capacities[i] > max_remaining:\n            max_remaining = route_capacities[i]\n            best_route_idx = i\n\n    if best_route_idx is not None:\n        # Merge the shortest route into the best route\n        target_route = new_solution[best_route_idx]\n        customers_to_merge = shortest_route[1:-1]\n\n        # Find the best insertion position in the target route\n        best_pos = 1\n        best_cost = float('inf')\n        for pos in range(1, len(target_route)):\n            temp_route = np.insert(target_route, pos, customers_to_merge)\n            cost = distance_matrix[temp_route[pos-1]][customers_to_merge[0]] + \\\n                   distance_matrix[customers_to_merge[-1]][temp_route[pos+len(customers_to_merge)]] - \\\n                   distance_matrix[temp_route[pos-1]][temp_route[pos+len(customers_to_merge)]]\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n\n        new_solution[best_route_idx] = np.insert(target_route, best_pos, customers_to_merge)\n        del new_solution[shortest_route_idx]\n\n    else:\n        # If no suitable route found, redistribute customers to other routes\n        customers = shortest_route[1:-1]\n        for customer in customers:\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == shortest_route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                           distance_matrix[customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original short route if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[shortest_route_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8359074295921145,
            0.9507183730602264
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the shortest route to merge\n    shortest_route_idx = np.argmin([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    shortest_route = new_solution[shortest_route_idx]\n\n    if len(shortest_route) <= 3:  # Skip if route is too short\n        return new_solution\n\n    # Calculate remaining capacity for each route\n    route_capacities = []\n    for route in new_solution:\n        route_capacities.append(capacity - np.sum(demand[route[1:-1]]))\n\n    # Find the route with the most remaining capacity that can accommodate the shortest route's customers\n    best_route_idx = None\n    max_remaining = -1\n    for i, route in enumerate(new_solution):\n        if i == shortest_route_idx:\n            continue\n        if route_capacities[i] >= np.sum(demand[shortest_route[1:-1]]) and route_capacities[i] > max_remaining:\n            max_remaining = route_capacities[i]\n            best_route_idx = i\n\n    if best_route_idx is not None:\n        # Merge the shortest route into the best route\n        target_route = new_solution[best_route_idx]\n        customers_to_merge = shortest_route[1:-1]\n\n        # Find the best insertion position in the target route\n        best_pos = 1\n        best_cost = float('inf')\n        for pos in range(1, len(target_route)):\n            temp_route = np.insert(target_route, pos, customers_to_merge)\n            cost = distance_matrix[temp_route[pos-1]][customers_to_merge[0]] + \\\n                   distance_matrix[customers_to_merge[-1]][temp_route[pos+len(customers_to_merge)]] - \\\n                   distance_matrix[temp_route[pos-1]][temp_route[pos+len(customers_to_merge)]]\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n\n        new_solution[best_route_idx] = np.insert(target_route, best_pos, customers_to_merge)\n        del new_solution[shortest_route_idx]\n\n    else:\n        # If no suitable route found, redistribute customers to other routes\n        customers = shortest_route[1:-1]\n        for customer in customers:\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == shortest_route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = distance_matrix[temp_route[pos-1]][customer] + \\\n                           distance_matrix[customer][temp_route[pos+1]] - \\\n                           distance_matrix[temp_route[pos-1]][temp_route[pos+1]]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original short route if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[shortest_route_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines spatial clustering with demand-aware route reconstruction, where it first groups customers based on spatial proximity and demand similarity, then reconstructs routes by iteratively assigning clusters to vehicles while balancing capacity and minimizing route length, creating a hybrid of spatial partitioning and demand-aware optimization.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1] / x[1][0], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Collect all unserved customers from the base solution\n    served_customers = set()\n    for route in base_solution:\n        served_customers.update(route[1:-1])\n    unserved_customers = [i for i in range(1, len(coords)) if i not in served_customers]\n\n    # Spatial clustering: group customers based on proximity and demand similarity\n    clusters = []\n    remaining_customers = set(unserved_customers)\n\n    while remaining_customers:\n        # Select a seed customer (highest demand)\n        seed = max(remaining_customers, key=lambda x: demand[x])\n        cluster = [seed]\n        remaining_customers.remove(seed)\n        current_demand = demand[seed]\n\n        # Grow the cluster with nearby customers that fit demand constraints\n        for customer in list(remaining_customers):\n            if (distance_matrix[seed][customer] < 1.5 * np.mean(distance_matrix[0]) and\n                current_demand + demand[customer] <= capacity * 0.8):\n                cluster.append(customer)\n                current_demand += demand[customer]\n                remaining_customers.remove(customer)\n\n        clusters.append(cluster)\n\n    # Demand-aware route reconstruction\n    new_solution = []\n    for cluster in clusters:\n        # Sort cluster by distance from depot\n        cluster_sorted = sorted(cluster, key=lambda x: distance_matrix[0][x])\n\n        # Create a new route starting from the depot\n        current_route = [0]\n        current_load = 0\n\n        for customer in cluster_sorted:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                # Close current route and start a new one\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n                current_route = [0, customer]\n                current_load = demand[customer]\n\n        # Close the last route\n        current_route.append(0)\n        new_solution.append(np.array(current_route))\n\n    # Merge routes if possible to reduce makespan\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Skip empty or single-customer routes\n            continue\n\n        merged = False\n        for i, existing_route in enumerate(merged_solution):\n            combined_demand = np.sum(demand[route[1:-1]]) + np.sum(demand[existing_route[1:-1]])\n            if combined_demand <= capacity:\n                # Merge routes by connecting them\n                merged_route = np.concatenate([existing_route[:-1], route[1:]])\n                merged_solution[i] = merged_route\n                merged = True\n                break\n\n        if not merged:\n            merged_solution.append(route)\n\n    # Add any remaining unserved customers to new routes\n    if unserved_customers:\n        for customer in unserved_customers:\n            new_route = np.array([0, customer, 0])\n            merged_solution.append(new_route)\n\n    return merged_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This novel algorithm employs a demand-driven spatial partitioning approach that first classifies customers into clusters based on both spatial proximity and demand compatibility, then reconstructs routes by iteratively merging clusters while optimizing for both route length and capacity utilization, creating a hybrid of spatial and demand-aware optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] / x[1][1], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Collect all unserved customers\n    served_customers = set()\n    for route in base_solution:\n        served_customers.update(route[1:-1])\n    unserved_customers = [i for i in range(1, len(coords)) if i not in served_customers]\n\n    # Demand-driven spatial partitioning\n    clusters = []\n    remaining_customers = set(unserved_customers)\n\n    while remaining_customers:\n        # Select seed customer with highest demand\n        seed = max(remaining_customers, key=lambda x: demand[x])\n        cluster = [seed]\n        remaining_customers.remove(seed)\n        current_demand = demand[seed]\n\n        # Grow cluster with compatible customers\n        for customer in list(remaining_customers):\n            if (distance_matrix[seed][customer] < 1.2 * np.mean(distance_matrix[0]) and\n                current_demand + demand[customer] <= capacity * 0.9):\n                cluster.append(customer)\n                current_demand += demand[customer]\n                remaining_customers.remove(customer)\n\n        clusters.append(cluster)\n\n    # Route reconstruction with capacity optimization\n    new_solution = []\n    for cluster in clusters:\n        # Sort by distance from depot and demand\n        cluster_sorted = sorted(cluster, key=lambda x: (distance_matrix[0][x], -demand[x]))\n\n        current_route = [0]\n        current_load = 0\n\n        for customer in cluster_sorted:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                # Try to insert in existing routes\n                inserted = False\n                for i, route in enumerate(new_solution):\n                    route_load = sum(demand[route[1:-1]])\n                    if route_load + demand[customer] <= capacity:\n                        # Find best insertion point\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for j in range(1, len(route)):\n                            cost = (distance_matrix[route[j-1]][customer] +\n                                   distance_matrix[customer][route[j]] -\n                                   distance_matrix[route[j-1]][route[j]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = j\n                        new_route = np.concatenate([route[:best_pos], [customer], route[best_pos:]])\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    current_route.append(0)\n                    new_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n\n    # Handle remaining unserved customers\n    if unserved_customers:\n        for customer in unserved_customers:\n            # Find best route to insert\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i, route in enumerate(new_solution):\n                route_load = sum(demand[route[1:-1]])\n                if route_load + demand[customer] > capacity:\n                    continue\n\n                for j in range(1, len(route)):\n                    cost = (distance_matrix[route[j-1]][customer] +\n                           distance_matrix[customer][route[j]] -\n                           distance_matrix[route[j-1]][route[j]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route = i\n                        best_pos = j\n\n            if best_route != -1:\n                new_route = np.concatenate([new_solution[best_route][:best_pos],\n                                           [customer],\n                                           new_solution[best_route][best_pos:]])\n                new_solution[best_route] = new_route\n            else:\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n",
        "score": [
            -0.7548038203622705,
            0.027544260025024414
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] / x[1][1], reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Collect all unserved customers\n    served_customers = set()\n    for route in base_solution:\n        served_customers.update(route[1:-1])\n    unserved_customers = [i for i in range(1, len(coords)) if i not in served_customers]\n\n    # Demand-driven spatial partitioning\n    clusters = []\n    remaining_customers = set(unserved_customers)\n\n    while remaining_customers:\n        # Select seed customer with highest demand\n        seed = max(remaining_customers, key=lambda x: demand[x])\n        cluster = [seed]\n        remaining_customers.remove(seed)\n        current_demand = demand[seed]\n\n        # Grow cluster with compatible customers\n        for customer in list(remaining_customers):\n            if (distance_matrix[seed][customer] < 1.2 * np.mean(distance_matrix[0]) and\n                current_demand + demand[customer] <= capacity * 0.9):\n                cluster.append(customer)\n                current_demand += demand[customer]\n                remaining_customers.remove(customer)\n\n        clusters.append(cluster)\n\n    # Route reconstruction with capacity optimization\n    new_solution = []\n    for cluster in clusters:\n        # Sort by distance from depot and demand\n        cluster_sorted = sorted(cluster, key=lambda x: (distance_matrix[0][x], -demand[x]))\n\n        current_route = [0]\n        current_load = 0\n\n        for customer in cluster_sorted:\n            if current_load + demand[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demand[customer]\n            else:\n                # Try to insert in existing routes\n                inserted = False\n                for i, route in enumerate(new_solution):\n                    route_load = sum(demand[route[1:-1]])\n                    if route_load + demand[customer] <= capacity:\n                        # Find best insertion point\n                        best_pos = 1\n                        best_cost = float('inf')\n                        for j in range(1, len(route)):\n                            cost = (distance_matrix[route[j-1]][customer] +\n                                   distance_matrix[customer][route[j]] -\n                                   distance_matrix[route[j-1]][route[j]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_pos = j\n                        new_route = np.concatenate([route[:best_pos], [customer], route[best_pos:]])\n                        new_solution[i] = new_route\n                        inserted = True\n                        break\n                if not inserted:\n                    current_route.append(0)\n                    new_solution.append(np.array(current_route))\n                    current_route = [0, customer]\n                    current_load = demand[customer]\n\n        if len(current_route) > 1:\n            current_route.append(0)\n            new_solution.append(np.array(current_route))\n\n    # Handle remaining unserved customers\n    if unserved_customers:\n        for customer in unserved_customers:\n            # Find best route to insert\n            best_route = -1\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i, route in enumerate(new_solution):\n                route_load = sum(demand[route[1:-1]])\n                if route_load + demand[customer] > capacity:\n                    continue\n\n                for j in range(1, len(route)):\n                    cost = (distance_matrix[route[j-1]][customer] +\n                           distance_matrix[customer][route[j]] -\n                           distance_matrix[route[j-1]][route[j]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_route = i\n                        best_pos = j\n\n            if best_route != -1:\n                new_route = np.concatenate([new_solution[best_route][:best_pos],\n                                           [customer],\n                                           new_solution[best_route][best_pos:]])\n                new_solution[best_route] = new_route\n            else:\n                new_solution.append(np.array([0, customer, 0]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm combines spatial clustering with demand-aware route splitting to create balanced routes by first grouping customers based on their spatial proximity and then intelligently splitting these clusters into feasible routes while considering both demand and distance constraints.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    base_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Collect all unassigned customers\n    assigned_customers = set()\n    for route in new_solution:\n        assigned_customers.update(route[1:-1])\n    all_customers = set(range(1, len(demand)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    if not unassigned_customers:\n        # If no unassigned customers, try to improve existing routes\n        if len(new_solution) > 1:\n            # Select a random route to split\n            route_idx = np.random.randint(0, len(new_solution))\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find the best split point\n                best_split = 1\n                best_score = float('inf')\n\n                for split in range(2, len(route)-1):\n                    # Check if the split creates feasible routes\n                    first_part = route[:split+1]\n                    second_part = route[split:]\n\n                    if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                        np.sum(demand[second_part[1:-1]]) <= capacity):\n                        # Calculate the score based on distance reduction\n                        original_dist = (distance_matrix[route[split-1]][route[split]] +\n                                       distance_matrix[route[split]][route[split+1]])\n                        new_dist = (distance_matrix[route[split-1]][0] +\n                                   distance_matrix[0][route[split]] +\n                                   distance_matrix[route[split]][0] +\n                                   distance_matrix[0][route[split+1]])\n\n                        score = new_dist - original_dist\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = split\n\n                if best_split > 1:\n                    # Perform the split\n                    first_part = route[:best_split+1]\n                    second_part = route[best_split:]\n                    new_solution[route_idx] = first_part\n                    new_solution.insert(route_idx + 1, second_part)\n    else:\n        # Create new routes for unassigned customers\n        remaining_customers = unassigned_customers.copy()\n\n        while remaining_customers:\n            # Select a customer to start a new route\n            current_customer = remaining_customers.pop(0)\n            current_demand = demand[current_customer]\n            current_route = [0, current_customer, 0]\n\n            # Try to add compatible customers\n            for _ in range(len(remaining_customers)):\n                if np.sum(demand[current_route[1:-1]]) + demand[remaining_customers[0]] <= capacity:\n                    # Find the best insertion position\n                    best_pos = 1\n                    best_cost = float('inf')\n\n                    for pos in range(1, len(current_route)):\n                        temp_route = np.insert(current_route, pos, remaining_customers[0])\n                        cost = (distance_matrix[temp_route[pos-1]][remaining_customers[0]] +\n                               distance_matrix[remaining_customers[0]][temp_route[pos+1]] -\n                               distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n\n                    current_route = np.insert(current_route, best_pos, remaining_customers[0])\n                    remaining_customers.pop(0)\n                else:\n                    break\n\n            new_solution.append(np.array(current_route))\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm employs a hybrid approach combining route merging with capacity-aware customer redistribution, where it strategically combines underutilized routes to reduce the number of vehicles while intelligently redistributing customers to maintain balance between total distance and makespan objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][1], x[1][0]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Find the two most underutilized routes\n    demand_utilization = [np.sum(demand[route[1:-1]]) / capacity for route in new_solution]\n    underutilized_indices = np.argsort(demand_utilization)[:2]\n    if len(underutilized_indices) < 2:\n        return new_solution\n\n    route1_idx, route2_idx = sorted(underutilized_indices)\n    route1 = new_solution[route1_idx]\n    route2 = new_solution[route2_idx]\n\n    # Try to merge the two underutilized routes\n    if len(route1) + len(route2) - 2 > 2:  # Ensure merged route has more than just depot\n        merged_route = np.concatenate([route1[:-1], route2[1:]])\n        if np.sum(demand[merged_route[1:-1]]) <= capacity:\n            # Replace the two routes with the merged one\n            new_solution.pop(max(route1_idx, route2_idx))\n            new_solution.pop(min(route1_idx, route2_idx))\n            new_solution.insert(min(route1_idx, route2_idx), merged_route)\n        else:\n            # If merge is infeasible, try to redistribute customers from the larger route\n            larger_route = route1 if len(route1) > len(route2) else route2\n            smaller_route = route2 if len(route1) > len(route2) else route1\n            customers_to_redistribute = larger_route[1:-1]\n\n            for customer in customers_to_redistribute:\n                # Find the best target route (either the other underutilized route or an existing route)\n                best_route_idx = None\n                best_cost = float('inf')\n                for i, route in enumerate(new_solution):\n                    if i in [route1_idx, route2_idx]:\n                        continue\n                    current_demand = np.sum(demand[route[1:-1]])\n                    if demand[customer] <= (capacity - current_demand):\n                        # Find insertion position that minimizes additional distance\n                        for pos in range(1, len(route)):\n                            cost = (distance_matrix[route[pos-1]][customer] +\n                                    distance_matrix[customer][route[pos]] -\n                                    distance_matrix[route[pos-1]][route[pos]])\n                            if cost < best_cost:\n                                best_cost = cost\n                                best_route_idx = i\n\n                if best_route_idx is not None:\n                    # Insert customer into the best position in the target route\n                    target_route = new_solution[best_route_idx]\n                    best_pos = 1\n                    best_cost = float('inf')\n                    for pos in range(1, len(target_route)):\n                        cost = (distance_matrix[target_route[pos-1]][customer] +\n                                distance_matrix[customer][target_route[pos]] -\n                                distance_matrix[target_route[pos-1]][target_route[pos]])\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                    new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n            # Remove the customer from the original route\n            for i in range(len(new_solution)):\n                if np.array_equal(new_solution[i], larger_route):\n                    new_solution[i] = np.delete(larger_route, np.where(larger_route == customer)[0][0])\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This algorithm employs a novel route reconstruction approach that combines spatial clustering with demand-balanced route splitting, where it first identifies spatial clusters of customers using a density-based method, then reconstructs routes by strategically splitting these clusters while balancing demand and minimizing both distance and makespan objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Extract all customers from the base solution\n    assigned_customers = set()\n    for route in new_solution:\n        assigned_customers.update(route[1:-1])\n\n    # Identify unassigned customers\n    all_customers = set(range(1, len(demand)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    # If no unassigned customers, try to improve existing routes\n    if not unassigned_customers:\n        # Select a random route to split\n        if len(new_solution) > 1:\n            route_idx = np.random.randint(0, len(new_solution))\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find the best split point based on spatial and demand balance\n                best_split = 1\n                best_score = float('inf')\n\n                for split in range(2, len(route)-1):\n                    # Check if the split creates feasible routes\n                    first_part = route[:split+1]\n                    second_part = route[split:]\n\n                    if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                        np.sum(demand[second_part[1:-1]]) <= capacity):\n\n                        # Calculate spatial balance score\n                        first_coords = coords[first_part[1:-1]]\n                        second_coords = coords[second_part[1:-1]]\n\n                        first_center = np.mean(first_coords, axis=0)\n                        second_center = np.mean(second_coords, axis=0)\n\n                        spatial_balance = np.linalg.norm(first_center - second_center)\n\n                        # Calculate demand balance score\n                        first_demand = np.sum(demand[first_part[1:-1]])\n                        second_demand = np.sum(demand[second_part[1:-1]])\n                        demand_balance = abs(first_demand - second_demand)\n\n                        # Combine scores with distance reduction\n                        original_dist = (distance_matrix[route[split-1]][route[split]] +\n                                       distance_matrix[route[split]][route[split+1]])\n                        new_dist = (distance_matrix[route[split-1]][0] +\n                                   distance_matrix[0][route[split]] +\n                                   distance_matrix[route[split]][0] +\n                                   distance_matrix[0][route[split+1]])\n\n                        dist_reduction = original_dist - new_dist\n\n                        # Weighted combined score\n                        score = 0.4 * spatial_balance + 0.3 * demand_balance - 0.3 * dist_reduction\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = split\n\n                if best_split > 1:\n                    # Perform the split\n                    first_part = route[:best_split+1]\n                    second_part = route[best_split:]\n                    new_solution[route_idx] = first_part\n                    new_solution.insert(route_idx + 1, second_part)\n    else:\n        # Create new routes for unassigned customers using spatial clustering\n        remaining_customers = unassigned_customers.copy()\n        customer_coords = coords[remaining_customers]\n\n        # Perform DBSCAN clustering to group nearby customers\n        from sklearn.cluster import DBSCAN\n        clustering = DBSCAN(eps=0.5*np.mean(distance_matrix[1:,1:]), min_samples=2).fit(customer_coords)\n        labels = clustering.labels_\n\n        # Create clusters of customers\n        clusters = {}\n        for i, label in enumerate(labels):\n            if label not in clusters:\n                clusters[label] = []\n            clusters[label].append(remaining_customers[i])\n\n        # Process each cluster to create routes\n        for cluster in clusters.values():\n            if not cluster:\n                continue\n\n            current_route = [0]\n            current_demand = 0\n            cluster_customers = cluster.copy()\n\n            while cluster_customers:\n                # Find the customer closest to the last customer in the current route\n                last_customer = current_route[-1] if current_route[-1] != 0 else 0\n                best_customer = None\n                best_cost = float('inf')\n\n                for customer in cluster_customers:\n                    if current_demand + demand[customer] <= capacity:\n                        cost = distance_matrix[last_customer][customer]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_customer = customer\n\n                if best_customer is not None:\n                    current_route.append(best_customer)\n                    current_demand += demand[best_customer]\n                    cluster_customers.remove(best_customer)\n                else:\n                    # No more customers can fit, complete the route\n                    current_route.append(0)\n                    new_solution.append(np.array(current_route))\n                    current_route = [0]\n                    current_demand = 0\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8879477872054757,
            0.4066440463066101
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = min(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Extract all customers from the base solution\n    assigned_customers = set()\n    for route in new_solution:\n        assigned_customers.update(route[1:-1])\n\n    # Identify unassigned customers\n    all_customers = set(range(1, len(demand)))\n    unassigned_customers = list(all_customers - assigned_customers)\n\n    # If no unassigned customers, try to improve existing routes\n    if not unassigned_customers:\n        # Select a random route to split\n        if len(new_solution) > 1:\n            route_idx = np.random.randint(0, len(new_solution))\n            route = new_solution[route_idx]\n\n            if len(route) > 3:\n                # Find the best split point based on spatial and demand balance\n                best_split = 1\n                best_score = float('inf')\n\n                for split in range(2, len(route)-1):\n                    # Check if the split creates feasible routes\n                    first_part = route[:split+1]\n                    second_part = route[split:]\n\n                    if (np.sum(demand[first_part[1:-1]]) <= capacity and\n                        np.sum(demand[second_part[1:-1]]) <= capacity):\n\n                        # Calculate spatial balance score\n                        first_coords = coords[first_part[1:-1]]\n                        second_coords = coords[second_part[1:-1]]\n\n                        first_center = np.mean(first_coords, axis=0)\n                        second_center = np.mean(second_coords, axis=0)\n\n                        spatial_balance = np.linalg.norm(first_center - second_center)\n\n                        # Calculate demand balance score\n                        first_demand = np.sum(demand[first_part[1:-1]])\n                        second_demand = np.sum(demand[second_part[1:-1]])\n                        demand_balance = abs(first_demand - second_demand)\n\n                        # Combine scores with distance reduction\n                        original_dist = (distance_matrix[route[split-1]][route[split]] +\n                                       distance_matrix[route[split]][route[split+1]])\n                        new_dist = (distance_matrix[route[split-1]][0] +\n                                   distance_matrix[0][route[split]] +\n                                   distance_matrix[route[split]][0] +\n                                   distance_matrix[0][route[split+1]])\n\n                        dist_reduction = original_dist - new_dist\n\n                        # Weighted combined score\n                        score = 0.4 * spatial_balance + 0.3 * demand_balance - 0.3 * dist_reduction\n\n                        if score < best_score:\n                            best_score = score\n                            best_split = split\n\n                if best_split > 1:\n                    # Perform the split\n                    first_part = route[:best_split+1]\n                    second_part = route[best_split:]\n                    new_solution[route_idx] = first_part\n                    new_solution.insert(route_idx + 1, second_part)\n    else:\n        # Create new routes for unassigned customers using spatial clustering\n        remaining_customers = unassigned_customers.copy()\n        customer_coords = coords[remaining_customers]\n\n        # Perform DBSCAN clustering to group nearby customers\n        from sklearn.cluster import DBSCAN\n        clustering = DBSCAN(eps=0.5*np.mean(distance_matrix[1:,1:]), min_samples=2).fit(customer_coords)\n        labels = clustering.labels_\n\n        # Create clusters of customers\n        clusters = {}\n        for i, label in enumerate(labels):\n            if label not in clusters:\n                clusters[label] = []\n            clusters[label].append(remaining_customers[i])\n\n        # Process each cluster to create routes\n        for cluster in clusters.values():\n            if not cluster:\n                continue\n\n            current_route = [0]\n            current_demand = 0\n            cluster_customers = cluster.copy()\n\n            while cluster_customers:\n                # Find the customer closest to the last customer in the current route\n                last_customer = current_route[-1] if current_route[-1] != 0 else 0\n                best_customer = None\n                best_cost = float('inf')\n\n                for customer in cluster_customers:\n                    if current_demand + demand[customer] <= capacity:\n                        cost = distance_matrix[last_customer][customer]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_customer = customer\n\n                if best_customer is not None:\n                    current_route.append(best_customer)\n                    current_demand += demand[best_customer]\n                    cluster_customers.remove(best_customer)\n                else:\n                    # No more customers can fit, complete the route\n                    current_route.append(0)\n                    new_solution.append(np.array(current_route))\n                    current_route = [0]\n                    current_demand = 0\n\n            if len(current_route) > 1:\n                current_route.append(0)\n                new_solution.append(np.array(current_route))\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm combines route merging with demand-aware customer redistribution to create balanced routes by strategically merging shorter routes and redistributing customers to longer routes while respecting capacity constraints, aiming to reduce the total distance without significantly increasing the makespan.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Find the shortest route\n    shortest_route_idx = np.argmin([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    shortest_route = new_solution[shortest_route_idx]\n\n    # Find the longest route\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    if shortest_route_idx == longest_route_idx:\n        return new_solution\n\n    # Try to merge the shortest route into the longest route\n    customers_to_merge = shortest_route[1:-1]\n    remaining_capacity = capacity - np.sum(demand[longest_route[1:-1]])\n\n    if np.sum(demand[customers_to_merge]) <= remaining_capacity:\n        # Find the best insertion position in the longest route\n        best_pos = 1\n        best_cost = float('inf')\n\n        for pos in range(1, len(longest_route)):\n            temp_route = np.insert(longest_route, pos, customers_to_merge)\n            cost = (distance_matrix[longest_route[pos-1]][customers_to_merge[0]] +\n                    distance_matrix[customers_to_merge[-1]][longest_route[pos]] -\n                    distance_matrix[longest_route[pos-1]][longest_route[pos]])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n\n        # Perform the merge\n        new_longest_route = np.insert(longest_route, best_pos, customers_to_merge)\n        new_solution[longest_route_idx] = new_longest_route\n        del new_solution[shortest_route_idx]\n    else:\n        # If merge is not possible, try to redistribute customers from the shortest route\n        for customer in customers_to_merge:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == shortest_route_idx or i == longest_route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = (distance_matrix[temp_route[pos-1]][customer] +\n                            distance_matrix[customer][temp_route[pos+1]] -\n                            distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n        # Remove the original shortest route if all customers are redistributed\n        if np.sum([len(route) for route in new_solution]) == np.sum([len(route) for route in base_solution]):\n            del new_solution[shortest_route_idx]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This new algorithm combines route splitting with strategic customer reallocation to balance route lengths by dividing overloaded routes and redistributing customers to underutilized routes while respecting capacity constraints, aiming to improve makespan without significantly increasing total distance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Find the route with the highest makespan\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Check if the route is overloaded\n    total_demand = np.sum(demand[longest_route[1:-1]])\n    if total_demand <= capacity:\n        return new_solution\n\n    # Try to split the longest route into two balanced routes\n    customers = longest_route[1:-1]\n    demands = demand[customers]\n    total_demand = np.sum(demands)\n\n    # Find the split point that balances the demands\n    best_split = 0\n    best_balance = float('inf')\n    cumulative_demand = 0\n\n    for i in range(len(customers)):\n        cumulative_demand += demands[i]\n        balance = abs(2 * cumulative_demand - total_demand)\n        if balance < best_balance:\n            best_balance = balance\n            best_split = i + 1\n\n    # Create two new routes\n    route1_customers = customers[:best_split]\n    route2_customers = customers[best_split:]\n\n    # Ensure both routes are feasible\n    if np.sum(demand[route1_customers]) > capacity or np.sum(demand[route2_customers]) > capacity:\n        return new_solution\n\n    # Create new routes\n    new_route1 = np.concatenate([[0], route1_customers, [0]])\n    new_route2 = np.concatenate([[0], route2_customers, [0]])\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = new_route1\n    new_solution.insert(longest_route_idx + 1, new_route2)\n\n    # Try to redistribute customers from the new routes to other routes\n    for route_idx in [longest_route_idx, longest_route_idx + 1]:\n        current_route = new_solution[route_idx]\n        customers_to_redistribute = current_route[1:-1]\n\n        for customer in customers_to_redistribute:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = (distance_matrix[temp_route[pos-1]][customer] +\n                            distance_matrix[customer][temp_route[pos+1]] -\n                            distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n                # Remove the customer from the original route\n                customer_pos = np.where(current_route == customer)[0][0]\n                current_route = np.delete(current_route, customer_pos)\n                new_solution[route_idx] = current_route\n\n    return new_solution\n\n",
        "score": [
            -0.5799765962133994,
            3.1090612411499023
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) <= 1:\n        return new_solution\n\n    # Find the route with the highest makespan\n    longest_route_idx = np.argmax([np.sum(distance_matrix[route[:-1], route[1:]]) for route in new_solution])\n    longest_route = new_solution[longest_route_idx]\n\n    # Check if the route is overloaded\n    total_demand = np.sum(demand[longest_route[1:-1]])\n    if total_demand <= capacity:\n        return new_solution\n\n    # Try to split the longest route into two balanced routes\n    customers = longest_route[1:-1]\n    demands = demand[customers]\n    total_demand = np.sum(demands)\n\n    # Find the split point that balances the demands\n    best_split = 0\n    best_balance = float('inf')\n    cumulative_demand = 0\n\n    for i in range(len(customers)):\n        cumulative_demand += demands[i]\n        balance = abs(2 * cumulative_demand - total_demand)\n        if balance < best_balance:\n            best_balance = balance\n            best_split = i + 1\n\n    # Create two new routes\n    route1_customers = customers[:best_split]\n    route2_customers = customers[best_split:]\n\n    # Ensure both routes are feasible\n    if np.sum(demand[route1_customers]) > capacity or np.sum(demand[route2_customers]) > capacity:\n        return new_solution\n\n    # Create new routes\n    new_route1 = np.concatenate([[0], route1_customers, [0]])\n    new_route2 = np.concatenate([[0], route2_customers, [0]])\n\n    # Replace the original route with the two new routes\n    new_solution[longest_route_idx] = new_route1\n    new_solution.insert(longest_route_idx + 1, new_route2)\n\n    # Try to redistribute customers from the new routes to other routes\n    for route_idx in [longest_route_idx, longest_route_idx + 1]:\n        current_route = new_solution[route_idx]\n        customers_to_redistribute = current_route[1:-1]\n\n        for customer in customers_to_redistribute:\n            # Find the route with the least remaining capacity that can accommodate the customer\n            best_route_idx = None\n            min_remaining = float('inf')\n            for i, route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n                current_demand = np.sum(demand[route[1:-1]])\n                remaining = capacity - current_demand\n                if demand[customer] <= remaining and remaining < min_remaining:\n                    min_remaining = remaining\n                    best_route_idx = i\n\n            if best_route_idx is not None:\n                # Find the best insertion position in the target route\n                target_route = new_solution[best_route_idx]\n                best_pos = 1\n                best_cost = float('inf')\n                for pos in range(1, len(target_route)):\n                    temp_route = np.insert(target_route, pos, customer)\n                    cost = (distance_matrix[temp_route[pos-1]][customer] +\n                            distance_matrix[customer][temp_route[pos+1]] -\n                            distance_matrix[temp_route[pos-1]][temp_route[pos+1]])\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                new_solution[best_route_idx] = np.insert(target_route, best_pos, customer)\n\n                # Remove the customer from the original route\n                customer_pos = np.where(current_route == customer)[0][0]\n                current_route = np.delete(current_route, customer_pos)\n                new_solution[route_idx] = current_route\n\n    return new_solution\n\n"
    }
]