[
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive with the smallest total distance and applies a demand-aware route splitting and spatial rebalancing strategy that intelligently divides routes based on demand distribution and spatial proximity while dynamically adjusting route merges to optimize both total distance and makespan, but with a novel \"demand-flow alignment\" approach that prioritizes customer sequences that maximize demand utilization and minimize spatial detours.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            demand_a = sum(demand[node] for node in route_a)\n            demand_b = sum(demand[node] for node in route_b)\n\n            if demand_a <= capacity and demand_b <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                nodes = route[1:-1]\n                new_route1 = [0]\n                new_route2 = [0]\n                current_demand1 = 0\n                current_demand2 = 0\n\n                for node in sorted(nodes, key=lambda x: (demand[x], coords[x][0])):\n                    if current_demand1 <= current_demand2:\n                        if current_demand1 + demand[node] <= capacity:\n                            new_route1.append(node)\n                            current_demand1 += demand[node]\n                    else:\n                        if current_demand2 + demand[node] <= capacity:\n                            new_route2.append(node)\n                            current_demand2 += demand[node]\n\n                if len(new_route1) > 1:\n                    new_route1.append(0)\n                    new_solution[route_idx] = np.array(new_route1)\n                if len(new_route2) > 1:\n                    new_route2.append(0)\n                    new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm selects a solution from the archive with the smallest makespan and applies a spatial clustering and demand-balanced merging strategy that intelligently groups nearby customers while dynamically merging routes to optimize both total distance and makespan, using a novel \"spatial-demand alignment\" approach that prioritizes customer sequences based on spatial proximity and demand balance to minimize route fragmentation and detours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx1 = random.randint(0, len(new_solution)-1)\n        route_idx2 = random.randint(0, len(new_solution)-1)\n\n        if route_idx1 != route_idx2:\n            route1 = new_solution[route_idx1]\n            route2 = new_solution[route_idx2]\n\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            total_demand = sum(demand[node] for node in merged_route)\n\n            if total_demand <= capacity:\n                new_solution.remove(route1)\n                new_solution.remove(route2)\n                new_solution.append(merged_route)\n            else:\n                nodes = np.concatenate([route1[1:-1], route2[1:-1]])\n                clustered_nodes = []\n\n                while len(nodes) > 0:\n                    center = nodes[np.argmin(np.sum(distance_matrix[nodes[:, None], nodes], axis=1))]\n                    cluster = [center]\n                    remaining_nodes = [node for node in nodes if node != center]\n\n                    for node in remaining_nodes:\n                        if sum(demand[n] for n in cluster) + demand[node] <= capacity:\n                            cluster.append(node)\n                        else:\n                            break\n\n                    clustered_nodes.append(np.array(cluster))\n                    nodes = np.array([node for node in nodes if node not in cluster])\n\n                new_routes = []\n                for cluster in clustered_nodes:\n                    route = np.concatenate([[0], cluster, [0]])\n                    new_routes.append(route)\n\n                if route_idx1 < route_idx2:\n                    new_solution[route_idx1:route_idx1+1] = new_routes\n                else:\n                    new_solution[route_idx2:route_idx2+1] = new_routes\n\n    return new_solution\n\n",
        "score": [
            -0.4676386792096112,
            0.15500429272651672
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx1 = random.randint(0, len(new_solution)-1)\n        route_idx2 = random.randint(0, len(new_solution)-1)\n\n        if route_idx1 != route_idx2:\n            route1 = new_solution[route_idx1]\n            route2 = new_solution[route_idx2]\n\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            total_demand = sum(demand[node] for node in merged_route)\n\n            if total_demand <= capacity:\n                new_solution.remove(route1)\n                new_solution.remove(route2)\n                new_solution.append(merged_route)\n            else:\n                nodes = np.concatenate([route1[1:-1], route2[1:-1]])\n                clustered_nodes = []\n\n                while len(nodes) > 0:\n                    center = nodes[np.argmin(np.sum(distance_matrix[nodes[:, None], nodes], axis=1))]\n                    cluster = [center]\n                    remaining_nodes = [node for node in nodes if node != center]\n\n                    for node in remaining_nodes:\n                        if sum(demand[n] for n in cluster) + demand[node] <= capacity:\n                            cluster.append(node)\n                        else:\n                            break\n\n                    clustered_nodes.append(np.array(cluster))\n                    nodes = np.array([node for node in nodes if node not in cluster])\n\n                new_routes = []\n                for cluster in clustered_nodes:\n                    route = np.concatenate([[0], cluster, [0]])\n                    new_routes.append(route)\n\n                if route_idx1 < route_idx2:\n                    new_solution[route_idx1:route_idx1+1] = new_routes\n                else:\n                    new_solution[route_idx2:route_idx2+1] = new_routes\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Capacitated Vehicle Routing Problem (Bi-CVRP), where a single depot and multiple customers are located in 2D space. Each customer has a positive demand, and all vehicles in the fleet have identical capacity limits. The objective is to construct a set of routes, each starting and ending at the depot, such that all customers are served, vehicle capacities are not exceeded on any route, and two conflicting objectives are minimized: (1) the total travel distance across all routes, and (2) the makespan, defined as the length of the longest individual route. Each solution in the archive is represented as a list of NumPy arrays, where each array denotes a single route (starting and ending with depot index 0), and is paired with a tuple of two objective values (total_distance, makespan). Your task is to implement a function named 'select_neighbor' that selects one promising solution from the archive and apply a novel or hybrid local search operator to generate a feasible neighbor solution from it. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself. Avoid standard methods like pure 2-opt; instead, invent or combine transformations, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. Ensure that the returned neighbor solution remains feasible under the vehicle capacity constraint. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel demand-aware route decomposition and spatial clustering algorithm that intelligently partitions routes based on both demand patterns and spatial coherence, then reassigns customers to new routes using a hybrid of demand-balanced clustering and spatial proximity optimization to simultaneously improve both total distance and makespan objectives}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Select a route to decompose\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Calculate demand and spatial characteristics of the route\n        route_demand = sum(demand[node] for node in route[1:-1])\n        route_length = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n\n        # Calculate demand and spatial centroid of the route\n        route_nodes = route[1:-1]\n        centroid_x = np.mean(coords[route_nodes, 0])\n        centroid_y = np.mean(coords[route_nodes, 1])\n        centroid = np.array([centroid_x, centroid_y])\n\n        # Find customers closest to the centroid\n        distances_to_centroid = np.linalg.norm(coords[route_nodes] - centroid, axis=1)\n        sorted_indices = np.argsort(distances_to_centroid)\n        median_idx = len(sorted_indices) // 2\n\n        # Split the route at the median customer closest to centroid\n        split_pos = sorted_indices[median_idx] + 1  # +1 to account for route[0] being depot\n\n        # Create two new routes\n        route1 = route[:split_pos+1]\n        route2 = np.concatenate([[0], route[split_pos+1:]])\n\n        # Check capacity constraints\n        demand1 = sum(demand[node] for node in route1[1:-1])\n        demand2 = sum(demand[node] for node in route2[1:-1])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Update solution with new routes\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to reassign customers to existing routes\n            for i in range(1, len(route)-1):\n                customer = route[i]\n                for j in range(len(new_solution)):\n                    if j != route_idx:\n                        temp_route = np.concatenate([new_solution[j][:-1], [customer], [0]])\n                        if sum(demand[node] for node in temp_route[1:-1]) <= capacity:\n                            new_solution[j] = temp_route\n                            break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{A novel demand-aware spatial clustering and route optimization algorithm that combines adaptive demand-balanced clustering with spatial proximity-aware route decomposition to simultaneously optimize both total distance and makespan by intelligently partitioning routes based on demand patterns and spatial coherence while maintaining capacity constraints through demand-aware customer reallocation and route merging.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive demand-aware spatial clustering\n    if len(new_solution) > 1:\n        # Select a route to optimize\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Calculate demand and spatial characteristics\n        route_nodes = route[1:-1]\n        route_demand = sum(demand[node] for node in route_nodes)\n        route_length = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n\n        # Find clusters based on demand and spatial proximity\n        clusters = []\n        current_cluster = [route_nodes[0]]\n        current_demand = demand[route_nodes[0]]\n\n        for i in range(1, len(route_nodes)):\n            node = route_nodes[i]\n            # Check if adding this node maintains capacity\n            if current_demand + demand[node] <= capacity:\n                current_cluster.append(node)\n                current_demand += demand[node]\n            else:\n                clusters.append(current_cluster)\n                current_cluster = [node]\n                current_demand = demand[node]\n\n        if current_cluster:\n            clusters.append(current_cluster)\n\n        # Create new routes from clusters\n        new_routes = []\n        for cluster in clusters:\n            new_route = np.concatenate([[0], cluster, [0]])\n            new_routes.append(new_route)\n\n        # Replace original route with new routes\n        new_solution[route_idx:route_idx+1] = new_routes\n\n        # Try to merge routes if possible\n        for i in range(len(new_solution)-1, 0, -1):\n            current_route = new_solution[i]\n            prev_route = new_solution[i-1]\n\n            combined_demand = sum(demand[node] for node in current_route[1:-1]) + sum(demand[node] for node in prev_route[1:-1])\n            if combined_demand <= capacity:\n                merged_route = np.concatenate([prev_route[:-1], current_route[1:]])\n                new_solution[i-1] = merged_route\n                del new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6867912396667263,
            0.9807066023349762
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive demand-aware spatial clustering\n    if len(new_solution) > 1:\n        # Select a route to optimize\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Calculate demand and spatial characteristics\n        route_nodes = route[1:-1]\n        route_demand = sum(demand[node] for node in route_nodes)\n        route_length = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n\n        # Find clusters based on demand and spatial proximity\n        clusters = []\n        current_cluster = [route_nodes[0]]\n        current_demand = demand[route_nodes[0]]\n\n        for i in range(1, len(route_nodes)):\n            node = route_nodes[i]\n            # Check if adding this node maintains capacity\n            if current_demand + demand[node] <= capacity:\n                current_cluster.append(node)\n                current_demand += demand[node]\n            else:\n                clusters.append(current_cluster)\n                current_cluster = [node]\n                current_demand = demand[node]\n\n        if current_cluster:\n            clusters.append(current_cluster)\n\n        # Create new routes from clusters\n        new_routes = []\n        for cluster in clusters:\n            new_route = np.concatenate([[0], cluster, [0]])\n            new_routes.append(new_route)\n\n        # Replace original route with new routes\n        new_solution[route_idx:route_idx+1] = new_routes\n\n        # Try to merge routes if possible\n        for i in range(len(new_solution)-1, 0, -1):\n            current_route = new_solution[i]\n            prev_route = new_solution[i-1]\n\n            combined_demand = sum(demand[node] for node in current_route[1:-1]) + sum(demand[node] for node in prev_route[1:-1])\n            if combined_demand <= capacity:\n                merged_route = np.concatenate([prev_route[:-1], current_route[1:]])\n                new_solution[i-1] = merged_route\n                del new_solution[i]\n\n    return new_solution\n\n"
    }
]