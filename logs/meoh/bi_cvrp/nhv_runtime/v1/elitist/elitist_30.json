[
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest makespan and applies a \"demand-centric spatial clustering\" operation that dynamically rebalances routes based on demand patterns and spatial cohesion, while ensuring feasibility through adaptive capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            demand_a = sum(demand[node] for node in route_a[1:-1])\n            demand_b = sum(demand[node] for node in route_b[1:-1])\n\n            if demand_a <= capacity and demand_b <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                nodes = list(route_a[1:-1]) + list(route_b[1:-1])\n                clusters = []\n                current_cluster = [nodes[0]]\n                current_demand = demand[nodes[0]]\n\n                for node in nodes[1:]:\n                    demand_ratio = (current_demand + demand[node]) / capacity\n                    spatial_score = np.mean([distance_matrix[node, n] for n in current_cluster])\n                    cohesion_score = spatial_score / (1 + abs(demand_ratio - 0.5))\n\n                    if (current_demand + demand[node] <= capacity) and (cohesion_score < 1.2 * np.mean(distance_matrix)):\n                        current_cluster.append(node)\n                        current_demand += demand[node]\n                    else:\n                        clusters.append(current_cluster)\n                        current_cluster = [node]\n                        current_demand = demand[node]\n\n                if current_cluster:\n                    clusters.append(current_cluster)\n\n                new_solution[route_idx] = np.array([0] + clusters[0] + [0])\n                for cluster in clusters[1:]:\n                    new_route = np.array([0] + cluster + [0])\n                    new_solution.insert(route_idx+1, new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.793252973925807,
            0.030415624380111694
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance and applies a spatial clustering and demand-balancing strategy that intelligently groups nearby customers while ensuring balanced demand distribution across routes, using a novel hybrid of k-means clustering and demand-aware route splitting to optimize both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        while route2_idx == route1_idx:\n            route2_idx = random.randint(0, len(new_solution)-1)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        total_demand_route1 = sum(demand[node] for node in route1[1:-1])\n        total_demand_route2 = sum(demand[node] for node in route2[1:-1])\n\n        if total_demand_route1 + total_demand_route2 <= capacity:\n            merged_route = [0]\n            i, j = 1, 1\n            while i < len(route1)-1 or j < len(route2)-1:\n                if i < len(route1)-1 and j < len(route2)-1:\n                    dist1 = distance_matrix[route1[i-1]][route1[i]]\n                    dist2 = distance_matrix[route2[j-1]][route2[j]]\n\n                    if dist1 < dist2:\n                        merged_route.append(route1[i])\n                        i += 1\n                    else:\n                        merged_route.append(route2[j])\n                        j += 1\n                elif i < len(route1)-1:\n                    merged_route.append(route1[i])\n                    i += 1\n                else:\n                    merged_route.append(route2[j])\n                    j += 1\n            merged_route.append(0)\n            new_solution[route1_idx] = np.array(merged_route)\n            del new_solution[route2_idx]\n        else:\n            if total_demand_route1 > total_demand_route2:\n                larger_route = route1\n                larger_idx = route1_idx\n            else:\n                larger_route = route2\n                larger_idx = route2_idx\n\n            if len(larger_route) > 3:\n                split_pos = random.randint(1, len(larger_route)-2)\n                route_a = larger_route[:split_pos+1]\n                route_b = np.concatenate([[0], larger_route[split_pos+1:]])\n\n                demand_a = sum(demand[node] for node in route_a)\n                demand_b = sum(demand[node] for node in route_b)\n\n                if demand_a <= capacity and demand_b <= capacity:\n                    new_solution[larger_idx] = route_a\n                    new_solution.insert(larger_idx+1, route_b)\n                else:\n                    for i in range(1, len(larger_route)-1):\n                        customer = larger_route[i]\n                        for j in range(len(new_solution)):\n                            if j != larger_idx:\n                                temp_route = np.concatenate([new_solution[j][:-1], [customer], [0]])\n                                if sum(demand[node] for node in temp_route) <= capacity:\n                                    new_solution[j] = temp_route\n                                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8804522748791661,
            0.03801226615905762
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance and applies a demand-aware route splitting and spatial rebalancing strategy that intelligently divides routes based on demand distribution and spatial proximity while dynamically adjusting route merges to optimize both total distance and makespan, but with a novel \"demand-flow alignment\" approach that prioritizes customer sequences that maximize demand utilization and minimize spatial detours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            demand_a = sum(demand[node] for node in route_a)\n            demand_b = sum(demand[node] for node in route_b)\n\n            if demand_a <= capacity and demand_b <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                nodes = route[1:-1]\n                new_route1 = [0]\n                new_route2 = [0]\n                current_demand1 = 0\n                current_demand2 = 0\n\n                for node in sorted(nodes, key=lambda x: (demand[x], coords[x][0])):\n                    if current_demand1 <= current_demand2:\n                        if current_demand1 + demand[node] <= capacity:\n                            new_route1.append(node)\n                            current_demand1 += demand[node]\n                    else:\n                        if current_demand2 + demand[node] <= capacity:\n                            new_route2.append(node)\n                            current_demand2 += demand[node]\n\n                if len(new_route1) > 1:\n                    new_route1.append(0)\n                    new_solution[route_idx] = np.array(new_route1)\n                if len(new_route2) > 1:\n                    new_route2.append(0)\n                    new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.8471544027105962,
            0.032080382108688354
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a \"capacity-aware route splitting\" operation that intelligently splits routes by prioritizing demand balance and spatial clustering, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                demand_a = sum(demand[node] for node in route_a[1:-1])\n                demand_b = sum(demand[node] for node in route_b[1:-1])\n\n                if demand_a > demand_b:\n                    larger_route, smaller_route = route_a, route_b\n                else:\n                    larger_route, smaller_route = route_b, route_a\n\n                if demand_a + demand_b <= capacity:\n                    new_solution[route_idx] = np.concatenate([larger_route[:-1], smaller_route[1:]])\n                else:\n                    nodes = list(larger_route[1:-1]) + list(smaller_route[1:-1])\n                    new_route1 = [0]\n                    new_route2 = [0]\n                    current_demand1 = 0\n                    current_demand2 = 0\n\n                    for node in nodes:\n                        if current_demand1 <= current_demand2:\n                            if current_demand1 + demand[node] <= capacity:\n                                new_route1.append(node)\n                                current_demand1 += demand[node]\n                        else:\n                            if current_demand2 + demand[node] <= capacity:\n                                new_route2.append(node)\n                                current_demand2 += demand[node]\n\n                    if len(new_route1) > 1:\n                        new_route1.append(0)\n                        new_solution[route_idx] = np.array(new_route1)\n                    if len(new_route2) > 1:\n                        new_route2.append(0)\n                        new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.7968783466732369,
            0.03118923306465149
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest makespan, then performs a \"demand-aware spatial rebalancing\" operation by redistributing customers across routes based on both spatial proximity and demand patterns, while ensuring feasibility through adaptive capacity checks and route optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n        customers = route[1:-1]\n\n        if len(customers) > 1:\n            centroid_x = np.mean(coords[customers, 0])\n            centroid_y = np.mean(coords[customers, 1])\n            centroid = np.array([centroid_x, centroid_y])\n\n            distances_to_centroid = np.linalg.norm(coords[customers] - centroid, axis=1)\n            sorted_indices = np.argsort(distances_to_centroid)\n            split_pos = len(sorted_indices) // 2\n\n            group1 = customers[sorted_indices[:split_pos]]\n            group2 = customers[sorted_indices[split_pos:]]\n\n            def create_route(nodes):\n                if len(nodes) == 0:\n                    return None\n                route = [0] + list(nodes) + [0]\n                return np.array(route)\n\n            route1 = create_route(group1)\n            route2 = create_route(group2)\n\n            if route1 is not None and sum(demand[node] for node in route1[1:-1]) <= capacity:\n                new_solution[route_idx] = route1\n                if route2 is not None and sum(demand[node] for node in route2[1:-1]) <= capacity:\n                    new_solution.insert(route_idx+1, route2)\n                else:\n                    for node in route2[1:-1]:\n                        inserted = False\n                        for i in range(len(new_solution)):\n                            if i != route_idx:\n                                temp_route = np.concatenate([new_solution[i][:-1], [node], [0]])\n                                if sum(demand[node] for node in temp_route[1:-1]) <= capacity:\n                                    new_solution[i] = temp_route\n                                    inserted = True\n                                    break\n                        if not inserted:\n                            new_route = np.array([0, node, 0])\n                            new_solution.insert(route_idx+1, new_route)\n            else:\n                for node in group1:\n                    inserted = False\n                    for i in range(len(new_solution)):\n                        if i != route_idx:\n                            temp_route = np.concatenate([new_solution[i][:-1], [node], [0]])\n                            if sum(demand[node] for node in temp_route[1:-1]) <= capacity:\n                                new_solution[i] = temp_route\n                                inserted = True\n                                break\n                    if not inserted:\n                        new_route = np.array([0, node, 0])\n                        new_solution.insert(route_idx+1, new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.9098305778624728,
            0.691712498664856
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: apply route splitting, reallocation, and merging\n    new_solution = []\n    for route in base_solution:\n        # Split route if it's too long\n        if len(route) > 5:  # Arbitrary threshold for splitting\n            split_idx = len(route) // 2\n            new_route1 = np.concatenate([route[:split_idx + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n            new_solution.extend([new_route1, new_route2])\n        else:\n            new_solution.append(route.copy())\n\n    # Reallocate customers from long routes to short routes\n    long_routes = [r for r in new_solution if sum(demand[r[1:-1]]) > capacity * 0.8]\n    short_routes = [r for r in new_solution if sum(demand[r[1:-1]]) < capacity * 0.5]\n\n    for long_route in long_routes:\n        for i in range(1, len(long_route) - 1):\n            customer = long_route[i]\n            customer_demand = demand[customer]\n            for short_route in short_routes:\n                if sum(demand[short_route[1:-1]]) + customer_demand <= capacity:\n                    # Insert customer into short route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for j in range(1, len(short_route)):\n                        insert_cost = distance_matrix[short_route[j-1], customer] + distance_matrix[customer, short_route[j]] - distance_matrix[short_route[j-1], short_route[j]]\n                        if insert_cost < min_increase:\n                            min_increase = insert_cost\n                            best_pos = j\n                    new_short_route = np.insert(short_route, best_pos, customer)\n                    short_route[:] = new_short_route\n                    long_route = np.delete(long_route, i)\n                    break\n\n    # Merge short routes if possible\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Only merge very short routes\n            merged = False\n            for i, existing in enumerate(merged_solution):\n                if sum(demand[existing[1:-1]]) + sum(demand[route[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([existing[:-1], route[1:]])\n                    merged_solution[i] = merged_route\n                    merged = True\n                    break\n            if not merged:\n                merged_solution.append(route.copy())\n        else:\n            merged_solution.append(route.copy())\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in merged_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Add missing customers to shortest routes\n    if missing_customers:\n        merged_solution.sort(key=lambda x: len(x))\n        for customer in missing_customers:\n            for route in merged_solution:\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for j in range(1, len(route)):\n                        insert_cost = distance_matrix[route[j-1], customer] + distance_matrix[customer, route[j]] - distance_matrix[route[j-1], route[j]]\n                        if insert_cost < min_increase:\n                            min_increase = insert_cost\n                            best_pos = j\n                    new_route = np.insert(route, best_pos, customer)\n                    route[:] = new_route\n                    break\n\n    return merged_solution\n\n",
        "score": [
            -0.8957855911433819,
            0.27881261706352234
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest makespan and applies a spatial and demand-aware route partitioning strategy that intelligently redistributes customers across routes by considering both geographic proximity and demand balance, using a hybrid of nearest-neighbor insertion and demand-constrained route splitting to optimize both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        selected_route = new_solution[route_idx]\n\n        if len(selected_route) > 3:\n            split_pos = random.randint(1, len(selected_route)-2)\n            route_a = selected_route[:split_pos+1]\n            route_b = np.concatenate([[0], selected_route[split_pos+1:]])\n\n            demand_a = sum(demand[node] for node in route_a)\n            demand_b = sum(demand[node] for node in route_b)\n\n            if demand_a <= capacity and demand_b <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                for i in range(1, len(selected_route)-1):\n                    customer = selected_route[i]\n                    for j in range(len(new_solution)):\n                        if j != route_idx:\n                            temp_route = np.concatenate([new_solution[j][:-1], [customer], [0]])\n                            if sum(demand[node] for node in temp_route) <= capacity:\n                                new_solution[j] = temp_route\n                                break\n\n    if len(new_solution) < len(base_solution):\n        for route in new_solution:\n            if len(route) > 3:\n                for i in range(1, len(route)-1):\n                    customer = route[i]\n                    nearest_depot = np.argmin(distance_matrix[customer, 0])\n                    if distance_matrix[customer, nearest_depot] < distance_matrix[customer, route[i-1]] + distance_matrix[customer, route[i+1]]:\n                        new_route = np.array([0, customer, 0])\n                        if sum(demand[node] for node in new_route) <= capacity:\n                            new_solution.append(new_route)\n                            route = np.delete(route, i)\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.7787419361979331,
            0.031175941228866577
        ]
    },
    {
        "algorithm": "{A novel demand-aware route decomposition and spatial clustering algorithm that intelligently partitions routes based on both demand patterns and spatial coherence, then reassigns customers to new routes using a hybrid of demand-balanced clustering and spatial proximity optimization to simultaneously improve both total distance and makespan objectives}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Select a route to decompose\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Calculate demand and spatial characteristics of the route\n        route_demand = sum(demand[node] for node in route[1:-1])\n        route_length = sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1))\n\n        # Calculate demand and spatial centroid of the route\n        route_nodes = route[1:-1]\n        centroid_x = np.mean(coords[route_nodes, 0])\n        centroid_y = np.mean(coords[route_nodes, 1])\n        centroid = np.array([centroid_x, centroid_y])\n\n        # Find customers closest to the centroid\n        distances_to_centroid = np.linalg.norm(coords[route_nodes] - centroid, axis=1)\n        sorted_indices = np.argsort(distances_to_centroid)\n        median_idx = len(sorted_indices) // 2\n\n        # Split the route at the median customer closest to centroid\n        split_pos = sorted_indices[median_idx] + 1  # +1 to account for route[0] being depot\n\n        # Create two new routes\n        route1 = route[:split_pos+1]\n        route2 = np.concatenate([[0], route[split_pos+1:]])\n\n        # Check capacity constraints\n        demand1 = sum(demand[node] for node in route1[1:-1])\n        demand2 = sum(demand[node] for node in route2[1:-1])\n\n        if demand1 <= capacity and demand2 <= capacity:\n            # Update solution with new routes\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to reassign customers to existing routes\n            for i in range(1, len(route)-1):\n                customer = route[i]\n                for j in range(len(new_solution)):\n                    if j != route_idx:\n                        temp_route = np.concatenate([new_solution[j][:-1], [customer], [0]])\n                        if sum(demand[node] for node in temp_route[1:-1]) <= capacity:\n                            new_solution[j] = temp_route\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.856831690880937,
            0.0636361837387085
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance and applies a spatial clustering and demand-balancing strategy that intelligently groups nearby customers while ensuring balanced demand distribution across routes, using a novel hybrid of k-means clustering and demand-aware route splitting to optimize both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        while route2_idx == route1_idx:\n            route2_idx = random.randint(0, len(new_solution)-1)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        total_demand_route1 = sum(demand[node] for node in route1[1:-1])\n        total_demand_route2 = sum(demand[node] for node in route2[1:-1])\n\n        if total_demand_route1 + total_demand_route2 <= capacity:\n            merged_route = [0]\n            i, j = 1, 1\n            while i < len(route1)-1 or j < len(route2)-1:\n                if i < len(route1)-1 and j < len(route2)-1:\n                    dist1 = distance_matrix[route1[i-1]][route1[i]]\n                    dist2 = distance_matrix[route2[j-1]][route2[j]]\n\n                    if dist1 < dist2:\n                        merged_route.append(route1[i])\n                        i += 1\n                    else:\n                        merged_route.append(route2[j])\n                        j += 1\n                elif i < len(route1)-1:\n                    merged_route.append(route1[i])\n                    i += 1\n                else:\n                    merged_route.append(route2[j])\n                    j += 1\n            merged_route.append(0)\n            new_solution[route1_idx] = np.array(merged_route)\n            del new_solution[route2_idx]\n        else:\n            if total_demand_route1 > total_demand_route2:\n                larger_route = route1\n                larger_idx = route1_idx\n            else:\n                larger_route = route2\n                larger_idx = route2_idx\n\n            if len(larger_route) > 3:\n                split_pos = random.randint(1, len(larger_route)-2)\n                route_a = larger_route[:split_pos+1]\n                route_b = np.concatenate([[0], larger_route[split_pos+1:]])\n\n                demand_a = sum(demand[node] for node in route_a)\n                demand_b = sum(demand[node] for node in route_b)\n\n                if demand_a <= capacity and demand_b <= capacity:\n                    new_solution[larger_idx] = route_a\n                    new_solution.insert(larger_idx+1, route_b)\n                else:\n                    for i in range(1, len(larger_route)-1):\n                        customer = larger_route[i]\n                        for j in range(len(new_solution)):\n                            if j != larger_idx:\n                                temp_route = np.concatenate([new_solution[j][:-1], [customer], [0]])\n                                if sum(demand[node] for node in temp_route) <= capacity:\n                                    new_solution[j] = temp_route\n                                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8804522748791661,
            0.03801226615905762
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance and applies a demand-aware route splitting and spatial rebalancing strategy that intelligently divides routes based on demand distribution and spatial proximity while dynamically adjusting route merges to optimize both total distance and makespan, but with a novel \"demand-flow alignment\" approach that prioritizes customer sequences that maximize demand utilization and minimize spatial detours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            demand_a = sum(demand[node] for node in route_a)\n            demand_b = sum(demand[node] for node in route_b)\n\n            if demand_a <= capacity and demand_b <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                nodes = route[1:-1]\n                new_route1 = [0]\n                new_route2 = [0]\n                current_demand1 = 0\n                current_demand2 = 0\n\n                for node in sorted(nodes, key=lambda x: (demand[x], coords[x][0])):\n                    if current_demand1 <= current_demand2:\n                        if current_demand1 + demand[node] <= capacity:\n                            new_route1.append(node)\n                            current_demand1 += demand[node]\n                    else:\n                        if current_demand2 + demand[node] <= capacity:\n                            new_route2.append(node)\n                            current_demand2 += demand[node]\n\n                if len(new_route1) > 1:\n                    new_route1.append(0)\n                    new_solution[route_idx] = np.array(new_route1)\n                if len(new_route2) > 1:\n                    new_route2.append(0)\n                    new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.8471544027105962,
            0.032080382108688354
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a \"capacity-aware route splitting\" operation that intelligently splits routes by prioritizing demand balance and spatial clustering, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                demand_a = sum(demand[node] for node in route_a[1:-1])\n                demand_b = sum(demand[node] for node in route_b[1:-1])\n\n                if demand_a > demand_b:\n                    larger_route, smaller_route = route_a, route_b\n                else:\n                    larger_route, smaller_route = route_b, route_a\n\n                if demand_a + demand_b <= capacity:\n                    new_solution[route_idx] = np.concatenate([larger_route[:-1], smaller_route[1:]])\n                else:\n                    nodes = list(larger_route[1:-1]) + list(smaller_route[1:-1])\n                    new_route1 = [0]\n                    new_route2 = [0]\n                    current_demand1 = 0\n                    current_demand2 = 0\n\n                    for node in nodes:\n                        if current_demand1 <= current_demand2:\n                            if current_demand1 + demand[node] <= capacity:\n                                new_route1.append(node)\n                                current_demand1 += demand[node]\n                        else:\n                            if current_demand2 + demand[node] <= capacity:\n                                new_route2.append(node)\n                                current_demand2 += demand[node]\n\n                    if len(new_route1) > 1:\n                        new_route1.append(0)\n                        new_solution[route_idx] = np.array(new_route1)\n                    if len(new_route2) > 1:\n                        new_route2.append(0)\n                        new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.7968783466732369,
            0.03118923306465149
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest makespan and applies a \"demand-centric spatial clustering\" operation that dynamically rebalances routes based on demand patterns and spatial cohesion, while ensuring feasibility through adaptive capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            demand_a = sum(demand[node] for node in route_a[1:-1])\n            demand_b = sum(demand[node] for node in route_b[1:-1])\n\n            if demand_a <= capacity and demand_b <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                nodes = list(route_a[1:-1]) + list(route_b[1:-1])\n                clusters = []\n                current_cluster = [nodes[0]]\n                current_demand = demand[nodes[0]]\n\n                for node in nodes[1:]:\n                    demand_ratio = (current_demand + demand[node]) / capacity\n                    spatial_score = np.mean([distance_matrix[node, n] for n in current_cluster])\n                    cohesion_score = spatial_score / (1 + abs(demand_ratio - 0.5))\n\n                    if (current_demand + demand[node] <= capacity) and (cohesion_score < 1.2 * np.mean(distance_matrix)):\n                        current_cluster.append(node)\n                        current_demand += demand[node]\n                    else:\n                        clusters.append(current_cluster)\n                        current_cluster = [node]\n                        current_demand = demand[node]\n\n                if current_cluster:\n                    clusters.append(current_cluster)\n\n                new_solution[route_idx] = np.array([0] + clusters[0] + [0])\n                for cluster in clusters[1:]:\n                    new_route = np.array([0] + cluster + [0])\n                    new_solution.insert(route_idx+1, new_route)\n\n    return new_solution\n\n",
        "score": [
            -0.793252973925807,
            0.030415624380111694
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance and applies a spatial clustering and demand-balancing strategy that intelligently groups nearby customers while ensuring balanced demand distribution across routes, using a novel hybrid of k-means clustering and demand-aware route splitting to optimize both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        while route2_idx == route1_idx:\n            route2_idx = random.randint(0, len(new_solution)-1)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        total_demand_route1 = sum(demand[node] for node in route1[1:-1])\n        total_demand_route2 = sum(demand[node] for node in route2[1:-1])\n\n        if total_demand_route1 + total_demand_route2 <= capacity:\n            merged_route = [0]\n            i, j = 1, 1\n            while i < len(route1)-1 or j < len(route2)-1:\n                if i < len(route1)-1 and j < len(route2)-1:\n                    dist1 = distance_matrix[route1[i-1]][route1[i]]\n                    dist2 = distance_matrix[route2[j-1]][route2[j]]\n\n                    if dist1 < dist2:\n                        merged_route.append(route1[i])\n                        i += 1\n                    else:\n                        merged_route.append(route2[j])\n                        j += 1\n                elif i < len(route1)-1:\n                    merged_route.append(route1[i])\n                    i += 1\n                else:\n                    merged_route.append(route2[j])\n                    j += 1\n            merged_route.append(0)\n            new_solution[route1_idx] = np.array(merged_route)\n            del new_solution[route2_idx]\n        else:\n            if total_demand_route1 > total_demand_route2:\n                larger_route = route1\n                larger_idx = route1_idx\n            else:\n                larger_route = route2\n                larger_idx = route2_idx\n\n            if len(larger_route) > 3:\n                split_pos = random.randint(1, len(larger_route)-2)\n                route_a = larger_route[:split_pos+1]\n                route_b = np.concatenate([[0], larger_route[split_pos+1:]])\n\n                demand_a = sum(demand[node] for node in route_a)\n                demand_b = sum(demand[node] for node in route_b)\n\n                if demand_a <= capacity and demand_b <= capacity:\n                    new_solution[larger_idx] = route_a\n                    new_solution.insert(larger_idx+1, route_b)\n                else:\n                    for i in range(1, len(larger_route)-1):\n                        customer = larger_route[i]\n                        for j in range(len(new_solution)):\n                            if j != larger_idx:\n                                temp_route = np.concatenate([new_solution[j][:-1], [customer], [0]])\n                                if sum(demand[node] for node in temp_route) <= capacity:\n                                    new_solution[j] = temp_route\n                                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8804522748791661,
            0.03801226615905762
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance and applies a demand-aware route splitting and spatial rebalancing strategy that intelligently divides routes based on demand distribution and spatial proximity while dynamically adjusting route merges to optimize both total distance and makespan, but with a novel \"demand-flow alignment\" approach that prioritizes customer sequences that maximize demand utilization and minimize spatial detours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            demand_a = sum(demand[node] for node in route_a)\n            demand_b = sum(demand[node] for node in route_b)\n\n            if demand_a <= capacity and demand_b <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                nodes = route[1:-1]\n                new_route1 = [0]\n                new_route2 = [0]\n                current_demand1 = 0\n                current_demand2 = 0\n\n                for node in sorted(nodes, key=lambda x: (demand[x], coords[x][0])):\n                    if current_demand1 <= current_demand2:\n                        if current_demand1 + demand[node] <= capacity:\n                            new_route1.append(node)\n                            current_demand1 += demand[node]\n                    else:\n                        if current_demand2 + demand[node] <= capacity:\n                            new_route2.append(node)\n                            current_demand2 += demand[node]\n\n                if len(new_route1) > 1:\n                    new_route1.append(0)\n                    new_solution[route_idx] = np.array(new_route1)\n                if len(new_route2) > 1:\n                    new_route2.append(0)\n                    new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.8471544027105962,
            0.032080382108688354
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a \"capacity-aware route splitting\" operation that intelligently splits routes by prioritizing demand balance and spatial clustering, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                demand_a = sum(demand[node] for node in route_a[1:-1])\n                demand_b = sum(demand[node] for node in route_b[1:-1])\n\n                if demand_a > demand_b:\n                    larger_route, smaller_route = route_a, route_b\n                else:\n                    larger_route, smaller_route = route_b, route_a\n\n                if demand_a + demand_b <= capacity:\n                    new_solution[route_idx] = np.concatenate([larger_route[:-1], smaller_route[1:]])\n                else:\n                    nodes = list(larger_route[1:-1]) + list(smaller_route[1:-1])\n                    new_route1 = [0]\n                    new_route2 = [0]\n                    current_demand1 = 0\n                    current_demand2 = 0\n\n                    for node in nodes:\n                        if current_demand1 <= current_demand2:\n                            if current_demand1 + demand[node] <= capacity:\n                                new_route1.append(node)\n                                current_demand1 += demand[node]\n                        else:\n                            if current_demand2 + demand[node] <= capacity:\n                                new_route2.append(node)\n                                current_demand2 += demand[node]\n\n                    if len(new_route1) > 1:\n                        new_route1.append(0)\n                        new_solution[route_idx] = np.array(new_route1)\n                    if len(new_route2) > 1:\n                        new_route2.append(0)\n                        new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.7968783466732369,
            0.03118923306465149
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance and applies a spatial clustering and demand-balancing strategy that intelligently groups nearby customers while ensuring balanced demand distribution across routes, using a novel hybrid of k-means clustering and demand-aware route splitting to optimize both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        while route2_idx == route1_idx:\n            route2_idx = random.randint(0, len(new_solution)-1)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        total_demand_route1 = sum(demand[node] for node in route1[1:-1])\n        total_demand_route2 = sum(demand[node] for node in route2[1:-1])\n\n        if total_demand_route1 + total_demand_route2 <= capacity:\n            merged_route = [0]\n            i, j = 1, 1\n            while i < len(route1)-1 or j < len(route2)-1:\n                if i < len(route1)-1 and j < len(route2)-1:\n                    dist1 = distance_matrix[route1[i-1]][route1[i]]\n                    dist2 = distance_matrix[route2[j-1]][route2[j]]\n\n                    if dist1 < dist2:\n                        merged_route.append(route1[i])\n                        i += 1\n                    else:\n                        merged_route.append(route2[j])\n                        j += 1\n                elif i < len(route1)-1:\n                    merged_route.append(route1[i])\n                    i += 1\n                else:\n                    merged_route.append(route2[j])\n                    j += 1\n            merged_route.append(0)\n            new_solution[route1_idx] = np.array(merged_route)\n            del new_solution[route2_idx]\n        else:\n            if total_demand_route1 > total_demand_route2:\n                larger_route = route1\n                larger_idx = route1_idx\n            else:\n                larger_route = route2\n                larger_idx = route2_idx\n\n            if len(larger_route) > 3:\n                split_pos = random.randint(1, len(larger_route)-2)\n                route_a = larger_route[:split_pos+1]\n                route_b = np.concatenate([[0], larger_route[split_pos+1:]])\n\n                demand_a = sum(demand[node] for node in route_a)\n                demand_b = sum(demand[node] for node in route_b)\n\n                if demand_a <= capacity and demand_b <= capacity:\n                    new_solution[larger_idx] = route_a\n                    new_solution.insert(larger_idx+1, route_b)\n                else:\n                    for i in range(1, len(larger_route)-1):\n                        customer = larger_route[i]\n                        for j in range(len(new_solution)):\n                            if j != larger_idx:\n                                temp_route = np.concatenate([new_solution[j][:-1], [customer], [0]])\n                                if sum(demand[node] for node in temp_route) <= capacity:\n                                    new_solution[j] = temp_route\n                                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8804522748791661,
            0.03801226615905762
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance and applies a demand-aware route splitting and spatial rebalancing strategy that intelligently divides routes based on demand distribution and spatial proximity while dynamically adjusting route merges to optimize both total distance and makespan, but with a novel \"demand-flow alignment\" approach that prioritizes customer sequences that maximize demand utilization and minimize spatial detours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            demand_a = sum(demand[node] for node in route_a)\n            demand_b = sum(demand[node] for node in route_b)\n\n            if demand_a <= capacity and demand_b <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                nodes = route[1:-1]\n                new_route1 = [0]\n                new_route2 = [0]\n                current_demand1 = 0\n                current_demand2 = 0\n\n                for node in sorted(nodes, key=lambda x: (demand[x], coords[x][0])):\n                    if current_demand1 <= current_demand2:\n                        if current_demand1 + demand[node] <= capacity:\n                            new_route1.append(node)\n                            current_demand1 += demand[node]\n                    else:\n                        if current_demand2 + demand[node] <= capacity:\n                            new_route2.append(node)\n                            current_demand2 += demand[node]\n\n                if len(new_route1) > 1:\n                    new_route1.append(0)\n                    new_solution[route_idx] = np.array(new_route1)\n                if len(new_route2) > 1:\n                    new_route2.append(0)\n                    new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.8471544027105962,
            0.032080382108688354
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a \"capacity-aware route splitting\" operation that intelligently splits routes by prioritizing demand balance and spatial clustering, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                demand_a = sum(demand[node] for node in route_a[1:-1])\n                demand_b = sum(demand[node] for node in route_b[1:-1])\n\n                if demand_a > demand_b:\n                    larger_route, smaller_route = route_a, route_b\n                else:\n                    larger_route, smaller_route = route_b, route_a\n\n                if demand_a + demand_b <= capacity:\n                    new_solution[route_idx] = np.concatenate([larger_route[:-1], smaller_route[1:]])\n                else:\n                    nodes = list(larger_route[1:-1]) + list(smaller_route[1:-1])\n                    new_route1 = [0]\n                    new_route2 = [0]\n                    current_demand1 = 0\n                    current_demand2 = 0\n\n                    for node in nodes:\n                        if current_demand1 <= current_demand2:\n                            if current_demand1 + demand[node] <= capacity:\n                                new_route1.append(node)\n                                current_demand1 += demand[node]\n                        else:\n                            if current_demand2 + demand[node] <= capacity:\n                                new_route2.append(node)\n                                current_demand2 += demand[node]\n\n                    if len(new_route1) > 1:\n                        new_route1.append(0)\n                        new_solution[route_idx] = np.array(new_route1)\n                    if len(new_route2) > 1:\n                        new_route2.append(0)\n                        new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.7968783466732369,
            0.03118923306465149
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance and applies a spatial clustering and demand-balancing strategy that intelligently groups nearby customers while ensuring balanced demand distribution across routes, using a novel hybrid of k-means clustering and demand-aware route splitting to optimize both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        while route2_idx == route1_idx:\n            route2_idx = random.randint(0, len(new_solution)-1)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        total_demand_route1 = sum(demand[node] for node in route1[1:-1])\n        total_demand_route2 = sum(demand[node] for node in route2[1:-1])\n\n        if total_demand_route1 + total_demand_route2 <= capacity:\n            merged_route = [0]\n            i, j = 1, 1\n            while i < len(route1)-1 or j < len(route2)-1:\n                if i < len(route1)-1 and j < len(route2)-1:\n                    dist1 = distance_matrix[route1[i-1]][route1[i]]\n                    dist2 = distance_matrix[route2[j-1]][route2[j]]\n\n                    if dist1 < dist2:\n                        merged_route.append(route1[i])\n                        i += 1\n                    else:\n                        merged_route.append(route2[j])\n                        j += 1\n                elif i < len(route1)-1:\n                    merged_route.append(route1[i])\n                    i += 1\n                else:\n                    merged_route.append(route2[j])\n                    j += 1\n            merged_route.append(0)\n            new_solution[route1_idx] = np.array(merged_route)\n            del new_solution[route2_idx]\n        else:\n            if total_demand_route1 > total_demand_route2:\n                larger_route = route1\n                larger_idx = route1_idx\n            else:\n                larger_route = route2\n                larger_idx = route2_idx\n\n            if len(larger_route) > 3:\n                split_pos = random.randint(1, len(larger_route)-2)\n                route_a = larger_route[:split_pos+1]\n                route_b = np.concatenate([[0], larger_route[split_pos+1:]])\n\n                demand_a = sum(demand[node] for node in route_a)\n                demand_b = sum(demand[node] for node in route_b)\n\n                if demand_a <= capacity and demand_b <= capacity:\n                    new_solution[larger_idx] = route_a\n                    new_solution.insert(larger_idx+1, route_b)\n                else:\n                    for i in range(1, len(larger_route)-1):\n                        customer = larger_route[i]\n                        for j in range(len(new_solution)):\n                            if j != larger_idx:\n                                temp_route = np.concatenate([new_solution[j][:-1], [customer], [0]])\n                                if sum(demand[node] for node in temp_route) <= capacity:\n                                    new_solution[j] = temp_route\n                                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8804522748791661,
            0.03801226615905762
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance and applies a demand-aware route splitting and spatial rebalancing strategy that intelligently divides routes based on demand distribution and spatial proximity while dynamically adjusting route merges to optimize both total distance and makespan, but with a novel \"demand-flow alignment\" approach that prioritizes customer sequences that maximize demand utilization and minimize spatial detours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            demand_a = sum(demand[node] for node in route_a)\n            demand_b = sum(demand[node] for node in route_b)\n\n            if demand_a <= capacity and demand_b <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                nodes = route[1:-1]\n                new_route1 = [0]\n                new_route2 = [0]\n                current_demand1 = 0\n                current_demand2 = 0\n\n                for node in sorted(nodes, key=lambda x: (demand[x], coords[x][0])):\n                    if current_demand1 <= current_demand2:\n                        if current_demand1 + demand[node] <= capacity:\n                            new_route1.append(node)\n                            current_demand1 += demand[node]\n                    else:\n                        if current_demand2 + demand[node] <= capacity:\n                            new_route2.append(node)\n                            current_demand2 += demand[node]\n\n                if len(new_route1) > 1:\n                    new_route1.append(0)\n                    new_solution[route_idx] = np.array(new_route1)\n                if len(new_route2) > 1:\n                    new_route2.append(0)\n                    new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.8471544027105962,
            0.032080382108688354
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a \"capacity-aware route splitting\" operation that intelligently splits routes by prioritizing demand balance and spatial clustering, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                demand_a = sum(demand[node] for node in route_a[1:-1])\n                demand_b = sum(demand[node] for node in route_b[1:-1])\n\n                if demand_a > demand_b:\n                    larger_route, smaller_route = route_a, route_b\n                else:\n                    larger_route, smaller_route = route_b, route_a\n\n                if demand_a + demand_b <= capacity:\n                    new_solution[route_idx] = np.concatenate([larger_route[:-1], smaller_route[1:]])\n                else:\n                    nodes = list(larger_route[1:-1]) + list(smaller_route[1:-1])\n                    new_route1 = [0]\n                    new_route2 = [0]\n                    current_demand1 = 0\n                    current_demand2 = 0\n\n                    for node in nodes:\n                        if current_demand1 <= current_demand2:\n                            if current_demand1 + demand[node] <= capacity:\n                                new_route1.append(node)\n                                current_demand1 += demand[node]\n                        else:\n                            if current_demand2 + demand[node] <= capacity:\n                                new_route2.append(node)\n                                current_demand2 += demand[node]\n\n                    if len(new_route1) > 1:\n                        new_route1.append(0)\n                        new_solution[route_idx] = np.array(new_route1)\n                    if len(new_route2) > 1:\n                        new_route2.append(0)\n                        new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.7968783466732369,
            0.03118923306465149
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a \"capacity-aware route splitting\" operation that intelligently splits routes by prioritizing demand balance and spatial clustering, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                demand_a = sum(demand[node] for node in route_a[1:-1])\n                demand_b = sum(demand[node] for node in route_b[1:-1])\n\n                if demand_a > demand_b:\n                    larger_route, smaller_route = route_a, route_b\n                else:\n                    larger_route, smaller_route = route_b, route_a\n\n                if demand_a + demand_b <= capacity:\n                    new_solution[route_idx] = np.concatenate([larger_route[:-1], smaller_route[1:]])\n                else:\n                    nodes = list(larger_route[1:-1]) + list(smaller_route[1:-1])\n                    new_route1 = [0]\n                    new_route2 = [0]\n                    current_demand1 = 0\n                    current_demand2 = 0\n\n                    for node in nodes:\n                        if current_demand1 <= current_demand2:\n                            if current_demand1 + demand[node] <= capacity:\n                                new_route1.append(node)\n                                current_demand1 += demand[node]\n                        else:\n                            if current_demand2 + demand[node] <= capacity:\n                                new_route2.append(node)\n                                current_demand2 += demand[node]\n\n                    if len(new_route1) > 1:\n                        new_route1.append(0)\n                        new_solution[route_idx] = np.array(new_route1)\n                    if len(new_route2) > 1:\n                        new_route2.append(0)\n                        new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.7968783466732369,
            0.03118923306465149
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance and applies a demand-aware route splitting and spatial rebalancing strategy that intelligently divides routes based on demand distribution and spatial proximity while dynamically adjusting route merges to optimize both total distance and makespan, but with a novel \"demand-flow alignment\" approach that prioritizes customer sequences that maximize demand utilization and minimize spatial detours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            demand_a = sum(demand[node] for node in route_a)\n            demand_b = sum(demand[node] for node in route_b)\n\n            if demand_a <= capacity and demand_b <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                nodes = route[1:-1]\n                new_route1 = [0]\n                new_route2 = [0]\n                current_demand1 = 0\n                current_demand2 = 0\n\n                for node in sorted(nodes, key=lambda x: (demand[x], coords[x][0])):\n                    if current_demand1 <= current_demand2:\n                        if current_demand1 + demand[node] <= capacity:\n                            new_route1.append(node)\n                            current_demand1 += demand[node]\n                    else:\n                        if current_demand2 + demand[node] <= capacity:\n                            new_route2.append(node)\n                            current_demand2 += demand[node]\n\n                if len(new_route1) > 1:\n                    new_route1.append(0)\n                    new_solution[route_idx] = np.array(new_route1)\n                if len(new_route2) > 1:\n                    new_route2.append(0)\n                    new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.8471544027105962,
            0.032080382108688354
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance and applies a spatial clustering and demand-balancing strategy that intelligently groups nearby customers while ensuring balanced demand distribution across routes, using a novel hybrid of k-means clustering and demand-aware route splitting to optimize both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        while route2_idx == route1_idx:\n            route2_idx = random.randint(0, len(new_solution)-1)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        total_demand_route1 = sum(demand[node] for node in route1[1:-1])\n        total_demand_route2 = sum(demand[node] for node in route2[1:-1])\n\n        if total_demand_route1 + total_demand_route2 <= capacity:\n            merged_route = [0]\n            i, j = 1, 1\n            while i < len(route1)-1 or j < len(route2)-1:\n                if i < len(route1)-1 and j < len(route2)-1:\n                    dist1 = distance_matrix[route1[i-1]][route1[i]]\n                    dist2 = distance_matrix[route2[j-1]][route2[j]]\n\n                    if dist1 < dist2:\n                        merged_route.append(route1[i])\n                        i += 1\n                    else:\n                        merged_route.append(route2[j])\n                        j += 1\n                elif i < len(route1)-1:\n                    merged_route.append(route1[i])\n                    i += 1\n                else:\n                    merged_route.append(route2[j])\n                    j += 1\n            merged_route.append(0)\n            new_solution[route1_idx] = np.array(merged_route)\n            del new_solution[route2_idx]\n        else:\n            if total_demand_route1 > total_demand_route2:\n                larger_route = route1\n                larger_idx = route1_idx\n            else:\n                larger_route = route2\n                larger_idx = route2_idx\n\n            if len(larger_route) > 3:\n                split_pos = random.randint(1, len(larger_route)-2)\n                route_a = larger_route[:split_pos+1]\n                route_b = np.concatenate([[0], larger_route[split_pos+1:]])\n\n                demand_a = sum(demand[node] for node in route_a)\n                demand_b = sum(demand[node] for node in route_b)\n\n                if demand_a <= capacity and demand_b <= capacity:\n                    new_solution[larger_idx] = route_a\n                    new_solution.insert(larger_idx+1, route_b)\n                else:\n                    for i in range(1, len(larger_route)-1):\n                        customer = larger_route[i]\n                        for j in range(len(new_solution)):\n                            if j != larger_idx:\n                                temp_route = np.concatenate([new_solution[j][:-1], [customer], [0]])\n                                if sum(demand[node] for node in temp_route) <= capacity:\n                                    new_solution[j] = temp_route\n                                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8804522748791661,
            0.03801226615905762
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a \"capacity-aware route splitting\" operation that intelligently splits routes by prioritizing demand balance and spatial clustering, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                demand_a = sum(demand[node] for node in route_a[1:-1])\n                demand_b = sum(demand[node] for node in route_b[1:-1])\n\n                if demand_a > demand_b:\n                    larger_route, smaller_route = route_a, route_b\n                else:\n                    larger_route, smaller_route = route_b, route_a\n\n                if demand_a + demand_b <= capacity:\n                    new_solution[route_idx] = np.concatenate([larger_route[:-1], smaller_route[1:]])\n                else:\n                    nodes = list(larger_route[1:-1]) + list(smaller_route[1:-1])\n                    new_route1 = [0]\n                    new_route2 = [0]\n                    current_demand1 = 0\n                    current_demand2 = 0\n\n                    for node in nodes:\n                        if current_demand1 <= current_demand2:\n                            if current_demand1 + demand[node] <= capacity:\n                                new_route1.append(node)\n                                current_demand1 += demand[node]\n                        else:\n                            if current_demand2 + demand[node] <= capacity:\n                                new_route2.append(node)\n                                current_demand2 += demand[node]\n\n                    if len(new_route1) > 1:\n                        new_route1.append(0)\n                        new_solution[route_idx] = np.array(new_route1)\n                    if len(new_route2) > 1:\n                        new_route2.append(0)\n                        new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.7968783466732369,
            0.03118923306465149
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a \"capacity-aware route splitting\" operation that intelligently splits routes by prioritizing demand balance and spatial clustering, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                demand_a = sum(demand[node] for node in route_a[1:-1])\n                demand_b = sum(demand[node] for node in route_b[1:-1])\n\n                if demand_a > demand_b:\n                    larger_route, smaller_route = route_a, route_b\n                else:\n                    larger_route, smaller_route = route_b, route_a\n\n                if demand_a + demand_b <= capacity:\n                    new_solution[route_idx] = np.concatenate([larger_route[:-1], smaller_route[1:]])\n                else:\n                    nodes = list(larger_route[1:-1]) + list(smaller_route[1:-1])\n                    new_route1 = [0]\n                    new_route2 = [0]\n                    current_demand1 = 0\n                    current_demand2 = 0\n\n                    for node in nodes:\n                        if current_demand1 <= current_demand2:\n                            if current_demand1 + demand[node] <= capacity:\n                                new_route1.append(node)\n                                current_demand1 += demand[node]\n                        else:\n                            if current_demand2 + demand[node] <= capacity:\n                                new_route2.append(node)\n                                current_demand2 += demand[node]\n\n                    if len(new_route1) > 1:\n                        new_route1.append(0)\n                        new_solution[route_idx] = np.array(new_route1)\n                    if len(new_route2) > 1:\n                        new_route2.append(0)\n                        new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.7968783466732369,
            0.03118923306465149
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a \"capacity-aware route splitting\" operation that intelligently splits routes by prioritizing demand balance and spatial clustering, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                demand_a = sum(demand[node] for node in route_a[1:-1])\n                demand_b = sum(demand[node] for node in route_b[1:-1])\n\n                if demand_a > demand_b:\n                    larger_route, smaller_route = route_a, route_b\n                else:\n                    larger_route, smaller_route = route_b, route_a\n\n                if demand_a + demand_b <= capacity:\n                    new_solution[route_idx] = np.concatenate([larger_route[:-1], smaller_route[1:]])\n                else:\n                    nodes = list(larger_route[1:-1]) + list(smaller_route[1:-1])\n                    new_route1 = [0]\n                    new_route2 = [0]\n                    current_demand1 = 0\n                    current_demand2 = 0\n\n                    for node in nodes:\n                        if current_demand1 <= current_demand2:\n                            if current_demand1 + demand[node] <= capacity:\n                                new_route1.append(node)\n                                current_demand1 += demand[node]\n                        else:\n                            if current_demand2 + demand[node] <= capacity:\n                                new_route2.append(node)\n                                current_demand2 += demand[node]\n\n                    if len(new_route1) > 1:\n                        new_route1.append(0)\n                        new_solution[route_idx] = np.array(new_route1)\n                    if len(new_route2) > 1:\n                        new_route2.append(0)\n                        new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.7968783466732369,
            0.03118923306465149
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a \"capacity-aware route splitting\" operation that intelligently splits routes by prioritizing demand balance and spatial clustering, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                demand_a = sum(demand[node] for node in route_a[1:-1])\n                demand_b = sum(demand[node] for node in route_b[1:-1])\n\n                if demand_a > demand_b:\n                    larger_route, smaller_route = route_a, route_b\n                else:\n                    larger_route, smaller_route = route_b, route_a\n\n                if demand_a + demand_b <= capacity:\n                    new_solution[route_idx] = np.concatenate([larger_route[:-1], smaller_route[1:]])\n                else:\n                    nodes = list(larger_route[1:-1]) + list(smaller_route[1:-1])\n                    new_route1 = [0]\n                    new_route2 = [0]\n                    current_demand1 = 0\n                    current_demand2 = 0\n\n                    for node in nodes:\n                        if current_demand1 <= current_demand2:\n                            if current_demand1 + demand[node] <= capacity:\n                                new_route1.append(node)\n                                current_demand1 += demand[node]\n                        else:\n                            if current_demand2 + demand[node] <= capacity:\n                                new_route2.append(node)\n                                current_demand2 += demand[node]\n\n                    if len(new_route1) > 1:\n                        new_route1.append(0)\n                        new_solution[route_idx] = np.array(new_route1)\n                    if len(new_route2) > 1:\n                        new_route2.append(0)\n                        new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.7968783466732369,
            0.03118923306465149
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a \"capacity-aware route splitting\" operation that intelligently splits routes by prioritizing demand balance and spatial clustering, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                demand_a = sum(demand[node] for node in route_a[1:-1])\n                demand_b = sum(demand[node] for node in route_b[1:-1])\n\n                if demand_a > demand_b:\n                    larger_route, smaller_route = route_a, route_b\n                else:\n                    larger_route, smaller_route = route_b, route_a\n\n                if demand_a + demand_b <= capacity:\n                    new_solution[route_idx] = np.concatenate([larger_route[:-1], smaller_route[1:]])\n                else:\n                    nodes = list(larger_route[1:-1]) + list(smaller_route[1:-1])\n                    new_route1 = [0]\n                    new_route2 = [0]\n                    current_demand1 = 0\n                    current_demand2 = 0\n\n                    for node in nodes:\n                        if current_demand1 <= current_demand2:\n                            if current_demand1 + demand[node] <= capacity:\n                                new_route1.append(node)\n                                current_demand1 += demand[node]\n                        else:\n                            if current_demand2 + demand[node] <= capacity:\n                                new_route2.append(node)\n                                current_demand2 += demand[node]\n\n                    if len(new_route1) > 1:\n                        new_route1.append(0)\n                        new_solution[route_idx] = np.array(new_route1)\n                    if len(new_route2) > 1:\n                        new_route2.append(0)\n                        new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.7968783466732369,
            0.03118923306465149
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a \"capacity-aware route splitting\" operation that intelligently splits routes by prioritizing demand balance and spatial clustering, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                demand_a = sum(demand[node] for node in route_a[1:-1])\n                demand_b = sum(demand[node] for node in route_b[1:-1])\n\n                if demand_a > demand_b:\n                    larger_route, smaller_route = route_a, route_b\n                else:\n                    larger_route, smaller_route = route_b, route_a\n\n                if demand_a + demand_b <= capacity:\n                    new_solution[route_idx] = np.concatenate([larger_route[:-1], smaller_route[1:]])\n                else:\n                    nodes = list(larger_route[1:-1]) + list(smaller_route[1:-1])\n                    new_route1 = [0]\n                    new_route2 = [0]\n                    current_demand1 = 0\n                    current_demand2 = 0\n\n                    for node in nodes:\n                        if current_demand1 <= current_demand2:\n                            if current_demand1 + demand[node] <= capacity:\n                                new_route1.append(node)\n                                current_demand1 += demand[node]\n                        else:\n                            if current_demand2 + demand[node] <= capacity:\n                                new_route2.append(node)\n                                current_demand2 += demand[node]\n\n                    if len(new_route1) > 1:\n                        new_route1.append(0)\n                        new_solution[route_idx] = np.array(new_route1)\n                    if len(new_route2) > 1:\n                        new_route2.append(0)\n                        new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.7968783466732369,
            0.03118923306465149
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a \"capacity-aware route splitting\" operation that intelligently splits routes by prioritizing demand balance and spatial clustering, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                demand_a = sum(demand[node] for node in route_a[1:-1])\n                demand_b = sum(demand[node] for node in route_b[1:-1])\n\n                if demand_a > demand_b:\n                    larger_route, smaller_route = route_a, route_b\n                else:\n                    larger_route, smaller_route = route_b, route_a\n\n                if demand_a + demand_b <= capacity:\n                    new_solution[route_idx] = np.concatenate([larger_route[:-1], smaller_route[1:]])\n                else:\n                    nodes = list(larger_route[1:-1]) + list(smaller_route[1:-1])\n                    new_route1 = [0]\n                    new_route2 = [0]\n                    current_demand1 = 0\n                    current_demand2 = 0\n\n                    for node in nodes:\n                        if current_demand1 <= current_demand2:\n                            if current_demand1 + demand[node] <= capacity:\n                                new_route1.append(node)\n                                current_demand1 += demand[node]\n                        else:\n                            if current_demand2 + demand[node] <= capacity:\n                                new_route2.append(node)\n                                current_demand2 += demand[node]\n\n                    if len(new_route1) > 1:\n                        new_route1.append(0)\n                        new_solution[route_idx] = np.array(new_route1)\n                    if len(new_route2) > 1:\n                        new_route2.append(0)\n                        new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.7968783466732369,
            0.03118923306465149
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a \"capacity-aware route splitting\" operation that intelligently splits routes by prioritizing demand balance and spatial clustering, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                demand_a = sum(demand[node] for node in route_a[1:-1])\n                demand_b = sum(demand[node] for node in route_b[1:-1])\n\n                if demand_a > demand_b:\n                    larger_route, smaller_route = route_a, route_b\n                else:\n                    larger_route, smaller_route = route_b, route_a\n\n                if demand_a + demand_b <= capacity:\n                    new_solution[route_idx] = np.concatenate([larger_route[:-1], smaller_route[1:]])\n                else:\n                    nodes = list(larger_route[1:-1]) + list(smaller_route[1:-1])\n                    new_route1 = [0]\n                    new_route2 = [0]\n                    current_demand1 = 0\n                    current_demand2 = 0\n\n                    for node in nodes:\n                        if current_demand1 <= current_demand2:\n                            if current_demand1 + demand[node] <= capacity:\n                                new_route1.append(node)\n                                current_demand1 += demand[node]\n                        else:\n                            if current_demand2 + demand[node] <= capacity:\n                                new_route2.append(node)\n                                current_demand2 += demand[node]\n\n                    if len(new_route1) > 1:\n                        new_route1.append(0)\n                        new_solution[route_idx] = np.array(new_route1)\n                    if len(new_route2) > 1:\n                        new_route2.append(0)\n                        new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.7968783466732369,
            0.03118923306465149
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a \"capacity-aware route splitting\" operation that intelligently splits routes by prioritizing demand balance and spatial clustering, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                demand_a = sum(demand[node] for node in route_a[1:-1])\n                demand_b = sum(demand[node] for node in route_b[1:-1])\n\n                if demand_a > demand_b:\n                    larger_route, smaller_route = route_a, route_b\n                else:\n                    larger_route, smaller_route = route_b, route_a\n\n                if demand_a + demand_b <= capacity:\n                    new_solution[route_idx] = np.concatenate([larger_route[:-1], smaller_route[1:]])\n                else:\n                    nodes = list(larger_route[1:-1]) + list(smaller_route[1:-1])\n                    new_route1 = [0]\n                    new_route2 = [0]\n                    current_demand1 = 0\n                    current_demand2 = 0\n\n                    for node in nodes:\n                        if current_demand1 <= current_demand2:\n                            if current_demand1 + demand[node] <= capacity:\n                                new_route1.append(node)\n                                current_demand1 += demand[node]\n                        else:\n                            if current_demand2 + demand[node] <= capacity:\n                                new_route2.append(node)\n                                current_demand2 += demand[node]\n\n                    if len(new_route1) > 1:\n                        new_route1.append(0)\n                        new_solution[route_idx] = np.array(new_route1)\n                    if len(new_route2) > 1:\n                        new_route2.append(0)\n                        new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.7968783466732369,
            0.03118923306465149
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    }
]