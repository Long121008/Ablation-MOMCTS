[
    {
        "algorithm": "{The algorithm selects a solution from the archive with the smallest makespan, then performs a hybrid local search combining route swapping and partial 2-opt, ensuring feasibility by checking vehicle capacities and route lengths after each move.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route swapping + partial 2-opt\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Check if swapping customers between routes is feasible\n        if len(route1) > 2 and len(route2) > 2:\n            # Select a random customer from each route (excluding depots)\n            cust1 = random.choice(route1[1:-1])\n            cust2 = random.choice(route2[1:-1])\n\n            # Check capacity constraints\n            load1 = sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n            load2 = sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n\n            if load1 <= capacity and load2 <= capacity:\n                # Perform the swap\n                idx1 = np.where(route1 == cust1)[0][0]\n                idx2 = np.where(route2 == cust2)[0][0]\n\n                route1[idx1], route2[idx2] = route2[idx2], route1[idx1]\n\n                # Update the solution\n                new_solution[route_indices[0]] = route1\n                new_solution[route_indices[1]] = route2\n\n        # Partial 2-opt on a randomly selected route\n        selected_route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[selected_route_idx]\n\n        if len(selected_route) > 4:\n            # Select two non-consecutive edges to reverse\n            i = random.randint(1, len(selected_route) - 3)\n            j = random.randint(i + 1, len(selected_route) - 2)\n\n            # Check capacity constraint for the reversed segment\n            segment = selected_route[i:j+1]\n            reversed_segment = segment[::-1]\n            new_load = sum(demand[segment]) if demand[reversed_segment[1]] <= capacity else float('inf')\n\n            if new_load <= capacity:\n                selected_route[i:j+1] = reversed_segment\n                new_solution[selected_route_idx] = selected_route\n\n    return new_solution\n\n",
        "score": [
            -0.40923940680242377,
            0.11219814419746399
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment swapping with demand-aware route merging to balance distance and makespan by intelligently reallocating customers between routes while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    for sol, _ in archive:\n        if selected_solution is None or len(sol) > len(selected_solution):\n            selected_solution = sol\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route segment swap with demand-aware merging\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx].copy()\n        route2 = new_solution[route2_idx].copy()\n\n        # Select a segment from route1 (excluding depot)\n        if len(route1) > 2:\n            start1 = random.randint(1, len(route1) - 2)\n            end1 = random.randint(start1, len(route1) - 2)\n            segment1 = route1[start1:end1 + 1]\n\n            # Check if segment can be inserted into route2 without exceeding capacity\n            segment_demand = sum(demand[node] for node in segment1)\n            if sum(demand[node] for node in route2) + segment_demand <= capacity:\n                # Insert segment into route2 (random position)\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment1, route2[insert_pos:]])\n\n                # Remove segment from route1\n                new_route1 = np.concatenate([route1[:start1], route1[end1 + 1:]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5504315372918394,
            0.18334552645683289
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment swapping with demand-aware route merging to balance distance and makespan by intelligently reallocating customers between routes while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    for sol, _ in archive:\n        if selected_solution is None or len(sol) > len(selected_solution):\n            selected_solution = sol\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route segment swap with demand-aware merging\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx].copy()\n        route2 = new_solution[route2_idx].copy()\n\n        # Select a segment from route1 (excluding depot)\n        if len(route1) > 2:\n            start1 = random.randint(1, len(route1) - 2)\n            end1 = random.randint(start1, len(route1) - 2)\n            segment1 = route1[start1:end1 + 1]\n\n            # Check if segment can be inserted into route2 without exceeding capacity\n            segment_demand = sum(demand[node] for node in segment1)\n            if sum(demand[node] for node in route2) + segment_demand <= capacity:\n                # Insert segment into route2 (random position)\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment1, route2[insert_pos:]])\n\n                # Remove segment from route1\n                new_route1 = np.concatenate([route1[:start1], route1[end1 + 1:]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5504315372918394,
            0.18334552645683289
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the smallest makespan, then performs a hybrid local search combining route swapping and partial 2-opt, ensuring feasibility by checking vehicle capacities and route lengths after each move.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route swapping + partial 2-opt\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Check if swapping customers between routes is feasible\n        if len(route1) > 2 and len(route2) > 2:\n            # Select a random customer from each route (excluding depots)\n            cust1 = random.choice(route1[1:-1])\n            cust2 = random.choice(route2[1:-1])\n\n            # Check capacity constraints\n            load1 = sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n            load2 = sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n\n            if load1 <= capacity and load2 <= capacity:\n                # Perform the swap\n                idx1 = np.where(route1 == cust1)[0][0]\n                idx2 = np.where(route2 == cust2)[0][0]\n\n                route1[idx1], route2[idx2] = route2[idx2], route1[idx1]\n\n                # Update the solution\n                new_solution[route_indices[0]] = route1\n                new_solution[route_indices[1]] = route2\n\n        # Partial 2-opt on a randomly selected route\n        selected_route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[selected_route_idx]\n\n        if len(selected_route) > 4:\n            # Select two non-consecutive edges to reverse\n            i = random.randint(1, len(selected_route) - 3)\n            j = random.randint(i + 1, len(selected_route) - 2)\n\n            # Check capacity constraint for the reversed segment\n            segment = selected_route[i:j+1]\n            reversed_segment = segment[::-1]\n            new_load = sum(demand[segment]) if demand[reversed_segment[1]] <= capacity else float('inf')\n\n            if new_load <= capacity:\n                selected_route[i:j+1] = reversed_segment\n                new_solution[selected_route_idx] = selected_route\n\n    return new_solution\n\n",
        "score": [
            -0.40923940680242377,
            0.11219814419746399
        ]
    }
]