[
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with adaptive route splitting to balance distance and makespan by intelligently redistributing customers while respecting capacity constraints and dynamically adjusting route structures based on demand patterns.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segment relocation and splitting\n    if len(new_solution) > 1:\n        # Select a random route with high demand concentration\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        if len(route) > 3:\n            # Identify the most demanding segment\n            demands = demand[route[1:-1]]\n            segment_start = 1\n            segment_end = len(route) - 2\n            max_demand = 0\n\n            for i in range(1, len(route) - 2):\n                current_demand = 0\n                for j in range(i, len(route) - 1):\n                    current_demand += demand[route[j]]\n                    if current_demand > max_demand and current_demand <= capacity:\n                        max_demand = current_demand\n                        segment_start = i\n                        segment_end = j\n\n            segment = route[segment_start:segment_end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Try to relocate the segment to another route\n            relocated = False\n            for other_idx in range(len(new_solution)):\n                if other_idx != route_idx:\n                    other_route = new_solution[other_idx].copy()\n                    other_demand = sum(demand[node] for node in other_route[1:-1])\n\n                    if other_demand + segment_demand <= capacity:\n                        # Insert segment into other route (random position)\n                        insert_pos = random.randint(1, len(other_route) - 1)\n                        new_other_route = np.concatenate([other_route[:insert_pos], segment, other_route[insert_pos:]])\n                        new_solution[other_idx] = new_other_route\n\n                        # Remove segment from original route\n                        new_route = np.concatenate([route[:segment_start], route[segment_end + 1:]])\n                        new_solution[route_idx] = new_route\n\n                        relocated = True\n                        break\n\n            # If relocation wasn't possible, consider splitting the route\n            if not relocated and len(route) > 4:\n                # Find a split point that balances demand\n                total_demand = sum(demand[node] for node in route[1:-1])\n                half_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= half_demand:\n                        split_pos = i\n                        break\n\n                # Create two new routes\n                route1 = np.concatenate([[0], route[1:split_pos + 1], [0]])\n                route2 = np.concatenate([[0], route[split_pos + 1:], [0]])\n\n                # Replace the original route with the two new routes\n                new_solution.pop(route_idx)\n                new_solution.insert(route_idx, route2)\n                new_solution.insert(route_idx, route1)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.813587378359627,
            0.11050030589103699
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment reversal with capacity-aware route splitting to improve both distance and makespan objectives by strategically reversing segments and splitting routes while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    for sol, _ in archive:\n        if selected_solution is None or len(sol) > len(selected_solution):\n            selected_solution = sol\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route segment reversal with capacity-aware splitting\n    if len(new_solution) > 0:\n        # Select a random route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        if len(route) > 3:  # Need at least 3 nodes to reverse a segment\n            # Select a segment to reverse (excluding depot)\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n\n            # Reverse the segment\n            reversed_segment = route[start:end+1][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end+1:]])\n\n            # Check if the reversed route exceeds capacity\n            current_demand = sum(demand[node] for node in new_route)\n            if current_demand <= capacity:\n                new_solution[route_idx] = new_route\n            else:\n                # If capacity is exceeded, split the route\n                split_pos = start\n                while split_pos > 1 and sum(demand[node] for node in new_route[:split_pos]) + sum(demand[node] for node in new_route[split_pos:]) > capacity:\n                    split_pos -= 1\n\n                if split_pos > 1:\n                    # Create two new routes\n                    route1 = np.concatenate([[0], new_route[1:split_pos], [0]])\n                    route2 = np.concatenate([[0], new_route[split_pos:], [0]])\n\n                    # Update solution\n                    new_solution.pop(route_idx)\n                    new_solution.append(route1)\n                    new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.455235533705558,
            0.10044851899147034
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: apply route splitting, reallocation, and merging\n    new_solution = []\n    for route in base_solution:\n        # Split route if it's too long\n        if len(route) > 5:  # Arbitrary threshold for splitting\n            split_idx = len(route) // 2\n            new_route1 = np.concatenate([route[:split_idx + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n            new_solution.extend([new_route1, new_route2])\n        else:\n            new_solution.append(route.copy())\n\n    # Reallocate customers from long routes to short routes\n    long_routes = [r for r in new_solution if sum(demand[r[1:-1]]) > capacity * 0.8]\n    short_routes = [r for r in new_solution if sum(demand[r[1:-1]]) < capacity * 0.5]\n\n    for long_route in long_routes:\n        for i in range(1, len(long_route) - 1):\n            customer = long_route[i]\n            customer_demand = demand[customer]\n            for short_route in short_routes:\n                if sum(demand[short_route[1:-1]]) + customer_demand <= capacity:\n                    # Insert customer into short route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for j in range(1, len(short_route)):\n                        insert_cost = distance_matrix[short_route[j-1], customer] + distance_matrix[customer, short_route[j]] - distance_matrix[short_route[j-1], short_route[j]]\n                        if insert_cost < min_increase:\n                            min_increase = insert_cost\n                            best_pos = j\n                    new_short_route = np.insert(short_route, best_pos, customer)\n                    short_route[:] = new_short_route\n                    long_route = np.delete(long_route, i)\n                    break\n\n    # Merge short routes if possible\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Only merge very short routes\n            merged = False\n            for i, existing in enumerate(merged_solution):\n                if sum(demand[existing[1:-1]]) + sum(demand[route[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([existing[:-1], route[1:]])\n                    merged_solution[i] = merged_route\n                    merged = True\n                    break\n            if not merged:\n                merged_solution.append(route.copy())\n        else:\n            merged_solution.append(route.copy())\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in merged_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Add missing customers to shortest routes\n    if missing_customers:\n        merged_solution.sort(key=lambda x: len(x))\n        for customer in missing_customers:\n            for route in merged_solution:\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for j in range(1, len(route)):\n                        insert_cost = distance_matrix[route[j-1], customer] + distance_matrix[customer, route[j]] - distance_matrix[route[j-1], route[j]]\n                        if insert_cost < min_increase:\n                            min_increase = insert_cost\n                            best_pos = j\n                    new_route = np.insert(route, best_pos, customer)\n                    route[:] = new_route\n                    break\n\n    return merged_solution\n\n",
        "score": [
            -0.8957855911433819,
            0.27881261706352234
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the smallest total distance, then performs a hybrid local search combining route merging and split insertion, ensuring feasibility by checking vehicle capacities and route lengths after each move.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Hybrid local search: route merging + split insertion\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Check if merging routes is feasible\n        merged_load = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if merged_load <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route_indices[0]] = merged_route\n            new_solution.pop(route_indices[1])\n        else:\n            # Split insertion: move a segment from one route to another\n            if len(route1) > 3 and len(route2) > 2:\n                i = random.randint(1, len(route1) - 3)\n                j = random.randint(i + 1, len(route1) - 2)\n\n                segment = route1[i:j+1]\n                segment_load = sum(demand[segment[1:-1]])\n\n                if segment_load <= capacity:\n                    # Check if inserting the segment into route2 is feasible\n                    if sum(demand[route2[1:-1]]) + segment_load <= capacity:\n                        # Insert the segment into route2 at a random position\n                        insert_pos = random.randint(1, len(route2) - 1)\n                        new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                        new_solution[route_indices[1]] = new_route2\n\n                        # Remove the segment from route1\n                        new_route1 = np.concatenate([route1[:i], route1[j+1:]])\n                        new_solution[route_indices[0]] = new_route1\n\n    return new_solution\n\n",
        "score": [
            -0.653662150499426,
            0.1822623908519745
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that combines adaptive route splitting with distance-aware customer reallocation to balance distance and makespan by dynamically partitioning routes and strategically redistributing customers based on spatial proximity and demand constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Adaptive route splitting\n    if len(new_solution) > 1:\n        # Select the longest route\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx].copy()\n\n        # Find split points based on spatial clustering\n        if len(longest_route) > 4:\n            # Calculate centroids of route segments\n            centroids = []\n            for i in range(1, len(longest_route)-1):\n                centroid = np.mean([coords[node] for node in longest_route[i:i+2]], axis=0)\n                centroids.append((i, centroid))\n\n            # Find the most distant segment from route centroid\n            route_centroid = np.mean([coords[node] for node in longest_route[1:-1]], axis=0)\n            split_pos = max(centroids, key=lambda x: np.linalg.norm(x[1] - route_centroid))[0]\n\n            # Split the route\n            route_part1 = np.concatenate([longest_route[:split_pos+1], [0]])\n            route_part2 = np.concatenate([[0], longest_route[split_pos+1:]])\n\n            # Replace in solution\n            new_solution[longest_route_idx] = route_part1\n            new_solution.append(route_part2)\n\n    # Distance-aware customer reallocation\n    if len(new_solution) > 1:\n        # Select a random route to modify\n        route_idx = random.randint(0, len(new_solution)-1)\n        current_route = new_solution[route_idx].copy()\n\n        if len(current_route) > 3:\n            # Find the customer with highest detour potential\n            max_detour = -1\n            best_customer = None\n            best_new_route = None\n\n            for i in range(1, len(current_route)-1):\n                customer = current_route[i]\n                # Calculate detour if removed\n                prev_node = current_route[i-1]\n                next_node = current_route[i+1]\n                detour = distance_matrix[prev_node][next_node] - (distance_matrix[prev_node][customer] + distance_matrix[customer][next_node])\n\n                if detour > max_detour:\n                    # Check if can be inserted into another route\n                    for j in range(len(new_solution)):\n                        if j != route_idx:\n                            target_route = new_solution[j].copy()\n                            if sum(demand[node] for node in target_route) + demand[customer] <= capacity:\n                                # Find best insertion position (minimum insertion cost)\n                                min_cost = float('inf')\n                                best_pos = 1\n                                for k in range(1, len(target_route)):\n                                    cost = (distance_matrix[target_route[k-1]][customer] +\n                                            distance_matrix[customer][target_route[k]] -\n                                            distance_matrix[target_route[k-1]][target_route[k]])\n                                    if cost < min_cost:\n                                        min_cost = cost\n                                        best_pos = k\n\n                                if min_cost < 0:  # Only consider beneficial insertions\n                                    max_detour = detour\n                                    best_customer = customer\n                                    best_new_route = (j, best_pos)\n\n            if best_customer is not None:\n                # Perform the reallocation\n                target_route_idx, insert_pos = best_new_route\n                target_route = new_solution[target_route_idx].copy()\n\n                # Remove from current route\n                customer_pos = np.where(current_route == best_customer)[0][0]\n                new_current_route = np.concatenate([current_route[:customer_pos], current_route[customer_pos+1:]])\n\n                # Insert into target route\n                new_target_route = np.concatenate([target_route[:insert_pos], [best_customer], target_route[insert_pos:]])\n\n                # Update solution\n                new_solution[route_idx] = new_current_route\n                new_solution[target_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8821999505802749,
            1.432770013809204
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the smallest makespan, then performs a hybrid local search combining route swapping and partial 2-opt, ensuring feasibility by checking vehicle capacities and route lengths after each move.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Hybrid local search: route swapping + partial 2-opt\n    if len(new_solution) > 1:\n        # Randomly select two routes\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Check if swapping customers between routes is feasible\n        if len(route1) > 2 and len(route2) > 2:\n            # Select a random customer from each route (excluding depots)\n            cust1 = random.choice(route1[1:-1])\n            cust2 = random.choice(route2[1:-1])\n\n            # Check capacity constraints\n            load1 = sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n            load2 = sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n\n            if load1 <= capacity and load2 <= capacity:\n                # Perform the swap\n                idx1 = np.where(route1 == cust1)[0][0]\n                idx2 = np.where(route2 == cust2)[0][0]\n\n                route1[idx1], route2[idx2] = route2[idx2], route1[idx1]\n\n                # Update the solution\n                new_solution[route_indices[0]] = route1\n                new_solution[route_indices[1]] = route2\n\n        # Partial 2-opt on a randomly selected route\n        selected_route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[selected_route_idx]\n\n        if len(selected_route) > 4:\n            # Select two non-consecutive edges to reverse\n            i = random.randint(1, len(selected_route) - 3)\n            j = random.randint(i + 1, len(selected_route) - 2)\n\n            # Check capacity constraint for the reversed segment\n            segment = selected_route[i:j+1]\n            reversed_segment = segment[::-1]\n            new_load = sum(demand[segment]) if demand[reversed_segment[1]] <= capacity else float('inf')\n\n            if new_load <= capacity:\n                selected_route[i:j+1] = reversed_segment\n                new_solution[selected_route_idx] = selected_route\n\n    return new_solution\n\n",
        "score": [
            -0.40923940680242377,
            0.11219814419746399
        ]
    },
    {
        "algorithm": "{A novel local search strategy that combines adaptive route splitting with demand-balanced route merging, prioritizing high-demand nodes in underutilized routes while minimizing both total distance and makespan through intelligent node reallocation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Adaptive route splitting: split the longest route if it's significantly longer than others\n    if len(new_solution) > 1:\n        route_lengths = [sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        max_length = max(route_lengths)\n        avg_length = sum(route_lengths) / len(route_lengths)\n\n        if max_length > 1.5 * avg_length:\n            longest_route_idx = route_lengths.index(max_length)\n            longest_route = new_solution[longest_route_idx]\n\n            # Find the split point that balances demand and distance\n            total_demand = sum(demand[node] for node in longest_route[1:-1])\n            half_demand = total_demand / 2\n            cumulative_demand = 0\n            split_pos = 1\n\n            for i in range(1, len(longest_route)-1):\n                cumulative_demand += demand[longest_route[i]]\n                if cumulative_demand >= half_demand:\n                    split_pos = i\n                    break\n\n            # Split the route\n            new_route1 = np.concatenate([longest_route[:split_pos+1], [0]])\n            new_route2 = np.concatenate([[0], longest_route[split_pos+1:]])\n\n            # Replace the original route with the two new routes\n            new_solution.pop(longest_route_idx)\n            new_solution.append(new_route1)\n            new_solution.append(new_route2)\n\n    # Demand-balanced route merging: merge routes with complementary demands\n    if len(new_solution) > 1:\n        route_demands = [sum(demand[node] for node in route[1:-1]) for route in new_solution]\n        sorted_indices = sorted(range(len(route_demands)), key=lambda i: route_demands[i])\n\n        for i in range(len(sorted_indices)-1):\n            for j in range(i+1, len(sorted_indices)):\n                route1_idx = sorted_indices[i]\n                route2_idx = sorted_indices[j]\n                route1 = new_solution[route1_idx]\n                route2 = new_solution[route2_idx]\n\n                # Check if merging these routes would not exceed capacity\n                if route_demands[route1_idx] + route_demands[route2_idx] <= capacity:\n                    # Check if merging would reduce makespan\n                    route1_length = sum(distance_matrix[route1[k]][route1[k+1]] for k in range(len(route1)-1))\n                    route2_length = sum(distance_matrix[route2[k]][route2[k+1]] for k in range(len(route2)-1))\n                    merged_length = route1_length + route2_length - distance_matrix[route1[-2]][0] - distance_matrix[0][route2[1]]\n\n                    if max(route1_length, route2_length) > merged_length:\n                        # Merge the routes\n                        merged_route = np.concatenate([route1[:-1], route2[1:]])\n                        new_solution[route1_idx] = merged_route\n                        new_solution.pop(route2_idx)\n\n                        # Update demands and break inner loop\n                        route_demands[route1_idx] += route_demands[route2_idx]\n                        route_demands.pop(route2_idx)\n                        sorted_indices = sorted(range(len(route_demands)), key=lambda i: route_demands[i])\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7676457815064474,
            1.3465095162391663
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment swapping with demand-aware route merging to balance distance and makespan by intelligently reallocating customers between routes while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = None\n    for sol, _ in archive:\n        if selected_solution is None or len(sol) > len(selected_solution):\n            selected_solution = sol\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route segment swap with demand-aware merging\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx].copy()\n        route2 = new_solution[route2_idx].copy()\n\n        # Select a segment from route1 (excluding depot)\n        if len(route1) > 2:\n            start1 = random.randint(1, len(route1) - 2)\n            end1 = random.randint(start1, len(route1) - 2)\n            segment1 = route1[start1:end1 + 1]\n\n            # Check if segment can be inserted into route2 without exceeding capacity\n            segment_demand = sum(demand[node] for node in segment1)\n            if sum(demand[node] for node in route2) + segment_demand <= capacity:\n                # Insert segment into route2 (random position)\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment1, route2[insert_pos:]])\n\n                # Remove segment from route1\n                new_route1 = np.concatenate([route1[:start1], route1[end1 + 1:]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.5504315372918394,
            0.18334552645683289
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the smallest makespan, then performs a novel local search combining route splitting, customer reinsertion with backtracking, and route merging, ensuring feasibility by checking vehicle capacities and route lengths after each move.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Route splitting: Select a route and split it into two\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route) - 2)\n            new_route1 = np.concatenate((route[:split_pos + 1], [0]))\n            new_route2 = np.concatenate(([0], route[split_pos + 1:]))\n\n            # Check capacity constraints\n            load1 = sum(demand[new_route1[1:-1]])\n            load2 = sum(demand[new_route2[1:-1]])\n\n            if load1 <= capacity and load2 <= capacity:\n                new_solution[route_idx] = new_route1\n                new_solution.insert(route_idx + 1, new_route2)\n\n        # Customer reinsertion with backtracking\n        for _ in range(2):\n            if len(new_solution) > 1:\n                source_route_idx = random.randint(0, len(new_solution) - 1)\n                source_route = new_solution[source_route_idx]\n\n                if len(source_route) > 2:\n                    cust_idx = random.randint(1, len(source_route) - 2)\n                    customer = source_route[cust_idx]\n\n                    # Remove customer from source route\n                    new_source_route = np.concatenate((source_route[:cust_idx], source_route[cust_idx + 1:]))\n                    load_source = sum(demand[new_source_route[1:-1]])\n\n                    if load_source <= capacity:\n                        new_solution[source_route_idx] = new_source_route\n\n                        # Try inserting into other routes\n                        best_insertion = None\n                        best_cost = float('inf')\n\n                        for target_route_idx in range(len(new_solution)):\n                            if target_route_idx == source_route_idx:\n                                continue\n\n                            target_route = new_solution[target_route_idx]\n                            load_target = sum(demand[target_route[1:-1]])\n\n                            if load_target + demand[customer] <= capacity:\n                                # Try inserting at all possible positions\n                                for pos in range(1, len(target_route)):\n                                    new_target_route = np.concatenate((target_route[:pos], [customer], target_route[pos:]))\n                                    new_load = sum(demand[new_target_route[1:-1]])\n\n                                    if new_load <= capacity:\n                                        # Calculate insertion cost\n                                        prev_node = new_target_route[pos - 1]\n                                        next_node = new_target_route[pos + 1]\n                                        insertion_cost = distance_matrix[prev_node][customer] + distance_matrix[customer][next_node] - distance_matrix[prev_node][next_node]\n\n                                        if insertion_cost < best_cost:\n                                            best_cost = insertion_cost\n                                            best_insertion = (target_route_idx, new_target_route.copy())\n\n                        if best_insertion is not None:\n                            target_route_idx, best_route = best_insertion\n                            new_solution[target_route_idx] = best_route\n                        else:\n                            # If no valid insertion, put back the customer\n                            new_solution[source_route_idx] = source_route\n\n        # Route merging: Try to merge two routes\n        if len(new_solution) > 1:\n            route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n            route1 = new_solution[route1_idx]\n            route2 = new_solution[route2_idx]\n\n            # Check if merging is possible\n            total_load = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n            if total_load <= capacity:\n                # Create merged route\n                merged_route = np.concatenate((route1[:-1], route2[1:]))\n\n                # Check if the merged route is feasible\n                if len(merged_route) > 2:\n                    new_solution.pop(max(route1_idx, route2_idx))\n                    new_solution[min(route1_idx, route2_idx)] = merged_route\n\n    return new_solution\n\n",
        "score": [
            -0.570139205843343,
            0.8778406977653503
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][1], x[1][0]))[0].copy()\n\n    # Apply a hybrid local search: route splitting and customer reallocation\n    new_solution = []\n    for route in selected_solution:\n        # Split long routes if they exceed a threshold (e.g., 1.5x average makespan)\n        avg_makespan = np.mean([len(r) for r in selected_solution])\n        if len(route) > 1.5 * avg_makespan:\n            # Split the route into two parts\n            split_idx = len(route) // 2\n            new_solution.append(route[:split_idx + 1])  # +1 to include the depot\n            new_solution.append(route[split_idx:])      # Already includes the depot\n        else:\n            new_solution.append(route.copy())\n\n    # Reallocate customers between routes to balance makespan\n    for i in range(len(new_solution)):\n        for j in range(len(new_solution)):\n            if i != j:\n                # Try moving a customer from route i to route j if it improves makespan\n                for k in range(1, len(new_solution[i]) - 1):  # Skip depots\n                    customer = new_solution[i][k]\n                    # Check if moving this customer to route j is feasible\n                    if sum(demand[new_solution[j][1:-1]]) + demand[customer] <= capacity:\n                        # Calculate potential makespan improvement\n                        current_makespan = max(len(r) for r in new_solution)\n                        new_route_j = np.concatenate([new_solution[j][:-1], [customer], [0]])\n                        new_route_i = np.concatenate([new_solution[i][:k], new_solution[i][k+1:]])\n                        new_makespan = max(len(new_route_i), len(new_route_j))\n                        if new_makespan < current_makespan:\n                            # Perform the move\n                            new_solution[i] = new_route_i\n                            new_solution[j] = new_route_j\n                            break  # Move to next route after improvement\n\n    # Remove empty routes\n    new_solution = [r for r in new_solution if len(r) > 2]  # Routes must have at least depot-depot\n\n    # Ensure all customers are served\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])  # Exclude depots\n    all_customers = set(range(1, len(demand)))  # Exclude depot\n    if served_customers != all_customers:\n        # If some customers are missing, reinsert them into the shortest route\n        missing = all_customers - served_customers\n        for customer in missing:\n            shortest_route_idx = np.argmin([len(r) for r in new_solution])\n            if sum(demand[new_solution[shortest_route_idx][1:-1]]) + demand[customer] <= capacity:\n                new_solution[shortest_route_idx] = np.concatenate([new_solution[shortest_route_idx][:-1], [customer], [0]])\n\n    return new_solution\n\n",
        "score": [
            -0.7127160605574193,
            4.257017225027084
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: apply route splitting, reallocation, and merging\n    new_solution = []\n    for route in base_solution:\n        # Split route if it's too long\n        if len(route) > 5:  # Arbitrary threshold for splitting\n            split_idx = len(route) // 2\n            new_route1 = np.concatenate([route[:split_idx + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n            new_solution.extend([new_route1, new_route2])\n        else:\n            new_solution.append(route.copy())\n\n    # Reallocate customers from long routes to short routes\n    long_routes = [r for r in new_solution if sum(demand[r[1:-1]]) > capacity * 0.8]\n    short_routes = [r for r in new_solution if sum(demand[r[1:-1]]) < capacity * 0.5]\n\n    for long_route in long_routes:\n        for i in range(1, len(long_route) - 1):\n            customer = long_route[i]\n            customer_demand = demand[customer]\n            for short_route in short_routes:\n                if sum(demand[short_route[1:-1]]) + customer_demand <= capacity:\n                    # Insert customer into short route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for j in range(1, len(short_route)):\n                        insert_cost = distance_matrix[short_route[j-1], customer] + distance_matrix[customer, short_route[j]] - distance_matrix[short_route[j-1], short_route[j]]\n                        if insert_cost < min_increase:\n                            min_increase = insert_cost\n                            best_pos = j\n                    new_short_route = np.insert(short_route, best_pos, customer)\n                    short_route[:] = new_short_route\n                    long_route = np.delete(long_route, i)\n                    break\n\n    # Merge short routes if possible\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Only merge very short routes\n            merged = False\n            for i, existing in enumerate(merged_solution):\n                if sum(demand[existing[1:-1]]) + sum(demand[route[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([existing[:-1], route[1:]])\n                    merged_solution[i] = merged_route\n                    merged = True\n                    break\n            if not merged:\n                merged_solution.append(route.copy())\n        else:\n            merged_solution.append(route.copy())\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in merged_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Add missing customers to shortest routes\n    if missing_customers:\n        merged_solution.sort(key=lambda x: len(x))\n        for customer in missing_customers:\n            for route in merged_solution:\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for j in range(1, len(route)):\n                        insert_cost = distance_matrix[route[j-1], customer] + distance_matrix[customer, route[j]] - distance_matrix[route[j-1], route[j]]\n                        if insert_cost < min_increase:\n                            min_increase = insert_cost\n                            best_pos = j\n                    new_route = np.insert(route, best_pos, customer)\n                    route[:] = new_route\n                    break\n\n    return merged_solution\n\n",
        "score": [
            -0.8957855911433819,
            0.27881261706352234
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment reversal with capacity-aware route splitting to improve both distance and makespan objectives by strategically reversing segments and splitting routes while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    for sol, _ in archive:\n        if selected_solution is None or len(sol) > len(selected_solution):\n            selected_solution = sol\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route segment reversal with capacity-aware splitting\n    if len(new_solution) > 0:\n        # Select a random route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        if len(route) > 3:  # Need at least 3 nodes to reverse a segment\n            # Select a segment to reverse (excluding depot)\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n\n            # Reverse the segment\n            reversed_segment = route[start:end+1][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end+1:]])\n\n            # Check if the reversed route exceeds capacity\n            current_demand = sum(demand[node] for node in new_route)\n            if current_demand <= capacity:\n                new_solution[route_idx] = new_route\n            else:\n                # If capacity is exceeded, split the route\n                split_pos = start\n                while split_pos > 1 and sum(demand[node] for node in new_route[:split_pos]) + sum(demand[node] for node in new_route[split_pos:]) > capacity:\n                    split_pos -= 1\n\n                if split_pos > 1:\n                    # Create two new routes\n                    route1 = np.concatenate([[0], new_route[1:split_pos], [0]])\n                    route2 = np.concatenate([[0], new_route[split_pos:], [0]])\n\n                    # Update solution\n                    new_solution.pop(route_idx)\n                    new_solution.append(route1)\n                    new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.455235533705558,
            0.10044851899147034
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with adaptive route splitting to balance distance and makespan by intelligently redistributing customers while respecting capacity constraints and dynamically adjusting route structures based on demand patterns.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segment relocation and splitting\n    if len(new_solution) > 1:\n        # Select a random route with high demand concentration\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        if len(route) > 3:\n            # Identify the most demanding segment\n            demands = demand[route[1:-1]]\n            segment_start = 1\n            segment_end = len(route) - 2\n            max_demand = 0\n\n            for i in range(1, len(route) - 2):\n                current_demand = 0\n                for j in range(i, len(route) - 1):\n                    current_demand += demand[route[j]]\n                    if current_demand > max_demand and current_demand <= capacity:\n                        max_demand = current_demand\n                        segment_start = i\n                        segment_end = j\n\n            segment = route[segment_start:segment_end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Try to relocate the segment to another route\n            relocated = False\n            for other_idx in range(len(new_solution)):\n                if other_idx != route_idx:\n                    other_route = new_solution[other_idx].copy()\n                    other_demand = sum(demand[node] for node in other_route[1:-1])\n\n                    if other_demand + segment_demand <= capacity:\n                        # Insert segment into other route (random position)\n                        insert_pos = random.randint(1, len(other_route) - 1)\n                        new_other_route = np.concatenate([other_route[:insert_pos], segment, other_route[insert_pos:]])\n                        new_solution[other_idx] = new_other_route\n\n                        # Remove segment from original route\n                        new_route = np.concatenate([route[:segment_start], route[segment_end + 1:]])\n                        new_solution[route_idx] = new_route\n\n                        relocated = True\n                        break\n\n            # If relocation wasn't possible, consider splitting the route\n            if not relocated and len(route) > 4:\n                # Find a split point that balances demand\n                total_demand = sum(demand[node] for node in route[1:-1])\n                half_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= half_demand:\n                        split_pos = i\n                        break\n\n                # Create two new routes\n                route1 = np.concatenate([[0], route[1:split_pos + 1], [0]])\n                route2 = np.concatenate([[0], route[split_pos + 1:], [0]])\n\n                # Replace the original route with the two new routes\n                new_solution.pop(route_idx)\n                new_solution.insert(route_idx, route2)\n                new_solution.insert(route_idx, route1)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.813587378359627,
            0.11050030589103699
        ]
    }
]