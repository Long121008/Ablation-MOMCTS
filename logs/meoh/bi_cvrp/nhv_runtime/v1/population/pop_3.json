[
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with adaptive route splitting to balance distance and makespan by intelligently redistributing customers while respecting capacity constraints and dynamically adjusting route structures based on demand patterns.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segment relocation and splitting\n    if len(new_solution) > 1:\n        # Select a random route with high demand concentration\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        if len(route) > 3:\n            # Identify the most demanding segment\n            demands = demand[route[1:-1]]\n            segment_start = 1\n            segment_end = len(route) - 2\n            max_demand = 0\n\n            for i in range(1, len(route) - 2):\n                current_demand = 0\n                for j in range(i, len(route) - 1):\n                    current_demand += demand[route[j]]\n                    if current_demand > max_demand and current_demand <= capacity:\n                        max_demand = current_demand\n                        segment_start = i\n                        segment_end = j\n\n            segment = route[segment_start:segment_end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Try to relocate the segment to another route\n            relocated = False\n            for other_idx in range(len(new_solution)):\n                if other_idx != route_idx:\n                    other_route = new_solution[other_idx].copy()\n                    other_demand = sum(demand[node] for node in other_route[1:-1])\n\n                    if other_demand + segment_demand <= capacity:\n                        # Insert segment into other route (random position)\n                        insert_pos = random.randint(1, len(other_route) - 1)\n                        new_other_route = np.concatenate([other_route[:insert_pos], segment, other_route[insert_pos:]])\n                        new_solution[other_idx] = new_other_route\n\n                        # Remove segment from original route\n                        new_route = np.concatenate([route[:segment_start], route[segment_end + 1:]])\n                        new_solution[route_idx] = new_route\n\n                        relocated = True\n                        break\n\n            # If relocation wasn't possible, consider splitting the route\n            if not relocated and len(route) > 4:\n                # Find a split point that balances demand\n                total_demand = sum(demand[node] for node in route[1:-1])\n                half_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= half_demand:\n                        split_pos = i\n                        break\n\n                # Create two new routes\n                route1 = np.concatenate([[0], route[1:split_pos + 1], [0]])\n                route2 = np.concatenate([[0], route[split_pos + 1:], [0]])\n\n                # Replace the original route with the two new routes\n                new_solution.pop(route_idx)\n                new_solution.insert(route_idx, route2)\n                new_solution.insert(route_idx, route1)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.813587378359627,
            0.11050030589103699
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the smallest makespan, then performs a hybrid local search combining route reversal and segment relocation, ensuring feasibility by checking vehicle capacities and route lengths after each move.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Hybrid local search: route reversal + segment relocation\n        if len(route1) > 3:\n            i = random.randint(1, len(route1) - 2)\n            j = random.randint(i, len(route1) - 2)\n            segment = route1[i:j+1][::-1]\n            segment_load = sum(demand[segment[1:-1]])\n\n            if sum(demand[route2[1:-1]]) + segment_load <= capacity:\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                new_solution[route_indices[1]] = new_route2\n\n                new_route1 = np.concatenate([route1[:i], route1[j+1:]])\n                new_solution[route_indices[0]] = new_route1\n\n    return new_solution\n\n",
        "score": [
            -0.5850691019031518,
            0.10126999020576477
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: apply route splitting, reallocation, and merging\n    new_solution = []\n    for route in base_solution:\n        # Split route if it's too long\n        if len(route) > 5:  # Arbitrary threshold for splitting\n            split_idx = len(route) // 2\n            new_route1 = np.concatenate([route[:split_idx + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n            new_solution.extend([new_route1, new_route2])\n        else:\n            new_solution.append(route.copy())\n\n    # Reallocate customers from long routes to short routes\n    long_routes = [r for r in new_solution if sum(demand[r[1:-1]]) > capacity * 0.8]\n    short_routes = [r for r in new_solution if sum(demand[r[1:-1]]) < capacity * 0.5]\n\n    for long_route in long_routes:\n        for i in range(1, len(long_route) - 1):\n            customer = long_route[i]\n            customer_demand = demand[customer]\n            for short_route in short_routes:\n                if sum(demand[short_route[1:-1]]) + customer_demand <= capacity:\n                    # Insert customer into short route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for j in range(1, len(short_route)):\n                        insert_cost = distance_matrix[short_route[j-1], customer] + distance_matrix[customer, short_route[j]] - distance_matrix[short_route[j-1], short_route[j]]\n                        if insert_cost < min_increase:\n                            min_increase = insert_cost\n                            best_pos = j\n                    new_short_route = np.insert(short_route, best_pos, customer)\n                    short_route[:] = new_short_route\n                    long_route = np.delete(long_route, i)\n                    break\n\n    # Merge short routes if possible\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Only merge very short routes\n            merged = False\n            for i, existing in enumerate(merged_solution):\n                if sum(demand[existing[1:-1]]) + sum(demand[route[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([existing[:-1], route[1:]])\n                    merged_solution[i] = merged_route\n                    merged = True\n                    break\n            if not merged:\n                merged_solution.append(route.copy())\n        else:\n            merged_solution.append(route.copy())\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in merged_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Add missing customers to shortest routes\n    if missing_customers:\n        merged_solution.sort(key=lambda x: len(x))\n        for customer in missing_customers:\n            for route in merged_solution:\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for j in range(1, len(route)):\n                        insert_cost = distance_matrix[route[j-1], customer] + distance_matrix[customer, route[j]] - distance_matrix[route[j-1], route[j]]\n                        if insert_cost < min_increase:\n                            min_increase = insert_cost\n                            best_pos = j\n                    new_route = np.insert(route, best_pos, customer)\n                    route[:] = new_route\n                    break\n\n    return merged_solution\n\n",
        "score": [
            -0.8957855911433819,
            0.27881261706352234
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route decomposition with demand-balanced route reconstruction to optimize both total distance and makespan by strategically breaking and rebuilding routes while ensuring capacity constraints are met and considering spatial proximity for improved efficiency}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = None\n    for sol, _ in archive:\n        if selected_solution is None or len(sol) > len(selected_solution):\n            selected_solution = sol\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a random route to decompose\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        if len(route) > 3:  # Need at least 3 nodes (depot + 2 customers)\n            # Find the most distant customer pair in the route\n            max_dist = -1\n            split_pos = -1\n            for i in range(1, len(route) - 2):\n                dist = distance_matrix[route[i]][route[i+1]]\n                if dist > max_dist:\n                    max_dist = dist\n                    split_pos = i\n\n            if split_pos != -1:\n                # Split the route at the most distant pair\n                first_part = route[:split_pos+1]\n                second_part = route[split_pos+1:]\n\n                # Remove the original route\n                new_solution.pop(route_idx)\n\n                # Try to merge the parts into existing routes or create new ones\n                for part in [first_part, second_part]:\n                    part_demand = sum(demand[node] for node in part)\n                    inserted = False\n\n                    # Try to insert into existing routes\n                    for i in range(len(new_solution)):\n                        existing_route = new_solution[i].copy()\n                        existing_demand = sum(demand[node] for node in existing_route)\n\n                        if existing_demand + part_demand <= capacity:\n                            # Find the best insertion position based on distance\n                            best_pos = 1\n                            best_cost = float('inf')\n\n                            for pos in range(1, len(existing_route)):\n                                # Calculate insertion cost\n                                cost = (distance_matrix[existing_route[pos-1]][part[1]] +\n                                        distance_matrix[part[-2]][existing_route[pos]] -\n                                        distance_matrix[existing_route[pos-1]][existing_route[pos]])\n\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n\n                            # Insert the part\n                            new_route = np.concatenate([existing_route[:best_pos], part[1:-1], existing_route[best_pos:]])\n                            new_solution[i] = new_route\n                            inserted = True\n                            break\n\n                    if not inserted:\n                        # Create a new route if no suitable existing route found\n                        new_solution.append(part.copy())\n\n                # Remove empty routes (though unlikely in this implementation)\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.825161057155614,
            0.12730473279953003
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment swapping with load-aware route splitting to balance distance and makespan by intelligently reallocating customers between routes while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route segment swap with load-aware splitting\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx].copy()\n        route2 = new_solution[route2_idx].copy()\n\n        # Select a segment from route1 (excluding depot)\n        if len(route1) > 2:\n            start1 = random.randint(1, len(route1) - 2)\n            end1 = random.randint(start1, len(route1) - 2)\n            segment1 = route1[start1:end1 + 1]\n\n            # Calculate segment demand and remaining capacity\n            segment_demand = sum(demand[node] for node in segment1)\n            route2_demand = sum(demand[node] for node in route2)\n\n            if route2_demand + segment_demand <= capacity:\n                # Insert segment into route2\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment1, route2[insert_pos:]])\n\n                # Remove segment from route1\n                new_route1 = np.concatenate([route1[:start1], route1[end1 + 1:]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n            else:\n                # Split route2 to accommodate segment\n                split_pos = random.randint(1, len(route2) - 1)\n                new_route2a = route2[:split_pos + 1]\n                new_route2b = np.concatenate([segment1, route2[split_pos + 1:]])\n\n                # Check capacity constraints\n                if (sum(demand[node] for node in new_route2a) <= capacity and\n                    sum(demand[node] for node in new_route2b) <= capacity):\n\n                    # Remove segment from route1\n                    new_route1 = np.concatenate([route1[:start1], route1[end1 + 1:]])\n\n                    # Update solution\n                    new_solution[route1_idx] = new_route1\n                    new_solution = [route for route in new_solution if len(route) > 2]\n                    new_solution.extend([new_route2a, new_route2b])\n\n    return new_solution\n\n",
        "score": [
            -0.5544245095851635,
            0.08221039175987244
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that combines adaptive route splitting with distance-aware customer reallocation to balance distance and makespan by dynamically partitioning routes and strategically redistributing customers based on spatial proximity and demand constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Adaptive route splitting\n    if len(new_solution) > 1:\n        # Select the longest route\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx].copy()\n\n        # Find split points based on spatial clustering\n        if len(longest_route) > 4:\n            # Calculate centroids of route segments\n            centroids = []\n            for i in range(1, len(longest_route)-1):\n                centroid = np.mean([coords[node] for node in longest_route[i:i+2]], axis=0)\n                centroids.append((i, centroid))\n\n            # Find the most distant segment from route centroid\n            route_centroid = np.mean([coords[node] for node in longest_route[1:-1]], axis=0)\n            split_pos = max(centroids, key=lambda x: np.linalg.norm(x[1] - route_centroid))[0]\n\n            # Split the route\n            route_part1 = np.concatenate([longest_route[:split_pos+1], [0]])\n            route_part2 = np.concatenate([[0], longest_route[split_pos+1:]])\n\n            # Replace in solution\n            new_solution[longest_route_idx] = route_part1\n            new_solution.append(route_part2)\n\n    # Distance-aware customer reallocation\n    if len(new_solution) > 1:\n        # Select a random route to modify\n        route_idx = random.randint(0, len(new_solution)-1)\n        current_route = new_solution[route_idx].copy()\n\n        if len(current_route) > 3:\n            # Find the customer with highest detour potential\n            max_detour = -1\n            best_customer = None\n            best_new_route = None\n\n            for i in range(1, len(current_route)-1):\n                customer = current_route[i]\n                # Calculate detour if removed\n                prev_node = current_route[i-1]\n                next_node = current_route[i+1]\n                detour = distance_matrix[prev_node][next_node] - (distance_matrix[prev_node][customer] + distance_matrix[customer][next_node])\n\n                if detour > max_detour:\n                    # Check if can be inserted into another route\n                    for j in range(len(new_solution)):\n                        if j != route_idx:\n                            target_route = new_solution[j].copy()\n                            if sum(demand[node] for node in target_route) + demand[customer] <= capacity:\n                                # Find best insertion position (minimum insertion cost)\n                                min_cost = float('inf')\n                                best_pos = 1\n                                for k in range(1, len(target_route)):\n                                    cost = (distance_matrix[target_route[k-1]][customer] +\n                                            distance_matrix[customer][target_route[k]] -\n                                            distance_matrix[target_route[k-1]][target_route[k]])\n                                    if cost < min_cost:\n                                        min_cost = cost\n                                        best_pos = k\n\n                                if min_cost < 0:  # Only consider beneficial insertions\n                                    max_detour = detour\n                                    best_customer = customer\n                                    best_new_route = (j, best_pos)\n\n            if best_customer is not None:\n                # Perform the reallocation\n                target_route_idx, insert_pos = best_new_route\n                target_route = new_solution[target_route_idx].copy()\n\n                # Remove from current route\n                customer_pos = np.where(current_route == best_customer)[0][0]\n                new_current_route = np.concatenate([current_route[:customer_pos], current_route[customer_pos+1:]])\n\n                # Insert into target route\n                new_target_route = np.concatenate([target_route[:insert_pos], [best_customer], target_route[insert_pos:]])\n\n                # Update solution\n                new_solution[route_idx] = new_current_route\n                new_solution[target_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8821999505802749,
            1.432770013809204
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment reversal with capacity-aware route splitting to improve both distance and makespan objectives by strategically reversing segments and splitting routes while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    selected_solution = None\n    for sol, _ in archive:\n        if selected_solution is None or len(sol) > len(selected_solution):\n            selected_solution = sol\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route segment reversal with capacity-aware splitting\n    if len(new_solution) > 0:\n        # Select a random route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        if len(route) > 3:  # Need at least 3 nodes to reverse a segment\n            # Select a segment to reverse (excluding depot)\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n\n            # Reverse the segment\n            reversed_segment = route[start:end+1][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end+1:]])\n\n            # Check if the reversed route exceeds capacity\n            current_demand = sum(demand[node] for node in new_route)\n            if current_demand <= capacity:\n                new_solution[route_idx] = new_route\n            else:\n                # If capacity is exceeded, split the route\n                split_pos = start\n                while split_pos > 1 and sum(demand[node] for node in new_route[:split_pos]) + sum(demand[node] for node in new_route[split_pos:]) > capacity:\n                    split_pos -= 1\n\n                if split_pos > 1:\n                    # Create two new routes\n                    route1 = np.concatenate([[0], new_route[1:split_pos], [0]])\n                    route2 = np.concatenate([[0], new_route[split_pos:], [0]])\n\n                    # Update solution\n                    new_solution.pop(route_idx)\n                    new_solution.append(route1)\n                    new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.455235533705558,
            0.10044851899147034
        ]
    },
    {
        "algorithm": "{This algorithm employs a dynamic route fusion and segmentation strategy that intelligently combines routes based on spatial proximity and demand patterns, followed by adaptive route splitting to balance distance and makespan while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Calculate centroids of each route\n    centroids = []\n    for route in new_solution:\n        route_coords = coords[route[1:-1]]\n        centroid = np.mean(route_coords, axis=0)\n        centroids.append(centroid)\n\n    # Find pairs of routes that are close in space\n    route_pairs = []\n    for i in range(len(new_solution)):\n        for j in range(i + 1, len(new_solution)):\n            dist = np.linalg.norm(centroids[i] - centroids[j])\n            route_pairs.append((dist, i, j))\n\n    # Sort pairs by distance (closest first)\n    route_pairs.sort(key=lambda x: x[0])\n\n    # Try to merge the closest routes that can fit together\n    for dist, i, j in route_pairs:\n        route1 = new_solution[i].copy()\n        route2 = new_solution[j].copy()\n\n        # Calculate total demand of both routes\n        demand1 = sum(demand[node] for node in route1[1:-1])\n        demand2 = sum(demand[node] for node in route2[1:-1])\n\n        if demand1 + demand2 <= capacity:\n            # Calculate the best insertion point for route2 into route1\n            best_pos = 1\n            min_increase = float('inf')\n\n            # Try inserting route2 at different positions in route1\n            for pos in range(1, len(route1)):\n                # Calculate the cost of inserting route2 before position pos\n                insert_cost = (distance_matrix[route1[pos-1], route2[1]] +\n                              distance_matrix[route2[-2], route1[pos]] -\n                              distance_matrix[route1[pos-1], route1[pos]])\n\n                if insert_cost < min_increase:\n                    min_increase = insert_cost\n                    best_pos = pos\n\n            # Create the merged route\n            merged_route = np.concatenate([route1[:best_pos], route2[1:-1], route1[best_pos:]])\n\n            # Update the solution\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n\n            # Break after first successful merge to limit computational effort\n            break\n\n    # If no merge occurred, try splitting the longest route\n    if len(new_solution) == len(base_solution):\n        # Find the longest route\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n\n        route = new_solution[longest_route_idx].copy()\n        if len(route) > 4:  # Only split if route is long enough\n            # Calculate cumulative demand\n            cumulative_demand = [0]\n            for node in route[1:-1]:\n                cumulative_demand.append(cumulative_demand[-1] + demand[node])\n\n            total_demand = cumulative_demand[-1]\n            target_demand = total_demand / 2\n\n            # Find the split point closest to half the total demand\n            split_pos = min(range(1, len(cumulative_demand)),\n                          key=lambda i: abs(cumulative_demand[i] - target_demand))\n\n            # Create two new routes\n            route1 = np.concatenate([[0], route[1:split_pos+1], [0]])\n            route2 = np.concatenate([[0], route[split_pos+1:], [0]])\n\n            # Replace the original route with the two new routes\n            new_solution.pop(longest_route_idx)\n            new_solution.insert(longest_route_idx, route2)\n            new_solution.insert(longest_route_idx, route1)\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in new_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Add missing customers to the shortest routes\n    if missing_customers:\n        new_solution.sort(key=lambda x: len(x))\n        for customer in missing_customers:\n            for route in new_solution:\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for j in range(1, len(route)):\n                        insert_cost = (distance_matrix[route[j-1], customer] +\n                                     distance_matrix[customer, route[j]] -\n                                     distance_matrix[route[j-1], route[j]])\n                        if insert_cost < min_increase:\n                            min_increase = insert_cost\n                            best_pos = j\n                    new_route = np.insert(route, best_pos, customer)\n                    route[:] = new_route\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8290232802967046,
            0.7353135347366333
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the smallest total distance, then performs a hybrid local search combining route merging and split insertion, ensuring feasibility by checking vehicle capacities and route lengths after each move.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Hybrid local search: route merging + split insertion\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Check if merging routes is feasible\n        merged_load = sum(demand[route1[1:-1]]) + sum(demand[route2[1:-1]])\n        if merged_load <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route_indices[0]] = merged_route\n            new_solution.pop(route_indices[1])\n        else:\n            # Split insertion: move a segment from one route to another\n            if len(route1) > 3 and len(route2) > 2:\n                i = random.randint(1, len(route1) - 3)\n                j = random.randint(i + 1, len(route1) - 2)\n\n                segment = route1[i:j+1]\n                segment_load = sum(demand[segment[1:-1]])\n\n                if segment_load <= capacity:\n                    # Check if inserting the segment into route2 is feasible\n                    if sum(demand[route2[1:-1]]) + segment_load <= capacity:\n                        # Insert the segment into route2 at a random position\n                        insert_pos = random.randint(1, len(route2) - 1)\n                        new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                        new_solution[route_indices[1]] = new_route2\n\n                        # Remove the segment from route1\n                        new_route1 = np.concatenate([route1[:i], route1[j+1:]])\n                        new_solution[route_indices[0]] = new_route1\n\n    return new_solution\n\n",
        "score": [
            -0.653662150499426,
            0.1822623908519745
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a novel local search that combines route reversal, customer exchange, and route reordering, ensuring feasibility by checking vehicle capacities and route lengths after each move.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Route reversal with capacity check\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx]\n        if len(route) > 3:\n            reversed_route = np.concatenate(([0], route[-2:0:-1], [0]))\n            if sum(demand[reversed_route[1:-1]]) <= capacity:\n                new_solution[route_idx] = reversed_route\n\n    # Customer exchange between routes\n    if len(new_solution) > 1:\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) > 2 and len(route2) > 2:\n            cust1_idx = random.randint(1, len(route1) - 2)\n            cust2_idx = random.randint(1, len(route2) - 2)\n            cust1 = route1[cust1_idx]\n            cust2 = route2[cust2_idx]\n\n            # Check capacity constraints\n            new_load1 = sum(demand[route1[1:-1]]) - demand[cust1] + demand[cust2]\n            new_load2 = sum(demand[route2[1:-1]]) - demand[cust2] + demand[cust1]\n\n            if new_load1 <= capacity and new_load2 <= capacity:\n                # Perform exchange\n                new_route1 = route1.copy()\n                new_route2 = route2.copy()\n                new_route1[cust1_idx] = cust2\n                new_route2[cust2_idx] = cust1\n\n                # Check if exchange improves distance\n                original_dist = (distance_matrix[route1[cust1_idx-1], cust1] + distance_matrix[cust1, route1[cust1_idx+1]] +\n                               distance_matrix[route2[cust2_idx-1], cust2] + distance_matrix[cust2, route2[cust2_idx+1]])\n                new_dist = (distance_matrix[route1[cust1_idx-1], cust2] + distance_matrix[cust2, route1[cust1_idx+1]] +\n                           distance_matrix[route2[cust2_idx-1], cust1] + distance_matrix[cust1, route2[cust2_idx+1]])\n\n                if new_dist < original_dist:\n                    new_solution[route1_idx] = new_route1\n                    new_solution[route2_idx] = new_route2\n\n    # Route reordering to balance makespan\n    if len(new_solution) > 1:\n        route_lengths = [sum(distance_matrix[route[i], route[i+1]] for i in range(len(route)-1)) for route in new_solution]\n        longest_idx = route_lengths.index(max(route_lengths))\n        shortest_idx = route_lengths.index(min(route_lengths))\n\n        if longest_idx != shortest_idx:\n            longest_route = new_solution[longest_idx]\n            shortest_route = new_solution[shortest_idx]\n\n            # Try to move a customer from longest to shortest route\n            for cust_idx in range(1, len(longest_route)-1):\n                customer = longest_route[cust_idx]\n                if sum(demand[shortest_route[1:-1]]) + demand[customer] <= capacity:\n                    # Find best insertion position\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for pos in range(1, len(shortest_route)):\n                        increase = (distance_matrix[shortest_route[pos-1], customer] +\n                                  distance_matrix[customer, shortest_route[pos]] -\n                                  distance_matrix[shortest_route[pos-1], shortest_route[pos]])\n                        if increase < min_increase:\n                            min_increase = increase\n                            best_pos = pos\n\n                    # Perform move if it improves makespan\n                    new_shortest = np.insert(shortest_route, best_pos, customer)\n                    new_longest = np.delete(longest_route, cust_idx)\n\n                    if len(new_longest) > 1:  # Ensure valid route\n                        new_length_shortest = sum(distance_matrix[new_shortest[i], new_shortest[i+1]] for i in range(len(new_shortest)-1))\n                        new_length_longest = sum(distance_matrix[new_longest[i], new_longest[i+1]] for i in range(len(new_longest)-1))\n\n                        if max(new_length_shortest, new_length_longest) < max(route_lengths):\n                            new_solution[shortest_idx] = new_shortest\n                            new_solution[longest_idx] = new_longest\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.7023135195748289,
            0.3406626284122467
        ]
    }
]