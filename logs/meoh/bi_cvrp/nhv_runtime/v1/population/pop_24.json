[
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest makespan, then performs a \"demand-balanced route merging\" operation by intelligently merging routes based on spatial proximity and demand balance, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.choice([i for i in range(len(new_solution)) if i != route1_idx])\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        if len(route1) + len(route2) - 2 <= 3:\n            return new_solution\n\n        demand1 = sum(demand[node] for node in route1[1:-1])\n        demand2 = sum(demand[node] for node in route2[1:-1])\n\n        if demand1 + demand2 <= capacity:\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx if route2_idx > route1_idx else route2_idx - 1]\n        else:\n            nodes = list(route1[1:-1]) + list(route2[1:-1])\n            new_route1 = [0]\n            new_route2 = [0]\n            current_demand1 = 0\n            current_demand2 = 0\n\n            for node in sorted(nodes, key=lambda x: coords[x][0]):\n                if current_demand1 <= current_demand2:\n                    if current_demand1 + demand[node] <= capacity:\n                        new_route1.append(node)\n                        current_demand1 += demand[node]\n                else:\n                    if current_demand2 + demand[node] <= capacity:\n                        new_route2.append(node)\n                        current_demand2 += demand[node]\n\n            if len(new_route1) > 1:\n                new_route1.append(0)\n                new_solution[route1_idx] = np.array(new_route1)\n            if len(new_route2) > 1:\n                new_route2.append(0)\n                new_solution.insert(route1_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.855544377307763,
            0.07271641492843628
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a \"capacity-aware route splitting\" operation that intelligently splits routes by prioritizing demand balance and spatial clustering, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx]\n\n        if len(route) > 3:\n            split_pos = random.randint(1, len(route)-2)\n            route_a = route[:split_pos+1]\n            route_b = np.concatenate([[0], route[split_pos+1:]])\n\n            if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                new_solution[route_idx] = route_a\n                new_solution.insert(route_idx+1, route_b)\n            else:\n                demand_a = sum(demand[node] for node in route_a[1:-1])\n                demand_b = sum(demand[node] for node in route_b[1:-1])\n\n                if demand_a > demand_b:\n                    larger_route, smaller_route = route_a, route_b\n                else:\n                    larger_route, smaller_route = route_b, route_a\n\n                if demand_a + demand_b <= capacity:\n                    new_solution[route_idx] = np.concatenate([larger_route[:-1], smaller_route[1:]])\n                else:\n                    nodes = list(larger_route[1:-1]) + list(smaller_route[1:-1])\n                    new_route1 = [0]\n                    new_route2 = [0]\n                    current_demand1 = 0\n                    current_demand2 = 0\n\n                    for node in nodes:\n                        if current_demand1 <= current_demand2:\n                            if current_demand1 + demand[node] <= capacity:\n                                new_route1.append(node)\n                                current_demand1 += demand[node]\n                        else:\n                            if current_demand2 + demand[node] <= capacity:\n                                new_route2.append(node)\n                                current_demand2 += demand[node]\n\n                    if len(new_route1) > 1:\n                        new_route1.append(0)\n                        new_solution[route_idx] = np.array(new_route1)\n                    if len(new_route2) > 1:\n                        new_route2.append(0)\n                        new_solution.insert(route_idx+1, np.array(new_route2))\n\n    return new_solution\n\n",
        "score": [
            -0.7968783466732369,
            0.03118923306465149
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest makespan, then performs a \"demand-balanced route consolidation\" operation that intelligently merges routes by prioritizing demand balance and spatial proximity, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_demands = [sum(demand[node] for node in route[1:-1]) for route in new_solution]\n        route_centroids = [np.mean(coords[route[1:-1]], axis=0) if len(route) > 2 else coords[0] for route in new_solution]\n\n        best_consolidation_pair = None\n        best_consolidation_gain = 0\n\n        for i in range(len(new_solution)):\n            for j in range(i+1, len(new_solution)):\n                if route_demands[i] + route_demands[j] <= capacity:\n                    spatial_distance = np.linalg.norm(route_centroids[i] - route_centroids[j])\n                    demand_balance = abs(route_demands[i] - route_demands[j]) / (route_demands[i] + route_demands[j] + 1e-6)\n\n                    gain = -spatial_distance * (1 - demand_balance)\n\n                    if gain > best_consolidation_gain:\n                        best_consolidation_gain = gain\n                        best_consolidation_pair = (i, j)\n\n        if best_consolidation_pair is not None:\n            i, j = best_consolidation_pair\n            route1, route2 = new_solution[i], new_solution[j]\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[i] = merged_route\n            new_solution.pop(j)\n        else:\n            for route_idx in range(len(new_solution)):\n                route = new_solution[route_idx]\n                if len(route) > 3:\n                    nodes = route[1:-1]\n                    demand_values = demand[nodes]\n                    sorted_indices = np.argsort(demand_values)\n                    split_pos = len(sorted_indices) // 2\n\n                    route1 = np.concatenate([[0], nodes[sorted_indices[:split_pos]], [0]])\n                    route2 = np.concatenate([[0], nodes[sorted_indices[split_pos:]], [0]])\n\n                    if sum(demand[node] for node in route1[1:-1]) <= capacity and sum(demand[node] for node in route2[1:-1]) <= capacity:\n                        new_solution.pop(route_idx)\n                        new_solution.insert(route_idx, route2)\n                        new_solution.insert(route_idx, route1)\n                        break\n\n    new_solution = [route for route in new_solution if len(route) > 2]\n    return new_solution\n\n",
        "score": [
            -0.8637310086968226,
            0.2780264616012573
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: apply route splitting, reallocation, and merging\n    new_solution = []\n    for route in base_solution:\n        # Split route if it's too long\n        if len(route) > 5:  # Arbitrary threshold for splitting\n            split_idx = len(route) // 2\n            new_route1 = np.concatenate([route[:split_idx + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n            new_solution.extend([new_route1, new_route2])\n        else:\n            new_solution.append(route.copy())\n\n    # Reallocate customers from long routes to short routes\n    long_routes = [r for r in new_solution if sum(demand[r[1:-1]]) > capacity * 0.8]\n    short_routes = [r for r in new_solution if sum(demand[r[1:-1]]) < capacity * 0.5]\n\n    for long_route in long_routes:\n        for i in range(1, len(long_route) - 1):\n            customer = long_route[i]\n            customer_demand = demand[customer]\n            for short_route in short_routes:\n                if sum(demand[short_route[1:-1]]) + customer_demand <= capacity:\n                    # Insert customer into short route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for j in range(1, len(short_route)):\n                        insert_cost = distance_matrix[short_route[j-1], customer] + distance_matrix[customer, short_route[j]] - distance_matrix[short_route[j-1], short_route[j]]\n                        if insert_cost < min_increase:\n                            min_increase = insert_cost\n                            best_pos = j\n                    new_short_route = np.insert(short_route, best_pos, customer)\n                    short_route[:] = new_short_route\n                    long_route = np.delete(long_route, i)\n                    break\n\n    # Merge short routes if possible\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Only merge very short routes\n            merged = False\n            for i, existing in enumerate(merged_solution):\n                if sum(demand[existing[1:-1]]) + sum(demand[route[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([existing[:-1], route[1:]])\n                    merged_solution[i] = merged_route\n                    merged = True\n                    break\n            if not merged:\n                merged_solution.append(route.copy())\n        else:\n            merged_solution.append(route.copy())\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in merged_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Add missing customers to shortest routes\n    if missing_customers:\n        merged_solution.sort(key=lambda x: len(x))\n        for customer in missing_customers:\n            for route in merged_solution:\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for j in range(1, len(route)):\n                        insert_cost = distance_matrix[route[j-1], customer] + distance_matrix[customer, route[j]] - distance_matrix[route[j-1], route[j]]\n                        if insert_cost < min_increase:\n                            min_increase = insert_cost\n                            best_pos = j\n                    new_route = np.insert(route, best_pos, customer)\n                    route[:] = new_route\n                    break\n\n    return merged_solution\n\n",
        "score": [
            -0.8957855911433819,
            0.27881261706352234
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a novel \"route fusion and split\" operation that intelligently combines and splits routes based on demand and spatial proximity, while ensuring feasibility through dynamic capacity checks and demand balancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Select two routes to potentially fuse\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        while route2_idx == route1_idx:\n            route2_idx = random.randint(0, len(new_solution)-1)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Calculate combined demand\n        combined_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n\n        if combined_demand <= capacity:\n            # Fuse the two routes by alternating customers from each route\n            fused_route = [0]\n            i, j = 1, 1\n            while i < len(route1)-1 or j < len(route2)-1:\n                if i < len(route1)-1 and j < len(route2)-1:\n                    if random.random() < 0.5:\n                        fused_route.append(route1[i])\n                        i += 1\n                    else:\n                        fused_route.append(route2[j])\n                        j += 1\n                elif i < len(route1)-1:\n                    fused_route.append(route1[i])\n                    i += 1\n                else:\n                    fused_route.append(route2[j])\n                    j += 1\n            fused_route.append(0)\n\n            # Replace the two routes with the fused route\n            new_solution[route1_idx] = np.array(fused_route)\n            del new_solution[route2_idx]\n        else:\n            # Split the larger route to balance demand\n            larger_route = route1 if len(route1) > len(route2) else route2\n            if len(larger_route) > 3:\n                split_pos = random.randint(1, len(larger_route)-2)\n                route_a = larger_route[:split_pos+1]\n                route_b = np.concatenate([[0], larger_route[split_pos+1:]])\n\n                # Update solution\n                if larger_route is route1:\n                    new_solution[route1_idx] = route_a\n                    new_solution.insert(route1_idx+1, route_b)\n                else:\n                    new_solution[route2_idx] = route_a\n                    new_solution.insert(route2_idx+1, route_b)\n\n    return new_solution\n\n",
        "score": [
            -0.7629222217200675,
            0.03390398621559143
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest makespan and applies a demand-aware route merging and spatial rebalancing strategy that intelligently combines routes based on demand distribution and spatial proximity while dynamically adjusting route splits to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        while route2_idx == route1_idx:\n            route2_idx = random.randint(0, len(new_solution)-1)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        total_demand_route1 = sum(demand[node] for node in route1[1:-1])\n        total_demand_route2 = sum(demand[node] for node in route2[1:-1])\n\n        if total_demand_route1 + total_demand_route2 <= capacity:\n            merged_route = [0]\n            i, j = 1, 1\n            while i < len(route1)-1 or j < len(route2)-1:\n                if i < len(route1)-1 and j < len(route2)-1:\n                    dist1 = distance_matrix[route1[i-1]][route1[i]]\n                    dist2 = distance_matrix[route2[j-1]][route2[j]]\n\n                    if dist1 < dist2:\n                        merged_route.append(route1[i])\n                        i += 1\n                    else:\n                        merged_route.append(route2[j])\n                        j += 1\n                elif i < len(route1)-1:\n                    merged_route.append(route1[i])\n                    i += 1\n                else:\n                    merged_route.append(route2[j])\n                    j += 1\n            merged_route.append(0)\n            new_solution[route1_idx] = np.array(merged_route)\n            del new_solution[route2_idx]\n        else:\n            if total_demand_route1 > total_demand_route2:\n                larger_route = route1\n                larger_idx = route1_idx\n            else:\n                larger_route = route2\n                larger_idx = route2_idx\n\n            if len(larger_route) > 3:\n                split_pos = random.randint(1, len(larger_route)-2)\n                route_a = larger_route[:split_pos+1]\n                route_b = np.concatenate([[0], larger_route[split_pos+1:]])\n\n                demand_a = sum(demand[node] for node in route_a)\n                demand_b = sum(demand[node] for node in route_b)\n\n                if demand_a <= capacity and demand_b <= capacity:\n                    new_solution[larger_idx] = route_a\n                    new_solution.insert(larger_idx+1, route_b)\n                else:\n                    for i in range(1, len(larger_route)-1):\n                        customer = larger_route[i]\n                        for j in range(len(new_solution)):\n                            if j != larger_idx:\n                                temp_route = np.concatenate([new_solution[j][:-1], [customer], [0]])\n                                if sum(demand[node] for node in temp_route) <= capacity:\n                                    new_solution[j] = temp_route\n                                    break\n\n    return new_solution\n\n",
        "score": [
            -0.785157681778991,
            0.03810310363769531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance and applies a demand-balanced route splitting and spatial rebalancing strategy that intelligently divides routes based on demand distribution and spatial proximity while dynamically adjusting route merges to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        while route2_idx == route1_idx:\n            route2_idx = random.randint(0, len(new_solution)-1)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        total_demand_route1 = sum(demand[node] for node in route1[1:-1])\n        total_demand_route2 = sum(demand[node] for node in route2[1:-1])\n\n        if total_demand_route1 + total_demand_route2 <= capacity:\n            merged_route = [0]\n            i, j = 1, 1\n            while i < len(route1)-1 or j < len(route2)-1:\n                if i < len(route1)-1 and j < len(route2)-1:\n                    dist1 = distance_matrix[route1[i-1]][route1[i]]\n                    dist2 = distance_matrix[route2[j-1]][route2[j]]\n\n                    if dist1 < dist2:\n                        merged_route.append(route1[i])\n                        i += 1\n                    else:\n                        merged_route.append(route2[j])\n                        j += 1\n                elif i < len(route1)-1:\n                    merged_route.append(route1[i])\n                    i += 1\n                else:\n                    merged_route.append(route2[j])\n                    j += 1\n            merged_route.append(0)\n            new_solution[route1_idx] = np.array(merged_route)\n            del new_solution[route2_idx]\n        else:\n            if total_demand_route1 > total_demand_route2:\n                larger_route = route1\n                larger_idx = route1_idx\n            else:\n                larger_route = route2\n                larger_idx = route2_idx\n\n            if len(larger_route) > 3:\n                split_pos = random.randint(1, len(larger_route)-2)\n                route_a = larger_route[:split_pos+1]\n                route_b = np.concatenate([[0], larger_route[split_pos+1:]])\n\n                demand_a = sum(demand[node] for node in route_a)\n                demand_b = sum(demand[node] for node in route_b)\n\n                if demand_a <= capacity and demand_b <= capacity:\n                    new_solution[larger_idx] = route_a\n                    new_solution.insert(larger_idx+1, route_b)\n                else:\n                    for i in range(1, len(larger_route)-1):\n                        customer = larger_route[i]\n                        for j in range(len(new_solution)):\n                            if j != larger_idx:\n                                temp_route = np.concatenate([new_solution[j][:-1], [customer], [0]])\n                                if sum(demand[node] for node in temp_route) <= capacity:\n                                    new_solution[j] = temp_route\n                                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7939417527862587,
            0.038456350564956665
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route decomposition with demand-balanced route reconstruction to optimize both total distance and makespan by strategically breaking and rebuilding routes while ensuring capacity constraints are met and considering spatial proximity for improved efficiency}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = None\n    for sol, _ in archive:\n        if selected_solution is None or len(sol) > len(selected_solution):\n            selected_solution = sol\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a random route to decompose\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        if len(route) > 3:  # Need at least 3 nodes (depot + 2 customers)\n            # Find the most distant customer pair in the route\n            max_dist = -1\n            split_pos = -1\n            for i in range(1, len(route) - 2):\n                dist = distance_matrix[route[i]][route[i+1]]\n                if dist > max_dist:\n                    max_dist = dist\n                    split_pos = i\n\n            if split_pos != -1:\n                # Split the route at the most distant pair\n                first_part = route[:split_pos+1]\n                second_part = route[split_pos+1:]\n\n                # Remove the original route\n                new_solution.pop(route_idx)\n\n                # Try to merge the parts into existing routes or create new ones\n                for part in [first_part, second_part]:\n                    part_demand = sum(demand[node] for node in part)\n                    inserted = False\n\n                    # Try to insert into existing routes\n                    for i in range(len(new_solution)):\n                        existing_route = new_solution[i].copy()\n                        existing_demand = sum(demand[node] for node in existing_route)\n\n                        if existing_demand + part_demand <= capacity:\n                            # Find the best insertion position based on distance\n                            best_pos = 1\n                            best_cost = float('inf')\n\n                            for pos in range(1, len(existing_route)):\n                                # Calculate insertion cost\n                                cost = (distance_matrix[existing_route[pos-1]][part[1]] +\n                                        distance_matrix[part[-2]][existing_route[pos]] -\n                                        distance_matrix[existing_route[pos-1]][existing_route[pos]])\n\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n\n                            # Insert the part\n                            new_route = np.concatenate([existing_route[:best_pos], part[1:-1], existing_route[best_pos:]])\n                            new_solution[i] = new_route\n                            inserted = True\n                            break\n\n                    if not inserted:\n                        # Create a new route if no suitable existing route found\n                        new_solution.append(part.copy())\n\n                # Remove empty routes (though unlikely in this implementation)\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.825161057155614,
            0.12730473279953003
        ]
    }
]