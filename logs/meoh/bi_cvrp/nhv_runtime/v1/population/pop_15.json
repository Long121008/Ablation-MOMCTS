[
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with spatial clustering and demand-aware route splitting to optimize both distance and makespan by intelligently redistributing customers while considering capacity constraints and spatial proximity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [obj[0] / (obj[1] + 1e-6) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = selected_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a route to modify\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        # Select a segment to relocate (excluding depot)\n        if len(route) > 2:\n            start = random.randint(1, len(route) - 2)\n            end = random.randint(start, len(route) - 2)\n            segment = route[start:end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Find the best target route considering spatial clustering and demand balance\n            best_route_idx = -1\n            best_pos = -1\n            best_score = float('inf')\n\n            for i, target_route in enumerate(new_solution):\n                if i == route_idx:\n                    continue\n\n                target_demand = sum(demand[node] for node in target_route)\n\n                for pos in range(1, len(target_route)):\n                    # Check capacity constraint\n                    if target_demand + segment_demand <= capacity:\n                        # Calculate spatial proximity score\n                        prev_node = target_route[pos-1]\n                        next_node = target_route[pos]\n                        segment_start = segment[0]\n                        segment_end = segment[-1]\n\n                        dist_before = distance_matrix[prev_node, next_node]\n                        dist_after = distance_matrix[prev_node, segment_start] + distance_matrix[segment_end, next_node]\n\n                        # Calculate demand balance score\n                        new_demand = target_demand + segment_demand\n                        demand_score = abs(new_demand - capacity/2)\n\n                        # Combined score: prioritize spatial proximity and demand balance\n                        score = (dist_after - dist_before) + 0.3 * demand_score\n\n                        if score < best_score:\n                            best_score = score\n                            best_route_idx = i\n                            best_pos = pos\n\n            if best_route_idx != -1:\n                # Perform the relocation\n                target_route = new_solution[best_route_idx].copy()\n                new_target_route = np.concatenate([target_route[:best_pos], segment, target_route[best_pos:]])\n                new_original_route = np.concatenate([route[:start], route[end + 1:]])\n\n                # Update solution\n                new_solution[route_idx] = new_original_route\n                new_solution[best_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n                # Try to split long routes if makespan is high\n                if len(new_solution) > 1 and archive[np.argmax(scores)][1][1] > capacity * 0.7:\n                    split_candidate_idx = random.choice(range(len(new_solution)))\n                    split_candidate = new_solution[split_candidate_idx].copy()\n\n                    if len(split_candidate) > 4:  # Only split if route has enough customers\n                        # Find the best split point considering demand balance\n                        best_split_pos = -1\n                        best_split_score = float('inf')\n                        current_demand = 0\n\n                        for pos in range(1, len(split_candidate) - 1):\n                            current_demand += demand[split_candidate[pos]]\n                            remaining_demand = sum(demand[node] for node in split_candidate[pos+1:-1])\n                            demand_diff = abs(current_demand - remaining_demand)\n\n                            if demand_diff < best_split_score:\n                                best_split_score = demand_diff\n                                best_split_pos = pos\n\n                        if best_split_pos != -1:\n                            # Create two new routes\n                            route1 = np.concatenate([split_candidate[:best_split_pos+1], [0]])\n                            route2 = np.concatenate([[0], split_candidate[best_split_pos+1:]])\n\n                            # Replace original route with two new routes\n                            new_solution.pop(split_candidate_idx)\n                            new_solution.append(route1)\n                            new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.966829113330336,
            0.35800206661224365
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a novel \"route fusion and split\" operation that intelligently combines and splits routes based on demand and spatial proximity, while ensuring feasibility through dynamic capacity checks and demand balancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        # Select two routes to potentially fuse\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        while route2_idx == route1_idx:\n            route2_idx = random.randint(0, len(new_solution)-1)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Calculate combined demand\n        combined_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n\n        if combined_demand <= capacity:\n            # Fuse the two routes by alternating customers from each route\n            fused_route = [0]\n            i, j = 1, 1\n            while i < len(route1)-1 or j < len(route2)-1:\n                if i < len(route1)-1 and j < len(route2)-1:\n                    if random.random() < 0.5:\n                        fused_route.append(route1[i])\n                        i += 1\n                    else:\n                        fused_route.append(route2[j])\n                        j += 1\n                elif i < len(route1)-1:\n                    fused_route.append(route1[i])\n                    i += 1\n                else:\n                    fused_route.append(route2[j])\n                    j += 1\n            fused_route.append(0)\n\n            # Replace the two routes with the fused route\n            new_solution[route1_idx] = np.array(fused_route)\n            del new_solution[route2_idx]\n        else:\n            # Split the larger route to balance demand\n            larger_route = route1 if len(route1) > len(route2) else route2\n            if len(larger_route) > 3:\n                split_pos = random.randint(1, len(larger_route)-2)\n                route_a = larger_route[:split_pos+1]\n                route_b = np.concatenate([[0], larger_route[split_pos+1:]])\n\n                # Update solution\n                if larger_route is route1:\n                    new_solution[route1_idx] = route_a\n                    new_solution.insert(route1_idx+1, route_b)\n                else:\n                    new_solution[route2_idx] = route_a\n                    new_solution.insert(route2_idx+1, route_b)\n\n    return new_solution\n\n",
        "score": [
            -0.7629222217200675,
            0.03390398621559143
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the smallest makespan, then performs a hybrid local search combining route splitting and customer relocation, ensuring feasibility by checking vehicle capacities and route lengths after each move.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) >= 1:\n        route_idx = random.randint(0, len(new_solution) - 1)\n        selected_route = new_solution[route_idx]\n\n        if len(selected_route) > 4:\n            split_point = random.randint(2, len(selected_route) - 3)\n            segment1 = selected_route[:split_point + 1]\n            segment2 = selected_route[split_point:]\n\n            if sum(demand[segment1[1:-1]]) <= capacity and sum(demand[segment2[1:-1]]) <= capacity:\n                new_solution[route_idx] = segment1\n                new_solution.insert(route_idx + 1, segment2)\n\n        if len(new_solution) > 1:\n            other_route_idx = random.choice([i for i in range(len(new_solution)) if i != route_idx])\n            other_route = new_solution[other_route_idx]\n\n            if len(selected_route) > 3 and len(other_route) > 3:\n                customer_pos = random.randint(1, len(selected_route) - 2)\n                customer = selected_route[customer_pos]\n\n                if sum(demand[other_route[1:-1]]) + demand[customer] <= capacity:\n                    new_route = np.concatenate([other_route[:-1], [customer], other_route[-1:]])\n                    new_solution[other_route_idx] = new_route\n                    new_solution[route_idx] = np.concatenate([selected_route[:customer_pos], selected_route[customer_pos + 1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.782959590874127,
            0.04566532373428345
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest makespan and applies a demand-aware route merging and spatial rebalancing strategy that intelligently combines routes based on both demand proximity and spatial clustering while dynamically adjusting route splits to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        while route2_idx == route1_idx:\n            route2_idx = random.randint(0, len(new_solution)-1)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        combined_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n\n        if combined_demand <= capacity:\n            merged_route = [0]\n            i, j = 1, 1\n            while i < len(route1)-1 or j < len(route2)-1:\n                if i < len(route1)-1 and j < len(route2)-1:\n                    dist1 = distance_matrix[route1[i-1]][route1[i]] + distance_matrix[route1[i]][route1[i+1]] if i+1 < len(route1)-1 else distance_matrix[route1[i-1]][route1[i]]\n                    dist2 = distance_matrix[route2[j-1]][route2[j]] + distance_matrix[route2[j]][route2[j+1]] if j+1 < len(route2)-1 else distance_matrix[route2[j-1]][route2[j]]\n\n                    if dist1 < dist2:\n                        merged_route.append(route1[i])\n                        i += 1\n                    else:\n                        merged_route.append(route2[j])\n                        j += 1\n                elif i < len(route1)-1:\n                    merged_route.append(route1[i])\n                    i += 1\n                else:\n                    merged_route.append(route2[j])\n                    j += 1\n            merged_route.append(0)\n            new_solution[route1_idx] = np.array(merged_route)\n            del new_solution[route2_idx]\n        else:\n            larger_route = route1 if len(route1) > len(route2) else route2\n            if len(larger_route) > 3:\n                split_pos = random.randint(1, len(larger_route)-2)\n                route_a = larger_route[:split_pos+1]\n                route_b = np.concatenate([[0], larger_route[split_pos+1:]])\n\n                if sum(demand[node] for node in route_a) <= capacity and sum(demand[node] for node in route_b) <= capacity:\n                    if larger_route is route1:\n                        new_solution[route1_idx] = route_a\n                        new_solution.insert(route1_idx+1, route_b)\n                    else:\n                        new_solution[route2_idx] = route_a\n                        new_solution.insert(route2_idx+1, route_b)\n                else:\n                    for i in range(1, len(larger_route)-1):\n                        customer = larger_route[i]\n                        for j in range(len(new_solution)):\n                            if j != (route1_idx if larger_route is route1 else route2_idx):\n                                temp_route = np.concatenate([new_solution[j][:-1], [customer], [0]])\n                                if sum(demand[node] for node in temp_route) <= capacity:\n                                    new_solution[j] = temp_route\n                                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7693691060749481,
            0.039344578981399536
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route decomposition with demand-balanced route reconstruction to optimize both total distance and makespan by strategically breaking and rebuilding routes while ensuring capacity constraints are met and considering spatial proximity for improved efficiency}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = None\n    for sol, _ in archive:\n        if selected_solution is None or len(sol) > len(selected_solution):\n            selected_solution = sol\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a random route to decompose\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        if len(route) > 3:  # Need at least 3 nodes (depot + 2 customers)\n            # Find the most distant customer pair in the route\n            max_dist = -1\n            split_pos = -1\n            for i in range(1, len(route) - 2):\n                dist = distance_matrix[route[i]][route[i+1]]\n                if dist > max_dist:\n                    max_dist = dist\n                    split_pos = i\n\n            if split_pos != -1:\n                # Split the route at the most distant pair\n                first_part = route[:split_pos+1]\n                second_part = route[split_pos+1:]\n\n                # Remove the original route\n                new_solution.pop(route_idx)\n\n                # Try to merge the parts into existing routes or create new ones\n                for part in [first_part, second_part]:\n                    part_demand = sum(demand[node] for node in part)\n                    inserted = False\n\n                    # Try to insert into existing routes\n                    for i in range(len(new_solution)):\n                        existing_route = new_solution[i].copy()\n                        existing_demand = sum(demand[node] for node in existing_route)\n\n                        if existing_demand + part_demand <= capacity:\n                            # Find the best insertion position based on distance\n                            best_pos = 1\n                            best_cost = float('inf')\n\n                            for pos in range(1, len(existing_route)):\n                                # Calculate insertion cost\n                                cost = (distance_matrix[existing_route[pos-1]][part[1]] +\n                                        distance_matrix[part[-2]][existing_route[pos]] -\n                                        distance_matrix[existing_route[pos-1]][existing_route[pos]])\n\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n\n                            # Insert the part\n                            new_route = np.concatenate([existing_route[:best_pos], part[1:-1], existing_route[best_pos:]])\n                            new_solution[i] = new_route\n                            inserted = True\n                            break\n\n                    if not inserted:\n                        # Create a new route if no suitable existing route found\n                        new_solution.append(part.copy())\n\n                # Remove empty routes (though unlikely in this implementation)\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.825161057155614,
            0.12730473279953003
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with adaptive route splitting to balance distance and makespan by intelligently redistributing customers while respecting capacity constraints and dynamically adjusting route structures based on demand patterns.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segment relocation and splitting\n    if len(new_solution) > 1:\n        # Select a random route with high demand concentration\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        if len(route) > 3:\n            # Identify the most demanding segment\n            demands = demand[route[1:-1]]\n            segment_start = 1\n            segment_end = len(route) - 2\n            max_demand = 0\n\n            for i in range(1, len(route) - 2):\n                current_demand = 0\n                for j in range(i, len(route) - 1):\n                    current_demand += demand[route[j]]\n                    if current_demand > max_demand and current_demand <= capacity:\n                        max_demand = current_demand\n                        segment_start = i\n                        segment_end = j\n\n            segment = route[segment_start:segment_end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Try to relocate the segment to another route\n            relocated = False\n            for other_idx in range(len(new_solution)):\n                if other_idx != route_idx:\n                    other_route = new_solution[other_idx].copy()\n                    other_demand = sum(demand[node] for node in other_route[1:-1])\n\n                    if other_demand + segment_demand <= capacity:\n                        # Insert segment into other route (random position)\n                        insert_pos = random.randint(1, len(other_route) - 1)\n                        new_other_route = np.concatenate([other_route[:insert_pos], segment, other_route[insert_pos:]])\n                        new_solution[other_idx] = new_other_route\n\n                        # Remove segment from original route\n                        new_route = np.concatenate([route[:segment_start], route[segment_end + 1:]])\n                        new_solution[route_idx] = new_route\n\n                        relocated = True\n                        break\n\n            # If relocation wasn't possible, consider splitting the route\n            if not relocated and len(route) > 4:\n                # Find a split point that balances demand\n                total_demand = sum(demand[node] for node in route[1:-1])\n                half_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= half_demand:\n                        split_pos = i\n                        break\n\n                # Create two new routes\n                route1 = np.concatenate([[0], route[1:split_pos + 1], [0]])\n                route2 = np.concatenate([[0], route[split_pos + 1:], [0]])\n\n                # Replace the original route with the two new routes\n                new_solution.pop(route_idx)\n                new_solution.insert(route_idx, route2)\n                new_solution.insert(route_idx, route1)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.813587378359627,
            0.11050030589103699
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: apply route splitting, reallocation, and merging\n    new_solution = []\n    for route in base_solution:\n        # Split route if it's too long\n        if len(route) > 5:  # Arbitrary threshold for splitting\n            split_idx = len(route) // 2\n            new_route1 = np.concatenate([route[:split_idx + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n            new_solution.extend([new_route1, new_route2])\n        else:\n            new_solution.append(route.copy())\n\n    # Reallocate customers from long routes to short routes\n    long_routes = [r for r in new_solution if sum(demand[r[1:-1]]) > capacity * 0.8]\n    short_routes = [r for r in new_solution if sum(demand[r[1:-1]]) < capacity * 0.5]\n\n    for long_route in long_routes:\n        for i in range(1, len(long_route) - 1):\n            customer = long_route[i]\n            customer_demand = demand[customer]\n            for short_route in short_routes:\n                if sum(demand[short_route[1:-1]]) + customer_demand <= capacity:\n                    # Insert customer into short route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for j in range(1, len(short_route)):\n                        insert_cost = distance_matrix[short_route[j-1], customer] + distance_matrix[customer, short_route[j]] - distance_matrix[short_route[j-1], short_route[j]]\n                        if insert_cost < min_increase:\n                            min_increase = insert_cost\n                            best_pos = j\n                    new_short_route = np.insert(short_route, best_pos, customer)\n                    short_route[:] = new_short_route\n                    long_route = np.delete(long_route, i)\n                    break\n\n    # Merge short routes if possible\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Only merge very short routes\n            merged = False\n            for i, existing in enumerate(merged_solution):\n                if sum(demand[existing[1:-1]]) + sum(demand[route[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([existing[:-1], route[1:]])\n                    merged_solution[i] = merged_route\n                    merged = True\n                    break\n            if not merged:\n                merged_solution.append(route.copy())\n        else:\n            merged_solution.append(route.copy())\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in merged_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Add missing customers to shortest routes\n    if missing_customers:\n        merged_solution.sort(key=lambda x: len(x))\n        for customer in missing_customers:\n            for route in merged_solution:\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for j in range(1, len(route)):\n                        insert_cost = distance_matrix[route[j-1], customer] + distance_matrix[customer, route[j]] - distance_matrix[route[j-1], route[j]]\n                        if insert_cost < min_increase:\n                            min_increase = insert_cost\n                            best_pos = j\n                    new_route = np.insert(route, best_pos, customer)\n                    route[:] = new_route\n                    break\n\n    return merged_solution\n\n",
        "score": [
            -0.8957855911433819,
            0.27881261706352234
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest total distance, then performs a \"load-balanced route splitting\" operation that intelligently splits routes by prioritizing demand balance and spatial proximity, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        selected_route_idx = random.randint(0, len(new_solution)-1)\n        selected_route = new_solution[selected_route_idx]\n\n        if len(selected_route) > 3:\n            total_demand = sum(demand[node] for node in selected_route[1:-1])\n            target_demand = total_demand / 2\n\n            best_split_pos = 1\n            best_balance = float('inf')\n\n            for split_pos in range(1, len(selected_route)-1):\n                first_part_demand = sum(demand[node] for node in selected_route[1:split_pos+1])\n                balance = abs(first_part_demand - target_demand)\n\n                if balance < best_balance:\n                    best_balance = balance\n                    best_split_pos = split_pos\n\n            route_a = selected_route[:best_split_pos+1]\n            route_b = np.concatenate([[0], selected_route[best_split_pos+1:]])\n\n            if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                new_solution[selected_route_idx] = route_a\n                new_solution.insert(selected_route_idx+1, route_b)\n\n    return new_solution\n\n",
        "score": [
            -0.7698984926945336,
            0.0620327889919281
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with the smallest makespan, then performs a \"demand-balanced route merging\" operation that intelligently combines routes by prioritizing spatial proximity and demand balance, while ensuring feasibility through dynamic capacity checks and route rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route1_idx = random.randint(0, len(new_solution)-1)\n        route2_idx = random.randint(0, len(new_solution)-1)\n        while route2_idx == route1_idx:\n            route2_idx = random.randint(0, len(new_solution)-1)\n\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        route1_demand = sum(demand[node] for node in route1[1:-1])\n        route2_demand = sum(demand[node] for node in route2[1:-1])\n\n        if route1_demand + route2_demand <= capacity:\n            merged_route = [0]\n            last_node = 0\n            remaining_nodes = list(route1[1:-1]) + list(route2[1:-1])\n\n            while remaining_nodes:\n                nearest_node = min(remaining_nodes, key=lambda node: distance_matrix[last_node][node])\n                if sum(demand[node] for node in merged_route[1:]) + demand[nearest_node] <= capacity:\n                    merged_route.append(nearest_node)\n                    remaining_nodes.remove(nearest_node)\n                    last_node = nearest_node\n                else:\n                    break\n\n            if len(remaining_nodes) > 0:\n                split_pos = len(merged_route)\n                merged_route.append(0)\n                new_route = [0] + remaining_nodes + [0]\n                new_solution[route1_idx] = np.array(merged_route)\n                new_solution.insert(route1_idx+1, np.array(new_route))\n            else:\n                merged_route.append(0)\n                new_solution[route1_idx] = np.array(merged_route)\n                del new_solution[route2_idx]\n        else:\n            if route1_demand > route2_demand:\n                larger_route, smaller_idx = route1, route2_idx\n            else:\n                larger_route, smaller_idx = route2, route1_idx\n\n            if len(larger_route) > 3:\n                split_pos = random.randint(1, len(larger_route)-2)\n                route_a = larger_route[:split_pos+1]\n                route_b = np.concatenate([[0], larger_route[split_pos+1:]])\n\n                if sum(demand[node] for node in route_a[1:-1]) <= capacity and sum(demand[node] for node in route_b[1:-1]) <= capacity:\n                    if larger_route is route1:\n                        new_solution[route1_idx] = route_a\n                        new_solution.insert(route1_idx+1, route_b)\n                    else:\n                        new_solution[route2_idx] = route_a\n                        new_solution.insert(route2_idx+1, route_b)\n\n    return new_solution\n\n",
        "score": [
            -0.7193650518087165,
            0.037154436111450195
        ]
    }
]