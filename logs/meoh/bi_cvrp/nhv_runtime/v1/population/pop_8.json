[
    {
        "algorithm": "{An adaptive route segmentation and reallocation strategy that dynamically partitions and reassigns customer segments between routes based on spatial proximity and demand balance, while intelligently handling capacity constraints through demand-aware route splitting and merging to optimize both total distance and makespan.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segmentation and reallocation\n    if len(new_solution) > 1:\n        # Select a route to partition\n        route_idx = random.randint(0, len(new_solution)-1)\n        route = new_solution[route_idx].copy()\n\n        # Find best segmentation point based on spatial proximity and demand balance\n        best_split = 1\n        best_score = float('inf')\n        for i in range(1, len(route)-1):\n            # Calculate demand balance\n            load1 = sum(demand[node] for node in route[1:i+1])\n            load2 = sum(demand[node] for node in route[i+1:-1])\n            demand_balance = abs(load1 - load2)\n\n            # Calculate spatial proximity\n            dist1 = distance_matrix[route[i], route[i+1]]\n            dist2 = distance_matrix[route[i-1], route[i]]\n\n            # Combined score\n            score = demand_balance + 0.5 * (dist1 + dist2)\n\n            if score < best_score:\n                best_score = score\n                best_split = i\n\n        # Split the route\n        route1 = route[:best_split+1]\n        route2 = np.concatenate([[0], route[best_split+1:]])\n\n        # Check capacity constraints\n        if (sum(demand[node] for node in route1) <= capacity and\n            sum(demand[node] for node in route2) <= capacity):\n\n            # Update solution\n            new_solution[route_idx] = route1\n            new_solution.insert(route_idx+1, route2)\n        else:\n            # If split violates capacity, try to merge with adjacent route\n            if route_idx > 0:\n                prev_route = new_solution[route_idx-1]\n                combined_demand = sum(demand[node] for node in prev_route[1:-1]) + sum(demand[node] for node in route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([prev_route[:-1], route[1:]])\n                    new_solution[route_idx-1] = merged_route\n                    del new_solution[route_idx]\n                    return new_solution\n\n            if route_idx < len(new_solution)-1:\n                next_route = new_solution[route_idx+1]\n                combined_demand = sum(demand[node] for node in route[1:-1]) + sum(demand[node] for node in next_route[1:-1])\n                if combined_demand <= capacity:\n                    merged_route = np.concatenate([route[:-1], next_route[1:]])\n                    new_solution[route_idx] = merged_route\n                    del new_solution[route_idx+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8985434519053134,
            0.10493820905685425
        ]
    },
    {
        "algorithm": "{An adaptive route clustering and merging strategy that dynamically adjusts route boundaries by merging adjacent routes when their combined demand fits within capacity, while intelligently redistributing customers to minimize the makespan and total distance by considering both spatial proximity and demand balance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route clustering and merging\n    if len(new_solution) > 1:\n        # Select two adjacent routes to potentially merge\n        route1_idx = random.randint(0, len(new_solution)-2)\n        route2_idx = route1_idx + 1\n        route1 = new_solution[route1_idx]\n        route2 = new_solution[route2_idx]\n\n        # Calculate combined demand\n        combined_demand = sum(demand[node] for node in route1[1:-1]) + sum(demand[node] for node in route2[1:-1])\n\n        if combined_demand <= capacity:\n            # Merge the two routes\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n        else:\n            # Intelligent redistribution if merge is not possible\n            # Find the best split point in route1\n            best_split = 1\n            best_balance = float('inf')\n            for i in range(1, len(route1)-1):\n                load1 = sum(demand[node] for node in route1[1:i+1])\n                load2 = sum(demand[node] for node in route1[i+1:-1])\n                balance = abs(load1 - load2)\n                if balance < best_balance:\n                    best_balance = balance\n                    best_split = i\n\n            # Split route1 at the best point\n            route1a = route1[:best_split+1]\n            route1b = np.concatenate([[0], route1[best_split+1:]])\n\n            # Update solution\n            new_solution[route1_idx] = route1a\n            new_solution.insert(route1_idx+1, route1b)\n\n    return new_solution\n\n",
        "score": [
            -0.7018461732980548,
            0.09070909023284912
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment swapping with load-aware route splitting to balance distance and makespan by intelligently reallocating customers between routes while respecting capacity constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route segment swap with load-aware splitting\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx].copy()\n        route2 = new_solution[route2_idx].copy()\n\n        # Select a segment from route1 (excluding depot)\n        if len(route1) > 2:\n            start1 = random.randint(1, len(route1) - 2)\n            end1 = random.randint(start1, len(route1) - 2)\n            segment1 = route1[start1:end1 + 1]\n\n            # Calculate segment demand and remaining capacity\n            segment_demand = sum(demand[node] for node in segment1)\n            route2_demand = sum(demand[node] for node in route2)\n\n            if route2_demand + segment_demand <= capacity:\n                # Insert segment into route2\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment1, route2[insert_pos:]])\n\n                # Remove segment from route1\n                new_route1 = np.concatenate([route1[:start1], route1[end1 + 1:]])\n\n                # Update solution\n                new_solution[route1_idx] = new_route1\n                new_solution[route2_idx] = new_route2\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n            else:\n                # Split route2 to accommodate segment\n                split_pos = random.randint(1, len(route2) - 1)\n                new_route2a = route2[:split_pos + 1]\n                new_route2b = np.concatenate([segment1, route2[split_pos + 1:]])\n\n                # Check capacity constraints\n                if (sum(demand[node] for node in new_route2a) <= capacity and\n                    sum(demand[node] for node in new_route2b) <= capacity):\n\n                    # Remove segment from route1\n                    new_route1 = np.concatenate([route1[:start1], route1[end1 + 1:]])\n\n                    # Update solution\n                    new_solution[route1_idx] = new_route1\n                    new_solution = [route for route in new_solution if len(route) > 2]\n                    new_solution.extend([new_route2a, new_route2b])\n\n    return new_solution\n\n",
        "score": [
            -0.5544245095851635,
            0.08221039175987244
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive with the smallest makespan, then performs a hybrid local search combining route reversal and segment relocation, ensuring feasibility by checking vehicle capacities and route lengths after each move.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    if len(new_solution) > 1:\n        route_indices = random.sample(range(len(new_solution)), 2)\n        route1, route2 = new_solution[route_indices[0]], new_solution[route_indices[1]]\n\n        # Hybrid local search: route reversal + segment relocation\n        if len(route1) > 3:\n            i = random.randint(1, len(route1) - 2)\n            j = random.randint(i, len(route1) - 2)\n            segment = route1[i:j+1][::-1]\n            segment_load = sum(demand[segment[1:-1]])\n\n            if sum(demand[route2[1:-1]]) + segment_load <= capacity:\n                insert_pos = random.randint(1, len(route2) - 1)\n                new_route2 = np.concatenate([route2[:insert_pos], segment, route2[insert_pos:]])\n                new_solution[route_indices[1]] = new_route2\n\n                new_route1 = np.concatenate([route1[:i], route1[j+1:]])\n                new_solution[route_indices[0]] = new_route1\n\n    return new_solution\n\n",
        "score": [
            -0.5850691019031518,
            0.10126999020576477
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route decomposition with demand-balanced route reconstruction to optimize both total distance and makespan by strategically breaking and rebuilding routes while ensuring capacity constraints are met and considering spatial proximity for improved efficiency}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = None\n    for sol, _ in archive:\n        if selected_solution is None or len(sol) > len(selected_solution):\n            selected_solution = sol\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    if len(new_solution) > 1:\n        # Select a random route to decompose\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        if len(route) > 3:  # Need at least 3 nodes (depot + 2 customers)\n            # Find the most distant customer pair in the route\n            max_dist = -1\n            split_pos = -1\n            for i in range(1, len(route) - 2):\n                dist = distance_matrix[route[i]][route[i+1]]\n                if dist > max_dist:\n                    max_dist = dist\n                    split_pos = i\n\n            if split_pos != -1:\n                # Split the route at the most distant pair\n                first_part = route[:split_pos+1]\n                second_part = route[split_pos+1:]\n\n                # Remove the original route\n                new_solution.pop(route_idx)\n\n                # Try to merge the parts into existing routes or create new ones\n                for part in [first_part, second_part]:\n                    part_demand = sum(demand[node] for node in part)\n                    inserted = False\n\n                    # Try to insert into existing routes\n                    for i in range(len(new_solution)):\n                        existing_route = new_solution[i].copy()\n                        existing_demand = sum(demand[node] for node in existing_route)\n\n                        if existing_demand + part_demand <= capacity:\n                            # Find the best insertion position based on distance\n                            best_pos = 1\n                            best_cost = float('inf')\n\n                            for pos in range(1, len(existing_route)):\n                                # Calculate insertion cost\n                                cost = (distance_matrix[existing_route[pos-1]][part[1]] +\n                                        distance_matrix[part[-2]][existing_route[pos]] -\n                                        distance_matrix[existing_route[pos-1]][existing_route[pos]])\n\n                                if cost < best_cost:\n                                    best_cost = cost\n                                    best_pos = pos\n\n                            # Insert the part\n                            new_route = np.concatenate([existing_route[:best_pos], part[1:-1], existing_route[best_pos:]])\n                            new_solution[i] = new_route\n                            inserted = True\n                            break\n\n                    if not inserted:\n                        # Create a new route if no suitable existing route found\n                        new_solution.append(part.copy())\n\n                # Remove empty routes (though unlikely in this implementation)\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.825161057155614,
            0.12730473279953003
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment relocation with adaptive route splitting to balance distance and makespan by intelligently redistributing customers while respecting capacity constraints and dynamically adjusting route structures based on demand patterns.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = [route.copy() for route in base_solution]\n\n    # Adaptive route segment relocation and splitting\n    if len(new_solution) > 1:\n        # Select a random route with high demand concentration\n        route_idx = random.choice(range(len(new_solution)))\n        route = new_solution[route_idx].copy()\n\n        if len(route) > 3:\n            # Identify the most demanding segment\n            demands = demand[route[1:-1]]\n            segment_start = 1\n            segment_end = len(route) - 2\n            max_demand = 0\n\n            for i in range(1, len(route) - 2):\n                current_demand = 0\n                for j in range(i, len(route) - 1):\n                    current_demand += demand[route[j]]\n                    if current_demand > max_demand and current_demand <= capacity:\n                        max_demand = current_demand\n                        segment_start = i\n                        segment_end = j\n\n            segment = route[segment_start:segment_end + 1]\n            segment_demand = sum(demand[node] for node in segment)\n\n            # Try to relocate the segment to another route\n            relocated = False\n            for other_idx in range(len(new_solution)):\n                if other_idx != route_idx:\n                    other_route = new_solution[other_idx].copy()\n                    other_demand = sum(demand[node] for node in other_route[1:-1])\n\n                    if other_demand + segment_demand <= capacity:\n                        # Insert segment into other route (random position)\n                        insert_pos = random.randint(1, len(other_route) - 1)\n                        new_other_route = np.concatenate([other_route[:insert_pos], segment, other_route[insert_pos:]])\n                        new_solution[other_idx] = new_other_route\n\n                        # Remove segment from original route\n                        new_route = np.concatenate([route[:segment_start], route[segment_end + 1:]])\n                        new_solution[route_idx] = new_route\n\n                        relocated = True\n                        break\n\n            # If relocation wasn't possible, consider splitting the route\n            if not relocated and len(route) > 4:\n                # Find a split point that balances demand\n                total_demand = sum(demand[node] for node in route[1:-1])\n                half_demand = total_demand / 2\n                current_demand = 0\n                split_pos = 1\n\n                for i in range(1, len(route) - 1):\n                    current_demand += demand[route[i]]\n                    if current_demand >= half_demand:\n                        split_pos = i\n                        break\n\n                # Create two new routes\n                route1 = np.concatenate([[0], route[1:split_pos + 1], [0]])\n                route2 = np.concatenate([[0], route[split_pos + 1:], [0]])\n\n                # Replace the original route with the two new routes\n                new_solution.pop(route_idx)\n                new_solution.insert(route_idx, route2)\n                new_solution.insert(route_idx, route1)\n\n    # Remove empty routes\n    new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.813587378359627,
            0.11050030589103699
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: apply route splitting, reallocation, and merging\n    new_solution = []\n    for route in base_solution:\n        # Split route if it's too long\n        if len(route) > 5:  # Arbitrary threshold for splitting\n            split_idx = len(route) // 2\n            new_route1 = np.concatenate([route[:split_idx + 1], [0]])\n            new_route2 = np.concatenate([[0], route[split_idx:]])\n            new_solution.extend([new_route1, new_route2])\n        else:\n            new_solution.append(route.copy())\n\n    # Reallocate customers from long routes to short routes\n    long_routes = [r for r in new_solution if sum(demand[r[1:-1]]) > capacity * 0.8]\n    short_routes = [r for r in new_solution if sum(demand[r[1:-1]]) < capacity * 0.5]\n\n    for long_route in long_routes:\n        for i in range(1, len(long_route) - 1):\n            customer = long_route[i]\n            customer_demand = demand[customer]\n            for short_route in short_routes:\n                if sum(demand[short_route[1:-1]]) + customer_demand <= capacity:\n                    # Insert customer into short route\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for j in range(1, len(short_route)):\n                        insert_cost = distance_matrix[short_route[j-1], customer] + distance_matrix[customer, short_route[j]] - distance_matrix[short_route[j-1], short_route[j]]\n                        if insert_cost < min_increase:\n                            min_increase = insert_cost\n                            best_pos = j\n                    new_short_route = np.insert(short_route, best_pos, customer)\n                    short_route[:] = new_short_route\n                    long_route = np.delete(long_route, i)\n                    break\n\n    # Merge short routes if possible\n    merged_solution = []\n    for route in new_solution:\n        if len(route) <= 3:  # Only merge very short routes\n            merged = False\n            for i, existing in enumerate(merged_solution):\n                if sum(demand[existing[1:-1]]) + sum(demand[route[1:-1]]) <= capacity:\n                    merged_route = np.concatenate([existing[:-1], route[1:]])\n                    merged_solution[i] = merged_route\n                    merged = True\n                    break\n            if not merged:\n                merged_solution.append(route.copy())\n        else:\n            merged_solution.append(route.copy())\n\n    # Ensure all customers are served\n    all_customers = set(range(1, len(demand)))\n    served_customers = set()\n    for route in merged_solution:\n        served_customers.update(route[1:-1])\n    missing_customers = all_customers - served_customers\n\n    # Add missing customers to shortest routes\n    if missing_customers:\n        merged_solution.sort(key=lambda x: len(x))\n        for customer in missing_customers:\n            for route in merged_solution:\n                if sum(demand[route[1:-1]]) + demand[customer] <= capacity:\n                    best_pos = 1\n                    min_increase = float('inf')\n                    for j in range(1, len(route)):\n                        insert_cost = distance_matrix[route[j-1], customer] + distance_matrix[customer, route[j]] - distance_matrix[route[j-1], route[j]]\n                        if insert_cost < min_increase:\n                            min_increase = insert_cost\n                            best_pos = j\n                    new_route = np.insert(route, best_pos, customer)\n                    route[:] = new_route\n                    break\n\n    return merged_solution\n\n",
        "score": [
            -0.8957855911433819,
            0.27881261706352234
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route merging with demand-aware route splitting to balance distance and makespan by intelligently consolidating routes while respecting capacity constraints and potentially reducing the number of vehicles used.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n    Args:\n        archive: A list of tuples, where each tuple contains:\n            - solution: A list of numpy arrays, each representing a vehicle route. \n                        Each route starts and ends at the depot (node index 0), e.g., [0, 3, 5, 0].\n            - objective: A tuple of two float values (total_distance, makespan), \n                        representing the two objective values of the solution.\n        \n        coords: A numpy array of shape (n_nodes, 2), representing (x, y) coordinates of each node (depot + customers).\n        demand: A numpy array of shape (n_nodes,), where demand[i] is the demand of node i. The depot has demand 0.\n        distance_matrix: A numpy array of shape (n_nodes, n_nodes), where [i][j] is the Euclidean distance between node i and j.\n        capacity: A float representing the maximum capacity of each vehicle.\n\n    Returns:\n        A new neighbor solution.\n    \"\"\"\n    scores = [(obj[1] / (obj[0] + 1e-6)) for _, obj in archive]\n    selected_solution = archive[np.argmax(scores)][0].copy()\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route merging with demand-aware splitting\n    if len(new_solution) > 1:\n        # Select two random routes\n        route1_idx, route2_idx = random.sample(range(len(new_solution)), 2)\n        route1 = new_solution[route1_idx].copy()\n        route2 = new_solution[route2_idx].copy()\n\n        # Calculate total demand and check if they can be merged\n        route1_demand = sum(demand[node] for node in route1)\n        route2_demand = sum(demand[node] for node in route2)\n\n        if route1_demand + route2_demand <= capacity:\n            # Merge the two routes by connecting them through the depot\n            merged_route = np.concatenate([route1[:-1], route2[1:]])\n\n            # Update solution\n            new_solution[route1_idx] = merged_route\n            del new_solution[route2_idx]\n        else:\n            # Split one of the routes to accommodate the other\n            # Choose the route with higher demand to split\n            if route1_demand > route2_demand:\n                target_route = route1\n                other_route = route2\n            else:\n                target_route = route2\n                other_route = route1\n\n            # Find a split point that would allow merging\n            for i in range(1, len(target_route)-1):\n                split_demand = sum(demand[node] for node in target_route[:i+1])\n                if split_demand + sum(demand[node] for node in other_route) <= capacity:\n                    # Create split routes\n                    new_route1 = target_route[:i+1]\n                    new_route2 = np.concatenate([target_route[i+1:-1], other_route[1:]])\n\n                    # Update solution\n                    if route1_demand > route2_demand:\n                        new_solution[route1_idx] = new_route1\n                        new_solution[route2_idx] = new_route2\n                    else:\n                        new_solution[route2_idx] = new_route1\n                        new_solution[route1_idx] = new_route2\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8031431238120432,
            0.11203908920288086
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that combines adaptive route splitting with distance-aware customer reallocation to balance distance and makespan by dynamically partitioning routes and strategically redistributing customers based on spatial proximity and demand constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Adaptive route splitting\n    if len(new_solution) > 1:\n        # Select the longest route\n        longest_route_idx = max(range(len(new_solution)), key=lambda i: len(new_solution[i]))\n        longest_route = new_solution[longest_route_idx].copy()\n\n        # Find split points based on spatial clustering\n        if len(longest_route) > 4:\n            # Calculate centroids of route segments\n            centroids = []\n            for i in range(1, len(longest_route)-1):\n                centroid = np.mean([coords[node] for node in longest_route[i:i+2]], axis=0)\n                centroids.append((i, centroid))\n\n            # Find the most distant segment from route centroid\n            route_centroid = np.mean([coords[node] for node in longest_route[1:-1]], axis=0)\n            split_pos = max(centroids, key=lambda x: np.linalg.norm(x[1] - route_centroid))[0]\n\n            # Split the route\n            route_part1 = np.concatenate([longest_route[:split_pos+1], [0]])\n            route_part2 = np.concatenate([[0], longest_route[split_pos+1:]])\n\n            # Replace in solution\n            new_solution[longest_route_idx] = route_part1\n            new_solution.append(route_part2)\n\n    # Distance-aware customer reallocation\n    if len(new_solution) > 1:\n        # Select a random route to modify\n        route_idx = random.randint(0, len(new_solution)-1)\n        current_route = new_solution[route_idx].copy()\n\n        if len(current_route) > 3:\n            # Find the customer with highest detour potential\n            max_detour = -1\n            best_customer = None\n            best_new_route = None\n\n            for i in range(1, len(current_route)-1):\n                customer = current_route[i]\n                # Calculate detour if removed\n                prev_node = current_route[i-1]\n                next_node = current_route[i+1]\n                detour = distance_matrix[prev_node][next_node] - (distance_matrix[prev_node][customer] + distance_matrix[customer][next_node])\n\n                if detour > max_detour:\n                    # Check if can be inserted into another route\n                    for j in range(len(new_solution)):\n                        if j != route_idx:\n                            target_route = new_solution[j].copy()\n                            if sum(demand[node] for node in target_route) + demand[customer] <= capacity:\n                                # Find best insertion position (minimum insertion cost)\n                                min_cost = float('inf')\n                                best_pos = 1\n                                for k in range(1, len(target_route)):\n                                    cost = (distance_matrix[target_route[k-1]][customer] +\n                                            distance_matrix[customer][target_route[k]] -\n                                            distance_matrix[target_route[k-1]][target_route[k]])\n                                    if cost < min_cost:\n                                        min_cost = cost\n                                        best_pos = k\n\n                                if min_cost < 0:  # Only consider beneficial insertions\n                                    max_detour = detour\n                                    best_customer = customer\n                                    best_new_route = (j, best_pos)\n\n            if best_customer is not None:\n                # Perform the reallocation\n                target_route_idx, insert_pos = best_new_route\n                target_route = new_solution[target_route_idx].copy()\n\n                # Remove from current route\n                customer_pos = np.where(current_route == best_customer)[0][0]\n                new_current_route = np.concatenate([current_route[:customer_pos], current_route[customer_pos+1:]])\n\n                # Insert into target route\n                new_target_route = np.concatenate([target_route[:insert_pos], [best_customer], target_route[insert_pos:]])\n\n                # Update solution\n                new_solution[route_idx] = new_current_route\n                new_solution[target_route_idx] = new_target_route\n\n                # Remove empty routes\n                new_solution = [route for route in new_solution if len(route) > 2]\n\n    return new_solution\n\n",
        "score": [
            -0.8821999505802749,
            1.432770013809204
        ]
    },
    {
        "algorithm": "{A hybrid local search strategy that combines route-segment reversal with capacity-aware route splitting to improve both distance and makespan objectives by strategically reversing segments and splitting routes while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], coords: np.ndarray, demand: np.ndarray, distance_matrix: np.ndarray, capacity: float) -> np.ndarray:\n    selected_solution = None\n    for sol, _ in archive:\n        if selected_solution is None or len(sol) > len(selected_solution):\n            selected_solution = sol\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: route segment reversal with capacity-aware splitting\n    if len(new_solution) > 0:\n        # Select a random route\n        route_idx = random.randint(0, len(new_solution) - 1)\n        route = new_solution[route_idx].copy()\n\n        if len(route) > 3:  # Need at least 3 nodes to reverse a segment\n            # Select a segment to reverse (excluding depot)\n            start = random.randint(1, len(route) - 3)\n            end = random.randint(start + 1, len(route) - 2)\n\n            # Reverse the segment\n            reversed_segment = route[start:end+1][::-1]\n            new_route = np.concatenate([route[:start], reversed_segment, route[end+1:]])\n\n            # Check if the reversed route exceeds capacity\n            current_demand = sum(demand[node] for node in new_route)\n            if current_demand <= capacity:\n                new_solution[route_idx] = new_route\n            else:\n                # If capacity is exceeded, split the route\n                split_pos = start\n                while split_pos > 1 and sum(demand[node] for node in new_route[:split_pos]) + sum(demand[node] for node in new_route[split_pos:]) > capacity:\n                    split_pos -= 1\n\n                if split_pos > 1:\n                    # Create two new routes\n                    route1 = np.concatenate([[0], new_route[1:split_pos], [0]])\n                    route2 = np.concatenate([[0], new_route[split_pos:], [0]])\n\n                    # Update solution\n                    new_solution.pop(route_idx)\n                    new_solution.append(route1)\n                    new_solution.append(route2)\n\n    return new_solution\n\n",
        "score": [
            -0.455235533705558,
            0.10044851899147034
        ]
    }
]