[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a combination of objective values and tour entropy, then applies a hybrid local search combining adaptive segment rotation, dynamic node relocation, and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        entropy.append(len(unique_pairs))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['rotate', 'relocate', 'flip'], weights=[0.4, 0.35, 0.25])[0]\n\n    if operator == 'rotate':\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j+1]\n        rotated = np.roll(segment, k-i)\n        new_solution[i:j+1] = rotated\n\n    elif operator == 'relocate':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'flip':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and tour structure entropy, then applies a hybrid local search combining adaptive segment inversion, dynamic edge swapping, and probabilistic node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for i in range(len(solutions)):\n        for j in range(i+1, len(solutions)):\n            diversity.append(np.sum(solutions[i] != solutions[j]))\n\n    avg_diversity = np.mean(diversity) if diversity else 0\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.5 + norm_obj2[i] * 0.5) * (1 + random.uniform(-0.1, 0.1)) + (avg_diversity / len(solutions)) * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['invert', 'swap', 'insert'], weights=[0.45, 0.35, 0.2])[0]\n\n    if operator == 'invert':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'insert':\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.935694035966631,
            6.038871162813267
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for i in range(len(solutions)):\n        for j in range(i+1, len(solutions)):\n            diversity.append(np.sum(solutions[i] != solutions[j]))\n\n    avg_diversity = np.mean(diversity) if diversity else 0\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.5 + norm_obj2[i] * 0.5) * (1 + random.uniform(-0.1, 0.1)) + (avg_diversity / len(solutions)) * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['invert', 'swap', 'insert'], weights=[0.45, 0.35, 0.2])[0]\n\n    if operator == 'invert':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'insert':\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of normalized objective values and solution diversity, then applies a hybrid local search combining adaptive segment reversal with probabilistic edge swapping and node relocation, while ensuring tour feasibility through careful validation of all operations.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        unique, counts = np.unique(sol, return_counts=True)\n        d = len(unique) / len(sol)\n        diversity.append(d)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.7 + norm_obj2[i] * 0.3) * (1 + random.uniform(-0.1, 0.1)) + diversity[i] * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'relocate', 'swap'], weights=[0.5, 0.3, 0.2])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            if len(segment) % 2 == 0:\n                segment = segment[::-1]\n            new_solution[i:j+1] = segment\n\n    elif operator == 'relocate':\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objectives and crowding distance, then applies a hybrid local search combining adaptive segment reversal with probabilistic edge swapping and node relocation, while ensuring tour feasibility through careful validation of all operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    crowding = []\n    sorted_obj1 = np.sort(norm_obj1)\n    sorted_obj2 = np.sort(norm_obj2)\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive)-1:\n            crowding.append(float('inf'))\n        else:\n            crowding.append((sorted_obj1[i+1] - sorted_obj1[i-1]) / (sorted_obj1[-1] - sorted_obj1[0] + 1e-8) +\n                           (sorted_obj2[i+1] - sorted_obj2[i-1]) / (sorted_obj2[-1] - sorted_obj2[0] + 1e-8))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.1, 0.1)) + crowding[i] * 0.5\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'relocate', 'swap'], weights=[0.4, 0.4, 0.2])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            if len(segment) % 2 == 0:\n                segment = segment[::-1]\n            new_solution[i:j+1] = segment\n\n    elif operator == 'relocate':\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.059481178567123,
            7.537832137094423
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    crowding = []\n    sorted_obj1 = np.sort(norm_obj1)\n    sorted_obj2 = np.sort(norm_obj2)\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive)-1:\n            crowding.append(float('inf'))\n        else:\n            crowding.append((sorted_obj1[i+1] - sorted_obj1[i-1]) / (sorted_obj1[-1] - sorted_obj1[0] + 1e-8) +\n                           (sorted_obj2[i+1] - sorted_obj2[i-1]) / (sorted_obj2[-1] - sorted_obj2[0] + 1e-8))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.1, 0.1)) + crowding[i] * 0.5\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'relocate', 'swap'], weights=[0.4, 0.4, 0.2])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            if len(segment) % 2 == 0:\n                segment = segment[::-1]\n            new_solution[i:j+1] = segment\n\n    elif operator == 'relocate':\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment reversal with a probabilistic edge swap strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        score = obj[0] * 0.6 + obj[1] * 0.4\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['reverse', 'swap'])\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[i:j+1][::-1]\n                new_solution[i:j+1] = segment\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection strategy, then applies a hybrid local search combining a novel segment rotation with a probabilistic node insertion strategy, while ensuring feasibility by carefully maintaining the tour structure and validating all moves based on bi-objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    diversity_scores = []\n    for i, sol in enumerate(solutions):\n        unique_segments = len(set(tuple(sol[i:i+3]) for i in range(len(sol))))\n        diversity_scores.append(unique_segments)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['rotate', 'insert'])\n\n    if operator == 'rotate':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                            distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k], new_solution[j+1]] +\n                        distance_matrix_1[new_solution[i], new_solution[(k+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[j+1]] +\n                            distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k], new_solution[j+1]] +\n                        distance_matrix_2[new_solution[i], new_solution[(k+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[j:k+1]\n                new_solution[i:k+1] = np.concatenate([segment, new_solution[i:j]])\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            10.03448026824519,
            9.773737712369362
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    diversity_scores = []\n    for i, sol in enumerate(solutions):\n        unique_segments = len(set(tuple(sol[i:i+3]) for i in range(len(sol))))\n        diversity_scores.append(unique_segments)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choice(['rotate', 'insert'])\n\n    if operator == 'rotate':\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                            distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[k], new_solution[j+1]] +\n                        distance_matrix_1[new_solution[i], new_solution[(k+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[j+1]] +\n                            distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[k], new_solution[j+1]] +\n                        distance_matrix_2[new_solution[i], new_solution[(k+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                segment = new_solution[j:k+1]\n                new_solution[i:k+1] = np.concatenate([segment, new_solution[i:j]])\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive segment reversal, guided node insertion, and probabilistic edge swapping while maintaining tour feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    entropy = []\n    for sol in solutions:\n        counts = np.bincount(sol, minlength=len(instance))\n        prob = counts / len(sol)\n        e = -np.sum(prob * np.log(prob + 1e-8))\n        entropy.append(e)\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.6 + norm_obj2[i] * 0.4) * (1 + random.uniform(-0.2, 0.2)) + entropy[i] * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['reverse', 'insert', 'swap'], weights=[0.4, 0.3, 0.3])[0]\n\n    if operator == 'reverse':\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'swap':\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and tour diversity, then applies a hybrid local search combining adaptive segment rotation, guided node relocation, and probabilistic edge flipping while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        unique_nodes = len(np.unique(sol))\n        diversity.append(unique_nodes / len(sol))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.5 + norm_obj2[i] * 0.5) * (1 + random.uniform(-0.1, 0.1)) + diversity[i] * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['rotate', 'relocate', 'flip'], weights=[0.3, 0.4, 0.3])[0]\n\n    if operator == 'rotate':\n        k = random.randint(1, n//2)\n        new_solution = np.roll(new_solution, k)\n\n    elif operator == 'relocate':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    elif operator == 'flip':\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.8397493798001845,
            5.9613476173299915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    norm_obj1 = np.array([o[0] for o in objectives])\n    norm_obj2 = np.array([o[1] for o in objectives])\n    norm_obj1 = (norm_obj1 - np.min(norm_obj1)) / (np.max(norm_obj1) - np.min(norm_obj1) + 1e-8)\n    norm_obj2 = (norm_obj2 - np.min(norm_obj2)) / (np.max(norm_obj2) - np.min(norm_obj2) + 1e-8)\n\n    diversity = []\n    for sol in solutions:\n        unique_nodes = len(np.unique(sol))\n        diversity.append(unique_nodes / len(sol))\n\n    scores = []\n    for i in range(len(archive)):\n        score = (norm_obj1[i] * 0.5 + norm_obj2[i] * 0.5) * (1 + random.uniform(-0.1, 0.1)) + diversity[i] * 0.4\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    operator = random.choices(['rotate', 'relocate', 'flip'], weights=[0.3, 0.4, 0.3])[0]\n\n    if operator == 'rotate':\n        k = random.randint(1, n//2)\n        new_solution = np.roll(new_solution, k)\n\n    elif operator == 'relocate':\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    elif operator == 'flip':\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    }
]