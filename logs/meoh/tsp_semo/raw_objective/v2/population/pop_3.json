[
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search operator combining edge swapping, segment reversal, and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of three operators\n    operator = random.choice(['swap', 'reverse', 'insert'])\n\n    if operator == 'swap':\n        # Edge swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operator == 'reverse':\n        # Segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'insert':\n        # Node insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            6.0843578326115075,
            6.11521640805595
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and tour properties, then applies a hybrid local search combining a novel segment rotation operator with a probabilistic edge insertion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate potential improvement scores (lower is better)\n    scores = []\n    for i, (sol, obj) in enumerate(zip(solutions, objectives)):\n        # Score based on objective values and tour properties\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        # Add randomness to avoid always selecting the same solution\n        score += random.uniform(0, 0.1)\n        scores.append(score)\n\n    # Select solution with lowest score (most promising)\n    selected_idx = np.argmin(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of two novel operators\n    operator = random.choice(['rotate', 'prob_insert'])\n\n    if operator == 'rotate':\n        # Segment rotation (novel operator)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j+1]\n        rotated = np.roll(segment, k - i)\n        new_solution[i:j+1] = rotated\n\n    elif operator == 'prob_insert':\n        # Probabilistic edge insertion (novel operator)\n        a, b = random.sample(range(n), 2)\n        if random.random() < 0.5:\n            # Insert node a between b and its successor\n            node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            pos = (b + 1) % n\n            new_solution = np.insert(new_solution, pos, node)\n        else:\n            # Insert node b between a and its successor\n            node = new_solution[b]\n            new_solution = np.delete(new_solution, b)\n            pos = (a + 1) % n\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.8163101237854455,
            6.55605786123142
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values, then applies a novel hybrid local search that combines node swapping with a dynamic sub-tour reversal strategy, ensuring feasibility while exploring diverse neighborhoods in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - min(x[1][0], x[1][1]) / max(x[1][0], x[1][1])))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic sub-tour reversal based on distance matrix analysis\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j - 1:\n        # Reverse sub-tour only if it improves the solution in at least one objective space\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node swapping with objective-aware selection\n    a, b = random.sample(range(n), 2)\n    if a != b:\n        # Swap nodes only if it improves the solution in at least one objective space\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            5.447495483045565,
            9.257948291932776
        ]
    },
    {
        "algorithm": "{The new algorithm combines the ideas of selective node swapping with a dynamic edge reversal strategy, guided by a multi-objective improvement potential assessment to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * random.uniform(0.8, 1.2))[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic edge reversal based on objective improvement potential\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j - 1:\n            # Calculate potential improvement in both objectives\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            reversed_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Apply reversal if it improves at least one objective\n            if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Selective node swapping based on distance reduction\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        # Calculate potential improvement in both objectives\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        swapped_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        swapped_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        # Apply swap if it improves at least one objective\n        if (swapped_cost1 < original_cost1) or (swapped_cost2 < original_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.04639647100613,
            8.254628272033251
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and tour structure, then applies a novel hybrid local search operator that combines a multi-segment inversion with a guided node swapping mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective diversity and tour structure\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate selection probability based on objective diversity\n    obj_scores = [obj[0] * obj[1] for obj in objectives]  # Product of objectives\n    total_score = sum(obj_scores)\n    probabilities = [score / total_score for score in obj_scores] if total_score > 0 else [1.0 / len(archive)] * len(archive)\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-segment inversion\n    num_segments = random.randint(2, min(4, n // 2))\n    segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    start = 0\n    for end in segment_indices:\n        segments.append(new_solution[start:end])\n        start = end\n    segments.append(new_solution[start:])\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Guided node swapping\n    for _ in range(2):\n        # Find node with highest combined distance to neighbors\n        max_cost = -1\n        swap_node = -1\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i - 1]\n            next_node = new_solution[(i + 1) % n]\n            cost = (distance_matrix_1[node, prev_node] + distance_matrix_1[node, next_node] +\n                    distance_matrix_2[node, prev_node] + distance_matrix_2[node, next_node])\n            if cost > max_cost:\n                max_cost = cost\n                swap_node = i\n\n        # Swap with random node that improves both objectives\n        if swap_node != -1:\n            candidates = []\n            for i in range(n):\n                if i != swap_node and i != (swap_node - 1) % n and i != (swap_node + 1) % n:\n                    # Calculate cost change\n                    old_cost = (distance_matrix_1[new_solution[swap_node], new_solution[swap_node - 1]] +\n                               distance_matrix_1[new_solution[swap_node], new_solution[(swap_node + 1) % n]] +\n                               distance_matrix_2[new_solution[swap_node], new_solution[swap_node - 1]] +\n                               distance_matrix_2[new_solution[swap_node], new_solution[(swap_node + 1) % n]])\n                    new_cost = (distance_matrix_1[new_solution[i], new_solution[swap_node - 1]] +\n                               distance_matrix_1[new_solution[i], new_solution[(swap_node + 1) % n]] +\n                               distance_matrix_2[new_solution[i], new_solution[swap_node - 1]] +\n                               distance_matrix_2[new_solution[i], new_solution[(swap_node + 1) % n]])\n                    if new_cost < old_cost:\n                        candidates.append(i)\n\n            if candidates:\n                swap_pos = random.choice(candidates)\n                new_solution[swap_node], new_solution[swap_pos] = new_solution[swap_pos], new_solution[swap_node]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.5900808361289664,
            6.424524111797443
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted random selection that prioritizes solutions with better objective values, then applies a novel hybrid local search operator that combines a randomized segment reversal with a guided edge swap to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with weighted random selection based on objective values\n    objectives = [obj for _, obj in archive]\n    weights = [1.0 / (1 + (obj[0] + obj[1])) for obj in objectives]\n    selected_idx = random.choices(range(len(archive)), weights=weights)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: randomized segment reversal + guided edge swap\n    # Step 1: Randomized segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Guided edge swap\n    # Find the worst edge in both objective spaces\n    worst_edge = -1\n    max_cost = -1\n    for i in range(n):\n        node_i = new_solution[i]\n        node_j = new_solution[(i + 1) % n]\n        cost = distance_matrix_1[node_i, node_j] + distance_matrix_2[node_i, node_j]\n        if cost > max_cost:\n            max_cost = cost\n            worst_edge = i\n\n    # Swap with a random node to improve the worst edge\n    if worst_edge != -1:\n        swap_pos = random.randint(0, n - 1)\n        if swap_pos != worst_edge and swap_pos != (worst_edge + 1) % n:\n            new_solution[worst_edge], new_solution[swap_pos] = new_solution[swap_pos], new_solution[worst_edge]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.212718244656829,
            6.405654289752864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a rank-based selection mechanism that emphasizes high-performing solutions, then applies a hybrid local search combining a randomized 3-opt move with a guided node insertion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank-based selection\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(len(sorted_archive) * 0.2), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: randomized 3-opt + guided node insertion\n    # Step 1: Randomized 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Step 2: Guided node insertion\n    # Find the worst node in both objective spaces\n    worst_node = -1\n    max_cost = -1\n    for i in range(n):\n        node_prev = new_solution[i-1]\n        node_curr = new_solution[i]\n        node_next = new_solution[(i+1)%n]\n        cost = (distance_matrix_1[node_prev, node_curr] + distance_matrix_1[node_curr, node_next] +\n                distance_matrix_2[node_prev, node_curr] + distance_matrix_2[node_curr, node_next])\n        if cost > max_cost:\n            max_cost = cost\n            worst_node = i\n\n    # Reinsert the worst node at a random position\n    if worst_node != -1:\n        node = new_solution[worst_node]\n        new_solution = np.delete(new_solution, worst_node)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.4385701161480515,
            6.588334415777144
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score that balances the two objectives, then applies a hybrid local search combining a randomized segment rotation with a guided edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    if max_obj1 == 0 or max_obj2 == 0:\n        weights = [1.0 / (1 + (obj[0] + obj[1])) for obj in objectives]\n    else:\n        weights = [1.0 / (1 + (obj[0]/max_obj1 + obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = random.choices(range(len(archive)), weights=weights)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b:]])\n\n    worst_edge = -1\n    max_cost = -1\n    for i in range(n):\n        node_i = new_solution[i]\n        node_j = new_solution[(i + 1) % n]\n        cost = distance_matrix_1[node_i, node_j] + distance_matrix_2[node_i, node_j]\n        if cost > max_cost:\n            max_cost = cost\n            worst_edge = i\n\n    if worst_edge != -1:\n        insert_pos = random.randint(0, n - 1)\n        if insert_pos != worst_edge and insert_pos != (worst_edge + 1) % n:\n            node_to_insert = new_solution[worst_edge]\n            new_solution = np.concatenate([new_solution[:worst_edge], new_solution[worst_edge+1:]])\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.340644764626987,
            6.668513516768652
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search operator that combines a segment reversal with a randomized swap of non-adjacent nodes to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a heuristic that balances objective values and diversity\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (sum(x[1]) + 1) for x in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Segment reversal between two randomly selected nodes\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Randomized swap of non-adjacent nodes\n    a, b = random.sample(range(n), 2)\n    while abs(a - b) == 1:  # Ensure they are not adjacent\n        b = random.randint(0, n - 1)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.884660029589167,
            7.076059207277174
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a normalized combination of objective values and diversity, then applies a hybrid local search that combines a segment reversal with a guided swap of nodes based on their distance in both objective spaces to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute weights\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1.0 / (normalized.sum(axis=1) + 1)\n\n    # Select solution with weighted probability\n    selected_idx = random.choices(range(len(archive)), weights=weights)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Segment reversal between two randomly selected nodes\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Guided swap based on distance in both objective spaces\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    while abs(a - b) == 1:  # Ensure they are not adjacent\n        b = random.randint(0, n - 1)\n\n    # Calculate distance in both spaces\n    node_a = new_solution[a]\n    node_b = new_solution[b]\n    dist1 = distance_matrix_1[node_a, node_b]\n    dist2 = distance_matrix_2[node_a, node_b]\n\n    # Swap if the nodes are far in either space\n    if dist1 > np.mean(distance_matrix_1) or dist2 > np.mean(distance_matrix_2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.96849785486401,
            6.7967786782315
        ]
    }
]