[
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective balance using Pareto dominance and applies a hybrid local search combining adaptive segment insertion, node relocation with objective-aware acceptance, and conditional multi-node swap to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment insertion\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[i:j+1]\n        pos = np.random.randint(0, N)\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        if len(new_solution) > N:\n            new_solution = new_solution[:N]\n\n    # Node relocation with objective-aware acceptance\n    if np.random.rand() < 0.6:\n        i, pos = np.random.choice(N, size=2, replace=False)\n        node = new_solution[i]\n        candidate = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        candidate = np.insert(candidate, pos, node)\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost <= current_total * 1.05:  # Allow slight degradation\n            new_solution = candidate\n\n    # Conditional multi-node swap\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, min(5, N//2))\n        indices = np.random.choice(N, size=k, replace=False)\n        segment = new_solution[indices]\n        np.random.shuffle(segment)\n        candidate = new_solution.copy()\n        candidate[indices] = segment\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            5.975668459748311,
            6.316607588532149
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            5.015690534003456,
            7.696038592244591
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.397045776594858,
            6.876489070059456
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using entropy-based weights), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.227847574846752,
            5.713711108163281
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.155594647697006,
            5.7522293085064415
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score with adaptive weights, then applies a hybrid local search combining segment reversal and node insertion with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.random.uniform(0.4, 0.6)\n    scores = weights * normalized[:, 0] + (1 - weights) * normalized[:, 1]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic probability based on solution quality\n    prob = 0.5 + 0.2 * (scores[selected_idx] - np.min(scores)) / (np.max(scores) - np.min(scores) + 1e-8)\n\n    if np.random.rand() < prob:\n        # Segment reversal with adaptive segment length\n        seg_length = max(2, int(np.random.rand() * N / 3))\n        start = np.random.randint(N - seg_length)\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n    else:\n        # Node insertion with best improvement\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.202172320233735,
            5.743949921978457
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n",
        "score": [
            6.369828450537811,
            5.631717197948714
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.789158457538903,
            4.661156729355797
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.397045776594858,
            6.876489070059456
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using entropy-based weights), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.227847574846752,
            5.713711108163281
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.155594647697006,
            5.7522293085064415
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score with adaptive weights, then applies a hybrid local search combining segment reversal and node insertion with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.random.uniform(0.4, 0.6)\n    scores = weights * normalized[:, 0] + (1 - weights) * normalized[:, 1]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic probability based on solution quality\n    prob = 0.5 + 0.2 * (scores[selected_idx] - np.min(scores)) / (np.max(scores) - np.min(scores) + 1e-8)\n\n    if np.random.rand() < prob:\n        # Segment reversal with adaptive segment length\n        seg_length = max(2, int(np.random.rand() * N / 3))\n        start = np.random.randint(N - seg_length)\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n    else:\n        # Node insertion with best improvement\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.202172320233735,
            5.743949921978457
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            5.015690534003456,
            7.696038592244591
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n",
        "score": [
            6.369828450537811,
            5.631717197948714
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted sum of normalized objectives with equal weights (0.5 for each objective), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.5 + norm_objectives[:, 1] * 0.5\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            6.059291832154049,
            5.786648258257412
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            5.015690534003456,
            7.696038592244591
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.397045776594858,
            6.876489070059456
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using entropy-based weights), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.227847574846752,
            5.713711108163281
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.155594647697006,
            5.7522293085064415
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.789158457538903,
            4.661156729355797
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n",
        "score": [
            6.369828450537811,
            5.631717197948714
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.7 for first objective, 0.3 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.625591026710601,
            8.158764205204154
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reinsertion with path reversal and edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reinsertion with path reversal\n    a = np.random.randint(0, N)\n    node = new_solution[a]\n    new_solution = np.delete(new_solution, a)\n\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(N-1):\n        candidate = np.insert(new_solution, i, node)\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Edge exchange with path reversal\n    if np.random.rand() < 0.3:  # 30% chance to exchange edges\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Path reversal with segment selection\n    if np.random.rand() < 0.4:  # 40% chance to reverse a segment\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.89980875824665,
            5.80465254215507
        ]
    },
    {
        "algorithm": "{The new algorithm selects the best solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment rotation, node swapping, and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with probabilistic check\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            k = np.random.randint(1, len(segment))\n            new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Node swapping with distance-based probability\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%N]]\n        dist2 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]\n        if dist1 < dist2 or np.random.rand() < 0.2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.4:\n        i = np.random.randint(N)\n        j = (i + np.random.randint(2, N-1)) % N\n        if i != j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            4.776826336531361,
            7.956278084036375
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score with adaptive weights, then applies a hybrid local search combining segment reversal and node insertion with dynamic probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.random.uniform(0.4, 0.6)\n    scores = weights * normalized[:, 0] + (1 - weights) * normalized[:, 1]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Dynamic probability based on solution quality\n    prob = 0.5 + 0.2 * (scores[selected_idx] - np.min(scores)) / (np.max(scores) - np.min(scores) + 1e-8)\n\n    if np.random.rand() < prob:\n        # Segment reversal with adaptive segment length\n        seg_length = max(2, int(np.random.rand() * N / 3))\n        start = np.random.randint(N - seg_length)\n        new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n    else:\n        # Node insertion with best improvement\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.202172320233735,
            5.743949921978457
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using entropy-based weights), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.227847574846752,
            5.713711108163281
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.155594647697006,
            5.7522293085064415
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.397045776594858,
            6.876489070059456
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.789158457538903,
            4.661156729355797
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining edge reversal and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives\n    costs1 = np.array([obj[0] for _, obj in archive])\n    costs2 = np.array([obj[1] for _, obj in archive])\n    min_cost1, max_cost1 = np.min(costs1), np.max(costs1)\n    min_cost2, max_cost2 = np.min(costs2), np.max(costs2)\n\n    if max_cost1 == min_cost1:\n        normalized1 = np.ones_like(costs1)\n    else:\n        normalized1 = (costs1 - min_cost1) / (max_cost1 - min_cost1)\n\n    if max_cost2 == min_cost2:\n        normalized2 = np.ones_like(costs2)\n    else:\n        normalized2 = (costs2 - min_cost2) / (max_cost2 - min_cost2)\n\n    # Weighted combination (0.7 for first objective, 0.3 for second)\n    combined = 0.7 * normalized1 + 0.3 * normalized2\n    selected_idx = np.argmin(combined)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge reversal + segment inversion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1][::-1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting reversed segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment inversion if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            4.127446975248162,
            9.261212523597171
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted objective score, then applies a novel local search combining adaptive segment rotation, node transposition, and conditional edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with objective-aware selection\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            # Evaluate potential transposition\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost < original_cost:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            # Evaluate reversal\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost:\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            5.015690534003456,
            7.696038592244591
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.789158457538903,
            4.661156729355797
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using entropy-based weights), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.227847574846752,
            5.713711108163281
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.155594647697006,
            5.7522293085064415
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.397045776594858,
            6.876489070059456
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node clustering, segment rotation, and adaptive edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node clustering and segment rotation\n    if np.random.rand() < 0.4:\n        cluster_size = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - cluster_size)\n        segment = new_solution[start:start+cluster_size]\n        rotation = np.random.randint(1, cluster_size)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+cluster_size] = rotated_segment\n\n    # Adaptive edge flipping\n    if np.random.rand() < 0.5:\n        for _ in range(min(3, N//2)):\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n\n            # Calculate cost change for both objectives\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%N]]\n\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%N]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%N]]\n\n            # Apply flip if beneficial for at least one objective\n            if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Random segment reversal with feasibility check\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if a != 0 and b != N-1 and a != b-1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.08374539576344,
            5.754247885828572
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using entropy-based weights), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.227847574846752,
            5.713711108163281
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.155594647697006,
            5.7522293085064415
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.397045776594858,
            6.876489070059456
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.789158457538903,
            4.661156729355797
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.7 for first objective, 0.3 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.383681529895855,
            9.079510318929984
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.155594647697006,
            5.7522293085064415
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.397045776594858,
            6.876489070059456
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted geometric mean of normalized objectives, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sqrt(norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.513101284408078,
            8.463498002451317
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.789158457538903,
            4.661156729355797
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using entropy-based weights), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.227847574846752,
            5.713711108163281
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a non-dominated solution from the archive using Pareto dominance criteria, then applies a hybrid local search combining node relocation and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    selected = random.choice(non_dominated)[0].copy()\n\n    # Hybrid local search: node relocation + segment reversal\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_pos = np.random.randint(N)\n    node = new_solution[node_pos]\n\n    # Find the best relocation position\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(N):\n        if i == node_pos or i == (node_pos - 1) % N:\n            continue  # Skip current position and adjacent positions\n\n        # Try relocating node to position i\n        candidate = new_solution.copy()\n        candidate = np.delete(candidate, node_pos)\n        candidate = np.insert(candidate, i, node)\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Apply segment reversal if beneficial\n    if np.random.rand() < 0.3:  # 30% chance to reverse\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.867734539397287,
            6.19320447485245
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted geometric mean of normalized objectives, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sqrt(norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.513101284408078,
            8.463498002451317
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.397045776594858,
            6.876489070059456
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.155594647697006,
            5.7522293085064415
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted geometric mean of normalized objectives, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sqrt(norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.513101284408078,
            8.463498002451317
        ]
    },
    {
        "algorithm": "{The new algorithm selects a non-dominated solution from the archive using Pareto dominance criteria, then applies a hybrid local search combining node relocation and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    selected = random.choice(non_dominated)[0].copy()\n\n    # Hybrid local search: node relocation + segment reversal\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_pos = np.random.randint(N)\n    node = new_solution[node_pos]\n\n    # Find the best relocation position\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(N):\n        if i == node_pos or i == (node_pos - 1) % N:\n            continue  # Skip current position and adjacent positions\n\n        # Try relocating node to position i\n        candidate = new_solution.copy()\n        candidate = np.delete(candidate, node_pos)\n        candidate = np.insert(candidate, i, node)\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Apply segment reversal if beneficial\n    if np.random.rand() < 0.3:  # 30% chance to reverse\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.867734539397287,
            6.19320447485245
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    }
]