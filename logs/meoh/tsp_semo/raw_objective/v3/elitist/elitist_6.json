[
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining segment rotation, alternating path reversal, and cross-segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with alternating path reversal\n    if np.random.rand() < 0.3:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n        if np.random.rand() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Cross-segment insertion\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Alternating node swapping\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i % 2 == 0 and j % 2 == 0:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n",
        "score": [
            6.05796776854438,
            5.978742272488504
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.945176859466265,
            6.067019488382575
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using entropy-based weights), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.227847574846752,
            5.713711108163281
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.155594647697006,
            5.7522293085064415
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score that balances both objectives, then applies a hybrid local search combining segment insertion and node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(new_solution)\n\n    # Hybrid local search: segment insertion or node relocation\n    if np.random.rand() < 0.6:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n    else:\n        # Node relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            5.900424285316852,
            6.089619878083495
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.397045776594858,
            6.876489070059456
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.9947997204509464,
            5.994869928348804
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.789158457538903,
            4.661156729355797
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining segment rotation, alternating path reversal, and cross-segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with alternating path reversal\n    if np.random.rand() < 0.3:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n        if np.random.rand() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Cross-segment insertion\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Alternating node swapping\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i % 2 == 0 and j % 2 == 0:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n",
        "score": [
            6.05796776854438,
            5.978742272488504
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.155594647697006,
            5.7522293085064415
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.397045776594858,
            6.876489070059456
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.9947997204509464,
            5.994869928348804
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted geometric mean of normalized objectives, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sqrt(norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.513101284408078,
            8.463498002451317
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.945176859466265,
            6.067019488382575
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.789158457538903,
            4.661156729355797
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score that balances both objectives, then applies a hybrid local search combining segment insertion and node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    N = len(new_solution)\n\n    # Hybrid local search: segment insertion or node relocation\n    if np.random.rand() < 0.6:\n        # Segment insertion\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n    else:\n        # Node relocation\n        i = np.random.randint(N)\n        j = np.random.randint(N)\n        while j == i:\n            j = np.random.randint(N)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            5.900424285316852,
            6.089619878083495
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives (using entropy-based weights), then applies a hybrid local search combining segment reversal and node swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([x[1] for x in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-8)\n    entropy = -np.sum(normalized_costs * np.log(normalized_costs + 1e-8), axis=0)\n    weights = entropy / np.sum(entropy)\n\n    # Select solution based on weighted objectives\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply node swap if beneficial\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(N, size=2, replace=False)\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n        current_total = current_cost1 + current_cost2\n\n        if total_cost < current_total:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.227847574846752,
            5.713711108163281
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining segment rotation, alternating path reversal, and cross-segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with alternating path reversal\n    if np.random.rand() < 0.3:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n        if np.random.rand() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Cross-segment insertion\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Alternating node swapping\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i % 2 == 0 and j % 2 == 0:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n",
        "score": [
            6.05796776854438,
            5.978742272488504
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.9947997204509464,
            5.994869928348804
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a non-dominated solution from the archive using Pareto dominance criteria, then applies a hybrid local search combining node relocation and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    selected = random.choice(non_dominated)[0].copy()\n\n    # Hybrid local search: node relocation + segment reversal\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_pos = np.random.randint(N)\n    node = new_solution[node_pos]\n\n    # Find the best relocation position\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(N):\n        if i == node_pos or i == (node_pos - 1) % N:\n            continue  # Skip current position and adjacent positions\n\n        # Try relocating node to position i\n        candidate = new_solution.copy()\n        candidate = np.delete(candidate, node_pos)\n        candidate = np.insert(candidate, i, node)\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Apply segment reversal if beneficial\n    if np.random.rand() < 0.3:  # 30% chance to reverse\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.867734539397287,
            6.19320447485245
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.945176859466265,
            6.067019488382575
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted geometric mean of normalized objectives, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sqrt(norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.513101284408078,
            8.463498002451317
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    # Hybrid local search: node insertion + segment rotation\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment_size = b - a + 1\n\n    # Rotate segment left or right\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n    else:\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], -1)\n\n    # Apply node insertion if beneficial\n    if np.random.rand() < 0.4:  # 40% chance to insert\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.397045776594858,
            6.876489070059456
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node relocation and segment reversal with adaptive probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7)\n    scores = [weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    selected = archive[selected_idx][0].copy()\n\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Hybrid local search with adaptive probabilities\n    if np.random.rand() < 0.6:  # Higher probability for relocation\n        # Node relocation\n        node_pos = np.random.randint(N)\n        node = new_solution[node_pos]\n\n        best_cost = float('inf')\n        best_pos = -1\n\n        for i in range(N):\n            if i == node_pos or i == (node_pos - 1) % N:\n                continue\n\n            candidate = new_solution.copy()\n            candidate = np.delete(candidate, node_pos)\n            candidate = np.insert(candidate, i, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = weights * cost1 + (1 - weights) * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Segment reversal\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.155594647697006,
            5.7522293085064415
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.945176859466265,
            6.067019488382575
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.9947997204509464,
            5.994869928348804
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted geometric mean of normalized objectives, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sqrt(norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.513101284408078,
            8.463498002451317
        ]
    },
    {
        "algorithm": "{The new algorithm selects a non-dominated solution from the archive using Pareto dominance criteria, then applies a hybrid local search combining node relocation and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    selected = random.choice(non_dominated)[0].copy()\n\n    # Hybrid local search: node relocation + segment reversal\n    new_solution = selected.copy()\n    N = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_pos = np.random.randint(N)\n    node = new_solution[node_pos]\n\n    # Find the best relocation position\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(N):\n        if i == node_pos or i == (node_pos - 1) % N:\n            continue  # Skip current position and adjacent positions\n\n        # Try relocating node to position i\n        candidate = new_solution.copy()\n        candidate = np.delete(candidate, node_pos)\n        candidate = np.insert(candidate, i, node)\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Apply segment reversal if beneficial\n    if np.random.rand() < 0.3:  # 30% chance to reverse\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.867734539397287,
            6.19320447485245
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining segment rotation, alternating path reversal, and cross-segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with alternating path reversal\n    if np.random.rand() < 0.3:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n        if np.random.rand() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Cross-segment insertion\n    if np.random.rand() < 0.4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Alternating node swapping\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i % 2 == 0 and j % 2 == 0:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n",
        "score": [
            6.05796776854438,
            5.978742272488504
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.945176859466265,
            6.067019488382575
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.9947997204509464,
            5.994869928348804
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.9947997204509464,
            5.994869928348804
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.945176859466265,
            6.067019488382575
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.9947997204509464,
            5.994869928348804
        ]
    }
]