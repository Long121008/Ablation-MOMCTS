[
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.945176859466265,
            6.067019488382575
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.9947997204509464,
            5.994869928348804
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining segment rotation, node chain insertion, and edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated\n\n    # Node chain insertion\n    if np.random.rand() < 0.3:\n        chain_length = min(3, N // 2)\n        chain = np.random.choice(new_solution, size=chain_length, replace=False)\n        pos = np.random.randint(N)\n        new_solution = np.concatenate([new_solution[:pos], chain, new_solution[pos:]])\n        new_solution = np.unique(new_solution)\n\n    # Edge reversal with feasibility check\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (j - i) > 1:\n            new_solution[i+1:j] = new_solution[j-1:i:-1]\n\n    return new_solution\n\n",
        "score": [
            6.231663226219714,
            6.107997658428222
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel 4-opt-like local search with adaptive segment rearrangement and guided node swaps to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Step 1: Select four random segments\n    a, b, c, d = sorted(random.sample(range(1, n-1), 4))\n    segments = [\n        new_solution[:a],\n        new_solution[a:b],\n        new_solution[b:c],\n        new_solution[c:d],\n        new_solution[d:]\n    ]\n\n    # Step 2: Rearrange segments in a novel pattern\n    new_order = np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]])\n\n    # Step 3: Adaptive guided swaps\n    for i in range(n):\n        if random.random() < 0.4:\n            j = random.randint(0, n-1)\n            if (distance_matrix_1[new_order[i], new_order[j]] + distance_matrix_2[new_order[i], new_order[j]]) < \\\n               (distance_matrix_1[new_order[i], new_order[(i+1)%n]] + distance_matrix_2[new_order[i], new_order[(i+1)%n]]):\n                new_order[i], new_order[j] = new_order[j], new_order[i]\n\n    # Step 4: Local segment inversion\n    if random.random() < 0.3:\n        x, y = sorted(random.sample(range(1, n-1), 2))\n        new_order[x:y] = new_order[x:y][::-1]\n\n    return new_order\n\n",
        "score": [
            6.383012759151082,
            6.57127879868931
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score weighted by the inverse of the normalized objective values, then applies a novel local search strategy combining edge reversal and segment rotation with adaptive segment sizes to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    obj1 = [o[0] for o in objectives]\n    obj2 = [o[1] for o in objectives]\n    min1, max1 = min(obj1), max(obj1)\n    min2, max2 = min(obj2), max(obj2)\n\n    weighted_scores = []\n    for i, (o1, o2) in enumerate(objectives):\n        norm1 = (o1 - min1) / (max1 - min1 + 1e-6)\n        norm2 = (o2 - min2) / (max2 - min2 + 1e-6)\n        score = 0.7 * (1 - norm1) + 0.3 * (1 - norm2)  # Higher weight for better objective 1\n        weighted_scores.append((score, i))\n\n    weighted_scores.sort(reverse=True)\n    base_solution = archive[weighted_scores[0][1]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_size = max(2, N // 4)\n    a = np.random.randint(0, N - segment_size)\n    b = a + segment_size - 1\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge reversal with adaptive segment size\n    segment_size = max(2, N // 3)\n    x = np.random.randint(0, N - segment_size)\n    y = x + segment_size - 1\n    new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            6.105817909283184,
            8.488978238382913
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge inversion and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: edge inversion + segment rotation\n    if n > 2:\n        # Select a random segment to rotate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Rotate the segment\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:b+1] = rotated_segment\n\n        # Invert edges between two random positions\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.446352880272228,
            6.4478337409255095
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy combining edge reversal and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation operator\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge reversal operator\n    x, y = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != N:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            6.2639558858526865,
            6.456350947292165
        ]
    },
    {
        "algorithm": "{This algorithm selects a promising solution from the archive based on a hybrid of Pareto dominance and solution diversity, then applies a novel 3-opt-like local search with a guided diversification step to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful modification\n\n    # Step 1: Select three random segments\n    a, b, c = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Step 2: Recombine segments in a novel way\n    new_order = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Step 3: Guided diversification - swap nodes based on distance matrices\n    for i in range(n):\n        if random.random() < 0.3:  # 30% chance to swap\n            j = random.randint(0, n-1)\n            if (distance_matrix_1[new_order[i], new_order[j]] + distance_matrix_2[new_order[i], new_order[j]]) < \\\n               (distance_matrix_1[new_order[i], new_order[(i+1)%n]] + distance_matrix_2[new_order[i], new_order[(i+1)%n]]):\n                new_order[i], new_order[j] = new_order[j], new_order[i]\n\n    return new_order\n\n",
        "score": [
            6.638091370909896,
            6.868138406096367
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.945176859466265,
            6.067019488382575
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.9947997204509464,
            5.994869928348804
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reordering with adaptive segment reversal and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reordering with adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(5, N))\n        start = np.random.randint(0, N - segment_length + 1)\n        if np.random.rand() < 0.6:  # 60% chance to reverse\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n        else:  # 40% chance to rotate\n            shift = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution[start:start+segment_length] = np.concatenate([segment[shift:], segment[:shift]])\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.5:\n        for i in range(N):\n            if np.random.rand() < 0.1:  # 10% chance to flip each edge\n                j = (i + 1) % N\n                if j != 0 or i != N-1:  # Ensure not flipping the last edge\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.824438531321193,
            6.844838077355632
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.9947997204509464,
            5.994869928348804
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining path reversal, node insertion, and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Path reversal with node insertion\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        if np.random.rand() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(N)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Edge swapping with feasibility check\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != 0 and j != N-1 and i != j-1:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Node relocation\n    if np.random.rand() < 0.3:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.945176859466265,
            6.067019488382575
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining edge insertion and segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: edge insertion + segment swapping\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to move\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment swapping if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to swap\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.9947997204509464,
            5.994869928348804
        ]
    }
]