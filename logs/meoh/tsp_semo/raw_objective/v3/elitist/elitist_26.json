[
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a rank-based selection with adaptive weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    norm_ranks = ranks / (len(archive) - 1)\n    combined_scores = norm_ranks[:, 0] * 0.4 + norm_ranks[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            10.362927120535325,
            4.36751843854373
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a multi-criteria dominance score, then applies a novel local search combining adaptive segment reinsertion with objective-aware path inversion and conditional node chain reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reinsertion\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            for j in range(i+1, len(candidate)+1):\n                candidate_solution = np.insert(candidate.copy(), i, segment)\n\n                cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    # Objective-aware path inversion\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                distance_matrix_1[inverted_path[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], path[0]] -\n                distance_matrix_1[path[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                distance_matrix_2[inverted_path[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], path[0]] -\n                distance_matrix_2[path[-1], new_solution[k]])\n\n        if cost1 + cost2 < 0:\n            new_solution[:k] = inverted_path\n\n    # Conditional node chain reversal\n    if np.random.rand() < 0.4:\n        chain_length = np.random.randint(3, min(6, N//3))\n        start = np.random.randint(0, N - chain_length)\n        chain = new_solution[start:start+chain_length]\n        reversed_chain = chain[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_1[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_1[new_solution[start-1], chain[0]] -\n                distance_matrix_1[chain[-1], new_solution[start+chain_length]])\n        cost2 = (distance_matrix_2[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_2[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_2[new_solution[start-1], chain[0]] -\n                distance_matrix_2[chain[-1], new_solution[start+chain_length]])\n\n        if cost1 + cost2 < 0:\n            new_solution[start:start+chain_length] = reversed_chain\n\n    return new_solution\n\n",
        "score": [
            6.051948985144374,
            5.600676384129802
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.359423514281508,
            6.933153602115607
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.678733823516097,
            6.312686110122009
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective score while applying a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.820911251229378,
            5.437982603815841
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a rank-based objective score (prioritizing solutions with better single-objective ranks), then applies a hybrid local search combining segment reversal, node exchange, and edge inversion with adaptive probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = ranks[np.random.randint(0, min(3, len(ranks)))]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n            if a > 0 and np.random.rand() < 0.4:\n                new_solution[a-1], new_solution[a] = new_solution[a], new_solution[a-1]\n\n    return new_solution\n\n",
        "score": [
            4.60736924906,
            10.26400497372948
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation, node exchange, and edge flipping with adaptive probability checks to ensure feasibility and explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / (np.sum(diversity_scores) + 1e-8)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment rotation with adaptive probability\n    if np.random.rand() < 0.5:\n        k = np.random.randint(1, N//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Node exchange with edge flipping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        if np.random.rand() < 0.4 and i > 0 and j < N-1:\n            new_solution[i-1], new_solution[j] = new_solution[j], new_solution[i-1]\n\n    return new_solution\n\n",
        "score": [
            6.369828450537811,
            5.631717197948714
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.359423514281508,
            6.933153602115607
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a multi-criteria dominance score, then applies a novel local search combining adaptive segment reinsertion with objective-aware path inversion and conditional node chain reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reinsertion\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        candidate = np.delete(new_solution, np.arange(a, b+1))\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(candidate)):\n            for j in range(i+1, len(candidate)+1):\n                candidate_solution = np.insert(candidate.copy(), i, segment)\n\n                cost1 = sum(distance_matrix_1[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                cost2 = sum(distance_matrix_2[candidate_solution[k-1], candidate_solution[k]] for k in range(N))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, segment)\n\n    # Objective-aware path inversion\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                distance_matrix_1[inverted_path[-1], new_solution[k]] -\n                distance_matrix_1[new_solution[-1], path[0]] -\n                distance_matrix_1[path[-1], new_solution[k]])\n        cost2 = (distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                distance_matrix_2[inverted_path[-1], new_solution[k]] -\n                distance_matrix_2[new_solution[-1], path[0]] -\n                distance_matrix_2[path[-1], new_solution[k]])\n\n        if cost1 + cost2 < 0:\n            new_solution[:k] = inverted_path\n\n    # Conditional node chain reversal\n    if np.random.rand() < 0.4:\n        chain_length = np.random.randint(3, min(6, N//3))\n        start = np.random.randint(0, N - chain_length)\n        chain = new_solution[start:start+chain_length]\n        reversed_chain = chain[::-1]\n\n        cost1 = (distance_matrix_1[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_1[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_1[new_solution[start-1], chain[0]] -\n                distance_matrix_1[chain[-1], new_solution[start+chain_length]])\n        cost2 = (distance_matrix_2[new_solution[start-1], reversed_chain[0]] +\n                distance_matrix_2[reversed_chain[-1], new_solution[start+chain_length]] -\n                distance_matrix_2[new_solution[start-1], chain[0]] -\n                distance_matrix_2[chain[-1], new_solution[start+chain_length]])\n\n        if cost1 + cost2 < 0:\n            new_solution[start:start+chain_length] = reversed_chain\n\n    return new_solution\n\n",
        "score": [
            6.051948985144374,
            5.600676384129802
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective score while applying a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and a novel segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    combined_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.5:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.820911251229378,
            5.437982603815841
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.359423514281508,
            6.933153602115607
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.352099967873407,
            8.778673507612456
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.359423514281508,
            6.933153602115607
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.359423514281508,
            6.933153602115607
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.352099967873407,
            8.778673507612456
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective twice as much as the second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.89306204513346,
            7.436696520476107
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.3 for the first objective and 0.7 for the second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            9.096352084524819,
            4.1617695886658534
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.359423514281508,
            6.933153602115607
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.352099967873407,
            8.778673507612456
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid selection criterion combining Pareto dominance and objective diversity, then applies a novel local search combining adaptive segment rotation with objective-aware node insertion and conditional path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Calculate dominance and diversity scores\n    dominance_scores = []\n    diversity_scores = []\n    for sol, obj in archive:\n        dominated = 0\n        for other_sol, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                dominated += 1\n        dominance_scores.append(dominated)\n        diversity_scores.append(obj[0] * obj[1])\n\n    # Combine scores and select promising solution\n    combined_scores = [d + div for d, div in zip(dominance_scores, diversity_scores)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        k = np.random.randint(1, b - a + 1)\n        segment = new_solution[a:b+1]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                        distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Remove node at i and insert at j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    # Conditional path reversal\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        reversed_path = path[::-1]\n\n        # Evaluate reversal\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        reversed_cost = (distance_matrix_1[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_1[reversed_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_2[reversed_path[-1], new_solution[k]])\n\n        if reversed_cost < original_cost:\n            new_solution[:k] = reversed_path\n\n    return new_solution\n\n",
        "score": [
            5.394969316527699,
            6.566129315427194
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.352099967873407,
            8.778673507612456
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.3 for the first objective and 0.7 for the second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            9.096352084524819,
            4.1617695886658534
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining segment rotation, node relocation with probabilistic edge swapping, and segment inversion with adaptive probability to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4 + crowding_distances * 0.2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.35 + 0.35 * (1 - combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 0])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            rotation = np.random.randint(1, b - a)\n            new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    if np.random.rand() < 0.55:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.25 and new_pos > 0 and new_pos < N-1:\n                if np.random.rand() < 0.55:\n                    new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n                else:\n                    new_solution[new_pos], new_solution[new_pos+1] = new_solution[new_pos+1], new_solution[new_pos]\n\n    if np.random.rand() < 0.25 + 0.25 * (combined_scores[np.argmin(combined_scores)] / np.max(objectives[:, 1])):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.359423514281508,
            6.933153602115607
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.352099967873407,
            8.778673507612456
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.3 for the first objective and 0.7 for the second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            9.096352084524819,
            4.1617695886658534
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid selection criterion combining Pareto dominance and objective diversity, then applies a novel local search combining adaptive segment rotation with objective-aware node insertion and conditional path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        return np.random.permutation(len(instance))\n\n    # Calculate dominance and diversity scores\n    dominance_scores = []\n    diversity_scores = []\n    for sol, obj in archive:\n        dominated = 0\n        for other_sol, other_obj in archive:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                dominated += 1\n        dominance_scores.append(dominated)\n        diversity_scores.append(obj[0] * obj[1])\n\n    # Combine scores and select promising solution\n    combined_scores = [d + div for d, div in zip(dominance_scores, diversity_scores)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        k = np.random.randint(1, b - a + 1)\n        segment = new_solution[a:b+1]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n\n        # Evaluate rotation\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        rotated_cost = (distance_matrix_1[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_1[rotated_segment[-1], new_solution[(b+1)%N]] +\n                        distance_matrix_2[new_solution[a-1], rotated_segment[0]] +\n                        distance_matrix_2[rotated_segment[-1], new_solution[(b+1)%N]])\n\n        if rotated_cost < original_cost:\n            new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Remove node at i and insert at j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    # Conditional path reversal\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        reversed_path = path[::-1]\n\n        # Evaluate reversal\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        reversed_cost = (distance_matrix_1[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_1[reversed_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], reversed_path[0]] +\n                         distance_matrix_2[reversed_path[-1], new_solution[k]])\n\n        if reversed_cost < original_cost:\n            new_solution[:k] = reversed_path\n\n    return new_solution\n\n",
        "score": [
            5.394969316527699,
            6.566129315427194
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.352099967873407,
            8.778673507612456
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.3 for the first objective and 0.7 for the second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            9.096352084524819,
            4.1617695886658534
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamically weighted objective score that balances diversity and convergence, then applies a hybrid local search combining adaptive segment rotation, node transposition, and conditional edge reversal with enhanced acceptance criteria to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([x[1] for x in archive])\n    weights = np.std(costs, axis=0) / np.mean(costs, axis=0)\n    weights = weights / np.sum(weights)\n\n    archive.sort(key=lambda x: (weights[0] * x[1][0] + weights[1] * x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation with probability based on solution quality\n    quality_score = (weights[0] * archive[0][1][0] + weights[1] * archive[0][1][1]) / np.mean(costs)\n    if np.random.rand() < 0.5 * quality_score:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Node transposition with enhanced acceptance criteria\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if i != j and (i != 0 or j != N-1):\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[i]] +\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                          distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[j], new_solution[i]] +\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if swapped_cost <= original_cost * 1.1:  # Allow slight cost increase\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Conditional edge reversal with probability based on segment length\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        segment_length = j - i + 1\n        if segment_length > 2 and segment_length < N/2:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                           distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], segment[0]] +\n                           distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                           distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                           distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                           distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost <= original_cost * 1.05:  # Allow small cost increase\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            5.486411840865416,
            6.410988798508834
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.352099967873407,
            8.778673507612456
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.352099967873407,
            8.778673507612456
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a hyperbolic combination of normalized objectives, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probability thresholds to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = 1 / (1 + norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmax(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.552467869975372,
            8.210929934520923
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.352099967873407,
            8.778673507612456
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights, then applies a hybrid local search combining segment reversal, node relocation, and probabilistic edge inversion to generate diverse neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.27608986177455,
            4.495841978458046
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combined objective score (weighting the first objective 70% and the second 30%), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.5 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.352099967873407,
            8.778673507612456
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score combining normalized costs and diversity, then applies a hybrid local search combining adaptive segment rotation, objective-aware node insertion, and conditional edge reversal with probabilistic selection criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([x[1] for x in archive])\n        normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n        scores = 0.6 * normalized[:, 0] + 0.4 * normalized[:, 1] - 0.2 * np.linspace(0, 1, len(archive))\n        selected_idx = np.argmin(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment rotation with objective-aware probability\n    if np.random.rand() < 0.5 * (1 - selected_idx/len(archive)):\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b+1] = rotated_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = np.random.choice(N-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Conditional edge reversal with cost evaluation\n    if np.random.rand() < 0.4:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1:\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n            original_cost = (distance_matrix_1[new_solution[i-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(j+1)%N]])\n            reversed_cost = (distance_matrix_1[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%N]] +\n                            distance_matrix_2[new_solution[i-1], reversed_segment[0]] +\n                            distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%N]])\n\n            if reversed_cost < original_cost * 1.1:  # Allow slight degradation\n                new_solution[i:j+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            4.565498084740369,
            7.85893708444895
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a hypervolume-aware selection criterion, then applies a novel local search combining adaptive segment reversal with objective-weighted node relocation and probabilistic multi-segment shuffling to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal\n    if np.random.rand() < 0.4:\n        segment_length = np.random.randint(2, min(6, N//2))\n        start = np.random.randint(0, N - segment_length + 1)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Objective-weighted node relocation\n    if np.random.rand() < 0.7:\n        i = np.random.randint(0, N)\n        node = new_solution[i]\n        candidate_positions = list(range(N))\n        candidate_positions.remove(i)\n\n        best_pos = i\n        best_cost = float('inf')\n\n        for pos in candidate_positions:\n            candidate = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            candidate = np.insert(candidate, pos, node)\n\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != i:\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Probabilistic multi-segment shuffling\n    if np.random.rand() < 0.3:\n        num_segments = np.random.randint(2, 4)\n        segment_indices = sorted(np.random.choice(range(1, N), size=num_segments-1, replace=False))\n        segments = np.split(new_solution, segment_indices)\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    return new_solution\n\n",
        "score": [
            5.579377089114326,
            6.075030883348134
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            5.760028182954555,
            5.835784268978294
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.789158457538903,
            4.661156729355797
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.789158457538903,
            4.661156729355797
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score with different weights, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.3 + norm_objectives[:, 1] * 0.7\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            8.343538406438231,
            4.402578436469173
        ]
    },
    {
        "algorithm": "{The heuristic selects a solution from the archive based on a combined objective score, then applies a novel local search combining node reinsertion with path reversal and edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node reinsertion with path reversal\n    a = np.random.randint(0, N)\n    node = new_solution[a]\n    new_solution = np.delete(new_solution, a)\n\n    best_cost = float('inf')\n    best_pos = -1\n\n    for i in range(N-1):\n        candidate = np.insert(new_solution, i, node)\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Edge exchange with path reversal\n    if np.random.rand() < 0.3:  # 30% chance to exchange edges\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Path reversal with segment selection\n    if np.random.rand() < 0.4:  # 40% chance to reverse a segment\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.89980875824665,
            5.80465254215507
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.789158457538903,
            4.661156729355797
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a hybrid local search combining edge reversal and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives\n    costs1 = np.array([obj[0] for _, obj in archive])\n    costs2 = np.array([obj[1] for _, obj in archive])\n    min_cost1, max_cost1 = np.min(costs1), np.max(costs1)\n    min_cost2, max_cost2 = np.min(costs2), np.max(costs2)\n\n    if max_cost1 == min_cost1:\n        normalized1 = np.ones_like(costs1)\n    else:\n        normalized1 = (costs1 - min_cost1) / (max_cost1 - min_cost1)\n\n    if max_cost2 == min_cost2:\n        normalized2 = np.ones_like(costs2)\n    else:\n        normalized2 = (costs2 - min_cost2) / (max_cost2 - min_cost2)\n\n    # Weighted combination (0.7 for first objective, 0.3 for second)\n    combined = 0.7 * normalized1 + 0.3 * normalized2\n    selected_idx = np.argmin(combined)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge reversal + segment inversion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1][::-1]\n\n    # Find the best insertion point\n    best_cost = float('inf')\n    best_insert = -1\n\n    for i in range(N):\n        if i >= a and i <= b:\n            continue  # Skip if insertion is within the segment\n\n        # Try inserting reversed segment after position i\n        candidate = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:]])\n        if len(candidate) != N:\n            continue  # Ensure no duplicates\n\n        # Calculate cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(N))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(N))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert = i\n\n    if best_insert != -1:\n        new_solution = np.concatenate([new_solution[:best_insert+1], segment, new_solution[best_insert+1:]])\n\n    # Apply segment inversion if beneficial\n    if np.random.rand() < 0.5:  # 50% chance to invert\n        x, y = sorted(np.random.choice(N, size=2, replace=False))\n        new_solution[x:y+1] = new_solution[x:y+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            4.127446975248162,
            9.261212523597171
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.789158457538903,
            4.661156729355797
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.789158457538903,
            4.661156729355797
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted geometric mean of normalized objectives, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sqrt(norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.513101284408078,
            8.463498002451317
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights (0.4 for first objective, 0.6 for second), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilities to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.4 + norm_objectives[:, 1] * 0.6\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            7.789158457538903,
            4.661156729355797
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted geometric mean of normalized objectives, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sqrt(norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.513101284408078,
            8.463498002451317
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted geometric mean of normalized objectives, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adaptive probabilities to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sqrt(norm_objectives[:, 0] * 0.7 + norm_objectives[:, 1] * 0.3)\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.6:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.4 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            4.513101284408078,
            8.463498002451317
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n",
        "score": [
            5.022891198681469,
            7.231238574001864
        ]
    }
]