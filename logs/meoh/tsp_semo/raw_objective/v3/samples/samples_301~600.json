[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic weighted objective score (adjusting weights between objectives based on their variability), then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with adjusted probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    std_dev = objectives.std(axis=0)\n    if std_dev[0] > std_dev[1]:\n        weight1, weight2 = 0.6, 0.4\n    else:\n        weight1, weight2 = 0.4, 0.6\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * weight1 + norm_objectives[:, 1] * weight2\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.8:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.6 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal, node insertion with probabilistic checks, and a novel edge-swapping operator that considers both objective distances to generate diverse and high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:,1], objectives[:,0]))\n    sorted_objectives = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (sorted_objectives[i+1,0] - sorted_objectives[i-1,0]) + (sorted_objectives[i+1,1] - sorted_objectives[i-1,1])\n    crowding_distances[sorted_indices[0]] = crowding_distances[sorted_indices[-1]] = float('inf')\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        d1_old = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]\n        d1_new = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%N]]\n        d2_old = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%N]]\n        d2_new = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%N]]\n        if (d1_new < d1_old and d2_new <= d2_old) or (d2_new < d2_old and d1_new <= d1_old):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.272563365725136,
            10.55656809581024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    sorted_indices = np.lexsort((objectives[:,1], objectives[:,0]))\n    sorted_objectives = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (sorted_objectives[i+1,0] - sorted_objectives[i-1,0]) + (sorted_objectives[i+1,1] - sorted_objectives[i-1,1])\n    crowding_distances[sorted_indices[0]] = crowding_distances[sorted_indices[-1]] = float('inf')\n    base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if np.random.rand() < 0.7:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    if np.random.rand() < 0.5:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        d1_old = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]\n        d1_new = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%N]]\n        d2_old = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%N]]\n        d2_new = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%N]]\n        if (d1_new < d1_old and d2_new <= d2_old) or (d2_new < d2_old and d1_new <= d1_old):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized combined objective score, then applies a hybrid local search combining segment reversal, node relocation, and edge inversion with probabilistic checks to ensure feasibility and diversity.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([x[1] for x in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = norm_objectives[:, 0] * 0.6 + norm_objectives[:, 1] * 0.4\n    base_solution = archive[np.argmin(combined_scores)][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with probabilistic check\n    if np.random.rand() < 0.4:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a > 1:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node relocation with edge inversion\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        old_pos = np.where(new_solution == node)[0][0]\n        new_pos = np.random.randint(N)\n        if new_pos != old_pos:\n            new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n            new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n            if np.random.rand() < 0.3 and new_pos > 0 and new_pos < N-1:\n                new_solution[new_pos-1], new_solution[new_pos] = new_solution[new_pos], new_solution[new_pos-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dominance-based selection criterion, then applies a hybrid local search combining node insertion, segment rotation, and probabilistic edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    non_dominated = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        base_solution = archive[np.random.choice(non_dominated)][0].copy()\n    else:\n        base_solution = archive[np.random.choice(len(archive))][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node insertion with segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a >= 1:\n            segment = new_solution[a:b+1]\n            rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n            new_solution[a:b+1] = rotated_segment\n\n    # Probabilistic edge swapping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1 and np.random.rand() < 0.4:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.533606090555088,
            7.1590482163298255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    non_dominated = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        base_solution = archive[np.random.choice(non_dominated)][0].copy()\n    else:\n        base_solution = archive[np.random.choice(len(archive))][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Node insertion with segment rotation\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        if b - a >= 1:\n            segment = new_solution[a:b+1]\n            rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n            new_solution[a:b+1] = rotated_segment\n\n    # Probabilistic edge swapping\n    if np.random.rand() < 0.6:\n        i, j = sorted(np.random.choice(N, size=2, replace=False))\n        if j - i > 1 and np.random.rand() < 0.4:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a dynamic objective score that balances both objectives, then applies a novel local search combining adaptive segment reversal with objective-aware node swapping and conditional path inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(x[1][0] for x in archive) if archive else 1.0\n    max_obj2 = max(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/max_obj1 + x[1][1]/max_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate reversal based on both objectives\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node swapping\n    if np.random.rand() < 0.6:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            # Calculate cost difference for both objectives\n            cost_diff = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Conditional path inversion\n    if np.random.rand() < 0.4:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        # Evaluate inversion\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score that prioritizes solutions with better individual objective values, then applies a hybrid local search combining adaptive segment reversal with objective-aware node insertion and conditional path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    min_obj1 = min(x[1][0] for x in archive) if archive else 1.0\n    min_obj2 = min(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/min_obj1 + x[1][1]/min_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n            cost_diff = (distance_matrix_1[new_solution[j-1], node] +\n                         distance_matrix_1[node, new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], node] +\n                         distance_matrix_2[node, new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff >= 0:\n                new_solution = np.delete(new_solution, j)\n                new_solution = np.insert(new_solution, i, node)\n\n    # Conditional path inversion\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n",
        "score": [
            6.2028574625981125,
            5.665902445958186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    min_obj1 = min(x[1][0] for x in archive) if archive else 1.0\n    min_obj2 = min(x[1][1] for x in archive) if archive else 1.0\n    archive.sort(key=lambda x: (x[1][0]/min_obj1 + x[1][1]/min_obj2))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if np.random.rand() < 0.6:\n        a, b = sorted(np.random.choice(N, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        original_cost = (distance_matrix_1[new_solution[a-1], segment[0]] +\n                         distance_matrix_1[segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[(b+1)%N]])\n        reversed_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%N]] +\n                         distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                         distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%N]])\n\n        if reversed_cost < original_cost:\n            new_solution[a:b+1] = reversed_segment\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.7:\n        i, j = np.random.choice(N, size=2, replace=False)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n            cost_diff = (distance_matrix_1[new_solution[j-1], node] +\n                         distance_matrix_1[node, new_solution[(j+1)%N]] -\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%N]] +\n                         distance_matrix_2[new_solution[j-1], node] +\n                         distance_matrix_2[node, new_solution[(j+1)%N]] -\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] -\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%N]])\n\n            if cost_diff >= 0:\n                new_solution = np.delete(new_solution, j)\n                new_solution = np.insert(new_solution, i, node)\n\n    # Conditional path inversion\n    if np.random.rand() < 0.5:\n        k = np.random.randint(2, N//2)\n        path = new_solution[:k]\n        inverted_path = path[::-1]\n\n        original_cost = (distance_matrix_1[new_solution[-1], path[0]] +\n                         distance_matrix_1[path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], path[0]] +\n                         distance_matrix_2[path[-1], new_solution[k]])\n        inverted_cost = (distance_matrix_1[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_1[inverted_path[-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[-1], inverted_path[0]] +\n                         distance_matrix_2[inverted_path[-1], new_solution[k]])\n\n        if inverted_cost < original_cost:\n            new_solution[:k] = inverted_path\n\n    return new_solution\n\n"
    }
]